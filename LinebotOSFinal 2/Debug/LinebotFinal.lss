
LinebotFinal.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000a724  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000008ec  00802000  0000a724  0000a7b8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000598  008028ec  008028ec  0000b0a4  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  0000b0a4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000b100  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000b88  00000000  00000000  0000b140  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001b06f  00000000  00000000  0000bcc8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000067e2  00000000  00000000  00026d37  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00009fb8  00000000  00000000  0002d519  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00002a74  00000000  00000000  000374d4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005ba5  00000000  00000000  00039f48  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00011912  00000000  00000000  0003faed  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000f50  00000000  00000000  000513ff  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__ctors_end>
       4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
       8:	0c 94 90 07 	jmp	0xf20	; 0xf20 <__vector_2>
       c:	0c 94 17 08 	jmp	0x102e	; 0x102e <__vector_3>
      10:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      14:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      18:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      1c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      20:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      24:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      28:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      2c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      30:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      34:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      38:	0c 94 c6 1e 	jmp	0x3d8c	; 0x3d8c <__vector_14>
      3c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      40:	0c 94 3a 1f 	jmp	0x3e74	; 0x3e74 <__vector_16>
      44:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      48:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      4c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      50:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      54:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      58:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      5c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      60:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      64:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      68:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      6c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      70:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      74:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      78:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      7c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      80:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      84:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      88:	0c 94 52 05 	jmp	0xaa4	; 0xaa4 <__vector_34>
      8c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      90:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      94:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      98:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      9c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      a0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      a4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      a8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      ac:	0c 94 9e 08 	jmp	0x113c	; 0x113c <__vector_43>
      b0:	0c 94 25 09 	jmp	0x124a	; 0x124a <__vector_44>
      b4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      b8:	0c 94 ea 10 	jmp	0x21d4	; 0x21d4 <__vector_46>
      bc:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      c0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      c4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      c8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      cc:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      d0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      d4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      d8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      dc:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      e0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      e4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      e8:	0c 94 0a 12 	jmp	0x2414	; 0x2414 <__vector_58>
      ec:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      f0:	0c 94 c3 11 	jmp	0x2386	; 0x2386 <__vector_60>
      f4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      f8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      fc:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     100:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     104:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     108:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     10c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     110:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     114:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     118:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     11c:	0c 94 04 04 	jmp	0x808	; 0x808 <__vector_71>
     120:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     124:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     128:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     12c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     130:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     134:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     138:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     13c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     140:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     144:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     148:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     14c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     150:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     154:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     158:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     15c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     160:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     164:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     168:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     16c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     170:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     174:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     178:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     17c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     180:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     184:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     188:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     18c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     190:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     194:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     198:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     19c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1a0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1a4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1a8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1ac:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1b0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1b4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1b8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1bc:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1c0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1c4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1c8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1cc:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1d0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1d4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1d8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1dc:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1e0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1e4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1e8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1ec:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1f0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1f4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1f8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>

000001fc <__trampolines_start>:
     1fc:	0c 94 31 42 	jmp	0x8462	; 0x8462 <WorkerRGB>
     200:	0c 94 0f 31 	jmp	0x621e	; 0x621e <cmpfunc>
     204:	0c 94 e2 42 	jmp	0x85c4	; 0x85c4 <WorkerStartup>
     208:	0c 94 b0 41 	jmp	0x8360	; 0x8360 <WorkerOLEDMenu>
     20c:	0c 94 71 35 	jmp	0x6ae2	; 0x6ae2 <WorkerLineFollowerSpeed>
     210:	0c 94 6a 11 	jmp	0x22d4	; 0x22d4 <stdio_putchar>
     214:	0c 94 cb 3a 	jmp	0x7596	; 0x7596 <WorkerMotorSpeed>
     218:	0c 94 5a 25 	jmp	0x4ab4	; 0x4ab4 <prvIdleTask>
     21c:	0c 94 0d 39 	jmp	0x721a	; 0x721a <WorkerMotorPos>
     220:	0c 94 e1 32 	jmp	0x65c2	; 0x65c2 <WorkerGyro>
     224:	0c 94 62 32 	jmp	0x64c4	; 0x64c4 <WorkerADC>
     228:	0c 94 2d 43 	jmp	0x865a	; 0x865a <WorkerTerminal>
     22c:	0c 94 54 11 	jmp	0x22a8	; 0x22a8 <stdio_getchar>
     230:	0c 94 47 36 	jmp	0x6c8e	; 0x6c8e <WorkerMotion>
     234:	0c 94 d2 34 	jmp	0x69a4	; 0x69a4 <WorkerLineFollowerDirect>

00000238 <__trampolines_end>:
     238:	6e 61       	ori	r22, 0x1E	; 30
     23a:	6e 00       	.word	0x006e	; ????

0000023c <__c.2332>:
     23c:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     24c:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     25c:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     26c:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     27c:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     28c:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     29c:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     2ac:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     2bc:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     2cc:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     2dc:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     2ec:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     2fc:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     30c:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     31c:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     32c:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

0000033a <pstr_nan>:
     33a:	4e 41 4e                                            NAN

0000033d <pstr_inity>:
     33d:	49 4e 49 54 59                                      INITY

00000342 <pstr_inf>:
     342:	49 4e 46                                            INF

00000345 <pwr_m10>:
     345:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     355:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

0000035d <pwr_p10>:
     35d:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     36d:	ca 1b 0e 5a ae c5 9d 74                             ...Z...t

00000375 <__c.4867>:
     375:	61 75 78 70 77 72 20 73 74 61 74 65 3a 27 73 74     auxpwr state:'st
     385:	61 74 65 27 3d 31 3a 20 74 75 72 6e 20 6f 6e 20     ate'=1: turn on 
     395:	61 75 78 20 70 6f 77 65 72 20 6e 65 74 2c 20 27     aux power net, '
     3a5:	73 74 61 74 65 27 3d 30 3a 20 74 75 72 6e 20 6f     state'=0: turn o
     3b5:	66 66 20 61 75 78 20 70 6f 77 65 72 20 6e 65 74     ff aux power net
     3c5:	0d 0a 00                                            ...

000003c8 <__c.4865>:
     3c8:	67 65 74 61 64 63 20 3a 72 65 74 75 72 6e 73 20     getadc :returns 
     3d8:	41 6e 61 6c 6f 67 20 63 68 61 6e 6e 65 6c 73 20     Analog channels 
     3e8:	69 6e 20 66 6f 72 6d 61 74 20 27 6c 65 66 74 5f     in format 'left_
     3f8:	6c 69 6e 65 5f 73 65 6e 73 6f 72 20 6d 69 64 5f     line_sensor mid_
     408:	6c 69 6e 65 5f 73 65 6e 73 6f 72 20 72 69 67 68     line_sensor righ
     418:	74 5f 6c 69 6e 65 5f 73 65 6e 73 6f 72 20 70 6f     t_line_sensor po
     428:	74 65 6e 74 69 6f 6d 65 74 65 72 0d 0a 00           tentiometer...

00000436 <__c.4863>:
     436:	67 65 74 67 79 72 20 3a 72 65 74 75 72 6e 73 20     getgyr :returns 
     446:	67 79 72 6f 73 63 6f 70 65 20 69 6e 66 6f 20 69     gyroscope info i
     456:	6e 20 66 6f 72 6d 61 74 20 27 79 61 77 72 61 74     n format 'yawrat
     466:	65 20 28 64 65 67 2f 73 29 20 79 61 77 28 64 65     e (deg/s) yaw(de
     476:	67 29 0d 0a 00                                      g)...

0000047b <__c.4861>:
     47b:	67 65 74 72 67 62 20 3a 72 65 74 75 72 6e 73 20     getrgb :returns 
     48b:	52 47 42 20 6c 69 67 68 74 20 73 65 6e 73 6f 72     RGB light sensor
     49b:	20 76 61 6c 75 65 73 0d 0a 00                        values...

000004a5 <__c.4859>:
     4a5:	67 65 74 65 6e 63 20 3a 67 65 74 20 6d 6f 74 6f     getenc :get moto
     4b5:	72 20 65 6e 63 6f 64 65 72 20 76 61 6c 75 65 73     r encoder values
     4c5:	0d 0a 00                                            ...

000004c8 <__c.4857>:
     4c8:	73 65 74 6d 6f 74 20 6c 65 66 74 6d 6f 74 6f 72     setmot leftmotor
     4d8:	5f 70 77 6d 20 72 69 67 68 74 6d 6f 74 6f 72 5f     _pwm rightmotor_
     4e8:	70 77 6d 20 3a 64 69 72 65 63 74 6c 79 20 63 6f     pwm :directly co
     4f8:	6e 74 72 6f 6c 20 6d 6f 74 6f 72 20 70 77 6d 20     ntrol motor pwm 
     508:	73 69 67 6e 61 6c 2e 20 50 77 6d 20 69 73 20 69     signal. Pwm is i
     518:	6e 20 61 20 72 61 6e 67 65 20 6f 66 20 2d 34 30     n a range of -40
     528:	39 35 20 74 6f 20 34 30 39 35 0d 0a 00              95 to 4095...

00000535 <__c.4855>:
     535:	73 65 74 6c 65 64 20 65 66 66 65 63 74 20 3a 73     setled effect :s
     545:	65 74 20 52 47 42 20 6c 65 64 20 65 66 66 65 63     et RGB led effec
     555:	74 20 28 73 65 65 20 52 47 42 54 61 73 6b 2e 68     t (see RGBTask.h
     565:	29 0d 0a 00                                         )...

00000569 <__c.4853>:
     569:	64 72 76 73 65 67 20 73 70 65 65 64 20 3a 66 6f     drvseg speed :fo
     579:	6c 6c 6f 77 20 6c 69 6e 65 20 73 65 67 6d 65 6e     llow line segmen
     589:	74 20 75 6e 74 69 6c 20 65 6e 64 20 61 74 20 61     t until end at a
     599:	20 73 70 65 65 64 20 6f 66 20 27 73 70 65 65 64      speed of 'speed
     5a9:	27 20 6d 6d 2f 73 0d 0a 00                          ' mm/s...

000005b2 <__c.4851>:
     5b2:	72 6f 74 63 74 72 20 61 6e 67 6c 65 20 73 70 65     rotctr angle spe
     5c2:	65 64 20 3a 72 6f 74 61 74 65 20 27 61 6e 67 6c     ed :rotate 'angl
     5d2:	65 27 20 64 65 67 72 65 65 73 20 61 72 6f 75 6e     e' degrees aroun
     5e2:	64 20 63 65 6e 74 65 72 20 6f 66 20 72 6f 62 6f     d center of robo
     5f2:	74 20 61 74 20 61 20 73 70 65 65 64 20 6f 66 20     t at a speed of 
     602:	27 73 70 65 65 64 27 20 6d 6d 2f 73 0d 0a 00        'speed' mm/s...

00000611 <__c.4849>:
     611:	64 72 76 73 74 72 20 64 69 73 74 61 6e 63 65 20     drvstr distance 
     621:	73 70 65 65 64 20 3a 44 72 69 76 65 20 73 74 72     speed :Drive str
     631:	61 69 67 68 74 20 6f 76 65 72 20 27 64 69 73 74     aight over 'dist
     641:	61 6e 63 65 27 20 6d 6d 20 61 74 20 61 20 73 70     ance' mm at a sp
     651:	65 65 64 20 6f 66 20 27 73 70 65 65 64 27 20 6d     eed of 'speed' m
     661:	6d 2f 73 0d 0a 00                                   m/s...

00000667 <__c.4847>:
     667:	6d 65 6d 6d 61 70 20 3a 73 68 6f 77 20 6d 65 6d     memmap :show mem
     677:	6f 72 79 20 6d 61 70 0d 0a 00                       ory map...

00000681 <__c.4845>:
     681:	74 73 6b 6c 73 74 20 3a 6c 69 73 74 20 46 72 65     tsklst :list Fre
     691:	65 52 54 4f 53 20 74 61 73 6b 73 0d 0a 00           eRTOS tasks...

0000069f <__c.4843>:
     69f:	68 65 6c 70 20 3a 74 68 69 73 20 68 65 6c 70 20     help :this help 
     6af:	70 61 67 65 0d 0a 00                                page...

000006b6 <__c.4841>:
     6b6:	43 6f 6d 6d 61 6e 64 20 6c 69 73 74 3a 0d 0a 00     Command list:...

000006c6 <__ctors_end>:
     6c6:	11 24       	eor	r1, r1
     6c8:	1f be       	out	0x3f, r1	; 63
     6ca:	cf ef       	ldi	r28, 0xFF	; 255
     6cc:	cd bf       	out	0x3d, r28	; 61
     6ce:	df e9       	ldi	r29, 0x9F	; 159
     6d0:	de bf       	out	0x3e, r29	; 62
     6d2:	00 e0       	ldi	r16, 0x00	; 0
     6d4:	0c bf       	out	0x3c, r16	; 60

000006d6 <__do_copy_data>:
     6d6:	18 e2       	ldi	r17, 0x28	; 40
     6d8:	a0 e0       	ldi	r26, 0x00	; 0
     6da:	b0 e2       	ldi	r27, 0x20	; 32
     6dc:	e4 e2       	ldi	r30, 0x24	; 36
     6de:	f7 ea       	ldi	r31, 0xA7	; 167
     6e0:	00 e0       	ldi	r16, 0x00	; 0
     6e2:	0b bf       	out	0x3b, r16	; 59
     6e4:	02 c0       	rjmp	.+4      	; 0x6ea <__do_copy_data+0x14>
     6e6:	07 90       	elpm	r0, Z+
     6e8:	0d 92       	st	X+, r0
     6ea:	ac 3e       	cpi	r26, 0xEC	; 236
     6ec:	b1 07       	cpc	r27, r17
     6ee:	d9 f7       	brne	.-10     	; 0x6e6 <__do_copy_data+0x10>

000006f0 <__do_clear_bss>:
     6f0:	2e e2       	ldi	r18, 0x2E	; 46
     6f2:	ac ee       	ldi	r26, 0xEC	; 236
     6f4:	b8 e2       	ldi	r27, 0x28	; 40
     6f6:	01 c0       	rjmp	.+2      	; 0x6fa <.do_clear_bss_start>

000006f8 <.do_clear_bss_loop>:
     6f8:	1d 92       	st	X+, r1

000006fa <.do_clear_bss_start>:
     6fa:	a4 38       	cpi	r26, 0x84	; 132
     6fc:	b2 07       	cpc	r27, r18
     6fe:	e1 f7       	brne	.-8      	; 0x6f8 <.do_clear_bss_loop>
     700:	0e 94 f7 30 	call	0x61ee	; 0x61ee <main>
     704:	0c 94 90 53 	jmp	0xa720	; 0xa720 <_exit>

00000708 <__bad_interrupt>:
     708:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000070c <DriverAdcInit>:
SemaphoreHandle_t AdcBusySema;					//Semaphore is taken when an ADC acquisition is performed
SemaphoreHandle_t ConversionCompleteSema;	//Semaphore used to signal completion of an ADC conversion

void DriverAdcInit(void)
{
	ADCA.CTRLA=0b00000001; //Enable ADC
     70c:	e0 e0       	ldi	r30, 0x00	; 0
     70e:	f2 e0       	ldi	r31, 0x02	; 2
     710:	81 e0       	ldi	r24, 0x01	; 1
     712:	80 83       	st	Z, r24
	ADCA.CTRLB=0b00000110; //Manual mode, 12 bit right justified
     714:	96 e0       	ldi	r25, 0x06	; 6
     716:	91 83       	std	Z+1, r25	; 0x01
	ADCA.REFCTRL=0b00000010; //1.00V internal reference, enable bandgap
     718:	92 e0       	ldi	r25, 0x02	; 2
     71a:	92 83       	std	Z+2, r25	; 0x02
	ADCA.PRESCALER=0b00000011; //DIV32; 1MHz ADCClk. Should be lower than 1,8MHz per spec
     71c:	93 e0       	ldi	r25, 0x03	; 3
     71e:	94 83       	std	Z+4, r25	; 0x04
	ADCA.CH0.INTCTRL=0b01; //Lo pri int
     720:	82 a3       	std	Z+34, r24	; 0x22
	
	AdcBusySema=xSemaphoreCreateBinary();
     722:	43 e0       	ldi	r20, 0x03	; 3
     724:	60 e0       	ldi	r22, 0x00	; 0
     726:	0e 94 ab 20 	call	0x4156	; 0x4156 <xQueueGenericCreate>
     72a:	80 93 56 2e 	sts	0x2E56, r24	; 0x802e56 <AdcBusySema>
     72e:	90 93 57 2e 	sts	0x2E57, r25	; 0x802e57 <AdcBusySema+0x1>
	ConversionCompleteSema=xSemaphoreCreateBinary();
     732:	43 e0       	ldi	r20, 0x03	; 3
     734:	60 e0       	ldi	r22, 0x00	; 0
     736:	81 e0       	ldi	r24, 0x01	; 1
     738:	0e 94 ab 20 	call	0x4156	; 0x4156 <xQueueGenericCreate>
     73c:	80 93 54 2e 	sts	0x2E54, r24	; 0x802e54 <ConversionCompleteSema>
     740:	90 93 55 2e 	sts	0x2E55, r25	; 0x802e55 <ConversionCompleteSema+0x1>
	xSemaphoreGive(AdcBusySema);		
     744:	20 e0       	ldi	r18, 0x00	; 0
     746:	40 e0       	ldi	r20, 0x00	; 0
     748:	50 e0       	ldi	r21, 0x00	; 0
     74a:	60 e0       	ldi	r22, 0x00	; 0
     74c:	70 e0       	ldi	r23, 0x00	; 0
     74e:	80 91 56 2e 	lds	r24, 0x2E56	; 0x802e56 <AdcBusySema>
     752:	90 91 57 2e 	lds	r25, 0x2E57	; 0x802e57 <AdcBusySema+0x1>
     756:	0c 94 ef 20 	jmp	0x41de	; 0x41de <xQueueGenericSend>

0000075a <DriverAdcGetCh>:
}

int16_t DriverAdcGetCh(int8_t PinPos,int8_t PinNeg)
{
     75a:	cf 93       	push	r28
     75c:	df 93       	push	r29
     75e:	c8 2f       	mov	r28, r24
     760:	d6 2f       	mov	r29, r22
	int16_t Res;
	
	xSemaphoreTake(AdcBusySema,portMAX_DELAY);
     762:	6f ef       	ldi	r22, 0xFF	; 255
     764:	7f ef       	ldi	r23, 0xFF	; 255
     766:	80 91 56 2e 	lds	r24, 0x2E56	; 0x802e56 <AdcBusySema>
     76a:	90 91 57 2e 	lds	r25, 0x2E57	; 0x802e57 <AdcBusySema+0x1>
     76e:	0e 94 43 23 	call	0x4686	; 0x4686 <xQueueSemaphoreTake>
	
	//Configure channels
	if (PinPos<16 && PinPos>=0)
     772:	c0 31       	cpi	r28, 0x10	; 16
     774:	28 f0       	brcs	.+10     	; 0x780 <DriverAdcGetCh+0x26>
		ADCA.CH0.MUXCTRL=PinPos<<3;
	else
		return 10000; //Invalid settings
     776:	80 e1       	ldi	r24, 0x10	; 16
     778:	97 e2       	ldi	r25, 0x27	; 39
	
	xSemaphoreTake(ConversionCompleteSema,portMAX_DELAY);
	Res=ADCA.CH0.RES;
	xSemaphoreGive(AdcBusySema);
	return Res;
}
     77a:	df 91       	pop	r29
     77c:	cf 91       	pop	r28
     77e:	08 95       	ret
	
	xSemaphoreTake(AdcBusySema,portMAX_DELAY);
	
	//Configure channels
	if (PinPos<16 && PinPos>=0)
		ADCA.CH0.MUXCTRL=PinPos<<3;
     780:	cc 0f       	add	r28, r28
     782:	cc 0f       	add	r28, r28
     784:	cc 0f       	add	r28, r28
     786:	c0 93 21 02 	sts	0x0221, r28	; 0x800221 <__TEXT_REGION_LENGTH__+0x700221>
	else
		return 10000; //Invalid settings

	if (PinNeg==-1) 
     78a:	df 3f       	cpi	r29, 0xFF	; 255
     78c:	a1 f1       	breq	.+104    	; 0x7f6 <DriverAdcGetCh+0x9c>
		{			
		ADCA.CH0.CTRL=0b00000001; //Single ended mode, no gain
		ADCA.CTRLB&=~0b00010000;  //Unsigned mode		
		}		
	else if (PinNeg>=0 && PinNeg<4)
     78e:	d4 30       	cpi	r29, 0x04	; 4
     790:	68 f5       	brcc	.+90     	; 0x7ec <DriverAdcGetCh+0x92>
		{			
		ADCA.CH0.CTRL=0b00000010; //Differential mode, no gain
     792:	82 e0       	ldi	r24, 0x02	; 2
		ADCA.CTRLB|=0b00010000;   //Signed mode
		ADCA.CH0.MUXCTRL|=PinNeg;
		}						
	else if (PinNeg>=4 && PinNeg<8)
		{
		ADCA.CH0.CTRL=0b00011111; //Differential mode, div 2
     794:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
		ADCA.CTRLB|=0b00010000;
     798:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
     79c:	80 61       	ori	r24, 0x10	; 16
     79e:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
		ADCA.CH0.MUXCTRL|=(PinNeg-4);	
     7a2:	80 91 21 02 	lds	r24, 0x0221	; 0x800221 <__TEXT_REGION_LENGTH__+0x700221>
     7a6:	d8 2b       	or	r29, r24
     7a8:	d0 93 21 02 	sts	0x0221, r29	; 0x800221 <__TEXT_REGION_LENGTH__+0x700221>
		}
	else return 10000; //Invalid settings
	
	//Start measurement
	ADCA.CH0.CTRL|=0b10000000; //Start conversion
     7ac:	80 91 20 02 	lds	r24, 0x0220	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
     7b0:	80 68       	ori	r24, 0x80	; 128
     7b2:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
	
	xSemaphoreTake(ConversionCompleteSema,portMAX_DELAY);
     7b6:	6f ef       	ldi	r22, 0xFF	; 255
     7b8:	7f ef       	ldi	r23, 0xFF	; 255
     7ba:	80 91 54 2e 	lds	r24, 0x2E54	; 0x802e54 <ConversionCompleteSema>
     7be:	90 91 55 2e 	lds	r25, 0x2E55	; 0x802e55 <ConversionCompleteSema+0x1>
     7c2:	0e 94 43 23 	call	0x4686	; 0x4686 <xQueueSemaphoreTake>
	Res=ADCA.CH0.RES;
     7c6:	c0 91 24 02 	lds	r28, 0x0224	; 0x800224 <__TEXT_REGION_LENGTH__+0x700224>
     7ca:	d0 91 25 02 	lds	r29, 0x0225	; 0x800225 <__TEXT_REGION_LENGTH__+0x700225>
	xSemaphoreGive(AdcBusySema);
     7ce:	20 e0       	ldi	r18, 0x00	; 0
     7d0:	40 e0       	ldi	r20, 0x00	; 0
     7d2:	50 e0       	ldi	r21, 0x00	; 0
     7d4:	60 e0       	ldi	r22, 0x00	; 0
     7d6:	70 e0       	ldi	r23, 0x00	; 0
     7d8:	80 91 56 2e 	lds	r24, 0x2E56	; 0x802e56 <AdcBusySema>
     7dc:	90 91 57 2e 	lds	r25, 0x2E57	; 0x802e57 <AdcBusySema+0x1>
     7e0:	0e 94 ef 20 	call	0x41de	; 0x41de <xQueueGenericSend>
	return Res;
     7e4:	ce 01       	movw	r24, r28
}
     7e6:	df 91       	pop	r29
     7e8:	cf 91       	pop	r28
     7ea:	08 95       	ret
		{			
		ADCA.CH0.CTRL=0b00000010; //Differential mode, no gain
		ADCA.CTRLB|=0b00010000;   //Signed mode
		ADCA.CH0.MUXCTRL|=PinNeg;
		}						
	else if (PinNeg>=4 && PinNeg<8)
     7ec:	d4 50       	subi	r29, 0x04	; 4
     7ee:	d4 30       	cpi	r29, 0x04	; 4
     7f0:	10 f6       	brcc	.-124    	; 0x776 <DriverAdcGetCh+0x1c>
		{
		ADCA.CH0.CTRL=0b00011111; //Differential mode, div 2
     7f2:	8f e1       	ldi	r24, 0x1F	; 31
     7f4:	cf cf       	rjmp	.-98     	; 0x794 <DriverAdcGetCh+0x3a>
	else
		return 10000; //Invalid settings

	if (PinNeg==-1) 
		{			
		ADCA.CH0.CTRL=0b00000001; //Single ended mode, no gain
     7f6:	81 e0       	ldi	r24, 0x01	; 1
     7f8:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
		ADCA.CTRLB&=~0b00010000;  //Unsigned mode		
     7fc:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
     800:	8f 7e       	andi	r24, 0xEF	; 239
     802:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
     806:	d2 cf       	rjmp	.-92     	; 0x7ac <DriverAdcGetCh+0x52>

00000808 <__vector_71>:
	xSemaphoreGive(AdcBusySema);
	return Res;
}

ISR(ADCA_CH0_vect)
{
     808:	1f 92       	push	r1
     80a:	0f 92       	push	r0
     80c:	0f b6       	in	r0, 0x3f	; 63
     80e:	0f 92       	push	r0
     810:	11 24       	eor	r1, r1
     812:	0b b6       	in	r0, 0x3b	; 59
     814:	0f 92       	push	r0
     816:	2f 93       	push	r18
     818:	3f 93       	push	r19
     81a:	4f 93       	push	r20
     81c:	5f 93       	push	r21
     81e:	6f 93       	push	r22
     820:	7f 93       	push	r23
     822:	8f 93       	push	r24
     824:	9f 93       	push	r25
     826:	af 93       	push	r26
     828:	bf 93       	push	r27
     82a:	ef 93       	push	r30
     82c:	ff 93       	push	r31
     82e:	cf 93       	push	r28
     830:	df 93       	push	r29
     832:	1f 92       	push	r1
     834:	cd b7       	in	r28, 0x3d	; 61
     836:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
     838:	19 82       	std	Y+1, r1	; 0x01
	xSemaphoreGiveFromISR(ConversionCompleteSema,&xHigherPriorityTaskWoken);
     83a:	be 01       	movw	r22, r28
     83c:	6f 5f       	subi	r22, 0xFF	; 255
     83e:	7f 4f       	sbci	r23, 0xFF	; 255
     840:	80 91 54 2e 	lds	r24, 0x2E54	; 0x802e54 <ConversionCompleteSema>
     844:	90 91 55 2e 	lds	r25, 0x2E55	; 0x802e55 <ConversionCompleteSema+0x1>
     848:	0e 94 33 22 	call	0x4466	; 0x4466 <xQueueGiveFromISR>
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     84c:	89 81       	ldd	r24, Y+1	; 0x01
     84e:	81 11       	cpse	r24, r1
     850:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <vPortYieldISR>
     854:	0f 90       	pop	r0
     856:	df 91       	pop	r29
     858:	cf 91       	pop	r28
     85a:	ff 91       	pop	r31
     85c:	ef 91       	pop	r30
     85e:	bf 91       	pop	r27
     860:	af 91       	pop	r26
     862:	9f 91       	pop	r25
     864:	8f 91       	pop	r24
     866:	7f 91       	pop	r23
     868:	6f 91       	pop	r22
     86a:	5f 91       	pop	r21
     86c:	4f 91       	pop	r20
     86e:	3f 91       	pop	r19
     870:	2f 91       	pop	r18
     872:	0f 90       	pop	r0
     874:	0b be       	out	0x3b, r0	; 59
     876:	0f 90       	pop	r0
     878:	0f be       	out	0x3f, r0	; 63
     87a:	0f 90       	pop	r0
     87c:	1f 90       	pop	r1
     87e:	18 95       	reti

00000880 <DriverAdps9960Init>:

#define REG_ID 0x92
#define ID 0xAB

void DriverAdps9960Init(void)
{
     880:	0f 93       	push	r16
     882:	cf 93       	push	r28
     884:	df 93       	push	r29
     886:	1f 92       	push	r1
     888:	1f 92       	push	r1
     88a:	cd b7       	in	r28, 0x3d	; 61
     88c:	de b7       	in	r29, 0x3e	; 62
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=REG_ENABLE;
     88e:	80 e8       	ldi	r24, 0x80	; 128
     890:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=(1<<REG_ENABLE_PON);
     892:	81 e0       	ldi	r24, 0x01	; 1
     894:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);
     896:	42 e0       	ldi	r20, 0x02	; 2
     898:	be 01       	movw	r22, r28
     89a:	6f 5f       	subi	r22, 0xFF	; 255
     89c:	7f 4f       	sbci	r23, 0xFF	; 255
     89e:	89 e3       	ldi	r24, 0x39	; 57
     8a0:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
	//printf ("TwimWrite:%d\r\n",res);
	
	Buffer[0]=REG_ID;
     8a4:	82 e9       	ldi	r24, 0x92	; 146
     8a6:	89 83       	std	Y+1, r24	; 0x01
	res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,1);
     8a8:	01 e0       	ldi	r16, 0x01	; 1
     8aa:	9e 01       	movw	r18, r28
     8ac:	2f 5f       	subi	r18, 0xFF	; 255
     8ae:	3f 4f       	sbci	r19, 0xFF	; 255
     8b0:	41 e0       	ldi	r20, 0x01	; 1
     8b2:	b9 01       	movw	r22, r18
     8b4:	89 e3       	ldi	r24, 0x39	; 57
     8b6:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
	if (Buffer[0]!=ID)
     8ba:	89 81       	ldd	r24, Y+1	; 0x01
     8bc:	8b 3a       	cpi	r24, 0xAB	; 171
     8be:	61 f0       	breq	.+24     	; 0x8d8 <DriverAdps9960Init+0x58>
		printf ("ADPS9960 ID readback fail: %d read\r\n",Buffer[0]);
     8c0:	1f 92       	push	r1
     8c2:	8f 93       	push	r24
     8c4:	82 ef       	ldi	r24, 0xF2	; 242
     8c6:	90 e2       	ldi	r25, 0x20	; 32
     8c8:	9f 93       	push	r25
     8ca:	8f 93       	push	r24
     8cc:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
     8d0:	0f 90       	pop	r0
     8d2:	0f 90       	pop	r0
     8d4:	0f 90       	pop	r0
     8d6:	0f 90       	pop	r0

	Buffer[0]=REG_ATIME;
     8d8:	81 e8       	ldi	r24, 0x81	; 129
     8da:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=219; //100ms integration time
     8dc:	8b ed       	ldi	r24, 0xDB	; 219
     8de:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);
     8e0:	42 e0       	ldi	r20, 0x02	; 2
     8e2:	be 01       	movw	r22, r28
     8e4:	6f 5f       	subi	r22, 0xFF	; 255
     8e6:	7f 4f       	sbci	r23, 0xFF	; 255
     8e8:	89 e3       	ldi	r24, 0x39	; 57
     8ea:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>

	Buffer[0]=REG_CTRL1;
     8ee:	8f e8       	ldi	r24, 0x8F	; 143
     8f0:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=0b11<<REG_CTRL1_AGAIN; //max gain
     8f2:	83 e0       	ldi	r24, 0x03	; 3
     8f4:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);
     8f6:	42 e0       	ldi	r20, 0x02	; 2
     8f8:	be 01       	movw	r22, r28
     8fa:	6f 5f       	subi	r22, 0xFF	; 255
     8fc:	7f 4f       	sbci	r23, 0xFF	; 255
     8fe:	89 e3       	ldi	r24, 0x39	; 57
     900:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>

}
     904:	0f 90       	pop	r0
     906:	0f 90       	pop	r0
     908:	df 91       	pop	r29
     90a:	cf 91       	pop	r28
     90c:	0f 91       	pop	r16
     90e:	08 95       	ret

00000910 <DriverAdps9960Get>:

void DriverAdps9960Get(uint16_t *Clear,uint16_t *Red,uint16_t *Green, uint16_t *Blue)
{
     910:	8f 92       	push	r8
     912:	9f 92       	push	r9
     914:	af 92       	push	r10
     916:	bf 92       	push	r11
     918:	cf 92       	push	r12
     91a:	df 92       	push	r13
     91c:	ef 92       	push	r14
     91e:	ff 92       	push	r15
     920:	0f 93       	push	r16
     922:	1f 93       	push	r17
     924:	cf 93       	push	r28
     926:	df 93       	push	r29
     928:	cd b7       	in	r28, 0x3d	; 61
     92a:	de b7       	in	r29, 0x3e	; 62
     92c:	29 97       	sbiw	r28, 0x09	; 9
     92e:	cd bf       	out	0x3d, r28	; 61
     930:	de bf       	out	0x3e, r29	; 62
     932:	4c 01       	movw	r8, r24
     934:	5b 01       	movw	r10, r22
     936:	6a 01       	movw	r12, r20
     938:	79 01       	movw	r14, r18
	uint8_t Buffer[9];
	uint16_t *C=(uint16_t *) &(Buffer[0]),*R=(uint16_t *) &(Buffer[2]),*G=(uint16_t *) &(Buffer[4]),*B=(uint16_t *) &(Buffer[6]);
	uint8_t *Status=&(Buffer[0]);


	Buffer[0]=REG_ENABLE;
     93a:	80 e8       	ldi	r24, 0x80	; 128
     93c:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=(1<<REG_ENABLE_PON) | (1<<REG_ENABLE_AEN);
     93e:	83 e0       	ldi	r24, 0x03	; 3
     940:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);
     942:	42 e0       	ldi	r20, 0x02	; 2
     944:	be 01       	movw	r22, r28
     946:	6f 5f       	subi	r22, 0xFF	; 255
     948:	7f 4f       	sbci	r23, 0xFF	; 255
     94a:	89 e3       	ldi	r24, 0x39	; 57
     94c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>


	do 
	{
		Buffer[0]=REG_STATUS;
     950:	13 e9       	ldi	r17, 0x93	; 147
     952:	03 c0       	rjmp	.+6      	; 0x95a <DriverAdps9960Get+0x4a>
		res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,1);
		configASSERT(res);
		//printf ("STATUS:%d\r\n",Buffer[0]);
	} while (!(Buffer[0] & (1<<REG_STATUX_AVALID)) );
     954:	89 81       	ldd	r24, Y+1	; 0x01
     956:	80 fd       	sbrc	r24, 0
     958:	15 c0       	rjmp	.+42     	; 0x984 <DriverAdps9960Get+0x74>
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);


	do 
	{
		Buffer[0]=REG_STATUS;
     95a:	19 83       	std	Y+1, r17	; 0x01
		res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,1);
     95c:	01 e0       	ldi	r16, 0x01	; 1
     95e:	9e 01       	movw	r18, r28
     960:	2f 5f       	subi	r18, 0xFF	; 255
     962:	3f 4f       	sbci	r19, 0xFF	; 255
     964:	41 e0       	ldi	r20, 0x01	; 1
     966:	b9 01       	movw	r22, r18
     968:	89 e3       	ldi	r24, 0x39	; 57
     96a:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
		configASSERT(res);
     96e:	81 11       	cpse	r24, r1
     970:	f1 cf       	rjmp	.-30     	; 0x954 <DriverAdps9960Get+0x44>
     972:	63 e4       	ldi	r22, 0x43	; 67
     974:	70 e0       	ldi	r23, 0x00	; 0
     976:	87 e1       	ldi	r24, 0x17	; 23
     978:	91 e2       	ldi	r25, 0x21	; 33
     97a:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
		//printf ("STATUS:%d\r\n",Buffer[0]);
	} while (!(Buffer[0] & (1<<REG_STATUX_AVALID)) );
     97e:	89 81       	ldd	r24, Y+1	; 0x01
     980:	80 ff       	sbrs	r24, 0
     982:	eb cf       	rjmp	.-42     	; 0x95a <DriverAdps9960Get+0x4a>


	Buffer[0]=REG_CDATA;
     984:	84 e9       	ldi	r24, 0x94	; 148
     986:	89 83       	std	Y+1, r24	; 0x01
	res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,8);
     988:	08 e0       	ldi	r16, 0x08	; 8
     98a:	9e 01       	movw	r18, r28
     98c:	2f 5f       	subi	r18, 0xFF	; 255
     98e:	3f 4f       	sbci	r19, 0xFF	; 255
     990:	41 e0       	ldi	r20, 0x01	; 1
     992:	b9 01       	movw	r22, r18
     994:	89 e3       	ldi	r24, 0x39	; 57
     996:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
	configASSERT(res);
     99a:	88 23       	and	r24, r24
     99c:	81 f1       	breq	.+96     	; 0x9fe <DriverAdps9960Get+0xee>
	//printf ("TwimWriteRead:%d\r\n",res);

	if (Clear!=NULL) *Clear=*C;	
     99e:	81 14       	cp	r8, r1
     9a0:	91 04       	cpc	r9, r1
     9a2:	29 f0       	breq	.+10     	; 0x9ae <DriverAdps9960Get+0x9e>
     9a4:	89 81       	ldd	r24, Y+1	; 0x01
     9a6:	9a 81       	ldd	r25, Y+2	; 0x02
     9a8:	f4 01       	movw	r30, r8
     9aa:	80 83       	st	Z, r24
     9ac:	91 83       	std	Z+1, r25	; 0x01
	if (Red!=NULL) *Red=*R;
     9ae:	a1 14       	cp	r10, r1
     9b0:	b1 04       	cpc	r11, r1
     9b2:	29 f0       	breq	.+10     	; 0x9be <DriverAdps9960Get+0xae>
     9b4:	8b 81       	ldd	r24, Y+3	; 0x03
     9b6:	9c 81       	ldd	r25, Y+4	; 0x04
     9b8:	f5 01       	movw	r30, r10
     9ba:	80 83       	st	Z, r24
     9bc:	91 83       	std	Z+1, r25	; 0x01
	if (Green!=NULL) *Green=*G;
     9be:	c1 14       	cp	r12, r1
     9c0:	d1 04       	cpc	r13, r1
     9c2:	29 f0       	breq	.+10     	; 0x9ce <DriverAdps9960Get+0xbe>
     9c4:	8d 81       	ldd	r24, Y+5	; 0x05
     9c6:	9e 81       	ldd	r25, Y+6	; 0x06
     9c8:	f6 01       	movw	r30, r12
     9ca:	80 83       	st	Z, r24
     9cc:	91 83       	std	Z+1, r25	; 0x01
	if (Blue!=NULL) *Blue=*B;
     9ce:	e1 14       	cp	r14, r1
     9d0:	f1 04       	cpc	r15, r1
     9d2:	29 f0       	breq	.+10     	; 0x9de <DriverAdps9960Get+0xce>
     9d4:	8f 81       	ldd	r24, Y+7	; 0x07
     9d6:	98 85       	ldd	r25, Y+8	; 0x08
     9d8:	f7 01       	movw	r30, r14
     9da:	80 83       	st	Z, r24
     9dc:	91 83       	std	Z+1, r25	; 0x01

     9de:	29 96       	adiw	r28, 0x09	; 9
     9e0:	cd bf       	out	0x3d, r28	; 61
     9e2:	de bf       	out	0x3e, r29	; 62
     9e4:	df 91       	pop	r29
     9e6:	cf 91       	pop	r28
     9e8:	1f 91       	pop	r17
     9ea:	0f 91       	pop	r16
     9ec:	ff 90       	pop	r15
     9ee:	ef 90       	pop	r14
     9f0:	df 90       	pop	r13
     9f2:	cf 90       	pop	r12
     9f4:	bf 90       	pop	r11
     9f6:	af 90       	pop	r10
     9f8:	9f 90       	pop	r9
     9fa:	8f 90       	pop	r8
     9fc:	08 95       	ret
	} while (!(Buffer[0] & (1<<REG_STATUX_AVALID)) );


	Buffer[0]=REG_CDATA;
	res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,8);
	configASSERT(res);
     9fe:	6a e4       	ldi	r22, 0x4A	; 74
     a00:	70 e0       	ldi	r23, 0x00	; 0
     a02:	87 e1       	ldi	r24, 0x17	; 23
     a04:	91 e2       	ldi	r25, 0x21	; 33
     a06:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
     a0a:	c9 cf       	rjmp	.-110    	; 0x99e <DriverAdps9960Get+0x8e>

00000a0c <DriverCursorstickInit>:

static QueueHandle_t CursorstickQueue;

void DriverCursorstickInit(void)
{
	PORTB.DIRCLR=0b11111000;
     a0c:	e0 e2       	ldi	r30, 0x20	; 32
     a0e:	f6 e0       	ldi	r31, 0x06	; 6
     a10:	98 ef       	ldi	r25, 0xF8	; 248
     a12:	92 83       	std	Z+2, r25	; 0x02
	PORTB.PIN3CTRL=0b01011001; //Pull up, inverted
     a14:	89 e5       	ldi	r24, 0x59	; 89
     a16:	83 8b       	std	Z+19, r24	; 0x13
	PORTB.PIN4CTRL=0b01011001; //Pull up, inverted	
     a18:	84 8b       	std	Z+20, r24	; 0x14
	PORTB.PIN5CTRL=0b01011001; //Pull up, inverted
     a1a:	85 8b       	std	Z+21, r24	; 0x15
	PORTB.PIN6CTRL=0b01011001; //Pull up, inverted
     a1c:	86 8b       	std	Z+22, r24	; 0x16
	PORTB.PIN7CTRL=0b01011001; //Pull up, inverted
     a1e:	87 8b       	std	Z+23, r24	; 0x17
	PORTB.INT0MASK=0b11111000; //Interrupt on all cursor stick lines
     a20:	92 87       	std	Z+10, r25	; 0x0a
	PORTB.INTCTRL=0b11;		   //Enable interrupt0 highest priority
     a22:	83 e0       	ldi	r24, 0x03	; 3
     a24:	81 87       	std	Z+9, r24	; 0x09
	
	CursorstickQueue=xQueueCreate(CURSOR_FIFO_LENGTH,1);
     a26:	40 e0       	ldi	r20, 0x00	; 0
     a28:	61 e0       	ldi	r22, 0x01	; 1
     a2a:	8a e0       	ldi	r24, 0x0A	; 10
     a2c:	0e 94 ab 20 	call	0x4156	; 0x4156 <xQueueGenericCreate>
     a30:	80 93 f2 28 	sts	0x28F2, r24	; 0x8028f2 <CursorstickQueue>
     a34:	90 93 f3 28 	sts	0x28F3, r25	; 0x8028f3 <CursorstickQueue+0x1>
     a38:	08 95       	ret

00000a3a <DriverCursorstickGet>:
}

uint8_t DriverCursorstickGet(void)
{
	uint8_t ret=0;
	if (PORTB.IN & (1<<3)) ret|=(1<<4);
     a3a:	80 91 28 06 	lds	r24, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     a3e:	83 ff       	sbrs	r24, 3
     a40:	12 c0       	rjmp	.+36     	; 0xa66 <DriverCursorstickGet+0x2c>
     a42:	80 e1       	ldi	r24, 0x10	; 16
	if (PORTB.IN & (1<<4)) ret|=(1<<3);
     a44:	90 91 28 06 	lds	r25, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     a48:	94 fd       	sbrc	r25, 4
     a4a:	88 60       	ori	r24, 0x08	; 8
	if (PORTB.IN & (1<<5)) ret|=(1<<2);
     a4c:	90 91 28 06 	lds	r25, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     a50:	95 fd       	sbrc	r25, 5
     a52:	84 60       	ori	r24, 0x04	; 4
	if (PORTB.IN & (1<<6)) ret|=(1<<1);
     a54:	90 91 28 06 	lds	r25, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     a58:	96 fd       	sbrc	r25, 6
     a5a:	82 60       	ori	r24, 0x02	; 2
	if (PORTB.IN & (1<<7)) ret|=(1<<0);
     a5c:	90 91 28 06 	lds	r25, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     a60:	97 fd       	sbrc	r25, 7
     a62:	03 c0       	rjmp	.+6      	; 0xa6a <DriverCursorstickGet+0x30>

	return ret;
}
     a64:	08 95       	ret
	CursorstickQueue=xQueueCreate(CURSOR_FIFO_LENGTH,1);
}

uint8_t DriverCursorstickGet(void)
{
	uint8_t ret=0;
     a66:	80 e0       	ldi	r24, 0x00	; 0
     a68:	ed cf       	rjmp	.-38     	; 0xa44 <DriverCursorstickGet+0xa>
	if (PORTB.IN & (1<<3)) ret|=(1<<4);
	if (PORTB.IN & (1<<4)) ret|=(1<<3);
	if (PORTB.IN & (1<<5)) ret|=(1<<2);
	if (PORTB.IN & (1<<6)) ret|=(1<<1);
	if (PORTB.IN & (1<<7)) ret|=(1<<0);
     a6a:	81 60       	ori	r24, 0x01	; 1

	return ret;
}
     a6c:	08 95       	ret

00000a6e <DriverCursorStickGetFifo>:

uint8_t DriverCursorStickGetFifo(TickType_t BlockTime)
{
     a6e:	cf 93       	push	r28
     a70:	df 93       	push	r29
     a72:	1f 92       	push	r1
     a74:	cd b7       	in	r28, 0x3d	; 61
     a76:	de b7       	in	r29, 0x3e	; 62
	uint8_t ButtonState;
	BaseType_t res;
	res=xQueueReceive(CursorstickQueue,&ButtonState,BlockTime);
     a78:	ac 01       	movw	r20, r24
     a7a:	be 01       	movw	r22, r28
     a7c:	6f 5f       	subi	r22, 0xFF	; 255
     a7e:	7f 4f       	sbci	r23, 0xFF	; 255
     a80:	80 91 f2 28 	lds	r24, 0x28F2	; 0x8028f2 <CursorstickQueue>
     a84:	90 91 f3 28 	lds	r25, 0x28F3	; 0x8028f3 <CursorstickQueue+0x1>
     a88:	0e 94 86 22 	call	0x450c	; 0x450c <xQueueReceive>
	if (res==pdTRUE) return ButtonState;
     a8c:	81 30       	cpi	r24, 0x01	; 1
     a8e:	29 f0       	breq	.+10     	; 0xa9a <DriverCursorStickGetFifo+0x2c>
	else return 0;
     a90:	80 e0       	ldi	r24, 0x00	; 0

}
     a92:	0f 90       	pop	r0
     a94:	df 91       	pop	r29
     a96:	cf 91       	pop	r28
     a98:	08 95       	ret
uint8_t DriverCursorStickGetFifo(TickType_t BlockTime)
{
	uint8_t ButtonState;
	BaseType_t res;
	res=xQueueReceive(CursorstickQueue,&ButtonState,BlockTime);
	if (res==pdTRUE) return ButtonState;
     a9a:	89 81       	ldd	r24, Y+1	; 0x01
	else return 0;

}
     a9c:	0f 90       	pop	r0
     a9e:	df 91       	pop	r29
     aa0:	cf 91       	pop	r28
     aa2:	08 95       	ret

00000aa4 <__vector_34>:

ISR (PORTB_INT0_vect)
{
     aa4:	1f 92       	push	r1
     aa6:	0f 92       	push	r0
     aa8:	0f b6       	in	r0, 0x3f	; 63
     aaa:	0f 92       	push	r0
     aac:	11 24       	eor	r1, r1
     aae:	0b b6       	in	r0, 0x3b	; 59
     ab0:	0f 92       	push	r0
     ab2:	cf 92       	push	r12
     ab4:	df 92       	push	r13
     ab6:	ef 92       	push	r14
     ab8:	ff 92       	push	r15
     aba:	0f 93       	push	r16
     abc:	1f 93       	push	r17
     abe:	2f 93       	push	r18
     ac0:	3f 93       	push	r19
     ac2:	4f 93       	push	r20
     ac4:	5f 93       	push	r21
     ac6:	6f 93       	push	r22
     ac8:	7f 93       	push	r23
     aca:	8f 93       	push	r24
     acc:	9f 93       	push	r25
     ace:	af 93       	push	r26
     ad0:	bf 93       	push	r27
     ad2:	ef 93       	push	r30
     ad4:	ff 93       	push	r31
     ad6:	cf 93       	push	r28
     ad8:	df 93       	push	r29
     ada:	1f 92       	push	r1
     adc:	1f 92       	push	r1
     ade:	cd b7       	in	r28, 0x3d	; 61
     ae0:	de b7       	in	r29, 0x3e	; 62
	printf("wakey wakey");
     ae2:	83 e3       	ldi	r24, 0x33	; 51
     ae4:	91 e2       	ldi	r25, 0x21	; 33
     ae6:	9f 93       	push	r25
     ae8:	8f 93       	push	r24
     aea:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
	DriverPowerVccAuxSet(1);
     aee:	81 e0       	ldi	r24, 0x01	; 1
     af0:	90 e0       	ldi	r25, 0x00	; 0
     af2:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <DriverPowerVccAuxSet>
	PMIC.CTRL |= 0b111;
     af6:	80 91 a2 00 	lds	r24, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     afa:	87 60       	ori	r24, 0x07	; 7
     afc:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	static uint32_t LastIntTime=0;
	uint32_t CurTime;
	uint8_t ButtonState;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
     b00:	19 82       	std	Y+1, r1	; 0x01
	
	CurTime=portGET_RUN_TIME_COUNTER_VALUE();
     b02:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
     b06:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
     b0a:	c0 90 6e 2e 	lds	r12, 0x2E6E	; 0x802e6e <StatsTimer>
     b0e:	d0 90 6f 2e 	lds	r13, 0x2E6F	; 0x802e6f <StatsTimer+0x1>
     b12:	e0 90 70 2e 	lds	r14, 0x2E70	; 0x802e70 <StatsTimer+0x2>
     b16:	f0 90 71 2e 	lds	r15, 0x2E71	; 0x802e71 <StatsTimer+0x3>
     b1a:	c8 0e       	add	r12, r24
     b1c:	d9 1e       	adc	r13, r25
     b1e:	e1 1c       	adc	r14, r1
     b20:	f1 1c       	adc	r15, r1
	ButtonState=DriverCursorstickGet();
     b22:	0e 94 1d 05 	call	0xa3a	; 0xa3a <DriverCursorstickGet>
     b26:	8a 83       	std	Y+2, r24	; 0x02
	
	if ((CurTime-LastIntTime)>CURSOR_MIN_INTERVAL) //debounce
     b28:	40 91 ee 28 	lds	r20, 0x28EE	; 0x8028ee <LastIntTime.4303>
     b2c:	50 91 ef 28 	lds	r21, 0x28EF	; 0x8028ef <LastIntTime.4303+0x1>
     b30:	60 91 f0 28 	lds	r22, 0x28F0	; 0x8028f0 <LastIntTime.4303+0x2>
     b34:	70 91 f1 28 	lds	r23, 0x28F1	; 0x8028f1 <LastIntTime.4303+0x3>
     b38:	97 01       	movw	r18, r14
     b3a:	86 01       	movw	r16, r12
     b3c:	04 1b       	sub	r16, r20
     b3e:	15 0b       	sbc	r17, r21
     b40:	26 0b       	sbc	r18, r22
     b42:	37 0b       	sbc	r19, r23
     b44:	b9 01       	movw	r22, r18
     b46:	a8 01       	movw	r20, r16
     b48:	0f 90       	pop	r0
     b4a:	0f 90       	pop	r0
     b4c:	41 30       	cpi	r20, 0x01	; 1
     b4e:	58 4a       	sbci	r21, 0xA8	; 168
     b50:	61 46       	sbci	r22, 0x61	; 97
     b52:	71 05       	cpc	r23, r1
     b54:	10 f0       	brcs	.+4      	; 0xb5a <__vector_34+0xb6>
		if (ButtonState>0) 
     b56:	81 11       	cpse	r24, r1
     b58:	21 c0       	rjmp	.+66     	; 0xb9c <__vector_34+0xf8>
		{
			xQueueSendToBackFromISR(CursorstickQueue,&ButtonState,&xHigherPriorityTaskWoken);
			LastIntTime=CurTime;
		}
		
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     b5a:	89 81       	ldd	r24, Y+1	; 0x01
     b5c:	81 11       	cpse	r24, r1
     b5e:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <vPortYieldISR>
     b62:	0f 90       	pop	r0
     b64:	0f 90       	pop	r0
     b66:	df 91       	pop	r29
     b68:	cf 91       	pop	r28
     b6a:	ff 91       	pop	r31
     b6c:	ef 91       	pop	r30
     b6e:	bf 91       	pop	r27
     b70:	af 91       	pop	r26
     b72:	9f 91       	pop	r25
     b74:	8f 91       	pop	r24
     b76:	7f 91       	pop	r23
     b78:	6f 91       	pop	r22
     b7a:	5f 91       	pop	r21
     b7c:	4f 91       	pop	r20
     b7e:	3f 91       	pop	r19
     b80:	2f 91       	pop	r18
     b82:	1f 91       	pop	r17
     b84:	0f 91       	pop	r16
     b86:	ff 90       	pop	r15
     b88:	ef 90       	pop	r14
     b8a:	df 90       	pop	r13
     b8c:	cf 90       	pop	r12
     b8e:	0f 90       	pop	r0
     b90:	0b be       	out	0x3b, r0	; 59
     b92:	0f 90       	pop	r0
     b94:	0f be       	out	0x3f, r0	; 63
     b96:	0f 90       	pop	r0
     b98:	1f 90       	pop	r1
     b9a:	18 95       	reti
	ButtonState=DriverCursorstickGet();
	
	if ((CurTime-LastIntTime)>CURSOR_MIN_INTERVAL) //debounce
		if (ButtonState>0) 
		{
			xQueueSendToBackFromISR(CursorstickQueue,&ButtonState,&xHigherPriorityTaskWoken);
     b9c:	20 e0       	ldi	r18, 0x00	; 0
     b9e:	ae 01       	movw	r20, r28
     ba0:	4f 5f       	subi	r20, 0xFF	; 255
     ba2:	5f 4f       	sbci	r21, 0xFF	; 255
     ba4:	be 01       	movw	r22, r28
     ba6:	6e 5f       	subi	r22, 0xFE	; 254
     ba8:	7f 4f       	sbci	r23, 0xFF	; 255
     baa:	80 91 f2 28 	lds	r24, 0x28F2	; 0x8028f2 <CursorstickQueue>
     bae:	90 91 f3 28 	lds	r25, 0x28F3	; 0x8028f3 <CursorstickQueue+0x1>
     bb2:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <xQueueGenericSendFromISR>
			LastIntTime=CurTime;
     bb6:	c0 92 ee 28 	sts	0x28EE, r12	; 0x8028ee <LastIntTime.4303>
     bba:	d0 92 ef 28 	sts	0x28EF, r13	; 0x8028ef <LastIntTime.4303+0x1>
     bbe:	e0 92 f0 28 	sts	0x28F0, r14	; 0x8028f0 <LastIntTime.4303+0x2>
     bc2:	f0 92 f1 28 	sts	0x28F1, r15	; 0x8028f1 <LastIntTime.4303+0x3>
     bc6:	c9 cf       	rjmp	.-110    	; 0xb5a <__vector_34+0xb6>

00000bc8 <DbgPrint>:
#include "DriverDbgUSART.h"


void DbgPrint(char *Text)
{
     bc8:	dc 01       	movw	r26, r24
}

void DbgPrintn(char *Text,int n)
{
	static int i;
	i=0;
     bca:	10 92 f7 28 	sts	0x28F7, r1	; 0x8028f7 <i.3624>
     bce:	10 92 f8 28 	sts	0x28F8, r1	; 0x8028f8 <i.3624+0x1>
	while (*Text!=0 && (i<n || n==0))
     bd2:	9c 91       	ld	r25, X
     bd4:	99 23       	and	r25, r25
     bd6:	b1 f0       	breq	.+44     	; 0xc04 <DbgPrint+0x3c>
     bd8:	fd 01       	movw	r30, r26
     bda:	31 96       	adiw	r30, 0x01	; 1
	{
		USART.DATA = *Text;
		while (!(USART.STATUS & 0b01000000));
		USART.STATUS=0b01000000;
     bdc:	80 e4       	ldi	r24, 0x40	; 64
{
	static int i;
	i=0;
	while (*Text!=0 && (i<n || n==0))
	{
		USART.DATA = *Text;
     bde:	90 93 a0 0a 	sts	0x0AA0, r25	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
		while (!(USART.STATUS & 0b01000000));
     be2:	90 91 a1 0a 	lds	r25, 0x0AA1	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
     be6:	96 ff       	sbrs	r25, 6
     be8:	fc cf       	rjmp	.-8      	; 0xbe2 <DbgPrint+0x1a>
		USART.STATUS=0b01000000;
     bea:	80 93 a1 0a 	sts	0x0AA1, r24	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
     bee:	9f 01       	movw	r18, r30
     bf0:	2a 1b       	sub	r18, r26
     bf2:	3b 0b       	sbc	r19, r27

void DbgPrintn(char *Text,int n)
{
	static int i;
	i=0;
	while (*Text!=0 && (i<n || n==0))
     bf4:	91 91       	ld	r25, Z+
     bf6:	91 11       	cpse	r25, r1
     bf8:	f2 cf       	rjmp	.-28     	; 0xbde <DbgPrint+0x16>
     bfa:	20 93 f7 28 	sts	0x28F7, r18	; 0x8028f7 <i.3624>
     bfe:	30 93 f8 28 	sts	0x28F8, r19	; 0x8028f8 <i.3624+0x1>
     c02:	08 95       	ret
     c04:	08 95       	ret

00000c06 <DbgPrintn>:
{
	DbgPrintn(Text,0);	
}

void DbgPrintn(char *Text,int n)
{
     c06:	fc 01       	movw	r30, r24
	static int i;
	i=0;
     c08:	10 92 f7 28 	sts	0x28F7, r1	; 0x8028f7 <i.3624>
     c0c:	10 92 f8 28 	sts	0x28F8, r1	; 0x8028f8 <i.3624+0x1>
	while (*Text!=0 && (i<n || n==0))
     c10:	90 81       	ld	r25, Z
     c12:	99 23       	and	r25, r25
     c14:	e1 f0       	breq	.+56     	; 0xc4e <DbgPrintn+0x48>
     c16:	31 96       	adiw	r30, 0x01	; 1
     c18:	20 e0       	ldi	r18, 0x00	; 0
     c1a:	30 e0       	ldi	r19, 0x00	; 0
	{
		USART.DATA = *Text;
		while (!(USART.STATUS & 0b01000000));
		USART.STATUS=0b01000000;
     c1c:	80 e4       	ldi	r24, 0x40	; 64

void DbgPrintn(char *Text,int n)
{
	static int i;
	i=0;
	while (*Text!=0 && (i<n || n==0))
     c1e:	26 17       	cp	r18, r22
     c20:	37 07       	cpc	r19, r23
     c22:	1c f0       	brlt	.+6      	; 0xc2a <DbgPrintn+0x24>
     c24:	61 15       	cp	r22, r1
     c26:	71 05       	cpc	r23, r1
     c28:	69 f4       	brne	.+26     	; 0xc44 <DbgPrintn+0x3e>
	{
		USART.DATA = *Text;
     c2a:	90 93 a0 0a 	sts	0x0AA0, r25	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
		while (!(USART.STATUS & 0b01000000));
     c2e:	90 91 a1 0a 	lds	r25, 0x0AA1	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
     c32:	96 ff       	sbrs	r25, 6
     c34:	fc cf       	rjmp	.-8      	; 0xc2e <DbgPrintn+0x28>
		USART.STATUS=0b01000000;
     c36:	80 93 a1 0a 	sts	0x0AA1, r24	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
		Text++;
		i++;
     c3a:	2f 5f       	subi	r18, 0xFF	; 255
     c3c:	3f 4f       	sbci	r19, 0xFF	; 255

void DbgPrintn(char *Text,int n)
{
	static int i;
	i=0;
	while (*Text!=0 && (i<n || n==0))
     c3e:	91 91       	ld	r25, Z+
     c40:	91 11       	cpse	r25, r1
     c42:	ed cf       	rjmp	.-38     	; 0xc1e <DbgPrintn+0x18>
     c44:	20 93 f7 28 	sts	0x28F7, r18	; 0x8028f7 <i.3624>
     c48:	30 93 f8 28 	sts	0x28F8, r19	; 0x8028f8 <i.3624+0x1>
     c4c:	08 95       	ret
     c4e:	08 95       	ret

00000c50 <DbgPrintInt>:
		i++;
	}
}

void DbgPrintInt(uint16_t Data)
{
     c50:	cf 92       	push	r12
     c52:	df 92       	push	r13
     c54:	ef 92       	push	r14
     c56:	ff 92       	push	r15
     c58:	0f 93       	push	r16
     c5a:	1f 93       	push	r17
     c5c:	cf 93       	push	r28
     c5e:	df 93       	push	r29
     c60:	7c 01       	movw	r14, r24
	//Use statics to minimize stack usage
	static int i;
	static uint8_t pf;
	
	i=10000;
     c62:	80 e1       	ldi	r24, 0x10	; 16
     c64:	97 e2       	ldi	r25, 0x27	; 39
     c66:	80 93 f5 28 	sts	0x28F5, r24	; 0x8028f5 <i.3634>
     c6a:	90 93 f6 28 	sts	0x28F6, r25	; 0x8028f6 <i.3634+0x1>
	pf=0;
     c6e:	10 92 f4 28 	sts	0x28F4, r1	; 0x8028f4 <pf.3635>
     c72:	c5 e0       	ldi	r28, 0x05	; 5
     c74:	d0 e0       	ldi	r29, 0x00	; 0
     c76:	c1 2c       	mov	r12, r1
     c78:	e0 e1       	ldi	r30, 0x10	; 16
     c7a:	f7 e2       	ldi	r31, 0x27	; 39
	{
		if (((Data/i)%10)!=0 || pf) //Trim leading 0's
		{
			USART.DATA = '0'+ ((Data/i)%10);
			while (!(USART.STATUS & 0b01000000));
			USART.STATUS=0b01000000;
     c7c:	a0 e4       	ldi	r26, 0x40	; 64
     c7e:	da 2e       	mov	r13, r26
			pf=1;		
		}
		i/=10;
     c80:	0a e0       	ldi	r16, 0x0A	; 10
     c82:	10 e0       	ldi	r17, 0x00	; 0
	
	i=10000;
	pf=0;
	while (i>0)
	{
		if (((Data/i)%10)!=0 || pf) //Trim leading 0's
     c84:	c7 01       	movw	r24, r14
     c86:	bf 01       	movw	r22, r30
     c88:	0e 94 88 4b 	call	0x9710	; 0x9710 <__udivmodhi4>
     c8c:	ab 01       	movw	r20, r22
     c8e:	9b 01       	movw	r18, r22
     c90:	ad ec       	ldi	r26, 0xCD	; 205
     c92:	bc ec       	ldi	r27, 0xCC	; 204
     c94:	0e 94 d2 4b 	call	0x97a4	; 0x97a4 <__umulhisi3>
     c98:	96 95       	lsr	r25
     c9a:	87 95       	ror	r24
     c9c:	96 95       	lsr	r25
     c9e:	87 95       	ror	r24
     ca0:	96 95       	lsr	r25
     ca2:	87 95       	ror	r24
     ca4:	9c 01       	movw	r18, r24
     ca6:	22 0f       	add	r18, r18
     ca8:	33 1f       	adc	r19, r19
     caa:	88 0f       	add	r24, r24
     cac:	99 1f       	adc	r25, r25
     cae:	88 0f       	add	r24, r24
     cb0:	99 1f       	adc	r25, r25
     cb2:	88 0f       	add	r24, r24
     cb4:	99 1f       	adc	r25, r25
     cb6:	82 0f       	add	r24, r18
     cb8:	93 1f       	adc	r25, r19
     cba:	9a 01       	movw	r18, r20
     cbc:	28 1b       	sub	r18, r24
     cbe:	39 0b       	sbc	r19, r25
     cc0:	c9 01       	movw	r24, r18
     cc2:	00 97       	sbiw	r24, 0x00	; 0
     cc4:	11 f4       	brne	.+4      	; 0xcca <DbgPrintInt+0x7a>
     cc6:	cc 20       	and	r12, r12
     cc8:	59 f0       	breq	.+22     	; 0xce0 <DbgPrintInt+0x90>
		{
			USART.DATA = '0'+ ((Data/i)%10);
     cca:	80 5d       	subi	r24, 0xD0	; 208
     ccc:	80 93 a0 0a 	sts	0x0AA0, r24	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
			while (!(USART.STATUS & 0b01000000));
     cd0:	80 91 a1 0a 	lds	r24, 0x0AA1	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
     cd4:	86 ff       	sbrs	r24, 6
     cd6:	fc cf       	rjmp	.-8      	; 0xcd0 <DbgPrintInt+0x80>
			USART.STATUS=0b01000000;
     cd8:	d0 92 a1 0a 	sts	0x0AA1, r13	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
			pf=1;		
     cdc:	cc 24       	eor	r12, r12
     cde:	c3 94       	inc	r12
		}
		i/=10;
     ce0:	cf 01       	movw	r24, r30
     ce2:	b8 01       	movw	r22, r16
     ce4:	0e 94 9c 4b 	call	0x9738	; 0x9738 <__divmodhi4>
     ce8:	fb 01       	movw	r30, r22
     cea:	21 97       	sbiw	r28, 0x01	; 1
	static int i;
	static uint8_t pf;
	
	i=10000;
	pf=0;
	while (i>0)
     cec:	59 f6       	brne	.-106    	; 0xc84 <DbgPrintInt+0x34>
     cee:	c0 92 f4 28 	sts	0x28F4, r12	; 0x8028f4 <pf.3635>
     cf2:	60 93 f5 28 	sts	0x28F5, r22	; 0x8028f5 <i.3634>
     cf6:	70 93 f6 28 	sts	0x28F6, r23	; 0x8028f6 <i.3634+0x1>
			USART.STATUS=0b01000000;
			pf=1;		
		}
		i/=10;
	}
}
     cfa:	df 91       	pop	r29
     cfc:	cf 91       	pop	r28
     cfe:	1f 91       	pop	r17
     d00:	0f 91       	pop	r16
     d02:	ff 90       	pop	r15
     d04:	ef 90       	pop	r14
     d06:	df 90       	pop	r13
     d08:	cf 90       	pop	r12
     d0a:	08 95       	ret

00000d0c <DriverLedInit>:
}

void DriverLedWrite(uint8_t LedData)
{
	PORTB.OUT=(PORTB.OUT & 0b11111000) | (LedData & 0b00000111);
	PORTA.OUT=(PORTA.OUT & 0b01111111) | ((LedData & 0b00001000) << 4); 
     d0c:	e0 e2       	ldi	r30, 0x20	; 32
     d0e:	f6 e0       	ldi	r31, 0x06	; 6
     d10:	87 e0       	ldi	r24, 0x07	; 7
     d12:	81 83       	std	Z+1, r24	; 0x01
     d14:	80 e4       	ldi	r24, 0x40	; 64
     d16:	80 8b       	std	Z+16, r24	; 0x10
     d18:	81 8b       	std	Z+17, r24	; 0x11
     d1a:	82 8b       	std	Z+18, r24	; 0x12
     d1c:	e0 e0       	ldi	r30, 0x00	; 0
     d1e:	f6 e0       	ldi	r31, 0x06	; 6
     d20:	90 e8       	ldi	r25, 0x80	; 128
     d22:	91 83       	std	Z+1, r25	; 0x01
     d24:	87 8b       	std	Z+23, r24	; 0x17
     d26:	08 95       	ret

00000d28 <DriverLedSet>:
}

void DriverLedSet(uint8_t LedData)
{
	PORTB.OUT=PORTB.OUT | (LedData & 0b00000111);
     d28:	e0 e2       	ldi	r30, 0x20	; 32
     d2a:	f6 e0       	ldi	r31, 0x06	; 6
     d2c:	94 81       	ldd	r25, Z+4	; 0x04
     d2e:	28 2f       	mov	r18, r24
     d30:	27 70       	andi	r18, 0x07	; 7
     d32:	92 2b       	or	r25, r18
     d34:	94 83       	std	Z+4, r25	; 0x04
	PORTA.OUT=PORTA.OUT | ((LedData & 0b00001000) << 4);
     d36:	e0 e0       	ldi	r30, 0x00	; 0
     d38:	f6 e0       	ldi	r31, 0x06	; 6
     d3a:	94 81       	ldd	r25, Z+4	; 0x04
     d3c:	88 70       	andi	r24, 0x08	; 8
     d3e:	82 95       	swap	r24
     d40:	80 7f       	andi	r24, 0xF0	; 240
     d42:	89 2b       	or	r24, r25
     d44:	84 83       	std	Z+4, r24	; 0x04
     d46:	08 95       	ret

00000d48 <DriverLedClear>:
}

void DriverLedClear(uint8_t LedData)
{
	PORTB.OUT=PORTB.OUT & ~(LedData & 0b00000111);
     d48:	e0 e2       	ldi	r30, 0x20	; 32
     d4a:	f6 e0       	ldi	r31, 0x06	; 6
     d4c:	24 81       	ldd	r18, Z+4	; 0x04
     d4e:	98 2f       	mov	r25, r24
     d50:	97 70       	andi	r25, 0x07	; 7
     d52:	90 95       	com	r25
     d54:	92 23       	and	r25, r18
     d56:	94 83       	std	Z+4, r25	; 0x04
	PORTA.OUT=PORTA.OUT & ~((LedData & 0b00001000) << 4);
     d58:	e0 e0       	ldi	r30, 0x00	; 0
     d5a:	f6 e0       	ldi	r31, 0x06	; 6
     d5c:	94 81       	ldd	r25, Z+4	; 0x04
     d5e:	88 70       	andi	r24, 0x08	; 8
     d60:	82 95       	swap	r24
     d62:	80 7f       	andi	r24, 0xF0	; 240
     d64:	80 95       	com	r24
     d66:	89 23       	and	r24, r25
     d68:	84 83       	std	Z+4, r24	; 0x04
     d6a:	08 95       	ret

00000d6c <DriverMotorInit>:


void DriverMotorInit(void)
{
	//GPIO init
	PORTF.DIRSET=0b11111;
     d6c:	e0 ea       	ldi	r30, 0xA0	; 160
     d6e:	f6 e0       	ldi	r31, 0x06	; 6
     d70:	8f e1       	ldi	r24, 0x1F	; 31
     d72:	81 83       	std	Z+1, r24	; 0x01
	PORTF.PIN4CTRL=0b01000000; //Invert
     d74:	80 e4       	ldi	r24, 0x40	; 64
     d76:	84 8b       	std	Z+20, r24	; 0x14
	PORTF.OUTSET=0b10000; //Sleep enable
     d78:	20 e1       	ldi	r18, 0x10	; 16
     d7a:	25 83       	std	Z+5, r18	; 0x05
	
	//Timer init, hbridge
	TCF0.CTRLA=0b00000001; //DIV1
     d7c:	e0 e0       	ldi	r30, 0x00	; 0
     d7e:	fb e0       	ldi	r31, 0x0B	; 11
     d80:	91 e0       	ldi	r25, 0x01	; 1
     d82:	90 83       	st	Z, r25
	TCF0.CTRLB=0b11110011; //OCA,OCB,OCC,OCD enable, SS PWM
     d84:	93 ef       	ldi	r25, 0xF3	; 243
     d86:	91 83       	std	Z+1, r25	; 0x01
	TCF0.PER=4096; //7812 Hz PWM
     d88:	40 e0       	ldi	r20, 0x00	; 0
     d8a:	50 e1       	ldi	r21, 0x10	; 16
     d8c:	46 a3       	std	Z+38, r20	; 0x26
     d8e:	57 a3       	std	Z+39, r21	; 0x27
	
	//Encoder 1A, 1B
	PORTC.DIRCLR=0b11000000; 
     d90:	e0 e4       	ldi	r30, 0x40	; 64
     d92:	f6 e0       	ldi	r31, 0x06	; 6
     d94:	90 ec       	ldi	r25, 0xC0	; 192
     d96:	92 83       	std	Z+2, r25	; 0x02
	PORTC.PIN6CTRL=0b01000000; //any edge detect
     d98:	86 8b       	std	Z+22, r24	; 0x16
	PORTC.PIN7CTRL=0b01000000; //any edge detect
     d9a:	87 8b       	std	Z+23, r24	; 0x17
	PORTC.INT0MASK=1<<6;
     d9c:	82 87       	std	Z+10, r24	; 0x0a
	PORTC.INT1MASK=1<<7;
     d9e:	90 e8       	ldi	r25, 0x80	; 128
     da0:	93 87       	std	Z+11, r25	; 0x0b
	PORTC.INTCTRL=0b0101;
     da2:	95 e0       	ldi	r25, 0x05	; 5
     da4:	91 87       	std	Z+9, r25	; 0x09

	//Encoder 2A, 2B
	PORTE.DIRCLR=0b00110000;
     da6:	e0 e8       	ldi	r30, 0x80	; 128
     da8:	f6 e0       	ldi	r31, 0x06	; 6
     daa:	30 e3       	ldi	r19, 0x30	; 48
     dac:	32 83       	std	Z+2, r19	; 0x02
	PORTE.PIN4CTRL=0b01000000; //any edge detect
     dae:	84 8b       	std	Z+20, r24	; 0x14
	PORTE.PIN5CTRL=0b01000000; //any edge detect
     db0:	85 8b       	std	Z+21, r24	; 0x15
	PORTE.INT0MASK=1<<4;
     db2:	22 87       	std	Z+10, r18	; 0x0a
	PORTE.INT1MASK=1<<5;
     db4:	80 e2       	ldi	r24, 0x20	; 32
     db6:	83 87       	std	Z+11, r24	; 0x0b
	PORTE.INTCTRL=0b0101;
     db8:	91 87       	std	Z+9, r25	; 0x09
	
	EncoderEventQueue=xQueueCreate(ENCODER_EVENT_QUEUE_LENGTH,sizeof(EncoderEventStruct));
     dba:	40 e0       	ldi	r20, 0x00	; 0
     dbc:	65 e0       	ldi	r22, 0x05	; 5
     dbe:	84 e1       	ldi	r24, 0x14	; 20
     dc0:	0e 94 ab 20 	call	0x4156	; 0x4156 <xQueueGenericCreate>
     dc4:	80 93 5c 2e 	sts	0x2E5C, r24	; 0x802e5c <EncoderEventQueue>
     dc8:	90 93 5d 2e 	sts	0x2E5D, r25	; 0x802e5d <EncoderEventQueue+0x1>
     dcc:	08 95       	ret

00000dce <DriverMotorSet>:

void DriverMotorSet(int16_t MotorLeft,int16_t MotorRight)
{
	//Sleep mode handling
	if (MotorLeft==0 && MotorRight==0)
		PORTF.OUTSET=0b10000; //DRV8833 in sleep mode
     dce:	20 e1       	ldi	r18, 0x10	; 16


void DriverMotorSet(int16_t MotorLeft,int16_t MotorRight)
{
	//Sleep mode handling
	if (MotorLeft==0 && MotorRight==0)
     dd0:	00 97       	sbiw	r24, 0x00	; 0
     dd2:	69 f5       	brne	.+90     	; 0xe2e <DriverMotorSet+0x60>
     dd4:	61 15       	cp	r22, r1
     dd6:	71 05       	cpc	r23, r1
     dd8:	09 f4       	brne	.+2      	; 0xddc <DriverMotorSet+0xe>
     dda:	57 c0       	rjmp	.+174    	; 0xe8a <DriverMotorSet+0xbc>
		PORTF.OUTSET=0b10000; //DRV8833 in sleep mode
	else
		PORTF.OUTCLR=0b10000; //DRV8833 in active mode
     ddc:	20 93 a6 06 	sts	0x06A6, r18	; 0x8006a6 <__TEXT_REGION_LENGTH__+0x7006a6>
		TCF0.CCB=MotorLeft;
	}
	else
	{
		if (MotorLeft<-4095) MotorLeft=-4095;
		TCF0.CCA=-MotorLeft;	
     de0:	81 30       	cpi	r24, 0x01	; 1
     de2:	20 ef       	ldi	r18, 0xF0	; 240
     de4:	92 07       	cpc	r25, r18
     de6:	0c f4       	brge	.+2      	; 0xdea <DriverMotorSet+0x1c>
     de8:	57 c0       	rjmp	.+174    	; 0xe98 <DriverMotorSet+0xca>
     dea:	91 95       	neg	r25
     dec:	81 95       	neg	r24
     dee:	91 09       	sbc	r25, r1
     df0:	80 93 28 0b 	sts	0x0B28, r24	; 0x800b28 <__TEXT_REGION_LENGTH__+0x700b28>
     df4:	90 93 29 0b 	sts	0x0B29, r25	; 0x800b29 <__TEXT_REGION_LENGTH__+0x700b29>
		TCF0.CCB=0;
     df8:	10 92 2a 0b 	sts	0x0B2A, r1	; 0x800b2a <__TEXT_REGION_LENGTH__+0x700b2a>
     dfc:	10 92 2b 0b 	sts	0x0B2B, r1	; 0x800b2b <__TEXT_REGION_LENGTH__+0x700b2b>
	}

	//Right motor
	if (MOTOR_RIGHT_INVERT==1) MotorRight=-MotorRight;
     e00:	71 95       	neg	r23
     e02:	61 95       	neg	r22
     e04:	71 09       	sbc	r23, r1
	if (MotorRight>0)
     e06:	16 16       	cp	r1, r22
     e08:	17 06       	cpc	r1, r23
     e0a:	44 f1       	brlt	.+80     	; 0xe5c <DriverMotorSet+0x8e>
		TCF0.CCD=MotorRight;
	}
	else
	{
		if (MotorRight<-4095) MotorRight=-4095;
		TCF0.CCC=-MotorRight;
     e0c:	61 30       	cpi	r22, 0x01	; 1
     e0e:	20 ef       	ldi	r18, 0xF0	; 240
     e10:	72 07       	cpc	r23, r18
     e12:	0c f4       	brge	.+2      	; 0xe16 <DriverMotorSet+0x48>
     e14:	44 c0       	rjmp	.+136    	; 0xe9e <DriverMotorSet+0xd0>
     e16:	71 95       	neg	r23
     e18:	61 95       	neg	r22
     e1a:	71 09       	sbc	r23, r1
     e1c:	60 93 2c 0b 	sts	0x0B2C, r22	; 0x800b2c <__TEXT_REGION_LENGTH__+0x700b2c>
     e20:	70 93 2d 0b 	sts	0x0B2D, r23	; 0x800b2d <__TEXT_REGION_LENGTH__+0x700b2d>
		TCF0.CCD=0;
     e24:	10 92 2e 0b 	sts	0x0B2E, r1	; 0x800b2e <__TEXT_REGION_LENGTH__+0x700b2e>
     e28:	10 92 2f 0b 	sts	0x0B2F, r1	; 0x800b2f <__TEXT_REGION_LENGTH__+0x700b2f>
	}
	
}
     e2c:	08 95       	ret
{
	//Sleep mode handling
	if (MotorLeft==0 && MotorRight==0)
		PORTF.OUTSET=0b10000; //DRV8833 in sleep mode
	else
		PORTF.OUTCLR=0b10000; //DRV8833 in active mode
     e2e:	20 93 a6 06 	sts	0x06A6, r18	; 0x8006a6 <__TEXT_REGION_LENGTH__+0x7006a6>
	
	//Left motor
	if (MOTOR_LEFT_INVERT==1) MotorLeft=-MotorLeft;
	if (MotorLeft>0)
     e32:	18 16       	cp	r1, r24
     e34:	19 06       	cpc	r1, r25
     e36:	a4 f6       	brge	.-88     	; 0xde0 <DriverMotorSet+0x12>
	{
		if (MotorLeft>4095) MotorLeft=4095;
		TCF0.CCA=0;
     e38:	10 92 28 0b 	sts	0x0B28, r1	; 0x800b28 <__TEXT_REGION_LENGTH__+0x700b28>
     e3c:	10 92 29 0b 	sts	0x0B29, r1	; 0x800b29 <__TEXT_REGION_LENGTH__+0x700b29>
		TCF0.CCB=MotorLeft;
     e40:	81 15       	cp	r24, r1
     e42:	20 e1       	ldi	r18, 0x10	; 16
     e44:	92 07       	cpc	r25, r18
     e46:	f4 f4       	brge	.+60     	; 0xe84 <DriverMotorSet+0xb6>
     e48:	80 93 2a 0b 	sts	0x0B2A, r24	; 0x800b2a <__TEXT_REGION_LENGTH__+0x700b2a>
     e4c:	90 93 2b 0b 	sts	0x0B2B, r25	; 0x800b2b <__TEXT_REGION_LENGTH__+0x700b2b>
		TCF0.CCA=-MotorLeft;	
		TCF0.CCB=0;
	}

	//Right motor
	if (MOTOR_RIGHT_INVERT==1) MotorRight=-MotorRight;
     e50:	71 95       	neg	r23
     e52:	61 95       	neg	r22
     e54:	71 09       	sbc	r23, r1
	if (MotorRight>0)
     e56:	16 16       	cp	r1, r22
     e58:	17 06       	cpc	r1, r23
     e5a:	c4 f6       	brge	.-80     	; 0xe0c <DriverMotorSet+0x3e>
	{
		if (MotorRight>4095) MotorRight=4095;
		TCF0.CCC=0;
     e5c:	10 92 2c 0b 	sts	0x0B2C, r1	; 0x800b2c <__TEXT_REGION_LENGTH__+0x700b2c>
     e60:	10 92 2d 0b 	sts	0x0B2D, r1	; 0x800b2d <__TEXT_REGION_LENGTH__+0x700b2d>
		TCF0.CCD=MotorRight;
     e64:	61 15       	cp	r22, r1
     e66:	80 e1       	ldi	r24, 0x10	; 16
     e68:	78 07       	cpc	r23, r24
     e6a:	2c f4       	brge	.+10     	; 0xe76 <DriverMotorSet+0xa8>
     e6c:	60 93 2e 0b 	sts	0x0B2E, r22	; 0x800b2e <__TEXT_REGION_LENGTH__+0x700b2e>
     e70:	70 93 2f 0b 	sts	0x0B2F, r23	; 0x800b2f <__TEXT_REGION_LENGTH__+0x700b2f>
     e74:	08 95       	ret
     e76:	6f ef       	ldi	r22, 0xFF	; 255
     e78:	7f e0       	ldi	r23, 0x0F	; 15
     e7a:	60 93 2e 0b 	sts	0x0B2E, r22	; 0x800b2e <__TEXT_REGION_LENGTH__+0x700b2e>
     e7e:	70 93 2f 0b 	sts	0x0B2F, r23	; 0x800b2f <__TEXT_REGION_LENGTH__+0x700b2f>
     e82:	08 95       	ret
	if (MOTOR_LEFT_INVERT==1) MotorLeft=-MotorLeft;
	if (MotorLeft>0)
	{
		if (MotorLeft>4095) MotorLeft=4095;
		TCF0.CCA=0;
		TCF0.CCB=MotorLeft;
     e84:	8f ef       	ldi	r24, 0xFF	; 255
     e86:	9f e0       	ldi	r25, 0x0F	; 15
     e88:	df cf       	rjmp	.-66     	; 0xe48 <DriverMotorSet+0x7a>

void DriverMotorSet(int16_t MotorLeft,int16_t MotorRight)
{
	//Sleep mode handling
	if (MotorLeft==0 && MotorRight==0)
		PORTF.OUTSET=0b10000; //DRV8833 in sleep mode
     e8a:	20 93 a5 06 	sts	0x06A5, r18	; 0x8006a5 <__TEXT_REGION_LENGTH__+0x7006a5>
		TCF0.CCB=MotorLeft;
	}
	else
	{
		if (MotorLeft<-4095) MotorLeft=-4095;
		TCF0.CCA=-MotorLeft;	
     e8e:	81 30       	cpi	r24, 0x01	; 1
     e90:	20 ef       	ldi	r18, 0xF0	; 240
     e92:	92 07       	cpc	r25, r18
     e94:	0c f0       	brlt	.+2      	; 0xe98 <DriverMotorSet+0xca>
     e96:	a9 cf       	rjmp	.-174    	; 0xdea <DriverMotorSet+0x1c>
     e98:	81 e0       	ldi	r24, 0x01	; 1
     e9a:	90 ef       	ldi	r25, 0xF0	; 240
     e9c:	a6 cf       	rjmp	.-180    	; 0xdea <DriverMotorSet+0x1c>
		TCF0.CCD=MotorRight;
	}
	else
	{
		if (MotorRight<-4095) MotorRight=-4095;
		TCF0.CCC=-MotorRight;
     e9e:	61 e0       	ldi	r22, 0x01	; 1
     ea0:	70 ef       	ldi	r23, 0xF0	; 240
     ea2:	b9 cf       	rjmp	.-142    	; 0xe16 <DriverMotorSet+0x48>

00000ea4 <DriverMotorGetEncoder>:

EncoderStruct DriverMotorGetEncoder(void)
{
	EncoderStruct EncoderInfo;

	portENTER_CRITICAL();
     ea4:	0f b6       	in	r0, 0x3f	; 63
     ea6:	f8 94       	cli
     ea8:	0f 92       	push	r0
	if (!ENCODER_LEFT_INVERT)
		EncoderInfo.Cnt1=Cnt1;
     eaa:	40 91 58 2e 	lds	r20, 0x2E58	; 0x802e58 <Cnt1>
     eae:	50 91 59 2e 	lds	r21, 0x2E59	; 0x802e59 <Cnt1+0x1>
	else
		EncoderInfo.Cnt1=-Cnt1;
	
	if (!ENCODER_RIGHT_INVERT)
		EncoderInfo.Cnt2=Cnt2;
     eb2:	20 91 5a 2e 	lds	r18, 0x2E5A	; 0x802e5a <Cnt2>
     eb6:	30 91 5b 2e 	lds	r19, 0x2E5B	; 0x802e5b <Cnt2+0x1>
	else
		EncoderInfo.Cnt2=-Cnt2;
	portEXIT_CRITICAL();
     eba:	0f 90       	pop	r0
     ebc:	0f be       	out	0x3f, r0	; 63
	return EncoderInfo;
     ebe:	ba 01       	movw	r22, r20
     ec0:	c9 01       	movw	r24, r18
}
     ec2:	08 95       	ret

00000ec4 <DriverMotorGetEncoderEvent>:

EncoderEventStruct DriverMotorGetEncoderEvent(void)
{
     ec4:	cf 93       	push	r28
     ec6:	df 93       	push	r29
     ec8:	cd b7       	in	r28, 0x3d	; 61
     eca:	de b7       	in	r29, 0x3e	; 62
     ecc:	2a 97       	sbiw	r28, 0x0a	; 10
     ece:	cd bf       	out	0x3d, r28	; 61
     ed0:	de bf       	out	0x3e, r29	; 62
	EncoderEventStruct Event={0,NONE};
     ed2:	1e 82       	std	Y+6, r1	; 0x06
     ed4:	1f 82       	std	Y+7, r1	; 0x07
     ed6:	18 86       	std	Y+8, r1	; 0x08
     ed8:	19 86       	std	Y+9, r1	; 0x09
     eda:	1a 86       	std	Y+10, r1	; 0x0a
	int res;
	res=xQueueReceive(EncoderEventQueue,&Event,0);
     edc:	40 e0       	ldi	r20, 0x00	; 0
     ede:	50 e0       	ldi	r21, 0x00	; 0
     ee0:	be 01       	movw	r22, r28
     ee2:	6a 5f       	subi	r22, 0xFA	; 250
     ee4:	7f 4f       	sbci	r23, 0xFF	; 255
     ee6:	80 91 5c 2e 	lds	r24, 0x2E5C	; 0x802e5c <EncoderEventQueue>
     eea:	90 91 5d 2e 	lds	r25, 0x2E5D	; 0x802e5d <EncoderEventQueue+0x1>
     eee:	0e 94 86 22 	call	0x450c	; 0x450c <xQueueReceive>
	return Event;
     ef2:	85 e0       	ldi	r24, 0x05	; 5
     ef4:	fe 01       	movw	r30, r28
     ef6:	36 96       	adiw	r30, 0x06	; 6
     ef8:	de 01       	movw	r26, r28
     efa:	11 96       	adiw	r26, 0x01	; 1
     efc:	01 90       	ld	r0, Z+
     efe:	0d 92       	st	X+, r0
     f00:	8a 95       	dec	r24
     f02:	e1 f7       	brne	.-8      	; 0xefc <DriverMotorGetEncoderEvent+0x38>
     f04:	29 81       	ldd	r18, Y+1	; 0x01
     f06:	3a 81       	ldd	r19, Y+2	; 0x02
     f08:	4b 81       	ldd	r20, Y+3	; 0x03
     f0a:	5c 81       	ldd	r21, Y+4	; 0x04
     f0c:	6d 81       	ldd	r22, Y+5	; 0x05
}
     f0e:	70 e0       	ldi	r23, 0x00	; 0
     f10:	80 e0       	ldi	r24, 0x00	; 0
     f12:	90 e0       	ldi	r25, 0x00	; 0
     f14:	2a 96       	adiw	r28, 0x0a	; 10
     f16:	cd bf       	out	0x3d, r28	; 61
     f18:	de bf       	out	0x3e, r29	; 62
     f1a:	df 91       	pop	r29
     f1c:	cf 91       	pop	r28
     f1e:	08 95       	ret

00000f20 <__vector_2>:

//Encoder 1 ISR's
ISR (PORTC_INT0_vect)
{	
     f20:	1f 92       	push	r1
     f22:	0f 92       	push	r0
     f24:	0f b6       	in	r0, 0x3f	; 63
     f26:	0f 92       	push	r0
     f28:	11 24       	eor	r1, r1
     f2a:	0b b6       	in	r0, 0x3b	; 59
     f2c:	0f 92       	push	r0
     f2e:	1f 93       	push	r17
     f30:	2f 93       	push	r18
     f32:	3f 93       	push	r19
     f34:	4f 93       	push	r20
     f36:	5f 93       	push	r21
     f38:	6f 93       	push	r22
     f3a:	7f 93       	push	r23
     f3c:	8f 93       	push	r24
     f3e:	9f 93       	push	r25
     f40:	af 93       	push	r26
     f42:	bf 93       	push	r27
     f44:	ef 93       	push	r30
     f46:	ff 93       	push	r31
     f48:	cf 93       	push	r28
     f4a:	df 93       	push	r29
     f4c:	00 d0       	rcall	.+0      	; 0xf4e <__vector_2+0x2e>
     f4e:	00 d0       	rcall	.+0      	; 0xf50 <__vector_2+0x30>
     f50:	cd b7       	in	r28, 0x3d	; 61
     f52:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastTriggerTime=0;
	uint8_t Data,l0,l1;
	EncoderEventStruct Event;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
     f54:	1e 82       	std	Y+6, r1	; 0x06
	Event.Time=portGET_RUN_TIME_COUNTER_VALUE();
     f56:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
     f5a:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
     f5e:	80 91 6e 2e 	lds	r24, 0x2E6E	; 0x802e6e <StatsTimer>
     f62:	90 91 6f 2e 	lds	r25, 0x2E6F	; 0x802e6f <StatsTimer+0x1>
     f66:	a0 91 70 2e 	lds	r26, 0x2E70	; 0x802e70 <StatsTimer+0x2>
     f6a:	b0 91 71 2e 	lds	r27, 0x2E71	; 0x802e71 <StatsTimer+0x3>
     f6e:	82 0f       	add	r24, r18
     f70:	93 1f       	adc	r25, r19
     f72:	a1 1d       	adc	r26, r1
     f74:	b1 1d       	adc	r27, r1
     f76:	89 83       	std	Y+1, r24	; 0x01
     f78:	9a 83       	std	Y+2, r25	; 0x02
     f7a:	ab 83       	std	Y+3, r26	; 0x03
     f7c:	bc 83       	std	Y+4, r27	; 0x04
	#ifdef ENCODER_FILTER_ENABLE
		if ((Event.Time-LastTriggerTime)<ENCODER_FILTER_TIME) return;
	#endif

	Data=PORTC.IN;
     f7e:	80 91 48 06 	lds	r24, 0x0648	; 0x800648 <__TEXT_REGION_LENGTH__+0x700648>
	l0=Data & (1<<6);
	l1=Data & (1<<7);
     f82:	18 2f       	mov	r17, r24
     f84:	10 78       	andi	r17, 0x80	; 128
		
	//Process events
	if (l0) 
     f86:	86 ff       	sbrs	r24, 6
     f88:	37 c0       	rjmp	.+110    	; 0xff8 <__vector_2+0xd8>
		Event.Event=RISING_1A;
     f8a:	81 e0       	ldi	r24, 0x01	; 1
     f8c:	8d 83       	std	Y+5, r24	; 0x05
	else
		Event.Event=FALLING_1A;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
     f8e:	20 e0       	ldi	r18, 0x00	; 0
     f90:	ae 01       	movw	r20, r28
     f92:	4a 5f       	subi	r20, 0xFA	; 250
     f94:	5f 4f       	sbci	r21, 0xFF	; 255
     f96:	be 01       	movw	r22, r28
     f98:	6f 5f       	subi	r22, 0xFF	; 255
     f9a:	7f 4f       	sbci	r23, 0xFF	; 255
     f9c:	80 91 5c 2e 	lds	r24, 0x2E5C	; 0x802e5c <EncoderEventQueue>
     fa0:	90 91 5d 2e 	lds	r25, 0x2E5D	; 0x802e5d <EncoderEventQueue+0x1>
     fa4:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <xQueueGenericSendFromISR>
	//Process counter
	if ( l0 && !l1) Cnt1--; //Rising edge on Line0, Line1 low
     fa8:	11 23       	and	r17, r17
     faa:	b9 f1       	breq	.+110    	; 0x101a <__vector_2+0xfa>
	if ( l0 &&  l1) Cnt1++; //Rising edge on Line0, Line1 high	
	if (!l0 &&  l1) Cnt1--; //Falling edge on Line0, Line1 high
	if (!l0 && !l1) Cnt1++;//Falling edge on Line1, Line1 low
     fac:	80 91 58 2e 	lds	r24, 0x2E58	; 0x802e58 <Cnt1>
     fb0:	90 91 59 2e 	lds	r25, 0x2E59	; 0x802e59 <Cnt1+0x1>
     fb4:	01 96       	adiw	r24, 0x01	; 1
     fb6:	80 93 58 2e 	sts	0x2E58, r24	; 0x802e58 <Cnt1>
     fba:	90 93 59 2e 	sts	0x2E59, r25	; 0x802e59 <Cnt1+0x1>

	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     fbe:	8e 81       	ldd	r24, Y+6	; 0x06
     fc0:	81 11       	cpse	r24, r1
     fc2:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <vPortYieldISR>
	LastTriggerTime=Event.Time;
}
     fc6:	26 96       	adiw	r28, 0x06	; 6
     fc8:	cd bf       	out	0x3d, r28	; 61
     fca:	de bf       	out	0x3e, r29	; 62
     fcc:	df 91       	pop	r29
     fce:	cf 91       	pop	r28
     fd0:	ff 91       	pop	r31
     fd2:	ef 91       	pop	r30
     fd4:	bf 91       	pop	r27
     fd6:	af 91       	pop	r26
     fd8:	9f 91       	pop	r25
     fda:	8f 91       	pop	r24
     fdc:	7f 91       	pop	r23
     fde:	6f 91       	pop	r22
     fe0:	5f 91       	pop	r21
     fe2:	4f 91       	pop	r20
     fe4:	3f 91       	pop	r19
     fe6:	2f 91       	pop	r18
     fe8:	1f 91       	pop	r17
     fea:	0f 90       	pop	r0
     fec:	0b be       	out	0x3b, r0	; 59
     fee:	0f 90       	pop	r0
     ff0:	0f be       	out	0x3f, r0	; 63
     ff2:	0f 90       	pop	r0
     ff4:	1f 90       	pop	r1
     ff6:	18 95       	reti
		
	//Process events
	if (l0) 
		Event.Event=RISING_1A;
	else
		Event.Event=FALLING_1A;
     ff8:	85 e0       	ldi	r24, 0x05	; 5
     ffa:	8d 83       	std	Y+5, r24	; 0x05

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
     ffc:	20 e0       	ldi	r18, 0x00	; 0
     ffe:	ae 01       	movw	r20, r28
    1000:	4a 5f       	subi	r20, 0xFA	; 250
    1002:	5f 4f       	sbci	r21, 0xFF	; 255
    1004:	be 01       	movw	r22, r28
    1006:	6f 5f       	subi	r22, 0xFF	; 255
    1008:	7f 4f       	sbci	r23, 0xFF	; 255
    100a:	80 91 5c 2e 	lds	r24, 0x2E5C	; 0x802e5c <EncoderEventQueue>
    100e:	90 91 5d 2e 	lds	r25, 0x2E5D	; 0x802e5d <EncoderEventQueue+0x1>
    1012:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <xQueueGenericSendFromISR>
	//Process counter
	if ( l0 && !l1) Cnt1--; //Rising edge on Line0, Line1 low
	if ( l0 &&  l1) Cnt1++; //Rising edge on Line0, Line1 high	
	if (!l0 &&  l1) Cnt1--; //Falling edge on Line0, Line1 high
    1016:	11 23       	and	r17, r17
    1018:	49 f2       	breq	.-110    	; 0xfac <__vector_2+0x8c>
    101a:	80 91 58 2e 	lds	r24, 0x2E58	; 0x802e58 <Cnt1>
    101e:	90 91 59 2e 	lds	r25, 0x2E59	; 0x802e59 <Cnt1+0x1>
    1022:	01 97       	sbiw	r24, 0x01	; 1
    1024:	80 93 58 2e 	sts	0x2E58, r24	; 0x802e58 <Cnt1>
    1028:	90 93 59 2e 	sts	0x2E59, r25	; 0x802e59 <Cnt1+0x1>
    102c:	c8 cf       	rjmp	.-112    	; 0xfbe <__vector_2+0x9e>

0000102e <__vector_3>:
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	LastTriggerTime=Event.Time;
}

ISR (PORTC_INT1_vect)
{
    102e:	1f 92       	push	r1
    1030:	0f 92       	push	r0
    1032:	0f b6       	in	r0, 0x3f	; 63
    1034:	0f 92       	push	r0
    1036:	11 24       	eor	r1, r1
    1038:	0b b6       	in	r0, 0x3b	; 59
    103a:	0f 92       	push	r0
    103c:	1f 93       	push	r17
    103e:	2f 93       	push	r18
    1040:	3f 93       	push	r19
    1042:	4f 93       	push	r20
    1044:	5f 93       	push	r21
    1046:	6f 93       	push	r22
    1048:	7f 93       	push	r23
    104a:	8f 93       	push	r24
    104c:	9f 93       	push	r25
    104e:	af 93       	push	r26
    1050:	bf 93       	push	r27
    1052:	ef 93       	push	r30
    1054:	ff 93       	push	r31
    1056:	cf 93       	push	r28
    1058:	df 93       	push	r29
    105a:	00 d0       	rcall	.+0      	; 0x105c <__vector_3+0x2e>
    105c:	00 d0       	rcall	.+0      	; 0x105e <__vector_3+0x30>
    105e:	cd b7       	in	r28, 0x3d	; 61
    1060:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastTriggerTime=0;
	uint8_t Data,l0,l1;
	EncoderEventStruct Event;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    1062:	1e 82       	std	Y+6, r1	; 0x06
	Event.Time=portGET_RUN_TIME_COUNTER_VALUE();
    1064:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    1068:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    106c:	80 91 6e 2e 	lds	r24, 0x2E6E	; 0x802e6e <StatsTimer>
    1070:	90 91 6f 2e 	lds	r25, 0x2E6F	; 0x802e6f <StatsTimer+0x1>
    1074:	a0 91 70 2e 	lds	r26, 0x2E70	; 0x802e70 <StatsTimer+0x2>
    1078:	b0 91 71 2e 	lds	r27, 0x2E71	; 0x802e71 <StatsTimer+0x3>
    107c:	82 0f       	add	r24, r18
    107e:	93 1f       	adc	r25, r19
    1080:	a1 1d       	adc	r26, r1
    1082:	b1 1d       	adc	r27, r1
    1084:	89 83       	std	Y+1, r24	; 0x01
    1086:	9a 83       	std	Y+2, r25	; 0x02
    1088:	ab 83       	std	Y+3, r26	; 0x03
    108a:	bc 83       	std	Y+4, r27	; 0x04
	#ifdef ENCODER_FILTER_ENABLE
		if ((Event.Time-LastTriggerTime)<ENCODER_FILTER_TIME) return;
	#endif
	
	Data=PORTC.IN;
    108c:	80 91 48 06 	lds	r24, 0x0648	; 0x800648 <__TEXT_REGION_LENGTH__+0x700648>
	l0=Data & (1<<6);
    1090:	18 2f       	mov	r17, r24
    1092:	10 74       	andi	r17, 0x40	; 64
	l1=Data & (1<<7);
	
	//Process events
	if (l1)
    1094:	87 ff       	sbrs	r24, 7
    1096:	37 c0       	rjmp	.+110    	; 0x1106 <__vector_3+0xd8>
		Event.Event=RISING_1B;
    1098:	82 e0       	ldi	r24, 0x02	; 2
    109a:	8d 83       	std	Y+5, r24	; 0x05
	else
		Event.Event=FALLING_1B;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    109c:	20 e0       	ldi	r18, 0x00	; 0
    109e:	ae 01       	movw	r20, r28
    10a0:	4a 5f       	subi	r20, 0xFA	; 250
    10a2:	5f 4f       	sbci	r21, 0xFF	; 255
    10a4:	be 01       	movw	r22, r28
    10a6:	6f 5f       	subi	r22, 0xFF	; 255
    10a8:	7f 4f       	sbci	r23, 0xFF	; 255
    10aa:	80 91 5c 2e 	lds	r24, 0x2E5C	; 0x802e5c <EncoderEventQueue>
    10ae:	90 91 5d 2e 	lds	r25, 0x2E5D	; 0x802e5d <EncoderEventQueue+0x1>
    10b2:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <xQueueGenericSendFromISR>
	//Process counter
	if ( l1 && !l0) Cnt1++;//Rising edge on Line1, Line0 low
    10b6:	11 23       	and	r17, r17
    10b8:	b9 f1       	breq	.+110    	; 0x1128 <__vector_3+0xfa>
	if ( l1 &&  l0) Cnt1--;//Rising edge on Line1, Line0 high
	if (!l1 &&  l0) Cnt1++;//Falling edge on Line1, Line0 high
	if (!l1 && !l0) Cnt1--;//Falling edge on Line1, Line0 low
    10ba:	80 91 58 2e 	lds	r24, 0x2E58	; 0x802e58 <Cnt1>
    10be:	90 91 59 2e 	lds	r25, 0x2E59	; 0x802e59 <Cnt1+0x1>
    10c2:	01 97       	sbiw	r24, 0x01	; 1
    10c4:	80 93 58 2e 	sts	0x2E58, r24	; 0x802e58 <Cnt1>
    10c8:	90 93 59 2e 	sts	0x2E59, r25	; 0x802e59 <Cnt1+0x1>

	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    10cc:	8e 81       	ldd	r24, Y+6	; 0x06
    10ce:	81 11       	cpse	r24, r1
    10d0:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <vPortYieldISR>
	LastTriggerTime=Event.Time;
}
    10d4:	26 96       	adiw	r28, 0x06	; 6
    10d6:	cd bf       	out	0x3d, r28	; 61
    10d8:	de bf       	out	0x3e, r29	; 62
    10da:	df 91       	pop	r29
    10dc:	cf 91       	pop	r28
    10de:	ff 91       	pop	r31
    10e0:	ef 91       	pop	r30
    10e2:	bf 91       	pop	r27
    10e4:	af 91       	pop	r26
    10e6:	9f 91       	pop	r25
    10e8:	8f 91       	pop	r24
    10ea:	7f 91       	pop	r23
    10ec:	6f 91       	pop	r22
    10ee:	5f 91       	pop	r21
    10f0:	4f 91       	pop	r20
    10f2:	3f 91       	pop	r19
    10f4:	2f 91       	pop	r18
    10f6:	1f 91       	pop	r17
    10f8:	0f 90       	pop	r0
    10fa:	0b be       	out	0x3b, r0	; 59
    10fc:	0f 90       	pop	r0
    10fe:	0f be       	out	0x3f, r0	; 63
    1100:	0f 90       	pop	r0
    1102:	1f 90       	pop	r1
    1104:	18 95       	reti
	
	//Process events
	if (l1)
		Event.Event=RISING_1B;
	else
		Event.Event=FALLING_1B;
    1106:	86 e0       	ldi	r24, 0x06	; 6
    1108:	8d 83       	std	Y+5, r24	; 0x05

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    110a:	20 e0       	ldi	r18, 0x00	; 0
    110c:	ae 01       	movw	r20, r28
    110e:	4a 5f       	subi	r20, 0xFA	; 250
    1110:	5f 4f       	sbci	r21, 0xFF	; 255
    1112:	be 01       	movw	r22, r28
    1114:	6f 5f       	subi	r22, 0xFF	; 255
    1116:	7f 4f       	sbci	r23, 0xFF	; 255
    1118:	80 91 5c 2e 	lds	r24, 0x2E5C	; 0x802e5c <EncoderEventQueue>
    111c:	90 91 5d 2e 	lds	r25, 0x2E5D	; 0x802e5d <EncoderEventQueue+0x1>
    1120:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <xQueueGenericSendFromISR>
	//Process counter
	if ( l1 && !l0) Cnt1++;//Rising edge on Line1, Line0 low
	if ( l1 &&  l0) Cnt1--;//Rising edge on Line1, Line0 high
	if (!l1 &&  l0) Cnt1++;//Falling edge on Line1, Line0 high
    1124:	11 23       	and	r17, r17
    1126:	49 f2       	breq	.-110    	; 0x10ba <__vector_3+0x8c>
    1128:	80 91 58 2e 	lds	r24, 0x2E58	; 0x802e58 <Cnt1>
    112c:	90 91 59 2e 	lds	r25, 0x2E59	; 0x802e59 <Cnt1+0x1>
    1130:	01 96       	adiw	r24, 0x01	; 1
    1132:	80 93 58 2e 	sts	0x2E58, r24	; 0x802e58 <Cnt1>
    1136:	90 93 59 2e 	sts	0x2E59, r25	; 0x802e59 <Cnt1+0x1>
    113a:	c8 cf       	rjmp	.-112    	; 0x10cc <__vector_3+0x9e>

0000113c <__vector_43>:
	LastTriggerTime=Event.Time;
}

//Encoder 2 ISR's
ISR (PORTE_INT0_vect)
{
    113c:	1f 92       	push	r1
    113e:	0f 92       	push	r0
    1140:	0f b6       	in	r0, 0x3f	; 63
    1142:	0f 92       	push	r0
    1144:	11 24       	eor	r1, r1
    1146:	0b b6       	in	r0, 0x3b	; 59
    1148:	0f 92       	push	r0
    114a:	1f 93       	push	r17
    114c:	2f 93       	push	r18
    114e:	3f 93       	push	r19
    1150:	4f 93       	push	r20
    1152:	5f 93       	push	r21
    1154:	6f 93       	push	r22
    1156:	7f 93       	push	r23
    1158:	8f 93       	push	r24
    115a:	9f 93       	push	r25
    115c:	af 93       	push	r26
    115e:	bf 93       	push	r27
    1160:	ef 93       	push	r30
    1162:	ff 93       	push	r31
    1164:	cf 93       	push	r28
    1166:	df 93       	push	r29
    1168:	00 d0       	rcall	.+0      	; 0x116a <__vector_43+0x2e>
    116a:	00 d0       	rcall	.+0      	; 0x116c <__vector_43+0x30>
    116c:	cd b7       	in	r28, 0x3d	; 61
    116e:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastTriggerTime=0;
	uint8_t Data,l0,l1;
	EncoderEventStruct Event;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    1170:	1e 82       	std	Y+6, r1	; 0x06
	Event.Time=portGET_RUN_TIME_COUNTER_VALUE();
    1172:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    1176:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    117a:	80 91 6e 2e 	lds	r24, 0x2E6E	; 0x802e6e <StatsTimer>
    117e:	90 91 6f 2e 	lds	r25, 0x2E6F	; 0x802e6f <StatsTimer+0x1>
    1182:	a0 91 70 2e 	lds	r26, 0x2E70	; 0x802e70 <StatsTimer+0x2>
    1186:	b0 91 71 2e 	lds	r27, 0x2E71	; 0x802e71 <StatsTimer+0x3>
    118a:	82 0f       	add	r24, r18
    118c:	93 1f       	adc	r25, r19
    118e:	a1 1d       	adc	r26, r1
    1190:	b1 1d       	adc	r27, r1
    1192:	89 83       	std	Y+1, r24	; 0x01
    1194:	9a 83       	std	Y+2, r25	; 0x02
    1196:	ab 83       	std	Y+3, r26	; 0x03
    1198:	bc 83       	std	Y+4, r27	; 0x04
	#ifdef ENCODER_FILTER_ENABLE
		if ((Event.Time-LastTriggerTime)<ENCODER_FILTER_TIME) return;
	#endif
	
	Data=PORTE.IN;
    119a:	80 91 88 06 	lds	r24, 0x0688	; 0x800688 <__TEXT_REGION_LENGTH__+0x700688>
	l0=Data & (1<<4);
	l1=Data & (1<<5);
    119e:	18 2f       	mov	r17, r24
    11a0:	10 72       	andi	r17, 0x20	; 32
	
	//Process events
	if (l0)
    11a2:	84 ff       	sbrs	r24, 4
    11a4:	37 c0       	rjmp	.+110    	; 0x1214 <__vector_43+0xd8>
		Event.Event=RISING_2A;
    11a6:	83 e0       	ldi	r24, 0x03	; 3
    11a8:	8d 83       	std	Y+5, r24	; 0x05
	else
		Event.Event=FALLING_2A;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    11aa:	20 e0       	ldi	r18, 0x00	; 0
    11ac:	ae 01       	movw	r20, r28
    11ae:	4a 5f       	subi	r20, 0xFA	; 250
    11b0:	5f 4f       	sbci	r21, 0xFF	; 255
    11b2:	be 01       	movw	r22, r28
    11b4:	6f 5f       	subi	r22, 0xFF	; 255
    11b6:	7f 4f       	sbci	r23, 0xFF	; 255
    11b8:	80 91 5c 2e 	lds	r24, 0x2E5C	; 0x802e5c <EncoderEventQueue>
    11bc:	90 91 5d 2e 	lds	r25, 0x2E5D	; 0x802e5d <EncoderEventQueue+0x1>
    11c0:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <xQueueGenericSendFromISR>
	//Process counter
	if ( l0 && !l1) Cnt2--; //Rising edge on Line0, Line1 low
    11c4:	11 23       	and	r17, r17
    11c6:	b9 f1       	breq	.+110    	; 0x1236 <__vector_43+0xfa>
	if ( l0 &&  l1) Cnt2++; //Rising edge on Line0, Line1 high
	if (!l0 &&  l1) Cnt2--; //Falling edge on Line0, Line1 high
	if (!l0 && !l1) Cnt2++;//Falling edge on Line1, Line1 low
    11c8:	80 91 5a 2e 	lds	r24, 0x2E5A	; 0x802e5a <Cnt2>
    11cc:	90 91 5b 2e 	lds	r25, 0x2E5B	; 0x802e5b <Cnt2+0x1>
    11d0:	01 96       	adiw	r24, 0x01	; 1
    11d2:	80 93 5a 2e 	sts	0x2E5A, r24	; 0x802e5a <Cnt2>
    11d6:	90 93 5b 2e 	sts	0x2E5B, r25	; 0x802e5b <Cnt2+0x1>
	
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    11da:	8e 81       	ldd	r24, Y+6	; 0x06
    11dc:	81 11       	cpse	r24, r1
    11de:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <vPortYieldISR>
	LastTriggerTime=Event.Time;
}
    11e2:	26 96       	adiw	r28, 0x06	; 6
    11e4:	cd bf       	out	0x3d, r28	; 61
    11e6:	de bf       	out	0x3e, r29	; 62
    11e8:	df 91       	pop	r29
    11ea:	cf 91       	pop	r28
    11ec:	ff 91       	pop	r31
    11ee:	ef 91       	pop	r30
    11f0:	bf 91       	pop	r27
    11f2:	af 91       	pop	r26
    11f4:	9f 91       	pop	r25
    11f6:	8f 91       	pop	r24
    11f8:	7f 91       	pop	r23
    11fa:	6f 91       	pop	r22
    11fc:	5f 91       	pop	r21
    11fe:	4f 91       	pop	r20
    1200:	3f 91       	pop	r19
    1202:	2f 91       	pop	r18
    1204:	1f 91       	pop	r17
    1206:	0f 90       	pop	r0
    1208:	0b be       	out	0x3b, r0	; 59
    120a:	0f 90       	pop	r0
    120c:	0f be       	out	0x3f, r0	; 63
    120e:	0f 90       	pop	r0
    1210:	1f 90       	pop	r1
    1212:	18 95       	reti
	
	//Process events
	if (l0)
		Event.Event=RISING_2A;
	else
		Event.Event=FALLING_2A;
    1214:	87 e0       	ldi	r24, 0x07	; 7
    1216:	8d 83       	std	Y+5, r24	; 0x05

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    1218:	20 e0       	ldi	r18, 0x00	; 0
    121a:	ae 01       	movw	r20, r28
    121c:	4a 5f       	subi	r20, 0xFA	; 250
    121e:	5f 4f       	sbci	r21, 0xFF	; 255
    1220:	be 01       	movw	r22, r28
    1222:	6f 5f       	subi	r22, 0xFF	; 255
    1224:	7f 4f       	sbci	r23, 0xFF	; 255
    1226:	80 91 5c 2e 	lds	r24, 0x2E5C	; 0x802e5c <EncoderEventQueue>
    122a:	90 91 5d 2e 	lds	r25, 0x2E5D	; 0x802e5d <EncoderEventQueue+0x1>
    122e:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <xQueueGenericSendFromISR>
	//Process counter
	if ( l0 && !l1) Cnt2--; //Rising edge on Line0, Line1 low
	if ( l0 &&  l1) Cnt2++; //Rising edge on Line0, Line1 high
	if (!l0 &&  l1) Cnt2--; //Falling edge on Line0, Line1 high
    1232:	11 23       	and	r17, r17
    1234:	49 f2       	breq	.-110    	; 0x11c8 <__vector_43+0x8c>
    1236:	80 91 5a 2e 	lds	r24, 0x2E5A	; 0x802e5a <Cnt2>
    123a:	90 91 5b 2e 	lds	r25, 0x2E5B	; 0x802e5b <Cnt2+0x1>
    123e:	01 97       	sbiw	r24, 0x01	; 1
    1240:	80 93 5a 2e 	sts	0x2E5A, r24	; 0x802e5a <Cnt2>
    1244:	90 93 5b 2e 	sts	0x2E5B, r25	; 0x802e5b <Cnt2+0x1>
    1248:	c8 cf       	rjmp	.-112    	; 0x11da <__vector_43+0x9e>

0000124a <__vector_44>:
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	LastTriggerTime=Event.Time;
}

ISR (PORTE_INT1_vect)
{
    124a:	1f 92       	push	r1
    124c:	0f 92       	push	r0
    124e:	0f b6       	in	r0, 0x3f	; 63
    1250:	0f 92       	push	r0
    1252:	11 24       	eor	r1, r1
    1254:	0b b6       	in	r0, 0x3b	; 59
    1256:	0f 92       	push	r0
    1258:	1f 93       	push	r17
    125a:	2f 93       	push	r18
    125c:	3f 93       	push	r19
    125e:	4f 93       	push	r20
    1260:	5f 93       	push	r21
    1262:	6f 93       	push	r22
    1264:	7f 93       	push	r23
    1266:	8f 93       	push	r24
    1268:	9f 93       	push	r25
    126a:	af 93       	push	r26
    126c:	bf 93       	push	r27
    126e:	ef 93       	push	r30
    1270:	ff 93       	push	r31
    1272:	cf 93       	push	r28
    1274:	df 93       	push	r29
    1276:	00 d0       	rcall	.+0      	; 0x1278 <__vector_44+0x2e>
    1278:	00 d0       	rcall	.+0      	; 0x127a <__vector_44+0x30>
    127a:	cd b7       	in	r28, 0x3d	; 61
    127c:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastTriggerTime=0;
	uint8_t Data,l0,l1;
	EncoderEventStruct Event;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    127e:	1e 82       	std	Y+6, r1	; 0x06
	Event.Time=portGET_RUN_TIME_COUNTER_VALUE();
    1280:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    1284:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    1288:	80 91 6e 2e 	lds	r24, 0x2E6E	; 0x802e6e <StatsTimer>
    128c:	90 91 6f 2e 	lds	r25, 0x2E6F	; 0x802e6f <StatsTimer+0x1>
    1290:	a0 91 70 2e 	lds	r26, 0x2E70	; 0x802e70 <StatsTimer+0x2>
    1294:	b0 91 71 2e 	lds	r27, 0x2E71	; 0x802e71 <StatsTimer+0x3>
    1298:	82 0f       	add	r24, r18
    129a:	93 1f       	adc	r25, r19
    129c:	a1 1d       	adc	r26, r1
    129e:	b1 1d       	adc	r27, r1
    12a0:	89 83       	std	Y+1, r24	; 0x01
    12a2:	9a 83       	std	Y+2, r25	; 0x02
    12a4:	ab 83       	std	Y+3, r26	; 0x03
    12a6:	bc 83       	std	Y+4, r27	; 0x04
	#ifdef ENCODER_FILTER_ENABLE
		if ((Event.Time-LastTriggerTime)<ENCODER_FILTER_TIME) return;
	#endif
	
	Data=PORTE.IN;
    12a8:	80 91 88 06 	lds	r24, 0x0688	; 0x800688 <__TEXT_REGION_LENGTH__+0x700688>
	l0=Data & (1<<4);
	l1=Data & (1<<5);
    12ac:	18 2f       	mov	r17, r24
    12ae:	10 72       	andi	r17, 0x20	; 32
	
	//Process events
	if (l0)
    12b0:	84 ff       	sbrs	r24, 4
    12b2:	1c c0       	rjmp	.+56     	; 0x12ec <__vector_44+0xa2>
	Event.Event=RISING_2B;
    12b4:	84 e0       	ldi	r24, 0x04	; 4
    12b6:	8d 83       	std	Y+5, r24	; 0x05
	else
	Event.Event=FALLING_2B;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    12b8:	20 e0       	ldi	r18, 0x00	; 0
    12ba:	ae 01       	movw	r20, r28
    12bc:	4a 5f       	subi	r20, 0xFA	; 250
    12be:	5f 4f       	sbci	r21, 0xFF	; 255
    12c0:	be 01       	movw	r22, r28
    12c2:	6f 5f       	subi	r22, 0xFF	; 255
    12c4:	7f 4f       	sbci	r23, 0xFF	; 255
    12c6:	80 91 5c 2e 	lds	r24, 0x2E5C	; 0x802e5c <EncoderEventQueue>
    12ca:	90 91 5d 2e 	lds	r25, 0x2E5D	; 0x802e5d <EncoderEventQueue+0x1>
    12ce:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <xQueueGenericSendFromISR>
	//Process counter
	if ( l1 && !l0) Cnt2++;//Rising edge on Line1, Line0 low
    12d2:	11 23       	and	r17, r17
    12d4:	09 f4       	brne	.+2      	; 0x12d8 <__vector_44+0x8e>
    12d6:	47 c0       	rjmp	.+142    	; 0x1366 <__vector_44+0x11c>
	if ( l1 &&  l0) Cnt2--;//Rising edge on Line1, Line0 high
    12d8:	80 91 5a 2e 	lds	r24, 0x2E5A	; 0x802e5a <Cnt2>
    12dc:	90 91 5b 2e 	lds	r25, 0x2E5B	; 0x802e5b <Cnt2+0x1>
    12e0:	01 97       	sbiw	r24, 0x01	; 1
    12e2:	80 93 5a 2e 	sts	0x2E5A, r24	; 0x802e5a <Cnt2>
    12e6:	90 93 5b 2e 	sts	0x2E5B, r25	; 0x802e5b <Cnt2+0x1>
    12ea:	1a c0       	rjmp	.+52     	; 0x1320 <__vector_44+0xd6>
	
	//Process events
	if (l0)
	Event.Event=RISING_2B;
	else
	Event.Event=FALLING_2B;
    12ec:	88 e0       	ldi	r24, 0x08	; 8
    12ee:	8d 83       	std	Y+5, r24	; 0x05

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    12f0:	20 e0       	ldi	r18, 0x00	; 0
    12f2:	ae 01       	movw	r20, r28
    12f4:	4a 5f       	subi	r20, 0xFA	; 250
    12f6:	5f 4f       	sbci	r21, 0xFF	; 255
    12f8:	be 01       	movw	r22, r28
    12fa:	6f 5f       	subi	r22, 0xFF	; 255
    12fc:	7f 4f       	sbci	r23, 0xFF	; 255
    12fe:	80 91 5c 2e 	lds	r24, 0x2E5C	; 0x802e5c <EncoderEventQueue>
    1302:	90 91 5d 2e 	lds	r25, 0x2E5D	; 0x802e5d <EncoderEventQueue+0x1>
    1306:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <xQueueGenericSendFromISR>
	//Process counter
	if ( l1 && !l0) Cnt2++;//Rising edge on Line1, Line0 low
    130a:	80 91 5a 2e 	lds	r24, 0x2E5A	; 0x802e5a <Cnt2>
    130e:	90 91 5b 2e 	lds	r25, 0x2E5B	; 0x802e5b <Cnt2+0x1>
    1312:	11 11       	cpse	r17, r1
    1314:	22 c0       	rjmp	.+68     	; 0x135a <__vector_44+0x110>
	if ( l1 &&  l0) Cnt2--;//Rising edge on Line1, Line0 high
	if (!l1 &&  l0) Cnt2++;//Falling edge on Line1, Line0 high
	if (!l1 && !l0) Cnt2--;//Falling edge on Line1, Line0 low
    1316:	01 97       	sbiw	r24, 0x01	; 1
    1318:	80 93 5a 2e 	sts	0x2E5A, r24	; 0x802e5a <Cnt2>
    131c:	90 93 5b 2e 	sts	0x2E5B, r25	; 0x802e5b <Cnt2+0x1>

	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    1320:	8e 81       	ldd	r24, Y+6	; 0x06
    1322:	81 11       	cpse	r24, r1
    1324:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <vPortYieldISR>
	LastTriggerTime=Event.Time;
}
    1328:	26 96       	adiw	r28, 0x06	; 6
    132a:	cd bf       	out	0x3d, r28	; 61
    132c:	de bf       	out	0x3e, r29	; 62
    132e:	df 91       	pop	r29
    1330:	cf 91       	pop	r28
    1332:	ff 91       	pop	r31
    1334:	ef 91       	pop	r30
    1336:	bf 91       	pop	r27
    1338:	af 91       	pop	r26
    133a:	9f 91       	pop	r25
    133c:	8f 91       	pop	r24
    133e:	7f 91       	pop	r23
    1340:	6f 91       	pop	r22
    1342:	5f 91       	pop	r21
    1344:	4f 91       	pop	r20
    1346:	3f 91       	pop	r19
    1348:	2f 91       	pop	r18
    134a:	1f 91       	pop	r17
    134c:	0f 90       	pop	r0
    134e:	0b be       	out	0x3b, r0	; 59
    1350:	0f 90       	pop	r0
    1352:	0f be       	out	0x3f, r0	; 63
    1354:	0f 90       	pop	r0
    1356:	1f 90       	pop	r1
    1358:	18 95       	reti
	else
	Event.Event=FALLING_2B;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
	//Process counter
	if ( l1 && !l0) Cnt2++;//Rising edge on Line1, Line0 low
    135a:	01 96       	adiw	r24, 0x01	; 1
    135c:	80 93 5a 2e 	sts	0x2E5A, r24	; 0x802e5a <Cnt2>
    1360:	90 93 5b 2e 	sts	0x2E5B, r25	; 0x802e5b <Cnt2+0x1>
    1364:	dd cf       	rjmp	.-70     	; 0x1320 <__vector_44+0xd6>
	if ( l1 &&  l0) Cnt2--;//Rising edge on Line1, Line0 high
	if (!l1 &&  l0) Cnt2++;//Falling edge on Line1, Line0 high
    1366:	80 91 5a 2e 	lds	r24, 0x2E5A	; 0x802e5a <Cnt2>
    136a:	90 91 5b 2e 	lds	r25, 0x2E5B	; 0x802e5b <Cnt2+0x1>
    136e:	01 96       	adiw	r24, 0x01	; 1
    1370:	80 93 5a 2e 	sts	0x2E5A, r24	; 0x802e5a <Cnt2>
    1374:	90 93 5b 2e 	sts	0x2E5B, r25	; 0x802e5b <Cnt2+0x1>
    1378:	d3 cf       	rjmp	.-90     	; 0x1320 <__vector_44+0xd6>

0000137a <DriverMotorResetEncoder>:
}


void DriverMotorResetEncoder(void)
{
	portENTER_CRITICAL();	
    137a:	0f b6       	in	r0, 0x3f	; 63
    137c:	f8 94       	cli
    137e:	0f 92       	push	r0
	Cnt1=0;
    1380:	10 92 58 2e 	sts	0x2E58, r1	; 0x802e58 <Cnt1>
    1384:	10 92 59 2e 	sts	0x2E59, r1	; 0x802e59 <Cnt1+0x1>
	Cnt2=0;
    1388:	10 92 5a 2e 	sts	0x2E5A, r1	; 0x802e5a <Cnt2>
    138c:	10 92 5b 2e 	sts	0x2E5B, r1	; 0x802e5b <Cnt2+0x1>
	portEXIT_CRITICAL();
    1390:	0f 90       	pop	r0
    1392:	0f be       	out	0x3f, r0	; 63
    1394:	08 95       	ret

00001396 <DriverMPU6050Init>:
	uint8_t Buffer[18];

	Buffer[0]=MPU6050_AX;
	res=TWIMWriteRead(MPU6050_ADDR,Buffer,1,Buffer,18);

	configASSERT(res);
    1396:	0f 93       	push	r16
    1398:	1f 93       	push	r17
    139a:	cf 93       	push	r28
    139c:	df 93       	push	r29
    139e:	1f 92       	push	r1
    13a0:	1f 92       	push	r1
    13a2:	cd b7       	in	r28, 0x3d	; 61
    13a4:	de b7       	in	r29, 0x3e	; 62
    13a6:	85 e7       	ldi	r24, 0x75	; 117
    13a8:	89 83       	std	Y+1, r24	; 0x01
    13aa:	01 e0       	ldi	r16, 0x01	; 1
    13ac:	9e 01       	movw	r18, r28
    13ae:	2f 5f       	subi	r18, 0xFF	; 255
    13b0:	3f 4f       	sbci	r19, 0xFF	; 255
    13b2:	41 e0       	ldi	r20, 0x01	; 1
    13b4:	b9 01       	movw	r22, r18
    13b6:	88 e6       	ldi	r24, 0x68	; 104
    13b8:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
    13bc:	88 23       	and	r24, r24
    13be:	d9 f0       	breq	.+54     	; 0x13f6 <DriverMPU6050Init+0x60>
    13c0:	89 81       	ldd	r24, Y+1	; 0x01
    13c2:	88 36       	cpi	r24, 0x68	; 104
    13c4:	19 f1       	breq	.+70     	; 0x140c <DriverMPU6050Init+0x76>
    13c6:	1f 92       	push	r1
    13c8:	98 e6       	ldi	r25, 0x68	; 104
    13ca:	9f 93       	push	r25
    13cc:	1f 92       	push	r1
    13ce:	8f 93       	push	r24
    13d0:	84 e5       	ldi	r24, 0x54	; 84
    13d2:	91 e2       	ldi	r25, 0x21	; 33
    13d4:	9f 93       	push	r25
    13d6:	8f 93       	push	r24
    13d8:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
    13dc:	0f 90       	pop	r0
    13de:	0f 90       	pop	r0
    13e0:	0f 90       	pop	r0
    13e2:	0f 90       	pop	r0
    13e4:	0f 90       	pop	r0
    13e6:	0f 90       	pop	r0
    13e8:	0f 90       	pop	r0
    13ea:	0f 90       	pop	r0
    13ec:	df 91       	pop	r29
    13ee:	cf 91       	pop	r28
    13f0:	1f 91       	pop	r17
    13f2:	0f 91       	pop	r16
    13f4:	08 95       	ret
    13f6:	8f e3       	ldi	r24, 0x3F	; 63
    13f8:	91 e2       	ldi	r25, 0x21	; 33
    13fa:	0e 94 1b 51 	call	0xa236	; 0xa236 <puts>
    13fe:	0f 90       	pop	r0
    1400:	0f 90       	pop	r0
    1402:	df 91       	pop	r29
    1404:	cf 91       	pop	r28
    1406:	1f 91       	pop	r17
    1408:	0f 91       	pop	r16
    140a:	08 95       	ret
    140c:	89 e1       	ldi	r24, 0x19	; 25
    140e:	89 83       	std	Y+1, r24	; 0x01
    1410:	1a 82       	std	Y+2, r1	; 0x02
    1412:	42 e0       	ldi	r20, 0x02	; 2
    1414:	be 01       	movw	r22, r28
    1416:	6f 5f       	subi	r22, 0xFF	; 255
    1418:	7f 4f       	sbci	r23, 0xFF	; 255
    141a:	88 e6       	ldi	r24, 0x68	; 104
    141c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
    1420:	8a e1       	ldi	r24, 0x1A	; 26
    1422:	89 83       	std	Y+1, r24	; 0x01
    1424:	11 e0       	ldi	r17, 0x01	; 1
    1426:	1a 83       	std	Y+2, r17	; 0x02
    1428:	42 e0       	ldi	r20, 0x02	; 2
    142a:	be 01       	movw	r22, r28
    142c:	6f 5f       	subi	r22, 0xFF	; 255
    142e:	7f 4f       	sbci	r23, 0xFF	; 255
    1430:	88 e6       	ldi	r24, 0x68	; 104
    1432:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
    1436:	8b e1       	ldi	r24, 0x1B	; 27
    1438:	89 83       	std	Y+1, r24	; 0x01
    143a:	1a 82       	std	Y+2, r1	; 0x02
    143c:	42 e0       	ldi	r20, 0x02	; 2
    143e:	be 01       	movw	r22, r28
    1440:	6f 5f       	subi	r22, 0xFF	; 255
    1442:	7f 4f       	sbci	r23, 0xFF	; 255
    1444:	88 e6       	ldi	r24, 0x68	; 104
    1446:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
    144a:	87 e3       	ldi	r24, 0x37	; 55
    144c:	89 83       	std	Y+1, r24	; 0x01
    144e:	80 e1       	ldi	r24, 0x10	; 16
    1450:	8a 83       	std	Y+2, r24	; 0x02
    1452:	42 e0       	ldi	r20, 0x02	; 2
    1454:	be 01       	movw	r22, r28
    1456:	6f 5f       	subi	r22, 0xFF	; 255
    1458:	7f 4f       	sbci	r23, 0xFF	; 255
    145a:	88 e6       	ldi	r24, 0x68	; 104
    145c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
    1460:	88 e3       	ldi	r24, 0x38	; 56
    1462:	89 83       	std	Y+1, r24	; 0x01
    1464:	1a 83       	std	Y+2, r17	; 0x02
    1466:	42 e0       	ldi	r20, 0x02	; 2
    1468:	be 01       	movw	r22, r28
    146a:	6f 5f       	subi	r22, 0xFF	; 255
    146c:	7f 4f       	sbci	r23, 0xFF	; 255
    146e:	88 e6       	ldi	r24, 0x68	; 104
    1470:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
    1474:	8b e6       	ldi	r24, 0x6B	; 107
    1476:	89 83       	std	Y+1, r24	; 0x01
    1478:	1a 83       	std	Y+2, r17	; 0x02
    147a:	42 e0       	ldi	r20, 0x02	; 2
    147c:	be 01       	movw	r22, r28
    147e:	6f 5f       	subi	r22, 0xFF	; 255
    1480:	7f 4f       	sbci	r23, 0xFF	; 255
    1482:	88 e6       	ldi	r24, 0x68	; 104
    1484:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
    1488:	0f 90       	pop	r0
    148a:	0f 90       	pop	r0
    148c:	df 91       	pop	r29
    148e:	cf 91       	pop	r28
    1490:	1f 91       	pop	r17
    1492:	0f 91       	pop	r16
    1494:	08 95       	ret

00001496 <DriverMPU6050GyroGet>:
		data->accelZ = accelZ;
	}
}

void DriverMPU6050GyroGet(int16_t *Gx,int16_t *Gy,int16_t *Gz)
{
    1496:	af 92       	push	r10
    1498:	bf 92       	push	r11
    149a:	cf 92       	push	r12
    149c:	df 92       	push	r13
    149e:	ef 92       	push	r14
    14a0:	ff 92       	push	r15
    14a2:	0f 93       	push	r16
    14a4:	cf 93       	push	r28
    14a6:	df 93       	push	r29
    14a8:	cd b7       	in	r28, 0x3d	; 61
    14aa:	de b7       	in	r29, 0x3e	; 62
    14ac:	2c 97       	sbiw	r28, 0x0c	; 12
    14ae:	cd bf       	out	0x3d, r28	; 61
    14b0:	de bf       	out	0x3e, r29	; 62
    14b2:	5c 01       	movw	r10, r24
    14b4:	6b 01       	movw	r12, r22
    14b6:	7a 01       	movw	r14, r20
	uint8_t res;
	uint16_t x,y,z;
	uint8_t Buffer[6];

	//Read Gyro data
	Buffer[0]=MPU6050_GX;
    14b8:	83 e4       	ldi	r24, 0x43	; 67
    14ba:	89 83       	std	Y+1, r24	; 0x01
	res=TWIMWriteRead(MPU6050_ADDR,Buffer,1,Buffer,6);
    14bc:	06 e0       	ldi	r16, 0x06	; 6
    14be:	9e 01       	movw	r18, r28
    14c0:	2f 5f       	subi	r18, 0xFF	; 255
    14c2:	3f 4f       	sbci	r19, 0xFF	; 255
    14c4:	41 e0       	ldi	r20, 0x01	; 1
    14c6:	b9 01       	movw	r22, r18
    14c8:	88 e6       	ldi	r24, 0x68	; 104
    14ca:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
	configASSERT(res);
    14ce:	88 23       	and	r24, r24
    14d0:	89 f1       	breq	.+98     	; 0x1534 <DriverMPU6050GyroGet+0x9e>
	((char *) (&x))[0]=Buffer[1];
    14d2:	8a 81       	ldd	r24, Y+2	; 0x02
    14d4:	8b 87       	std	Y+11, r24	; 0x0b
	((char *) (&x))[1]=Buffer[0];
    14d6:	89 81       	ldd	r24, Y+1	; 0x01
    14d8:	8c 87       	std	Y+12, r24	; 0x0c
	
	((char *) (&y))[0]=Buffer[3];
    14da:	8c 81       	ldd	r24, Y+4	; 0x04
    14dc:	89 87       	std	Y+9, r24	; 0x09
	((char *) (&y))[1]=Buffer[2];
    14de:	8b 81       	ldd	r24, Y+3	; 0x03
    14e0:	8a 87       	std	Y+10, r24	; 0x0a
		
	((char *) (&z))[0]=Buffer[5];
    14e2:	8e 81       	ldd	r24, Y+6	; 0x06
    14e4:	8f 83       	std	Y+7, r24	; 0x07
	((char *) (&z))[1]=Buffer[4];
    14e6:	8d 81       	ldd	r24, Y+5	; 0x05
    14e8:	88 87       	std	Y+8, r24	; 0x08

	if (Gx!=NULL) *Gx=x;	
    14ea:	a1 14       	cp	r10, r1
    14ec:	b1 04       	cpc	r11, r1
    14ee:	29 f0       	breq	.+10     	; 0x14fa <DriverMPU6050GyroGet+0x64>
    14f0:	8b 85       	ldd	r24, Y+11	; 0x0b
    14f2:	9c 85       	ldd	r25, Y+12	; 0x0c
    14f4:	f5 01       	movw	r30, r10
    14f6:	80 83       	st	Z, r24
    14f8:	91 83       	std	Z+1, r25	; 0x01
	if (Gy!=NULL) *Gy=y;	
    14fa:	c1 14       	cp	r12, r1
    14fc:	d1 04       	cpc	r13, r1
    14fe:	29 f0       	breq	.+10     	; 0x150a <DriverMPU6050GyroGet+0x74>
    1500:	89 85       	ldd	r24, Y+9	; 0x09
    1502:	9a 85       	ldd	r25, Y+10	; 0x0a
    1504:	f6 01       	movw	r30, r12
    1506:	80 83       	st	Z, r24
    1508:	91 83       	std	Z+1, r25	; 0x01
	if (Gz!=NULL) *Gz=z;	
    150a:	e1 14       	cp	r14, r1
    150c:	f1 04       	cpc	r15, r1
    150e:	29 f0       	breq	.+10     	; 0x151a <DriverMPU6050GyroGet+0x84>
    1510:	8f 81       	ldd	r24, Y+7	; 0x07
    1512:	98 85       	ldd	r25, Y+8	; 0x08
    1514:	f7 01       	movw	r30, r14
    1516:	80 83       	st	Z, r24
    1518:	91 83       	std	Z+1, r25	; 0x01
}
    151a:	2c 96       	adiw	r28, 0x0c	; 12
    151c:	cd bf       	out	0x3d, r28	; 61
    151e:	de bf       	out	0x3e, r29	; 62
    1520:	df 91       	pop	r29
    1522:	cf 91       	pop	r28
    1524:	0f 91       	pop	r16
    1526:	ff 90       	pop	r15
    1528:	ef 90       	pop	r14
    152a:	df 90       	pop	r13
    152c:	cf 90       	pop	r12
    152e:	bf 90       	pop	r11
    1530:	af 90       	pop	r10
    1532:	08 95       	ret
	uint8_t Buffer[6];

	//Read Gyro data
	Buffer[0]=MPU6050_GX;
	res=TWIMWriteRead(MPU6050_ADDR,Buffer,1,Buffer,6);
	configASSERT(res);
    1534:	6f e7       	ldi	r22, 0x7F	; 127
    1536:	70 e0       	ldi	r23, 0x00	; 0
    1538:	8b e8       	ldi	r24, 0x8B	; 139
    153a:	91 e2       	ldi	r25, 0x21	; 33
    153c:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    1540:	c8 cf       	rjmp	.-112    	; 0x14d2 <DriverMPU6050GyroGet+0x3c>

00001542 <set_page_address.part.0>:

void DriverOLEDWake()
{
	if (!DriverOLEDInitialized) return;
	send_command(0xAF);
}
    1542:	1f 93       	push	r17
    1544:	cf 93       	push	r28
    1546:	df 93       	push	r29
    1548:	1f 92       	push	r1
    154a:	1f 92       	push	r1
    154c:	cd b7       	in	r28, 0x3d	; 61
    154e:	de b7       	in	r29, 0x3e	; 62
    1550:	10 e8       	ldi	r17, 0x80	; 128
    1552:	19 83       	std	Y+1, r17	; 0x01
    1554:	82 e2       	ldi	r24, 0x22	; 34
    1556:	8a 83       	std	Y+2, r24	; 0x02
    1558:	42 e0       	ldi	r20, 0x02	; 2
    155a:	be 01       	movw	r22, r28
    155c:	6f 5f       	subi	r22, 0xFF	; 255
    155e:	7f 4f       	sbci	r23, 0xFF	; 255
    1560:	8c e3       	ldi	r24, 0x3C	; 60
    1562:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
    1566:	19 83       	std	Y+1, r17	; 0x01
    1568:	1a 82       	std	Y+2, r1	; 0x02
    156a:	42 e0       	ldi	r20, 0x02	; 2
    156c:	be 01       	movw	r22, r28
    156e:	6f 5f       	subi	r22, 0xFF	; 255
    1570:	7f 4f       	sbci	r23, 0xFF	; 255
    1572:	8c e3       	ldi	r24, 0x3C	; 60
    1574:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
    1578:	19 83       	std	Y+1, r17	; 0x01
    157a:	87 e0       	ldi	r24, 0x07	; 7
    157c:	8a 83       	std	Y+2, r24	; 0x02
    157e:	42 e0       	ldi	r20, 0x02	; 2
    1580:	be 01       	movw	r22, r28
    1582:	6f 5f       	subi	r22, 0xFF	; 255
    1584:	7f 4f       	sbci	r23, 0xFF	; 255
    1586:	8c e3       	ldi	r24, 0x3C	; 60
    1588:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
    158c:	0f 90       	pop	r0
    158e:	0f 90       	pop	r0
    1590:	df 91       	pop	r29
    1592:	cf 91       	pop	r28
    1594:	1f 91       	pop	r17
    1596:	08 95       	ret

00001598 <set_column_address.part.1>:
    1598:	1f 93       	push	r17
    159a:	cf 93       	push	r28
    159c:	df 93       	push	r29
    159e:	1f 92       	push	r1
    15a0:	1f 92       	push	r1
    15a2:	cd b7       	in	r28, 0x3d	; 61
    15a4:	de b7       	in	r29, 0x3e	; 62
    15a6:	10 e8       	ldi	r17, 0x80	; 128
    15a8:	19 83       	std	Y+1, r17	; 0x01
    15aa:	81 e2       	ldi	r24, 0x21	; 33
    15ac:	8a 83       	std	Y+2, r24	; 0x02
    15ae:	42 e0       	ldi	r20, 0x02	; 2
    15b0:	be 01       	movw	r22, r28
    15b2:	6f 5f       	subi	r22, 0xFF	; 255
    15b4:	7f 4f       	sbci	r23, 0xFF	; 255
    15b6:	8c e3       	ldi	r24, 0x3C	; 60
    15b8:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
    15bc:	19 83       	std	Y+1, r17	; 0x01
    15be:	1a 82       	std	Y+2, r1	; 0x02
    15c0:	42 e0       	ldi	r20, 0x02	; 2
    15c2:	be 01       	movw	r22, r28
    15c4:	6f 5f       	subi	r22, 0xFF	; 255
    15c6:	7f 4f       	sbci	r23, 0xFF	; 255
    15c8:	8c e3       	ldi	r24, 0x3C	; 60
    15ca:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
    15ce:	19 83       	std	Y+1, r17	; 0x01
    15d0:	8f e7       	ldi	r24, 0x7F	; 127
    15d2:	8a 83       	std	Y+2, r24	; 0x02
    15d4:	42 e0       	ldi	r20, 0x02	; 2
    15d6:	be 01       	movw	r22, r28
    15d8:	6f 5f       	subi	r22, 0xFF	; 255
    15da:	7f 4f       	sbci	r23, 0xFF	; 255
    15dc:	8c e3       	ldi	r24, 0x3C	; 60
    15de:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
    15e2:	0f 90       	pop	r0
    15e4:	0f 90       	pop	r0
    15e6:	df 91       	pop	r29
    15e8:	cf 91       	pop	r28
    15ea:	1f 91       	pop	r17
    15ec:	08 95       	ret

000015ee <DriverOLEDDrawPixel.part.3>:
    15ee:	90 91 fa 28 	lds	r25, 0x28FA	; 0x8028fa <GlobOrientation>
    15f2:	91 11       	cpse	r25, r1
    15f4:	1c c0       	rjmp	.+56     	; 0x162e <DriverOLEDDrawPixel.part.3+0x40>
    15f6:	87 fd       	sbrc	r24, 7
    15f8:	19 c0       	rjmp	.+50     	; 0x162c <DriverOLEDDrawPixel.part.3+0x3e>
    15fa:	60 34       	cpi	r22, 0x40	; 64
    15fc:	b8 f4       	brcc	.+46     	; 0x162c <DriverOLEDDrawPixel.part.3+0x3e>
    15fe:	96 2f       	mov	r25, r22
    1600:	96 95       	lsr	r25
    1602:	96 95       	lsr	r25
    1604:	96 95       	lsr	r25
    1606:	e8 2f       	mov	r30, r24
    1608:	f0 e0       	ldi	r31, 0x00	; 0
    160a:	20 e8       	ldi	r18, 0x80	; 128
    160c:	92 9f       	mul	r25, r18
    160e:	e0 0d       	add	r30, r0
    1610:	f1 1d       	adc	r31, r1
    1612:	11 24       	eor	r1, r1
    1614:	e5 50       	subi	r30, 0x05	; 5
    1616:	f7 4d       	sbci	r31, 0xD7	; 215
    1618:	67 70       	andi	r22, 0x07	; 7
    161a:	81 e0       	ldi	r24, 0x01	; 1
    161c:	90 e0       	ldi	r25, 0x00	; 0
    161e:	01 c0       	rjmp	.+2      	; 0x1622 <DriverOLEDDrawPixel.part.3+0x34>
    1620:	88 0f       	add	r24, r24
    1622:	6a 95       	dec	r22
    1624:	ea f7       	brpl	.-6      	; 0x1620 <DriverOLEDDrawPixel.part.3+0x32>
    1626:	90 81       	ld	r25, Z
    1628:	89 2b       	or	r24, r25
    162a:	80 83       	st	Z, r24
    162c:	08 95       	ret
    162e:	91 30       	cpi	r25, 0x01	; 1
    1630:	21 f1       	breq	.+72     	; 0x167a <DriverOLEDDrawPixel.part.3+0x8c>
    1632:	92 30       	cpi	r25, 0x02	; 2
    1634:	d9 f7       	brne	.-10     	; 0x162c <DriverOLEDDrawPixel.part.3+0x3e>
    1636:	87 fd       	sbrc	r24, 7
    1638:	f9 cf       	rjmp	.-14     	; 0x162c <DriverOLEDDrawPixel.part.3+0x3e>
    163a:	60 34       	cpi	r22, 0x40	; 64
    163c:	b8 f7       	brcc	.-18     	; 0x162c <DriverOLEDDrawPixel.part.3+0x3e>
    163e:	70 e0       	ldi	r23, 0x00	; 0
    1640:	ef e3       	ldi	r30, 0x3F	; 63
    1642:	f0 e0       	ldi	r31, 0x00	; 0
    1644:	e6 1b       	sub	r30, r22
    1646:	f7 0b       	sbc	r31, r23
    1648:	f5 95       	asr	r31
    164a:	e7 95       	ror	r30
    164c:	f5 95       	asr	r31
    164e:	e7 95       	ror	r30
    1650:	f5 95       	asr	r31
    1652:	e7 95       	ror	r30
    1654:	f6 95       	lsr	r31
    1656:	fe 2f       	mov	r31, r30
    1658:	ee 27       	eor	r30, r30
    165a:	f7 95       	ror	r31
    165c:	e7 95       	ror	r30
    165e:	2f e7       	ldi	r18, 0x7F	; 127
    1660:	30 e0       	ldi	r19, 0x00	; 0
    1662:	a9 01       	movw	r20, r18
    1664:	48 1b       	sub	r20, r24
    1666:	51 09       	sbc	r21, r1
    1668:	e4 0f       	add	r30, r20
    166a:	f5 1f       	adc	r31, r21
    166c:	e5 50       	subi	r30, 0x05	; 5
    166e:	f7 4d       	sbci	r31, 0xD7	; 215
    1670:	60 95       	com	r22
    1672:	70 95       	com	r23
    1674:	67 70       	andi	r22, 0x07	; 7
    1676:	77 27       	eor	r23, r23
    1678:	d0 cf       	rjmp	.-96     	; 0x161a <DriverOLEDDrawPixel.part.3+0x2c>
    167a:	80 34       	cpi	r24, 0x40	; 64
    167c:	b8 f6       	brcc	.-82     	; 0x162c <DriverOLEDDrawPixel.part.3+0x3e>
    167e:	67 fd       	sbrc	r22, 7
    1680:	d5 cf       	rjmp	.-86     	; 0x162c <DriverOLEDDrawPixel.part.3+0x3e>
    1682:	98 2f       	mov	r25, r24
    1684:	96 95       	lsr	r25
    1686:	96 95       	lsr	r25
    1688:	96 95       	lsr	r25
    168a:	af e7       	ldi	r26, 0x7F	; 127
    168c:	b0 e0       	ldi	r27, 0x00	; 0
    168e:	a6 1b       	sub	r26, r22
    1690:	b1 09       	sbc	r27, r1
    1692:	40 e8       	ldi	r20, 0x80	; 128
    1694:	94 9f       	mul	r25, r20
    1696:	a0 0d       	add	r26, r0
    1698:	b1 1d       	adc	r27, r1
    169a:	11 24       	eor	r1, r1
    169c:	a5 50       	subi	r26, 0x05	; 5
    169e:	b7 4d       	sbci	r27, 0xD7	; 215
    16a0:	e8 2f       	mov	r30, r24
    16a2:	e7 70       	andi	r30, 0x07	; 7
    16a4:	81 e0       	ldi	r24, 0x01	; 1
    16a6:	90 e0       	ldi	r25, 0x00	; 0
    16a8:	01 c0       	rjmp	.+2      	; 0x16ac <DriverOLEDDrawPixel.part.3+0xbe>
    16aa:	88 0f       	add	r24, r24
    16ac:	ea 95       	dec	r30
    16ae:	ea f7       	brpl	.-6      	; 0x16aa <DriverOLEDDrawPixel.part.3+0xbc>
    16b0:	9c 91       	ld	r25, X
    16b2:	89 2b       	or	r24, r25
    16b4:	8c 93       	st	X, r24
    16b6:	08 95       	ret

000016b8 <DriverOLEDClearPixel.part.4>:
    16b8:	90 91 fa 28 	lds	r25, 0x28FA	; 0x8028fa <GlobOrientation>
    16bc:	91 11       	cpse	r25, r1
    16be:	1d c0       	rjmp	.+58     	; 0x16fa <DriverOLEDClearPixel.part.4+0x42>
    16c0:	87 fd       	sbrc	r24, 7
    16c2:	1a c0       	rjmp	.+52     	; 0x16f8 <DriverOLEDClearPixel.part.4+0x40>
    16c4:	60 34       	cpi	r22, 0x40	; 64
    16c6:	c0 f4       	brcc	.+48     	; 0x16f8 <DriverOLEDClearPixel.part.4+0x40>
    16c8:	96 2f       	mov	r25, r22
    16ca:	96 95       	lsr	r25
    16cc:	96 95       	lsr	r25
    16ce:	96 95       	lsr	r25
    16d0:	e8 2f       	mov	r30, r24
    16d2:	f0 e0       	ldi	r31, 0x00	; 0
    16d4:	20 e8       	ldi	r18, 0x80	; 128
    16d6:	92 9f       	mul	r25, r18
    16d8:	e0 0d       	add	r30, r0
    16da:	f1 1d       	adc	r31, r1
    16dc:	11 24       	eor	r1, r1
    16de:	e5 50       	subi	r30, 0x05	; 5
    16e0:	f7 4d       	sbci	r31, 0xD7	; 215
    16e2:	67 70       	andi	r22, 0x07	; 7
    16e4:	81 e0       	ldi	r24, 0x01	; 1
    16e6:	90 e0       	ldi	r25, 0x00	; 0
    16e8:	01 c0       	rjmp	.+2      	; 0x16ec <DriverOLEDClearPixel.part.4+0x34>
    16ea:	88 0f       	add	r24, r24
    16ec:	6a 95       	dec	r22
    16ee:	ea f7       	brpl	.-6      	; 0x16ea <DriverOLEDClearPixel.part.4+0x32>
    16f0:	80 95       	com	r24
    16f2:	90 81       	ld	r25, Z
    16f4:	89 23       	and	r24, r25
    16f6:	80 83       	st	Z, r24
    16f8:	08 95       	ret
    16fa:	91 30       	cpi	r25, 0x01	; 1
    16fc:	21 f1       	breq	.+72     	; 0x1746 <DriverOLEDClearPixel.part.4+0x8e>
    16fe:	92 30       	cpi	r25, 0x02	; 2
    1700:	d9 f7       	brne	.-10     	; 0x16f8 <DriverOLEDClearPixel.part.4+0x40>
    1702:	87 fd       	sbrc	r24, 7
    1704:	f9 cf       	rjmp	.-14     	; 0x16f8 <DriverOLEDClearPixel.part.4+0x40>
    1706:	60 34       	cpi	r22, 0x40	; 64
    1708:	b8 f7       	brcc	.-18     	; 0x16f8 <DriverOLEDClearPixel.part.4+0x40>
    170a:	70 e0       	ldi	r23, 0x00	; 0
    170c:	ef e3       	ldi	r30, 0x3F	; 63
    170e:	f0 e0       	ldi	r31, 0x00	; 0
    1710:	e6 1b       	sub	r30, r22
    1712:	f7 0b       	sbc	r31, r23
    1714:	f5 95       	asr	r31
    1716:	e7 95       	ror	r30
    1718:	f5 95       	asr	r31
    171a:	e7 95       	ror	r30
    171c:	f5 95       	asr	r31
    171e:	e7 95       	ror	r30
    1720:	f6 95       	lsr	r31
    1722:	fe 2f       	mov	r31, r30
    1724:	ee 27       	eor	r30, r30
    1726:	f7 95       	ror	r31
    1728:	e7 95       	ror	r30
    172a:	2f e7       	ldi	r18, 0x7F	; 127
    172c:	30 e0       	ldi	r19, 0x00	; 0
    172e:	a9 01       	movw	r20, r18
    1730:	48 1b       	sub	r20, r24
    1732:	51 09       	sbc	r21, r1
    1734:	e4 0f       	add	r30, r20
    1736:	f5 1f       	adc	r31, r21
    1738:	e5 50       	subi	r30, 0x05	; 5
    173a:	f7 4d       	sbci	r31, 0xD7	; 215
    173c:	60 95       	com	r22
    173e:	70 95       	com	r23
    1740:	67 70       	andi	r22, 0x07	; 7
    1742:	77 27       	eor	r23, r23
    1744:	cf cf       	rjmp	.-98     	; 0x16e4 <DriverOLEDClearPixel.part.4+0x2c>
    1746:	80 34       	cpi	r24, 0x40	; 64
    1748:	b8 f6       	brcc	.-82     	; 0x16f8 <DriverOLEDClearPixel.part.4+0x40>
    174a:	67 fd       	sbrc	r22, 7
    174c:	d5 cf       	rjmp	.-86     	; 0x16f8 <DriverOLEDClearPixel.part.4+0x40>
    174e:	98 2f       	mov	r25, r24
    1750:	96 95       	lsr	r25
    1752:	96 95       	lsr	r25
    1754:	96 95       	lsr	r25
    1756:	af e7       	ldi	r26, 0x7F	; 127
    1758:	b0 e0       	ldi	r27, 0x00	; 0
    175a:	a6 1b       	sub	r26, r22
    175c:	b1 09       	sbc	r27, r1
    175e:	40 e8       	ldi	r20, 0x80	; 128
    1760:	94 9f       	mul	r25, r20
    1762:	a0 0d       	add	r26, r0
    1764:	b1 1d       	adc	r27, r1
    1766:	11 24       	eor	r1, r1
    1768:	a5 50       	subi	r26, 0x05	; 5
    176a:	b7 4d       	sbci	r27, 0xD7	; 215
    176c:	e8 2f       	mov	r30, r24
    176e:	e7 70       	andi	r30, 0x07	; 7
    1770:	81 e0       	ldi	r24, 0x01	; 1
    1772:	90 e0       	ldi	r25, 0x00	; 0
    1774:	01 c0       	rjmp	.+2      	; 0x1778 <DriverOLEDClearPixel.part.4+0xc0>
    1776:	88 0f       	add	r24, r24
    1778:	ea 95       	dec	r30
    177a:	ea f7       	brpl	.-6      	; 0x1776 <DriverOLEDClearPixel.part.4+0xbe>
    177c:	80 95       	com	r24
    177e:	9c 91       	ld	r25, X
    1780:	89 23       	and	r24, r25
    1782:	8c 93       	st	X, r24
    1784:	08 95       	ret

00001786 <DriverOLEDPrintSmChar.part.5>:
    1786:	6f 92       	push	r6
    1788:	7f 92       	push	r7
    178a:	8f 92       	push	r8
    178c:	9f 92       	push	r9
    178e:	af 92       	push	r10
    1790:	bf 92       	push	r11
    1792:	cf 92       	push	r12
    1794:	df 92       	push	r13
    1796:	ef 92       	push	r14
    1798:	ff 92       	push	r15
    179a:	0f 93       	push	r16
    179c:	1f 93       	push	r17
    179e:	cf 93       	push	r28
    17a0:	df 93       	push	r29
    17a2:	90 91 fa 28 	lds	r25, 0x28FA	; 0x8028fa <GlobOrientation>
    17a6:	91 11       	cpse	r25, r1
    17a8:	28 c0       	rjmp	.+80     	; 0x17fa <DriverOLEDPrintSmChar.part.5+0x74>
    17aa:	22 23       	and	r18, r18
    17ac:	d1 f1       	breq	.+116    	; 0x1822 <DriverOLEDPrintSmChar.part.5+0x9c>
    17ae:	26 e0       	ldi	r18, 0x06	; 6
    17b0:	82 9f       	mul	r24, r18
    17b2:	c0 01       	movw	r24, r0
    17b4:	11 24       	eor	r1, r1
    17b6:	20 e8       	ldi	r18, 0x80	; 128
    17b8:	62 9f       	mul	r22, r18
    17ba:	80 0d       	add	r24, r0
    17bc:	91 1d       	adc	r25, r1
    17be:	11 24       	eor	r1, r1
    17c0:	50 e0       	ldi	r21, 0x00	; 0
    17c2:	40 52       	subi	r20, 0x20	; 32
    17c4:	51 09       	sbc	r21, r1
    17c6:	fa 01       	movw	r30, r20
    17c8:	ee 0f       	add	r30, r30
    17ca:	ff 1f       	adc	r31, r31
    17cc:	ee 0f       	add	r30, r30
    17ce:	ff 1f       	adc	r31, r31
    17d0:	e4 0f       	add	r30, r20
    17d2:	f5 1f       	adc	r31, r21
    17d4:	ea 55       	subi	r30, 0x5A	; 90
    17d6:	fe 4d       	sbci	r31, 0xDE	; 222
    17d8:	dc 01       	movw	r26, r24
    17da:	a5 50       	subi	r26, 0x05	; 5
    17dc:	b7 4d       	sbci	r27, 0xD7	; 215
    17de:	ac 01       	movw	r20, r24
    17e0:	4b 5f       	subi	r20, 0xFB	; 251
    17e2:	5f 4f       	sbci	r21, 0xFF	; 255
    17e4:	01 96       	adiw	r24, 0x01	; 1
    17e6:	21 91       	ld	r18, Z+
    17e8:	2d 93       	st	X+, r18
    17ea:	84 17       	cp	r24, r20
    17ec:	95 07       	cpc	r25, r21
    17ee:	d1 f7       	brne	.-12     	; 0x17e4 <DriverOLEDPrintSmChar.part.5+0x5e>
    17f0:	fc 01       	movw	r30, r24
    17f2:	e5 50       	subi	r30, 0x05	; 5
    17f4:	f7 4d       	sbci	r31, 0xD7	; 215
    17f6:	10 82       	st	Z, r1
    17f8:	05 c0       	rjmp	.+10     	; 0x1804 <DriverOLEDPrintSmChar.part.5+0x7e>
    17fa:	91 30       	cpi	r25, 0x01	; 1
    17fc:	e9 f0       	breq	.+58     	; 0x1838 <DriverOLEDPrintSmChar.part.5+0xb2>
    17fe:	92 30       	cpi	r25, 0x02	; 2
    1800:	09 f4       	brne	.+2      	; 0x1804 <DriverOLEDPrintSmChar.part.5+0x7e>
    1802:	77 c0       	rjmp	.+238    	; 0x18f2 <DriverOLEDPrintSmChar.part.5+0x16c>
    1804:	df 91       	pop	r29
    1806:	cf 91       	pop	r28
    1808:	1f 91       	pop	r17
    180a:	0f 91       	pop	r16
    180c:	ff 90       	pop	r15
    180e:	ef 90       	pop	r14
    1810:	df 90       	pop	r13
    1812:	cf 90       	pop	r12
    1814:	bf 90       	pop	r11
    1816:	af 90       	pop	r10
    1818:	9f 90       	pop	r9
    181a:	8f 90       	pop	r8
    181c:	7f 90       	pop	r7
    181e:	6f 90       	pop	r6
    1820:	08 95       	ret
    1822:	26 e0       	ldi	r18, 0x06	; 6
    1824:	82 9f       	mul	r24, r18
    1826:	c0 01       	movw	r24, r0
    1828:	11 24       	eor	r1, r1
    182a:	8b 37       	cpi	r24, 0x7B	; 123
    182c:	91 05       	cpc	r25, r1
    182e:	1c f2       	brlt	.-122    	; 0x17b6 <DriverOLEDPrintSmChar.part.5+0x30>
    1830:	6f 5f       	subi	r22, 0xFF	; 255
    1832:	80 e0       	ldi	r24, 0x00	; 0
    1834:	90 e0       	ldi	r25, 0x00	; 0
    1836:	bf cf       	rjmp	.-130    	; 0x17b6 <DriverOLEDPrintSmChar.part.5+0x30>
    1838:	88 2e       	mov	r8, r24
    183a:	88 0c       	add	r8, r8
    183c:	88 0d       	add	r24, r8
    183e:	88 2e       	mov	r8, r24
    1840:	88 0c       	add	r8, r8
    1842:	66 2e       	mov	r6, r22
    1844:	66 0c       	add	r6, r6
    1846:	66 0c       	add	r6, r6
    1848:	66 0c       	add	r6, r6
    184a:	e6 2c       	mov	r14, r6
    184c:	f1 2c       	mov	r15, r1
    184e:	87 e0       	ldi	r24, 0x07	; 7
    1850:	e8 0e       	add	r14, r24
    1852:	f1 1c       	adc	r15, r1
    1854:	a8 2c       	mov	r10, r8
    1856:	b1 2c       	mov	r11, r1
    1858:	24 e0       	ldi	r18, 0x04	; 4
    185a:	a2 0e       	add	r10, r18
    185c:	b1 1c       	adc	r11, r1
    185e:	76 2c       	mov	r7, r6
    1860:	50 e0       	ldi	r21, 0x00	; 0
    1862:	40 52       	subi	r20, 0x20	; 32
    1864:	51 09       	sbc	r21, r1
    1866:	cc 24       	eor	r12, r12
    1868:	c3 94       	inc	r12
    186a:	d1 2c       	mov	r13, r1
    186c:	ea 01       	movw	r28, r20
    186e:	cc 0f       	add	r28, r28
    1870:	dd 1f       	adc	r29, r29
    1872:	cc 0f       	add	r28, r28
    1874:	dd 1f       	adc	r29, r29
    1876:	4c 0f       	add	r20, r28
    1878:	5d 1f       	adc	r21, r29
    187a:	ea 01       	movw	r28, r20
    187c:	ca 55       	subi	r28, 0x5A	; 90
    187e:	de 4d       	sbci	r29, 0xDE	; 222
    1880:	87 2d       	mov	r24, r7
    1882:	86 19       	sub	r24, r6
    1884:	86 01       	movw	r16, r12
    1886:	02 c0       	rjmp	.+4      	; 0x188c <DriverOLEDPrintSmChar.part.5+0x106>
    1888:	00 0f       	add	r16, r16
    188a:	11 1f       	adc	r17, r17
    188c:	8a 95       	dec	r24
    188e:	e2 f7       	brpl	.-8      	; 0x1888 <DriverOLEDPrintSmChar.part.5+0x102>
    1890:	98 2c       	mov	r9, r8
    1892:	0a c0       	rjmp	.+20     	; 0x18a8 <DriverOLEDPrintSmChar.part.5+0x122>
    1894:	80 91 f9 28 	lds	r24, 0x28F9	; 0x8028f9 <DriverOLEDInitialized>
    1898:	81 11       	cpse	r24, r1
    189a:	26 c0       	rjmp	.+76     	; 0x18e8 <DriverOLEDPrintSmChar.part.5+0x162>
    189c:	93 94       	inc	r9
    189e:	89 2d       	mov	r24, r9
    18a0:	90 e0       	ldi	r25, 0x00	; 0
    18a2:	a8 16       	cp	r10, r24
    18a4:	b9 06       	cpc	r11, r25
    18a6:	cc f0       	brlt	.+50     	; 0x18da <DriverOLEDPrintSmChar.part.5+0x154>
    18a8:	89 2d       	mov	r24, r9
    18aa:	88 19       	sub	r24, r8
    18ac:	fe 01       	movw	r30, r28
    18ae:	e8 0f       	add	r30, r24
    18b0:	f1 1d       	adc	r31, r1
    18b2:	80 81       	ld	r24, Z
    18b4:	90 e0       	ldi	r25, 0x00	; 0
    18b6:	80 23       	and	r24, r16
    18b8:	91 23       	and	r25, r17
    18ba:	89 2b       	or	r24, r25
    18bc:	59 f7       	brne	.-42     	; 0x1894 <DriverOLEDPrintSmChar.part.5+0x10e>
    18be:	80 91 f9 28 	lds	r24, 0x28F9	; 0x8028f9 <DriverOLEDInitialized>
    18c2:	88 23       	and	r24, r24
    18c4:	59 f3       	breq	.-42     	; 0x189c <DriverOLEDPrintSmChar.part.5+0x116>
    18c6:	67 2d       	mov	r22, r7
    18c8:	89 2d       	mov	r24, r9
    18ca:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <DriverOLEDClearPixel.part.4>
    18ce:	93 94       	inc	r9
    18d0:	89 2d       	mov	r24, r9
    18d2:	90 e0       	ldi	r25, 0x00	; 0
    18d4:	a8 16       	cp	r10, r24
    18d6:	b9 06       	cpc	r11, r25
    18d8:	3c f7       	brge	.-50     	; 0x18a8 <DriverOLEDPrintSmChar.part.5+0x122>
    18da:	73 94       	inc	r7
    18dc:	87 2d       	mov	r24, r7
    18de:	90 e0       	ldi	r25, 0x00	; 0
    18e0:	e8 16       	cp	r14, r24
    18e2:	f9 06       	cpc	r15, r25
    18e4:	6c f6       	brge	.-102    	; 0x1880 <DriverOLEDPrintSmChar.part.5+0xfa>
    18e6:	8e cf       	rjmp	.-228    	; 0x1804 <DriverOLEDPrintSmChar.part.5+0x7e>
    18e8:	67 2d       	mov	r22, r7
    18ea:	89 2d       	mov	r24, r9
    18ec:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <DriverOLEDDrawPixel.part.3>
    18f0:	d5 cf       	rjmp	.-86     	; 0x189c <DriverOLEDPrintSmChar.part.5+0x116>
    18f2:	88 2e       	mov	r8, r24
    18f4:	88 0c       	add	r8, r8
    18f6:	88 0d       	add	r24, r8
    18f8:	88 2e       	mov	r8, r24
    18fa:	88 0c       	add	r8, r8
    18fc:	66 2e       	mov	r6, r22
    18fe:	66 0c       	add	r6, r6
    1900:	66 0c       	add	r6, r6
    1902:	66 0c       	add	r6, r6
    1904:	e6 2c       	mov	r14, r6
    1906:	f1 2c       	mov	r15, r1
    1908:	87 e0       	ldi	r24, 0x07	; 7
    190a:	e8 0e       	add	r14, r24
    190c:	f1 1c       	adc	r15, r1
    190e:	a8 2c       	mov	r10, r8
    1910:	b1 2c       	mov	r11, r1
    1912:	24 e0       	ldi	r18, 0x04	; 4
    1914:	a2 0e       	add	r10, r18
    1916:	b1 1c       	adc	r11, r1
    1918:	76 2c       	mov	r7, r6
    191a:	50 e0       	ldi	r21, 0x00	; 0
    191c:	40 52       	subi	r20, 0x20	; 32
    191e:	51 09       	sbc	r21, r1
    1920:	cc 24       	eor	r12, r12
    1922:	c3 94       	inc	r12
    1924:	d1 2c       	mov	r13, r1
    1926:	ea 01       	movw	r28, r20
    1928:	cc 0f       	add	r28, r28
    192a:	dd 1f       	adc	r29, r29
    192c:	cc 0f       	add	r28, r28
    192e:	dd 1f       	adc	r29, r29
    1930:	4c 0f       	add	r20, r28
    1932:	5d 1f       	adc	r21, r29
    1934:	ea 01       	movw	r28, r20
    1936:	ca 55       	subi	r28, 0x5A	; 90
    1938:	de 4d       	sbci	r29, 0xDE	; 222
    193a:	87 2d       	mov	r24, r7
    193c:	86 19       	sub	r24, r6
    193e:	86 01       	movw	r16, r12
    1940:	02 c0       	rjmp	.+4      	; 0x1946 <DriverOLEDPrintSmChar.part.5+0x1c0>
    1942:	00 0f       	add	r16, r16
    1944:	11 1f       	adc	r17, r17
    1946:	8a 95       	dec	r24
    1948:	e2 f7       	brpl	.-8      	; 0x1942 <DriverOLEDPrintSmChar.part.5+0x1bc>
    194a:	98 2c       	mov	r9, r8
    194c:	0a c0       	rjmp	.+20     	; 0x1962 <DriverOLEDPrintSmChar.part.5+0x1dc>
    194e:	80 91 f9 28 	lds	r24, 0x28F9	; 0x8028f9 <DriverOLEDInitialized>
    1952:	81 11       	cpse	r24, r1
    1954:	26 c0       	rjmp	.+76     	; 0x19a2 <DriverOLEDPrintSmChar.part.5+0x21c>
    1956:	93 94       	inc	r9
    1958:	89 2d       	mov	r24, r9
    195a:	90 e0       	ldi	r25, 0x00	; 0
    195c:	a8 16       	cp	r10, r24
    195e:	b9 06       	cpc	r11, r25
    1960:	cc f0       	brlt	.+50     	; 0x1994 <DriverOLEDPrintSmChar.part.5+0x20e>
    1962:	89 2d       	mov	r24, r9
    1964:	88 19       	sub	r24, r8
    1966:	fe 01       	movw	r30, r28
    1968:	e8 0f       	add	r30, r24
    196a:	f1 1d       	adc	r31, r1
    196c:	80 81       	ld	r24, Z
    196e:	90 e0       	ldi	r25, 0x00	; 0
    1970:	80 23       	and	r24, r16
    1972:	91 23       	and	r25, r17
    1974:	89 2b       	or	r24, r25
    1976:	59 f7       	brne	.-42     	; 0x194e <DriverOLEDPrintSmChar.part.5+0x1c8>
    1978:	80 91 f9 28 	lds	r24, 0x28F9	; 0x8028f9 <DriverOLEDInitialized>
    197c:	88 23       	and	r24, r24
    197e:	59 f3       	breq	.-42     	; 0x1956 <DriverOLEDPrintSmChar.part.5+0x1d0>
    1980:	67 2d       	mov	r22, r7
    1982:	89 2d       	mov	r24, r9
    1984:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <DriverOLEDClearPixel.part.4>
    1988:	93 94       	inc	r9
    198a:	89 2d       	mov	r24, r9
    198c:	90 e0       	ldi	r25, 0x00	; 0
    198e:	a8 16       	cp	r10, r24
    1990:	b9 06       	cpc	r11, r25
    1992:	3c f7       	brge	.-50     	; 0x1962 <DriverOLEDPrintSmChar.part.5+0x1dc>
    1994:	73 94       	inc	r7
    1996:	87 2d       	mov	r24, r7
    1998:	90 e0       	ldi	r25, 0x00	; 0
    199a:	e8 16       	cp	r14, r24
    199c:	f9 06       	cpc	r15, r25
    199e:	6c f6       	brge	.-102    	; 0x193a <DriverOLEDPrintSmChar.part.5+0x1b4>
    19a0:	31 cf       	rjmp	.-414    	; 0x1804 <DriverOLEDPrintSmChar.part.5+0x7e>
    19a2:	67 2d       	mov	r22, r7
    19a4:	89 2d       	mov	r24, r9
    19a6:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <DriverOLEDDrawPixel.part.3>
    19aa:	d5 cf       	rjmp	.-86     	; 0x1956 <DriverOLEDPrintSmChar.part.5+0x1d0>

000019ac <DriverOLEDUpdate>:
    19ac:	bf 92       	push	r11
    19ae:	cf 92       	push	r12
    19b0:	df 92       	push	r13
    19b2:	ef 92       	push	r14
    19b4:	ff 92       	push	r15
    19b6:	0f 93       	push	r16
    19b8:	1f 93       	push	r17
    19ba:	cf 93       	push	r28
    19bc:	df 93       	push	r29
    19be:	cd b7       	in	r28, 0x3d	; 61
    19c0:	de b7       	in	r29, 0x3e	; 62
    19c2:	61 97       	sbiw	r28, 0x11	; 17
    19c4:	cd bf       	out	0x3d, r28	; 61
    19c6:	de bf       	out	0x3e, r29	; 62
    19c8:	80 91 f9 28 	lds	r24, 0x28F9	; 0x8028f9 <DriverOLEDInitialized>
    19cc:	88 23       	and	r24, r24
    19ce:	49 f1       	breq	.+82     	; 0x1a22 <DriverOLEDUpdate+0x76>
    19d0:	0e 94 cc 0a 	call	0x1598	; 0x1598 <set_column_address.part.1>
    19d4:	80 91 f9 28 	lds	r24, 0x28F9	; 0x8028f9 <DriverOLEDInitialized>
    19d8:	81 11       	cpse	r24, r1
    19da:	30 c0       	rjmp	.+96     	; 0x1a3c <DriverOLEDUpdate+0x90>
    19dc:	8b ef       	ldi	r24, 0xFB	; 251
    19de:	c8 2e       	mov	r12, r24
    19e0:	88 e2       	ldi	r24, 0x28	; 40
    19e2:	d8 2e       	mov	r13, r24
    19e4:	9b ef       	ldi	r25, 0xFB	; 251
    19e6:	e9 2e       	mov	r14, r25
    19e8:	9c e2       	ldi	r25, 0x2C	; 44
    19ea:	f9 2e       	mov	r15, r25
    19ec:	8e 01       	movw	r16, r28
    19ee:	0e 5e       	subi	r16, 0xEE	; 238
    19f0:	1f 4f       	sbci	r17, 0xFF	; 255
    19f2:	20 e4       	ldi	r18, 0x40	; 64
    19f4:	b2 2e       	mov	r11, r18
    19f6:	b9 82       	std	Y+1, r11	; 0x01
    19f8:	fe 01       	movw	r30, r28
    19fa:	32 96       	adiw	r30, 0x02	; 2
    19fc:	d6 01       	movw	r26, r12
    19fe:	8d 91       	ld	r24, X+
    1a00:	81 93       	st	Z+, r24
    1a02:	e0 17       	cp	r30, r16
    1a04:	f1 07       	cpc	r31, r17
    1a06:	d9 f7       	brne	.-10     	; 0x19fe <DriverOLEDUpdate+0x52>
    1a08:	41 e1       	ldi	r20, 0x11	; 17
    1a0a:	be 01       	movw	r22, r28
    1a0c:	6f 5f       	subi	r22, 0xFF	; 255
    1a0e:	7f 4f       	sbci	r23, 0xFF	; 255
    1a10:	8c e3       	ldi	r24, 0x3C	; 60
    1a12:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
    1a16:	80 e1       	ldi	r24, 0x10	; 16
    1a18:	c8 0e       	add	r12, r24
    1a1a:	d1 1c       	adc	r13, r1
    1a1c:	ec 14       	cp	r14, r12
    1a1e:	fd 04       	cpc	r15, r13
    1a20:	51 f7       	brne	.-44     	; 0x19f6 <DriverOLEDUpdate+0x4a>
    1a22:	61 96       	adiw	r28, 0x11	; 17
    1a24:	cd bf       	out	0x3d, r28	; 61
    1a26:	de bf       	out	0x3e, r29	; 62
    1a28:	df 91       	pop	r29
    1a2a:	cf 91       	pop	r28
    1a2c:	1f 91       	pop	r17
    1a2e:	0f 91       	pop	r16
    1a30:	ff 90       	pop	r15
    1a32:	ef 90       	pop	r14
    1a34:	df 90       	pop	r13
    1a36:	cf 90       	pop	r12
    1a38:	bf 90       	pop	r11
    1a3a:	08 95       	ret
    1a3c:	0e 94 a1 0a 	call	0x1542	; 0x1542 <set_page_address.part.0>
    1a40:	cd cf       	rjmp	.-102    	; 0x19dc <DriverOLEDUpdate+0x30>

00001a42 <DriverOLEDPrintSmChar>:
    1a42:	90 91 f9 28 	lds	r25, 0x28F9	; 0x8028f9 <DriverOLEDInitialized>
    1a46:	99 23       	and	r25, r25
    1a48:	31 f0       	breq	.+12     	; 0x1a56 <DriverOLEDPrintSmChar+0x14>
    1a4a:	81 38       	cpi	r24, 0x81	; 129
    1a4c:	20 f4       	brcc	.+8      	; 0x1a56 <DriverOLEDPrintSmChar+0x14>
    1a4e:	61 34       	cpi	r22, 0x41	; 65
    1a50:	10 f4       	brcc	.+4      	; 0x1a56 <DriverOLEDPrintSmChar+0x14>
    1a52:	0c 94 c3 0b 	jmp	0x1786	; 0x1786 <DriverOLEDPrintSmChar.part.5>
    1a56:	08 95       	ret

00001a58 <DriverOLEDPrintSmText>:
    1a58:	ff 92       	push	r15
    1a5a:	0f 93       	push	r16
    1a5c:	1f 93       	push	r17
    1a5e:	cf 93       	push	r28
    1a60:	df 93       	push	r29
    1a62:	f8 2e       	mov	r15, r24
    1a64:	04 2f       	mov	r16, r20
    1a66:	80 91 f9 28 	lds	r24, 0x28F9	; 0x8028f9 <DriverOLEDInitialized>
    1a6a:	88 23       	and	r24, r24
    1a6c:	39 f1       	breq	.+78     	; 0x1abc <DriverOLEDPrintSmText+0x64>
    1a6e:	80 91 fa 28 	lds	r24, 0x28FA	; 0x8028fa <GlobOrientation>
    1a72:	98 2f       	mov	r25, r24
    1a74:	9d 7f       	andi	r25, 0xFD	; 253
    1a76:	41 f5       	brne	.+80     	; 0x1ac8 <DriverOLEDPrintSmText+0x70>
    1a78:	27 e0       	ldi	r18, 0x07	; 7
    1a7a:	2f 15       	cp	r18, r15
    1a7c:	f8 f0       	brcs	.+62     	; 0x1abc <DriverOLEDPrintSmText+0x64>
    1a7e:	fb 01       	movw	r30, r22
    1a80:	40 81       	ld	r20, Z
    1a82:	44 23       	and	r20, r20
    1a84:	d9 f0       	breq	.+54     	; 0x1abc <DriverOLEDPrintSmText+0x64>
    1a86:	eb 01       	movw	r28, r22
    1a88:	21 96       	adiw	r28, 0x01	; 1
    1a8a:	10 e0       	ldi	r17, 0x00	; 0
    1a8c:	0c c0       	rjmp	.+24     	; 0x1aa6 <DriverOLEDPrintSmText+0x4e>
    1a8e:	26 e0       	ldi	r18, 0x06	; 6
    1a90:	12 9f       	mul	r17, r18
    1a92:	c0 01       	movw	r24, r0
    1a94:	11 24       	eor	r1, r1
    1a96:	8b 37       	cpi	r24, 0x7B	; 123
    1a98:	91 05       	cpc	r25, r1
    1a9a:	64 f0       	brlt	.+24     	; 0x1ab4 <DriverOLEDPrintSmText+0x5c>
    1a9c:	f3 94       	inc	r15
    1a9e:	11 e0       	ldi	r17, 0x01	; 1
    1aa0:	49 91       	ld	r20, Y+
    1aa2:	44 23       	and	r20, r20
    1aa4:	59 f0       	breq	.+22     	; 0x1abc <DriverOLEDPrintSmText+0x64>
    1aa6:	11 38       	cpi	r17, 0x81	; 129
    1aa8:	18 f4       	brcc	.+6      	; 0x1ab0 <DriverOLEDPrintSmText+0x58>
    1aaa:	f0 e4       	ldi	r31, 0x40	; 64
    1aac:	ff 15       	cp	r31, r15
    1aae:	68 f5       	brcc	.+90     	; 0x1b0a <DriverOLEDPrintSmText+0xb2>
    1ab0:	00 23       	and	r16, r16
    1ab2:	69 f3       	breq	.-38     	; 0x1a8e <DriverOLEDPrintSmText+0x36>
    1ab4:	1f 5f       	subi	r17, 0xFF	; 255
    1ab6:	49 91       	ld	r20, Y+
    1ab8:	41 11       	cpse	r20, r1
    1aba:	f5 cf       	rjmp	.-22     	; 0x1aa6 <DriverOLEDPrintSmText+0x4e>
    1abc:	df 91       	pop	r29
    1abe:	cf 91       	pop	r28
    1ac0:	1f 91       	pop	r17
    1ac2:	0f 91       	pop	r16
    1ac4:	ff 90       	pop	r15
    1ac6:	08 95       	ret
    1ac8:	81 30       	cpi	r24, 0x01	; 1
    1aca:	c1 f7       	brne	.-16     	; 0x1abc <DriverOLEDPrintSmText+0x64>
    1acc:	8f e0       	ldi	r24, 0x0F	; 15
    1ace:	8f 15       	cp	r24, r15
    1ad0:	a8 f3       	brcs	.-22     	; 0x1abc <DriverOLEDPrintSmText+0x64>
    1ad2:	fb 01       	movw	r30, r22
    1ad4:	40 81       	ld	r20, Z
    1ad6:	44 23       	and	r20, r20
    1ad8:	89 f3       	breq	.-30     	; 0x1abc <DriverOLEDPrintSmText+0x64>
    1ada:	eb 01       	movw	r28, r22
    1adc:	21 96       	adiw	r28, 0x01	; 1
    1ade:	10 e0       	ldi	r17, 0x00	; 0
    1ae0:	0b c0       	rjmp	.+22     	; 0x1af8 <DriverOLEDPrintSmText+0xa0>
    1ae2:	26 e0       	ldi	r18, 0x06	; 6
    1ae4:	12 9f       	mul	r17, r18
    1ae6:	c0 01       	movw	r24, r0
    1ae8:	11 24       	eor	r1, r1
    1aea:	cb 97       	sbiw	r24, 0x3b	; 59
    1aec:	64 f0       	brlt	.+24     	; 0x1b06 <DriverOLEDPrintSmText+0xae>
    1aee:	f3 94       	inc	r15
    1af0:	11 e0       	ldi	r17, 0x01	; 1
    1af2:	49 91       	ld	r20, Y+
    1af4:	44 23       	and	r20, r20
    1af6:	11 f3       	breq	.-60     	; 0x1abc <DriverOLEDPrintSmText+0x64>
    1af8:	11 38       	cpi	r17, 0x81	; 129
    1afa:	18 f4       	brcc	.+6      	; 0x1b02 <DriverOLEDPrintSmText+0xaa>
    1afc:	f0 e4       	ldi	r31, 0x40	; 64
    1afe:	ff 15       	cp	r31, r15
    1b00:	50 f4       	brcc	.+20     	; 0x1b16 <DriverOLEDPrintSmText+0xbe>
    1b02:	00 23       	and	r16, r16
    1b04:	71 f3       	breq	.-36     	; 0x1ae2 <DriverOLEDPrintSmText+0x8a>
    1b06:	1f 5f       	subi	r17, 0xFF	; 255
    1b08:	f4 cf       	rjmp	.-24     	; 0x1af2 <DriverOLEDPrintSmText+0x9a>
    1b0a:	20 2f       	mov	r18, r16
    1b0c:	6f 2d       	mov	r22, r15
    1b0e:	81 2f       	mov	r24, r17
    1b10:	0e 94 c3 0b 	call	0x1786	; 0x1786 <DriverOLEDPrintSmChar.part.5>
    1b14:	cd cf       	rjmp	.-102    	; 0x1ab0 <DriverOLEDPrintSmText+0x58>
    1b16:	20 2f       	mov	r18, r16
    1b18:	6f 2d       	mov	r22, r15
    1b1a:	81 2f       	mov	r24, r17
    1b1c:	0e 94 c3 0b 	call	0x1786	; 0x1786 <DriverOLEDPrintSmChar.part.5>
    1b20:	f0 cf       	rjmp	.-32     	; 0x1b02 <DriverOLEDPrintSmText+0xaa>

00001b22 <DriverOLEDClearScreen>:
    1b22:	80 e0       	ldi	r24, 0x00	; 0
    1b24:	94 e0       	ldi	r25, 0x04	; 4
    1b26:	eb ef       	ldi	r30, 0xFB	; 251
    1b28:	f8 e2       	ldi	r31, 0x28	; 40
    1b2a:	df 01       	movw	r26, r30
    1b2c:	9c 01       	movw	r18, r24
    1b2e:	1d 92       	st	X+, r1
    1b30:	21 50       	subi	r18, 0x01	; 1
    1b32:	30 40       	sbci	r19, 0x00	; 0
    1b34:	e1 f7       	brne	.-8      	; 0x1b2e <DriverOLEDClearScreen+0xc>
    1b36:	08 95       	ret

00001b38 <DriverOLEDInit>:

void DriverOLEDInit(uint8_t Orientation)
{
    1b38:	0f 93       	push	r16
    1b3a:	1f 93       	push	r17
    1b3c:	cf 93       	push	r28
    1b3e:	df 93       	push	r29
    1b40:	00 d0       	rcall	.+0      	; 0x1b42 <DriverOLEDInit+0xa>
    1b42:	1f 92       	push	r1
    1b44:	cd b7       	in	r28, 0x3d	; 61
    1b46:	de b7       	in	r29, 0x3e	; 62
	uint8_t res;
	DriverOLEDInitialized=0;
    1b48:	10 92 f9 28 	sts	0x28F9, r1	; 0x8028f9 <DriverOLEDInitialized>
	GlobOrientation=Orientation;
    1b4c:	80 93 fa 28 	sts	0x28FA, r24	; 0x8028fa <GlobOrientation>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1b50:	10 e8       	ldi	r17, 0x80	; 128
    1b52:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1b54:	8e ea       	ldi	r24, 0xAE	; 174
    1b56:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1b58:	42 e0       	ldi	r20, 0x02	; 2
    1b5a:	be 01       	movw	r22, r28
    1b5c:	6f 5f       	subi	r22, 0xFF	; 255
    1b5e:	7f 4f       	sbci	r23, 0xFF	; 255
    1b60:	8c e3       	ldi	r24, 0x3C	; 60
    1b62:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
	DriverOLEDInitialized=0;
	GlobOrientation=Orientation;

	
	res=send_command(0xAE);
	if (!res) return;
    1b66:	88 23       	and	r24, r24
    1b68:	09 f4       	brne	.+2      	; 0x1b6c <DriverOLEDInit+0x34>
    1b6a:	c3 c0       	rjmp	.+390    	; 0x1cf2 <DriverOLEDInit+0x1ba>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1b6c:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1b6e:	85 ed       	ldi	r24, 0xD5	; 213
    1b70:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1b72:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1b74:	1c 83       	std	Y+4, r17	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1b76:	44 e0       	ldi	r20, 0x04	; 4
    1b78:	be 01       	movw	r22, r28
    1b7a:	6f 5f       	subi	r22, 0xFF	; 255
    1b7c:	7f 4f       	sbci	r23, 0xFF	; 255
    1b7e:	8c e3       	ldi	r24, 0x3C	; 60
    1b80:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1b84:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1b86:	88 ea       	ldi	r24, 0xA8	; 168
    1b88:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1b8a:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1b8c:	8f e3       	ldi	r24, 0x3F	; 63
    1b8e:	8c 83       	std	Y+4, r24	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1b90:	44 e0       	ldi	r20, 0x04	; 4
    1b92:	be 01       	movw	r22, r28
    1b94:	6f 5f       	subi	r22, 0xFF	; 255
    1b96:	7f 4f       	sbci	r23, 0xFF	; 255
    1b98:	8c e3       	ldi	r24, 0x3C	; 60
    1b9a:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1b9e:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1ba0:	83 ed       	ldi	r24, 0xD3	; 211
    1ba2:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1ba4:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1ba6:	1c 82       	std	Y+4, r1	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1ba8:	44 e0       	ldi	r20, 0x04	; 4
    1baa:	be 01       	movw	r22, r28
    1bac:	6f 5f       	subi	r22, 0xFF	; 255
    1bae:	7f 4f       	sbci	r23, 0xFF	; 255
    1bb0:	8c e3       	ldi	r24, 0x3C	; 60
    1bb2:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1bb6:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1bb8:	8d e8       	ldi	r24, 0x8D	; 141
    1bba:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1bbc:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1bbe:	84 e1       	ldi	r24, 0x14	; 20
    1bc0:	8c 83       	std	Y+4, r24	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1bc2:	44 e0       	ldi	r20, 0x04	; 4
    1bc4:	be 01       	movw	r22, r28
    1bc6:	6f 5f       	subi	r22, 0xFF	; 255
    1bc8:	7f 4f       	sbci	r23, 0xFF	; 255
    1bca:	8c e3       	ldi	r24, 0x3C	; 60
    1bcc:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1bd0:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1bd2:	00 e4       	ldi	r16, 0x40	; 64
    1bd4:	0a 83       	std	Y+2, r16	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1bd6:	42 e0       	ldi	r20, 0x02	; 2
    1bd8:	be 01       	movw	r22, r28
    1bda:	6f 5f       	subi	r22, 0xFF	; 255
    1bdc:	7f 4f       	sbci	r23, 0xFF	; 255
    1bde:	8c e3       	ldi	r24, 0x3C	; 60
    1be0:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1be4:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1be6:	86 ea       	ldi	r24, 0xA6	; 166
    1be8:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1bea:	42 e0       	ldi	r20, 0x02	; 2
    1bec:	be 01       	movw	r22, r28
    1bee:	6f 5f       	subi	r22, 0xFF	; 255
    1bf0:	7f 4f       	sbci	r23, 0xFF	; 255
    1bf2:	8c e3       	ldi	r24, 0x3C	; 60
    1bf4:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1bf8:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1bfa:	84 ea       	ldi	r24, 0xA4	; 164
    1bfc:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1bfe:	42 e0       	ldi	r20, 0x02	; 2
    1c00:	be 01       	movw	r22, r28
    1c02:	6f 5f       	subi	r22, 0xFF	; 255
    1c04:	7f 4f       	sbci	r23, 0xFF	; 255
    1c06:	8c e3       	ldi	r24, 0x3C	; 60
    1c08:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1c0c:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1c0e:	81 ea       	ldi	r24, 0xA1	; 161
    1c10:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1c12:	42 e0       	ldi	r20, 0x02	; 2
    1c14:	be 01       	movw	r22, r28
    1c16:	6f 5f       	subi	r22, 0xFF	; 255
    1c18:	7f 4f       	sbci	r23, 0xFF	; 255
    1c1a:	8c e3       	ldi	r24, 0x3C	; 60
    1c1c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1c20:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1c22:	88 ec       	ldi	r24, 0xC8	; 200
    1c24:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1c26:	42 e0       	ldi	r20, 0x02	; 2
    1c28:	be 01       	movw	r22, r28
    1c2a:	6f 5f       	subi	r22, 0xFF	; 255
    1c2c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c2e:	8c e3       	ldi	r24, 0x3C	; 60
    1c30:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1c34:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1c36:	80 e2       	ldi	r24, 0x20	; 32
    1c38:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1c3a:	42 e0       	ldi	r20, 0x02	; 2
    1c3c:	be 01       	movw	r22, r28
    1c3e:	6f 5f       	subi	r22, 0xFF	; 255
    1c40:	7f 4f       	sbci	r23, 0xFF	; 255
    1c42:	8c e3       	ldi	r24, 0x3C	; 60
    1c44:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1c48:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1c4a:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1c4c:	42 e0       	ldi	r20, 0x02	; 2
    1c4e:	be 01       	movw	r22, r28
    1c50:	6f 5f       	subi	r22, 0xFF	; 255
    1c52:	7f 4f       	sbci	r23, 0xFF	; 255
    1c54:	8c e3       	ldi	r24, 0x3C	; 60
    1c56:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1c5a:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1c5c:	8a ed       	ldi	r24, 0xDA	; 218
    1c5e:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1c60:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1c62:	82 e1       	ldi	r24, 0x12	; 18
    1c64:	8c 83       	std	Y+4, r24	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1c66:	44 e0       	ldi	r20, 0x04	; 4
    1c68:	be 01       	movw	r22, r28
    1c6a:	6f 5f       	subi	r22, 0xFF	; 255
    1c6c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c6e:	8c e3       	ldi	r24, 0x3C	; 60
    1c70:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1c74:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1c76:	81 e8       	ldi	r24, 0x81	; 129
    1c78:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1c7a:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1c7c:	8f e8       	ldi	r24, 0x8F	; 143
    1c7e:	8c 83       	std	Y+4, r24	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1c80:	44 e0       	ldi	r20, 0x04	; 4
    1c82:	be 01       	movw	r22, r28
    1c84:	6f 5f       	subi	r22, 0xFF	; 255
    1c86:	7f 4f       	sbci	r23, 0xFF	; 255
    1c88:	8c e3       	ldi	r24, 0x3C	; 60
    1c8a:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1c8e:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1c90:	89 ed       	ldi	r24, 0xD9	; 217
    1c92:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1c94:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1c96:	81 ef       	ldi	r24, 0xF1	; 241
    1c98:	8c 83       	std	Y+4, r24	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1c9a:	44 e0       	ldi	r20, 0x04	; 4
    1c9c:	be 01       	movw	r22, r28
    1c9e:	6f 5f       	subi	r22, 0xFF	; 255
    1ca0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ca2:	8c e3       	ldi	r24, 0x3C	; 60
    1ca4:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1ca8:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1caa:	8b ed       	ldi	r24, 0xDB	; 219
    1cac:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1cae:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1cb0:	0c 83       	std	Y+4, r16	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1cb2:	44 e0       	ldi	r20, 0x04	; 4
    1cb4:	be 01       	movw	r22, r28
    1cb6:	6f 5f       	subi	r22, 0xFF	; 255
    1cb8:	7f 4f       	sbci	r23, 0xFF	; 255
    1cba:	8c e3       	ldi	r24, 0x3C	; 60
    1cbc:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1cc0:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1cc2:	8f ea       	ldi	r24, 0xAF	; 175
    1cc4:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1cc6:	42 e0       	ldi	r20, 0x02	; 2
    1cc8:	be 01       	movw	r22, r28
    1cca:	6f 5f       	subi	r22, 0xFF	; 255
    1ccc:	7f 4f       	sbci	r23, 0xFF	; 255
    1cce:	8c e3       	ldi	r24, 0x3C	; 60
    1cd0:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
		return;
	}
}

void DriverOLEDClearScreen() {
	memset(buffer, 0, BUFFER_SIZE);
    1cd4:	80 e0       	ldi	r24, 0x00	; 0
    1cd6:	94 e0       	ldi	r25, 0x04	; 4
    1cd8:	eb ef       	ldi	r30, 0xFB	; 251
    1cda:	f8 e2       	ldi	r31, 0x28	; 40
    1cdc:	df 01       	movw	r26, r30
    1cde:	9c 01       	movw	r18, r24
    1ce0:	1d 92       	st	X+, r1
    1ce2:	21 50       	subi	r18, 0x01	; 1
    1ce4:	30 40       	sbci	r19, 0x00	; 0
    1ce6:	e1 f7       	brne	.-8      	; 0x1ce0 <DriverOLEDInit+0x1a8>
	send_command_data(0xdb, 0x40);
	send_command(0xaf);


	DriverOLEDClearScreen();
	DriverOLEDUpdate();
    1ce8:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <DriverOLEDUpdate>
	DriverOLEDInitialized=1;
    1cec:	81 e0       	ldi	r24, 0x01	; 1
    1cee:	80 93 f9 28 	sts	0x28F9, r24	; 0x8028f9 <DriverOLEDInitialized>
    1cf2:	24 96       	adiw	r28, 0x04	; 4
    1cf4:	cd bf       	out	0x3d, r28	; 61
    1cf6:	de bf       	out	0x3e, r29	; 62
    1cf8:	df 91       	pop	r29
    1cfa:	cf 91       	pop	r28
    1cfc:	1f 91       	pop	r17
    1cfe:	0f 91       	pop	r16
    1d00:	08 95       	ret

00001d02 <ShiftInBit>:
	PORTD.DIRSET=1<<3;
	PORTD.PIN3CTRL=0b01000000;
	USARTD0.CTRLA=0b00000000;
	USARTD0.CTRLB=0b1000;
	USARTD0.CTRLC=0b11000000;
	USARTD0.BAUDCTRLA=5; //0.375s per bit, 
    1d02:	cf 93       	push	r28
    1d04:	c8 2f       	mov	r28, r24
    1d06:	80 91 4a 2d 	lds	r24, 0x2D4A	; 0x802d4a <ByteIdx>
    1d0a:	8e 34       	cpi	r24, 0x4E	; 78
    1d0c:	50 f5       	brcc	.+84     	; 0x1d62 <ShiftInBit+0x60>
    1d0e:	90 91 4b 2d 	lds	r25, 0x2D4B	; 0x802d4b <BitIdx>
    1d12:	91 11       	cpse	r25, r1
    1d14:	06 c0       	rjmp	.+12     	; 0x1d22 <ShiftInBit+0x20>
    1d16:	e8 2f       	mov	r30, r24
    1d18:	f0 e0       	ldi	r31, 0x00	; 0
    1d1a:	e4 50       	subi	r30, 0x04	; 4
    1d1c:	f3 4d       	sbci	r31, 0xD3	; 211
    1d1e:	2f ef       	ldi	r18, 0xFF	; 255
    1d20:	20 83       	st	Z, r18
    1d22:	c1 11       	cpse	r28, r1
    1d24:	10 c0       	rjmp	.+32     	; 0x1d46 <ShiftInBit+0x44>
    1d26:	e8 2f       	mov	r30, r24
    1d28:	f0 e0       	ldi	r31, 0x00	; 0
    1d2a:	e4 50       	subi	r30, 0x04	; 4
    1d2c:	f3 4d       	sbci	r31, 0xD3	; 211
    1d2e:	20 e8       	ldi	r18, 0x80	; 128
    1d30:	30 e0       	ldi	r19, 0x00	; 0
    1d32:	09 2e       	mov	r0, r25
    1d34:	02 c0       	rjmp	.+4      	; 0x1d3a <ShiftInBit+0x38>
    1d36:	35 95       	asr	r19
    1d38:	27 95       	ror	r18
    1d3a:	0a 94       	dec	r0
    1d3c:	e2 f7       	brpl	.-8      	; 0x1d36 <ShiftInBit+0x34>
    1d3e:	20 95       	com	r18
    1d40:	30 81       	ld	r19, Z
    1d42:	23 23       	and	r18, r19
    1d44:	20 83       	st	Z, r18
    1d46:	9f 5f       	subi	r25, 0xFF	; 255
    1d48:	98 30       	cpi	r25, 0x08	; 8
    1d4a:	39 f4       	brne	.+14     	; 0x1d5a <ShiftInBit+0x58>
    1d4c:	10 92 4b 2d 	sts	0x2D4B, r1	; 0x802d4b <BitIdx>
    1d50:	8f 5f       	subi	r24, 0xFF	; 255
    1d52:	80 93 4a 2d 	sts	0x2D4A, r24	; 0x802d4a <ByteIdx>
    1d56:	cf 91       	pop	r28
    1d58:	08 95       	ret
    1d5a:	90 93 4b 2d 	sts	0x2D4B, r25	; 0x802d4b <BitIdx>
    1d5e:	cf 91       	pop	r28
    1d60:	08 95       	ret
    1d62:	67 e2       	ldi	r22, 0x27	; 39
    1d64:	70 e0       	ldi	r23, 0x00	; 0
    1d66:	8c e7       	ldi	r24, 0x7C	; 124
    1d68:	93 e2       	ldi	r25, 0x23	; 35
    1d6a:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    1d6e:	90 91 4b 2d 	lds	r25, 0x2D4B	; 0x802d4b <BitIdx>
    1d72:	80 91 4a 2d 	lds	r24, 0x2D4A	; 0x802d4a <ByteIdx>
    1d76:	91 11       	cpse	r25, r1
    1d78:	0d c0       	rjmp	.+26     	; 0x1d94 <ShiftInBit+0x92>
    1d7a:	e8 2f       	mov	r30, r24
    1d7c:	f0 e0       	ldi	r31, 0x00	; 0
    1d7e:	e4 50       	subi	r30, 0x04	; 4
    1d80:	f3 4d       	sbci	r31, 0xD3	; 211
    1d82:	2f ef       	ldi	r18, 0xFF	; 255
    1d84:	20 83       	st	Z, r18
    1d86:	8e 34       	cpi	r24, 0x4E	; 78
    1d88:	60 f2       	brcs	.-104    	; 0x1d22 <ShiftInBit+0x20>
    1d8a:	81 e0       	ldi	r24, 0x01	; 1
    1d8c:	80 93 4b 2d 	sts	0x2D4B, r24	; 0x802d4b <BitIdx>
    1d90:	cf 91       	pop	r28
    1d92:	08 95       	ret
    1d94:	8e 34       	cpi	r24, 0x4E	; 78
    1d96:	28 f2       	brcs	.-118    	; 0x1d22 <ShiftInBit+0x20>
    1d98:	9f 5f       	subi	r25, 0xFF	; 255
    1d9a:	98 30       	cpi	r25, 0x08	; 8
    1d9c:	b9 f2       	breq	.-82     	; 0x1d4c <ShiftInBit+0x4a>
    1d9e:	dd cf       	rjmp	.-70     	; 0x1d5a <ShiftInBit+0x58>

00001da0 <ShiftIn0>:
    1da0:	80 e0       	ldi	r24, 0x00	; 0
    1da2:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <ShiftInBit>
    1da6:	81 e0       	ldi	r24, 0x01	; 1
    1da8:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <ShiftInBit>
    1dac:	81 e0       	ldi	r24, 0x01	; 1
    1dae:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <ShiftInBit>
    1db2:	81 e0       	ldi	r24, 0x01	; 1
    1db4:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <ShiftInBit>
    1db8:	81 e0       	ldi	r24, 0x01	; 1
    1dba:	0c 94 81 0e 	jmp	0x1d02	; 0x1d02 <ShiftInBit>

00001dbe <ShiftIn1>:
    1dbe:	80 e0       	ldi	r24, 0x00	; 0
    1dc0:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <ShiftInBit>
    1dc4:	80 e0       	ldi	r24, 0x00	; 0
    1dc6:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <ShiftInBit>
    1dca:	80 e0       	ldi	r24, 0x00	; 0
    1dcc:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <ShiftInBit>
    1dd0:	80 e0       	ldi	r24, 0x00	; 0
    1dd2:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <ShiftInBit>
    1dd6:	81 e0       	ldi	r24, 0x01	; 1
    1dd8:	0c 94 81 0e 	jmp	0x1d02	; 0x1d02 <ShiftInBit>

00001ddc <ShiftInByte>:
    1ddc:	cf 93       	push	r28
    1dde:	df 93       	push	r29
    1de0:	d8 2f       	mov	r29, r24
    1de2:	c8 e0       	ldi	r28, 0x08	; 8
    1de4:	05 c0       	rjmp	.+10     	; 0x1df0 <ShiftInByte+0x14>
    1de6:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <ShiftIn0>
    1dea:	dd 0f       	add	r29, r29
    1dec:	c1 50       	subi	r28, 0x01	; 1
    1dee:	39 f0       	breq	.+14     	; 0x1dfe <ShiftInByte+0x22>
    1df0:	d7 ff       	sbrs	r29, 7
    1df2:	f9 cf       	rjmp	.-14     	; 0x1de6 <ShiftInByte+0xa>
    1df4:	0e 94 df 0e 	call	0x1dbe	; 0x1dbe <ShiftIn1>
    1df8:	dd 0f       	add	r29, r29
    1dfa:	c1 50       	subi	r28, 0x01	; 1
    1dfc:	c9 f7       	brne	.-14     	; 0x1df0 <ShiftInByte+0x14>
    1dfe:	df 91       	pop	r29
    1e00:	cf 91       	pop	r28
    1e02:	08 95       	ret

00001e04 <DriverPL9823Init>:
}

void DriverPL9823Init()
{
	//CS init
	PORTA.DIRSET=1<<6;
    1e04:	e0 e0       	ldi	r30, 0x00	; 0
    1e06:	f6 e0       	ldi	r31, 0x06	; 6
    1e08:	80 e4       	ldi	r24, 0x40	; 64
    1e0a:	81 83       	std	Z+1, r24	; 0x01
	PORTA.OUTCLR=1<<6;
    1e0c:	86 83       	std	Z+6, r24	; 0x06
    1e0e:	08 95       	ret

00001e10 <DriverPL9823Set>:
}

void DriverPL9823Set(uint32_t FrontLeft,uint32_t FrontRight,uint32_t RearRight,uint32_t RearLeft)
{
    1e10:	3f 92       	push	r3
    1e12:	4f 92       	push	r4
    1e14:	5f 92       	push	r5
    1e16:	6f 92       	push	r6
    1e18:	7f 92       	push	r7
    1e1a:	8f 92       	push	r8
    1e1c:	9f 92       	push	r9
    1e1e:	af 92       	push	r10
    1e20:	bf 92       	push	r11
    1e22:	cf 92       	push	r12
    1e24:	df 92       	push	r13
    1e26:	ef 92       	push	r14
    1e28:	ff 92       	push	r15
    1e2a:	0f 93       	push	r16
    1e2c:	1f 93       	push	r17
    1e2e:	cf 93       	push	r28
    1e30:	df 93       	push	r29
    1e32:	36 2e       	mov	r3, r22
    1e34:	47 2e       	mov	r4, r23
    1e36:	58 2e       	mov	r5, r24
    1e38:	d2 2e       	mov	r13, r18
    1e3a:	13 2f       	mov	r17, r19
    1e3c:	d4 2f       	mov	r29, r20
}

void PortSetup(void)
{
	//Data init
	PORTD.DIRSET=1<<3;
    1e3e:	88 e0       	ldi	r24, 0x08	; 8
    1e40:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <__TEXT_REGION_LENGTH__+0x700661>
	PORTD.PIN3CTRL=0b01000000;
    1e44:	90 e4       	ldi	r25, 0x40	; 64
    1e46:	90 93 73 06 	sts	0x0673, r25	; 0x800673 <__TEXT_REGION_LENGTH__+0x700673>
	USARTD0.CTRLA=0b00000000;
    1e4a:	10 92 a3 09 	sts	0x09A3, r1	; 0x8009a3 <__TEXT_REGION_LENGTH__+0x7009a3>
	USARTD0.CTRLB=0b1000;
    1e4e:	80 93 a4 09 	sts	0x09A4, r24	; 0x8009a4 <__TEXT_REGION_LENGTH__+0x7009a4>
	USARTD0.CTRLC=0b11000000;
    1e52:	80 ec       	ldi	r24, 0xC0	; 192
    1e54:	80 93 a5 09 	sts	0x09A5, r24	; 0x8009a5 <__TEXT_REGION_LENGTH__+0x7009a5>
	USARTD0.BAUDCTRLA=5; //0.375s per bit, 
    1e58:	85 e0       	ldi	r24, 0x05	; 5
    1e5a:	80 93 a6 09 	sts	0x09A6, r24	; 0x8009a6 <__TEXT_REGION_LENGTH__+0x7009a6>
    1e5e:	8c ef       	ldi	r24, 0xFC	; 252
    1e60:	88 2e       	mov	r8, r24
    1e62:	8c e2       	ldi	r24, 0x2C	; 44
    1e64:	98 2e       	mov	r9, r24
    1e66:	9a e4       	ldi	r25, 0x4A	; 74
    1e68:	69 2e       	mov	r6, r25
    1e6a:	9d e2       	ldi	r25, 0x2D	; 45
    1e6c:	79 2e       	mov	r7, r25
    1e6e:	f4 01       	movw	r30, r8

void ShiftReset()
{
	uint8_t a;
	for (a=0;a<BUFFER_SIZE;a++)
		DataBuffer[a]=255;	
    1e70:	8f ef       	ldi	r24, 0xFF	; 255
    1e72:	81 93       	st	Z+, r24
}

void ShiftReset()
{
	uint8_t a;
	for (a=0;a<BUFFER_SIZE;a++)
    1e74:	6e 16       	cp	r6, r30
    1e76:	7f 06       	cpc	r7, r31
    1e78:	e1 f7       	brne	.-8      	; 0x1e72 <DriverPL9823Set+0x62>
		DataBuffer[a]=255;	
	ByteIdx=0;	
    1e7a:	10 92 4a 2d 	sts	0x2D4A, r1	; 0x802d4a <ByteIdx>
    1e7e:	c5 e8       	ldi	r28, 0x85	; 133
}
void ShiftInReset()
{
	uint8_t a;
	for (a=0;a<133;a++) ShiftInBit(1);
    1e80:	81 e0       	ldi	r24, 0x01	; 1
    1e82:	0e 94 81 0e 	call	0x1d02	; 0x1d02 <ShiftInBit>
    1e86:	c1 50       	subi	r28, 0x01	; 1
    1e88:	d9 f7       	brne	.-10     	; 0x1e80 <DriverPL9823Set+0x70>
	
	ShiftReset();

	ShiftInReset();
	
	ShiftInByte((uint8_t) ((FrontLeft>>0) & 0xFF));
    1e8a:	83 2d       	mov	r24, r3
    1e8c:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <ShiftInByte>
	ShiftInByte((uint8_t) ((FrontLeft>>8) & 0xFF));
    1e90:	84 2d       	mov	r24, r4
    1e92:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <ShiftInByte>
	ShiftInByte((uint8_t) ((FrontLeft>>16) & 0xFF));
    1e96:	85 2d       	mov	r24, r5
    1e98:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <ShiftInByte>

	ShiftInByte((uint8_t) ((FrontRight>>0) & 0xFF));
    1e9c:	8d 2d       	mov	r24, r13
    1e9e:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <ShiftInByte>
	ShiftInByte((uint8_t) ((FrontRight>>8) & 0xFF));
    1ea2:	81 2f       	mov	r24, r17
    1ea4:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <ShiftInByte>
	ShiftInByte((uint8_t) ((FrontRight>>16) & 0xFF));
    1ea8:	8d 2f       	mov	r24, r29
    1eaa:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <ShiftInByte>
	
	ShiftInByte((uint8_t) ((RearRight>>0) & 0xFF));
    1eae:	8e 2d       	mov	r24, r14
    1eb0:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <ShiftInByte>
	ShiftInByte((uint8_t) ((RearRight>>8) & 0xFF));
    1eb4:	8f 2d       	mov	r24, r15
    1eb6:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <ShiftInByte>
	ShiftInByte((uint8_t) ((RearRight>>16) & 0xFF));
    1eba:	80 2f       	mov	r24, r16
    1ebc:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <ShiftInByte>
	
	ShiftInByte((uint8_t) ((RearLeft>>0) & 0xFF));
    1ec0:	8a 2d       	mov	r24, r10
    1ec2:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <ShiftInByte>
	ShiftInByte((uint8_t) ((RearLeft>>8) & 0xFF));
    1ec6:	8b 2d       	mov	r24, r11
    1ec8:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <ShiftInByte>
	ShiftInByte((uint8_t) ((RearLeft>>16) & 0xFF));
    1ecc:	8c 2d       	mov	r24, r12
    1ece:	0e 94 ee 0e 	call	0x1ddc	; 0x1ddc <ShiftInByte>
	
	portENTER_CRITICAL();
    1ed2:	0f b6       	in	r0, 0x3f	; 63
    1ed4:	f8 94       	cli
    1ed6:	0f 92       	push	r0


void SendBuffer()
{
	uint8_t a;
	TxIdx=0;
    1ed8:	10 92 fb 2c 	sts	0x2CFB, r1	; 0x802cfb <TxIdx>
	
	PORTA.OUTSET=1<<6; //CS enable
    1edc:	80 e4       	ldi	r24, 0x40	; 64
    1ede:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>


void SendByte(uint8_t Data)
{
	while (!(USARTD0.STATUS&(1<<5)));
	USARTD0.STATUS=(1<<6); //Clear TXCIF
    1ee2:	20 e4       	ldi	r18, 0x40	; 64
	uint8_t a;
	TxIdx=0;
	
	PORTA.OUTSET=1<<6; //CS enable
	for (a=0;a<BUFFER_SIZE;a++)
		SendByte(DataBuffer[a]);
    1ee4:	f4 01       	movw	r30, r8
    1ee6:	91 91       	ld	r25, Z+
    1ee8:	4f 01       	movw	r8, r30
static volatile uint8_t TxIdx;


void SendByte(uint8_t Data)
{
	while (!(USARTD0.STATUS&(1<<5)));
    1eea:	80 91 a1 09 	lds	r24, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    1eee:	85 ff       	sbrs	r24, 5
    1ef0:	fc cf       	rjmp	.-8      	; 0x1eea <DriverPL9823Set+0xda>
	USARTD0.STATUS=(1<<6); //Clear TXCIF
    1ef2:	20 93 a1 09 	sts	0x09A1, r18	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
	USARTD0.DATA=Data;
    1ef6:	90 93 a0 09 	sts	0x09A0, r25	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
{
	uint8_t a;
	TxIdx=0;
	
	PORTA.OUTSET=1<<6; //CS enable
	for (a=0;a<BUFFER_SIZE;a++)
    1efa:	68 14       	cp	r6, r8
    1efc:	79 04       	cpc	r7, r9
    1efe:	91 f7       	brne	.-28     	; 0x1ee4 <DriverPL9823Set+0xd4>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1f00:	8f ee       	ldi	r24, 0xEF	; 239
    1f02:	90 e0       	ldi	r25, 0x00	; 0
    1f04:	01 97       	sbiw	r24, 0x01	; 1
    1f06:	f1 f7       	brne	.-4      	; 0x1f04 <DriverPL9823Set+0xf4>
    1f08:	00 c0       	rjmp	.+0      	; 0x1f0a <DriverPL9823Set+0xfa>
    1f0a:	00 00       	nop
		SendByte(DataBuffer[a]);
	_delay_us(30);	
	PORTA.OUTCLR=1<<6; //CS disable
    1f0c:	80 e4       	ldi	r24, 0x40	; 64
    1f0e:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
	ShiftInByte((uint8_t) ((RearLeft>>8) & 0xFF));
	ShiftInByte((uint8_t) ((RearLeft>>16) & 0xFF));
	
	portENTER_CRITICAL();
	SendBuffer(); //Approx 260 s for entire buffer
	portEXIT_CRITICAL();
    1f12:	0f 90       	pop	r0
    1f14:	0f be       	out	0x3f, r0	; 63
}
    1f16:	df 91       	pop	r29
    1f18:	cf 91       	pop	r28
    1f1a:	1f 91       	pop	r17
    1f1c:	0f 91       	pop	r16
    1f1e:	ff 90       	pop	r15
    1f20:	ef 90       	pop	r14
    1f22:	df 90       	pop	r13
    1f24:	cf 90       	pop	r12
    1f26:	bf 90       	pop	r11
    1f28:	af 90       	pop	r10
    1f2a:	9f 90       	pop	r9
    1f2c:	8f 90       	pop	r8
    1f2e:	7f 90       	pop	r7
    1f30:	6f 90       	pop	r6
    1f32:	5f 90       	pop	r5
    1f34:	4f 90       	pop	r4
    1f36:	3f 90       	pop	r3
    1f38:	08 95       	ret

00001f3a <DriverPowerInit>:
#include "DriverPower.h"

void DriverPowerInit(void)
{
	//Aux Vcc GPIO setup
	PORTC.DIRSET=1<<5;
    1f3a:	80 e2       	ldi	r24, 0x20	; 32
    1f3c:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
    1f40:	08 95       	ret

00001f42 <DriverPowerVccAuxSet>:
}


void DriverPowerVccAuxSet(uint8_t State)
{
	if (State)
    1f42:	81 11       	cpse	r24, r1
    1f44:	04 c0       	rjmp	.+8      	; 0x1f4e <DriverPowerVccAuxSet+0xc>
		PORTC.OUTSET=1<<5;
	else
		PORTC.OUTCLR=1<<5;
    1f46:	80 e2       	ldi	r24, 0x20	; 32
    1f48:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
    1f4c:	08 95       	ret


void DriverPowerVccAuxSet(uint8_t State)
{
	if (State)
		PORTC.OUTSET=1<<5;
    1f4e:	80 e2       	ldi	r24, 0x20	; 32
    1f50:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
    1f54:	08 95       	ret

00001f56 <DriverSysClkXtalInit>:
    // Clock setup          
    if (F_XTAL<400E3) return -1; //Invalid frequency
    if (F_XTAL<=2E6) OSC.XOSCCTRL=0b00001011; //Select <2 Mhz XTAL osc, max startup time
    else if(F_XTAL<=9E6) OSC.XOSCCTRL=0b01001011; //Select <2 Mhz XTAL osc, max startup time 
    else if(F_XTAL<=12E6) OSC.XOSCCTRL=0b10001011; //Select <2 Mhz XTAL osc, max startup time 
    else if(F_XTAL<=16E6) OSC.XOSCCTRL=0b11001011; //Select <2 Mhz XTAL osc, max startup time 
    1f56:	8b ec       	ldi	r24, 0xCB	; 203
    1f58:	80 93 52 00 	sts	0x0052, r24	; 0x800052 <__TEXT_REGION_LENGTH__+0x700052>
    else return -1; //Invalid frequency
    OSC.CTRL=0b01000; //Enable oscillator
    1f5c:	88 e0       	ldi	r24, 0x08	; 8
    1f5e:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
    
	//Wait until XTAL osc is ready
    while (!(OSC.STATUS&0b1000)); 
    1f62:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
    1f66:	83 ff       	sbrs	r24, 3
    1f68:	fc cf       	rjmp	.-8      	; 0x1f62 <DriverSysClkXtalInit+0xc>
	{
		//Configure PLL
		Mult=F_CPU/F_XTAL;
		if (Mult>31) return -1; //Invalid frequency; too high
		if (F_XTAL * (uint32_t) Mult !=F_CPU) return -1; //Only supports whole dividers
		OSC.PLLCTRL=0b11000000 | (Mult);
    1f6a:	82 ec       	ldi	r24, 0xC2	; 194
    1f6c:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>
		OSC.CTRL=0b00011000; //Enable PLL
    1f70:	88 e1       	ldi	r24, 0x18	; 24
    1f72:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
		
		//Wait until PLL is ready
		while (!(OSC.STATUS & 0b00010000));
    1f76:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
    1f7a:	84 ff       	sbrs	r24, 4
    1f7c:	fc cf       	rjmp	.-8      	; 0x1f76 <DriverSysClkXtalInit+0x20>
		
		//Select PLL as system CLK source
		CCP=0xd8;
    1f7e:	88 ed       	ldi	r24, 0xD8	; 216
    1f80:	84 bf       	out	0x34, r24	; 52
		CLK.CTRL=0b100;
    1f82:	84 e0       	ldi	r24, 0x04	; 4
    1f84:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
	}
	return 0;
}
    1f88:	80 e0       	ldi	r24, 0x00	; 0
    1f8a:	08 95       	ret

00001f8c <DriverTWIMInit>:
}

void TWIMTransactionFinished( uint8_t result)
{
	Twim_result = result;
	Twim_status = TWIM_STATUS_READY;
    1f8c:	10 92 51 2d 	sts	0x2D51, r1	; 0x802d51 <Twim_status>
    1f90:	e0 e8       	ldi	r30, 0x80	; 128
    1f92:	f6 e0       	ldi	r31, 0x06	; 6
    1f94:	88 e1       	ldi	r24, 0x18	; 24
    1f96:	80 8b       	std	Z+16, r24	; 0x10
    1f98:	81 8b       	std	Z+17, r24	; 0x11
    1f9a:	e0 ea       	ldi	r30, 0xA0	; 160
    1f9c:	f4 e0       	ldi	r31, 0x04	; 4
    1f9e:	88 e7       	ldi	r24, 0x78	; 120
    1fa0:	81 83       	std	Z+1, r24	; 0x01
    1fa2:	83 e2       	ldi	r24, 0x23	; 35
    1fa4:	85 83       	std	Z+5, r24	; 0x05
    1fa6:	81 e0       	ldi	r24, 0x01	; 1
    1fa8:	84 83       	std	Z+4, r24	; 0x04
    1faa:	0e 94 be 21 	call	0x437c	; 0x437c <xQueueCreateMutex>
    1fae:	80 93 4e 2d 	sts	0x2D4E, r24	; 0x802d4e <SemaBus>
    1fb2:	90 93 4f 2d 	sts	0x2D4F, r25	; 0x802d4f <SemaBus+0x1>
    1fb6:	43 e0       	ldi	r20, 0x03	; 3
    1fb8:	60 e0       	ldi	r22, 0x00	; 0
    1fba:	81 e0       	ldi	r24, 0x01	; 1
    1fbc:	0e 94 ab 20 	call	0x4156	; 0x4156 <xQueueGenericCreate>
    1fc0:	80 93 4c 2d 	sts	0x2D4C, r24	; 0x802d4c <SemaRx>
    1fc4:	90 93 4d 2d 	sts	0x2D4D, r25	; 0x802d4d <SemaRx+0x1>
    1fc8:	08 95       	ret

00001fca <TWIMWriteRead>:
    1fca:	cf 92       	push	r12
    1fcc:	df 92       	push	r13
    1fce:	ef 92       	push	r14
    1fd0:	ff 92       	push	r15
    1fd2:	0f 93       	push	r16
    1fd4:	1f 93       	push	r17
    1fd6:	cf 93       	push	r28
    1fd8:	df 93       	push	r29
    1fda:	d8 2f       	mov	r29, r24
    1fdc:	6b 01       	movw	r12, r22
    1fde:	14 2f       	mov	r17, r20
    1fe0:	79 01       	movw	r14, r18
    1fe2:	6f ef       	ldi	r22, 0xFF	; 255
    1fe4:	7f ef       	ldi	r23, 0xFF	; 255
    1fe6:	80 91 4e 2d 	lds	r24, 0x2D4E	; 0x802d4e <SemaBus>
    1fea:	90 91 4f 2d 	lds	r25, 0x2D4F	; 0x802d4f <SemaBus+0x1>
    1fee:	0e 94 43 23 	call	0x4686	; 0x4686 <xQueueSemaphoreTake>
    1ff2:	c0 92 58 2d 	sts	0x2D58, r12	; 0x802d58 <Twim_writeData>
    1ff6:	d0 92 59 2d 	sts	0x2D59, r13	; 0x802d59 <Twim_writeData+0x1>
    1ffa:	e0 92 56 2d 	sts	0x2D56, r14	; 0x802d56 <Twim_readData>
    1ffe:	f0 92 57 2d 	sts	0x2D57, r15	; 0x802d57 <Twim_readData+0x1>
    2002:	c0 91 51 2d 	lds	r28, 0x2D51	; 0x802d51 <Twim_status>
    2006:	c1 11       	cpse	r28, r1
    2008:	55 c0       	rjmp	.+170    	; 0x20b4 <TWIMWriteRead+0xea>
    200a:	81 e0       	ldi	r24, 0x01	; 1
    200c:	80 93 51 2d 	sts	0x2D51, r24	; 0x802d51 <Twim_status>
    2010:	10 92 50 2d 	sts	0x2D50, r1	; 0x802d50 <Twim_result>
    2014:	8d 2f       	mov	r24, r29
    2016:	88 0f       	add	r24, r24
    2018:	80 93 5a 2d 	sts	0x2D5A, r24	; 0x802d5a <Twim_address>
    201c:	10 93 55 2d 	sts	0x2D55, r17	; 0x802d55 <Twim_bytesToWrite>
    2020:	00 93 54 2d 	sts	0x2D54, r16	; 0x802d54 <Twim_bytesToRead>
    2024:	10 92 53 2d 	sts	0x2D53, r1	; 0x802d53 <Twim_bytesWritten>
    2028:	10 92 52 2d 	sts	0x2D52, r1	; 0x802d52 <Twim_bytesRead>
    202c:	80 91 55 2d 	lds	r24, 0x2D55	; 0x802d55 <Twim_bytesToWrite>
    2030:	88 23       	and	r24, r24
    2032:	b1 f1       	breq	.+108    	; 0x20a0 <TWIMWriteRead+0xd6>
    2034:	80 91 5a 2d 	lds	r24, 0x2D5A	; 0x802d5a <Twim_address>
    2038:	8e 7f       	andi	r24, 0xFE	; 254
    203a:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <__TEXT_REGION_LENGTH__+0x7004a6>
    203e:	6f ef       	ldi	r22, 0xFF	; 255
    2040:	7f ef       	ldi	r23, 0xFF	; 255
    2042:	80 91 4c 2d 	lds	r24, 0x2D4C	; 0x802d4c <SemaRx>
    2046:	90 91 4d 2d 	lds	r25, 0x2D4D	; 0x802d4d <SemaRx+0x1>
    204a:	0e 94 43 23 	call	0x4686	; 0x4686 <xQueueSemaphoreTake>
    204e:	80 91 50 2d 	lds	r24, 0x2D50	; 0x802d50 <Twim_result>
    2052:	81 30       	cpi	r24, 0x01	; 1
    2054:	e1 f1       	breq	.+120    	; 0x20ce <TWIMWriteRead+0x104>
    2056:	1f 92       	push	r1
    2058:	8f 93       	push	r24
    205a:	1f 92       	push	r1
    205c:	df 93       	push	r29
    205e:	8b e9       	ldi	r24, 0x9B	; 155
    2060:	93 e2       	ldi	r25, 0x23	; 35
    2062:	9f 93       	push	r25
    2064:	8f 93       	push	r24
    2066:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
    206a:	20 e0       	ldi	r18, 0x00	; 0
    206c:	40 e0       	ldi	r20, 0x00	; 0
    206e:	50 e0       	ldi	r21, 0x00	; 0
    2070:	60 e0       	ldi	r22, 0x00	; 0
    2072:	70 e0       	ldi	r23, 0x00	; 0
    2074:	80 91 4e 2d 	lds	r24, 0x2D4E	; 0x802d4e <SemaBus>
    2078:	90 91 4f 2d 	lds	r25, 0x2D4F	; 0x802d4f <SemaBus+0x1>
    207c:	0e 94 ef 20 	call	0x41de	; 0x41de <xQueueGenericSend>
    2080:	0f 90       	pop	r0
    2082:	0f 90       	pop	r0
    2084:	0f 90       	pop	r0
    2086:	0f 90       	pop	r0
    2088:	0f 90       	pop	r0
    208a:	0f 90       	pop	r0
    208c:	8c 2f       	mov	r24, r28
    208e:	df 91       	pop	r29
    2090:	cf 91       	pop	r28
    2092:	1f 91       	pop	r17
    2094:	0f 91       	pop	r16
    2096:	ff 90       	pop	r15
    2098:	ef 90       	pop	r14
    209a:	df 90       	pop	r13
    209c:	cf 90       	pop	r12
    209e:	08 95       	ret
    20a0:	80 91 54 2d 	lds	r24, 0x2D54	; 0x802d54 <Twim_bytesToRead>
    20a4:	88 23       	and	r24, r24
    20a6:	59 f2       	breq	.-106    	; 0x203e <TWIMWriteRead+0x74>
    20a8:	80 91 5a 2d 	lds	r24, 0x2D5A	; 0x802d5a <Twim_address>
    20ac:	81 60       	ori	r24, 0x01	; 1
    20ae:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <__TEXT_REGION_LENGTH__+0x7004a6>
    20b2:	c5 cf       	rjmp	.-118    	; 0x203e <TWIMWriteRead+0x74>
    20b4:	20 e0       	ldi	r18, 0x00	; 0
    20b6:	40 e0       	ldi	r20, 0x00	; 0
    20b8:	50 e0       	ldi	r21, 0x00	; 0
    20ba:	60 e0       	ldi	r22, 0x00	; 0
    20bc:	70 e0       	ldi	r23, 0x00	; 0
    20be:	80 91 4e 2d 	lds	r24, 0x2D4E	; 0x802d4e <SemaBus>
    20c2:	90 91 4f 2d 	lds	r25, 0x2D4F	; 0x802d4f <SemaBus+0x1>
    20c6:	0e 94 ef 20 	call	0x41de	; 0x41de <xQueueGenericSend>
    20ca:	c0 e0       	ldi	r28, 0x00	; 0
    20cc:	df cf       	rjmp	.-66     	; 0x208c <TWIMWriteRead+0xc2>
    20ce:	20 e0       	ldi	r18, 0x00	; 0
    20d0:	40 e0       	ldi	r20, 0x00	; 0
    20d2:	50 e0       	ldi	r21, 0x00	; 0
    20d4:	60 e0       	ldi	r22, 0x00	; 0
    20d6:	70 e0       	ldi	r23, 0x00	; 0
    20d8:	80 91 4e 2d 	lds	r24, 0x2D4E	; 0x802d4e <SemaBus>
    20dc:	90 91 4f 2d 	lds	r25, 0x2D4F	; 0x802d4f <SemaBus+0x1>
    20e0:	0e 94 ef 20 	call	0x41de	; 0x41de <xQueueGenericSend>
    20e4:	c1 e0       	ldi	r28, 0x01	; 1
    20e6:	d2 cf       	rjmp	.-92     	; 0x208c <TWIMWriteRead+0xc2>

000020e8 <TWIMWrite>:
    20e8:	0f 93       	push	r16
    20ea:	00 e0       	ldi	r16, 0x00	; 0
    20ec:	20 e0       	ldi	r18, 0x00	; 0
    20ee:	30 e0       	ldi	r19, 0x00	; 0
    20f0:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
    20f4:	0f 91       	pop	r16
    20f6:	08 95       	ret

000020f8 <TWIMWriteHandler>:
    20f8:	90 91 55 2d 	lds	r25, 0x2D55	; 0x802d55 <Twim_bytesToWrite>
    20fc:	20 91 54 2d 	lds	r18, 0x2D54	; 0x802d54 <Twim_bytesToRead>
    2100:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>
    2104:	84 fd       	sbrc	r24, 4
    2106:	22 c0       	rjmp	.+68     	; 0x214c <TWIMWriteHandler+0x54>
    2108:	80 91 53 2d 	lds	r24, 0x2D53	; 0x802d53 <Twim_bytesWritten>
    210c:	89 17       	cp	r24, r25
    210e:	68 f0       	brcs	.+26     	; 0x212a <TWIMWriteHandler+0x32>
    2110:	80 91 52 2d 	lds	r24, 0x2D52	; 0x802d52 <Twim_bytesRead>
    2114:	82 17       	cp	r24, r18
    2116:	18 f1       	brcs	.+70     	; 0x215e <TWIMWriteHandler+0x66>
    2118:	83 e0       	ldi	r24, 0x03	; 3
    211a:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    211e:	81 e0       	ldi	r24, 0x01	; 1
    2120:	80 93 50 2d 	sts	0x2D50, r24	; 0x802d50 <Twim_result>
    2124:	10 92 51 2d 	sts	0x2D51, r1	; 0x802d51 <Twim_status>
    2128:	08 95       	ret
    212a:	80 91 53 2d 	lds	r24, 0x2D53	; 0x802d53 <Twim_bytesWritten>
    212e:	e0 91 58 2d 	lds	r30, 0x2D58	; 0x802d58 <Twim_writeData>
    2132:	f0 91 59 2d 	lds	r31, 0x2D59	; 0x802d59 <Twim_writeData+0x1>
    2136:	e8 0f       	add	r30, r24
    2138:	f1 1d       	adc	r31, r1
    213a:	80 81       	ld	r24, Z
    213c:	80 93 a7 04 	sts	0x04A7, r24	; 0x8004a7 <__TEXT_REGION_LENGTH__+0x7004a7>
    2140:	80 91 53 2d 	lds	r24, 0x2D53	; 0x802d53 <Twim_bytesWritten>
    2144:	8f 5f       	subi	r24, 0xFF	; 255
    2146:	80 93 53 2d 	sts	0x2D53, r24	; 0x802d53 <Twim_bytesWritten>
    214a:	08 95       	ret
    214c:	83 e0       	ldi	r24, 0x03	; 3
    214e:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    2152:	85 e0       	ldi	r24, 0x05	; 5
    2154:	80 93 50 2d 	sts	0x2D50, r24	; 0x802d50 <Twim_result>
    2158:	10 92 51 2d 	sts	0x2D51, r1	; 0x802d51 <Twim_status>
    215c:	08 95       	ret
    215e:	80 91 5a 2d 	lds	r24, 0x2D5A	; 0x802d5a <Twim_address>
    2162:	81 60       	ori	r24, 0x01	; 1
    2164:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <__TEXT_REGION_LENGTH__+0x7004a6>
    2168:	08 95       	ret

0000216a <TWIMReadHandler>:
    216a:	80 91 52 2d 	lds	r24, 0x2D52	; 0x802d52 <Twim_bytesRead>
    216e:	80 32       	cpi	r24, 0x20	; 32
    2170:	f8 f4       	brcc	.+62     	; 0x21b0 <TWIMReadHandler+0x46>
    2172:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <__TEXT_REGION_LENGTH__+0x7004a7>
    2176:	90 91 52 2d 	lds	r25, 0x2D52	; 0x802d52 <Twim_bytesRead>
    217a:	e0 91 56 2d 	lds	r30, 0x2D56	; 0x802d56 <Twim_readData>
    217e:	f0 91 57 2d 	lds	r31, 0x2D57	; 0x802d57 <Twim_readData+0x1>
    2182:	e9 0f       	add	r30, r25
    2184:	f1 1d       	adc	r31, r1
    2186:	80 83       	st	Z, r24
    2188:	80 91 52 2d 	lds	r24, 0x2D52	; 0x802d52 <Twim_bytesRead>
    218c:	8f 5f       	subi	r24, 0xFF	; 255
    218e:	80 93 52 2d 	sts	0x2D52, r24	; 0x802d52 <Twim_bytesRead>
    2192:	90 91 54 2d 	lds	r25, 0x2D54	; 0x802d54 <Twim_bytesToRead>
    2196:	80 91 52 2d 	lds	r24, 0x2D52	; 0x802d52 <Twim_bytesRead>
    219a:	89 17       	cp	r24, r25
    219c:	b8 f0       	brcs	.+46     	; 0x21cc <TWIMReadHandler+0x62>
    219e:	87 e0       	ldi	r24, 0x07	; 7
    21a0:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    21a4:	81 e0       	ldi	r24, 0x01	; 1
    21a6:	80 93 50 2d 	sts	0x2D50, r24	; 0x802d50 <Twim_result>
    21aa:	10 92 51 2d 	sts	0x2D51, r1	; 0x802d51 <Twim_status>
    21ae:	08 95       	ret
    21b0:	83 e0       	ldi	r24, 0x03	; 3
    21b2:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    21b6:	82 e0       	ldi	r24, 0x02	; 2
    21b8:	80 93 50 2d 	sts	0x2D50, r24	; 0x802d50 <Twim_result>
    21bc:	10 92 51 2d 	sts	0x2D51, r1	; 0x802d51 <Twim_status>
    21c0:	90 91 54 2d 	lds	r25, 0x2D54	; 0x802d54 <Twim_bytesToRead>
    21c4:	80 91 52 2d 	lds	r24, 0x2D52	; 0x802d52 <Twim_bytesRead>
    21c8:	89 17       	cp	r24, r25
    21ca:	48 f7       	brcc	.-46     	; 0x219e <TWIMReadHandler+0x34>
    21cc:	82 e0       	ldi	r24, 0x02	; 2
    21ce:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    21d2:	08 95       	ret

000021d4 <__vector_46>:
}

ISR (TWIM_BUS_vect)
{
    21d4:	1f 92       	push	r1
    21d6:	0f 92       	push	r0
    21d8:	0f b6       	in	r0, 0x3f	; 63
    21da:	0f 92       	push	r0
    21dc:	11 24       	eor	r1, r1
    21de:	0b b6       	in	r0, 0x3b	; 59
    21e0:	0f 92       	push	r0
    21e2:	2f 93       	push	r18
    21e4:	3f 93       	push	r19
    21e6:	4f 93       	push	r20
    21e8:	5f 93       	push	r21
    21ea:	6f 93       	push	r22
    21ec:	7f 93       	push	r23
    21ee:	8f 93       	push	r24
    21f0:	9f 93       	push	r25
    21f2:	af 93       	push	r26
    21f4:	bf 93       	push	r27
    21f6:	ef 93       	push	r30
    21f8:	ff 93       	push	r31
    21fa:	cf 93       	push	r28
    21fc:	df 93       	push	r29
    21fe:	1f 92       	push	r1
    2200:	cd b7       	in	r28, 0x3d	; 61
    2202:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    2204:	19 82       	std	Y+1, r1	; 0x01
	uint8_t currentStatus = TWIM_BUS.MASTER.STATUS;
    2206:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>

	/* If arbitration lost or bus error. */
	if ((currentStatus & TWI_MASTER_ARBLOST_bm) ||
    220a:	98 2f       	mov	r25, r24
    220c:	9c 70       	andi	r25, 0x0C	; 12
    220e:	e1 f4       	brne	.+56     	; 0x2248 <__vector_46+0x74>

		TWIMArbitrationLostBusErrorHandler();
	}

	/* If master write interrupt. */
	else if (currentStatus & TWI_MASTER_WIF_bm) {
    2210:	86 fd       	sbrc	r24, 6
    2212:	44 c0       	rjmp	.+136    	; 0x229c <__vector_46+0xc8>
		TWIMWriteHandler();
	}

	/* If master read interrupt. */
	else if (currentStatus & TWI_MASTER_RIF_bm) {
    2214:	87 fd       	sbrc	r24, 7
    2216:	45 c0       	rjmp	.+138    	; 0x22a2 <__vector_46+0xce>
	}
}

void TWIMTransactionFinished( uint8_t result)
{
	Twim_result = result;
    2218:	86 e0       	ldi	r24, 0x06	; 6
    221a:	80 93 50 2d 	sts	0x2D50, r24	; 0x802d50 <Twim_result>
	Twim_status = TWIM_STATUS_READY;
    221e:	10 92 51 2d 	sts	0x2D51, r1	; 0x802d51 <Twim_status>
	/* If unexpected state. */
	else {
		TWIMTransactionFinished(TWIM_RESULT_FAIL);
	}
	
	if (Twim_status == TWIM_STATUS_READY) //Transaction finished
    2222:	80 91 51 2d 	lds	r24, 0x2D51	; 0x802d51 <Twim_status>
    2226:	81 11       	cpse	r24, r1
    2228:	1f c0       	rjmp	.+62     	; 0x2268 <__vector_46+0x94>
	{
		BaseType_t res=xSemaphoreGiveFromISR( SemaRx, &xHigherPriorityTaskWoken );
    222a:	be 01       	movw	r22, r28
    222c:	6f 5f       	subi	r22, 0xFF	; 255
    222e:	7f 4f       	sbci	r23, 0xFF	; 255
    2230:	80 91 4c 2d 	lds	r24, 0x2D4C	; 0x802d4c <SemaRx>
    2234:	90 91 4d 2d 	lds	r25, 0x2D4D	; 0x802d4d <SemaRx+0x1>
    2238:	0e 94 33 22 	call	0x4466	; 0x4466 <xQueueGiveFromISR>

		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );		
    223c:	89 81       	ldd	r24, Y+1	; 0x01
    223e:	88 23       	and	r24, r24
    2240:	99 f0       	breq	.+38     	; 0x2268 <__vector_46+0x94>
    2242:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <vPortYieldISR>
	}
}
    2246:	10 c0       	rjmp	.+32     	; 0x2268 <__vector_46+0x94>
	}
}

void TWIMArbitrationLostBusErrorHandler()
{
	uint8_t currentStatus = TWIM_BUS.MASTER.STATUS;
    2248:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>

	/* If bus error. */
	if (currentStatus & TWI_MASTER_BUSERR_bm) {
    224c:	82 fd       	sbrc	r24, 2
    224e:	22 c0       	rjmp	.+68     	; 0x2294 <__vector_46+0xc0>
		Twim_result = TWIM_RESULT_BUS_ERROR;
	}
	/* If arbitration lost. */
	else {
		Twim_result = TWIM_RESULT_ARBITRATION_LOST;
    2250:	93 e0       	ldi	r25, 0x03	; 3
    2252:	90 93 50 2d 	sts	0x2D50, r25	; 0x802d50 <Twim_result>
	}

	/* Clear interrupt flag. */
	TWIM_BUS.MASTER.STATUS = currentStatus | TWI_MASTER_ARBLOST_bm;
    2256:	88 60       	ori	r24, 0x08	; 8
    2258:	80 93 a4 04 	sts	0x04A4, r24	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>

	Twim_status = TWIM_STATUS_READY;
    225c:	10 92 51 2d 	sts	0x2D51, r1	; 0x802d51 <Twim_status>
	/* If unexpected state. */
	else {
		TWIMTransactionFinished(TWIM_RESULT_FAIL);
	}
	
	if (Twim_status == TWIM_STATUS_READY) //Transaction finished
    2260:	80 91 51 2d 	lds	r24, 0x2D51	; 0x802d51 <Twim_status>
    2264:	88 23       	and	r24, r24
    2266:	09 f3       	breq	.-62     	; 0x222a <__vector_46+0x56>
	{
		BaseType_t res=xSemaphoreGiveFromISR( SemaRx, &xHigherPriorityTaskWoken );

		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );		
	}
}
    2268:	0f 90       	pop	r0
    226a:	df 91       	pop	r29
    226c:	cf 91       	pop	r28
    226e:	ff 91       	pop	r31
    2270:	ef 91       	pop	r30
    2272:	bf 91       	pop	r27
    2274:	af 91       	pop	r26
    2276:	9f 91       	pop	r25
    2278:	8f 91       	pop	r24
    227a:	7f 91       	pop	r23
    227c:	6f 91       	pop	r22
    227e:	5f 91       	pop	r21
    2280:	4f 91       	pop	r20
    2282:	3f 91       	pop	r19
    2284:	2f 91       	pop	r18
    2286:	0f 90       	pop	r0
    2288:	0b be       	out	0x3b, r0	; 59
    228a:	0f 90       	pop	r0
    228c:	0f be       	out	0x3f, r0	; 63
    228e:	0f 90       	pop	r0
    2290:	1f 90       	pop	r1
    2292:	18 95       	reti
{
	uint8_t currentStatus = TWIM_BUS.MASTER.STATUS;

	/* If bus error. */
	if (currentStatus & TWI_MASTER_BUSERR_bm) {
		Twim_result = TWIM_RESULT_BUS_ERROR;
    2294:	94 e0       	ldi	r25, 0x04	; 4
    2296:	90 93 50 2d 	sts	0x2D50, r25	; 0x802d50 <Twim_result>
    229a:	dd cf       	rjmp	.-70     	; 0x2256 <__vector_46+0x82>
		TWIMArbitrationLostBusErrorHandler();
	}

	/* If master write interrupt. */
	else if (currentStatus & TWI_MASTER_WIF_bm) {
		TWIMWriteHandler();
    229c:	0e 94 7c 10 	call	0x20f8	; 0x20f8 <TWIMWriteHandler>
    22a0:	df cf       	rjmp	.-66     	; 0x2260 <__vector_46+0x8c>
	}

	/* If master read interrupt. */
	else if (currentStatus & TWI_MASTER_RIF_bm) {
		TWIMReadHandler();
    22a2:	0e 94 b5 10 	call	0x216a	; 0x216a <TWIMReadHandler>
    22a6:	dc cf       	rjmp	.-72     	; 0x2260 <__vector_46+0x8c>

000022a8 <stdio_getchar>:
		
	return 0;
}
	
static int stdio_getchar(FILE *stream)
{
    22a8:	cf 93       	push	r28
    22aa:	df 93       	push	r29
    22ac:	1f 92       	push	r1
    22ae:	cd b7       	in	r28, 0x3d	; 61
    22b0:	de b7       	in	r29, 0x3e	; 62
	char c;
	xQueueReceive(UsartRxQueue,&c,portMAX_DELAY);
    22b2:	4f ef       	ldi	r20, 0xFF	; 255
    22b4:	5f ef       	ldi	r21, 0xFF	; 255
    22b6:	be 01       	movw	r22, r28
    22b8:	6f 5f       	subi	r22, 0xFF	; 255
    22ba:	7f 4f       	sbci	r23, 0xFF	; 255
    22bc:	80 91 60 2e 	lds	r24, 0x2E60	; 0x802e60 <UsartRxQueue>
    22c0:	90 91 61 2e 	lds	r25, 0x2E61	; 0x802e61 <UsartRxQueue+0x1>
    22c4:	0e 94 86 22 	call	0x450c	; 0x450c <xQueueReceive>
	return c;
    22c8:	89 81       	ldd	r24, Y+1	; 0x01
}
    22ca:	90 e0       	ldi	r25, 0x00	; 0
    22cc:	0f 90       	pop	r0
    22ce:	df 91       	pop	r29
    22d0:	cf 91       	pop	r28
    22d2:	08 95       	ret

000022d4 <stdio_putchar>:

}


static int stdio_putchar(char c, FILE * stream)
{
    22d4:	cf 93       	push	r28
    22d6:	df 93       	push	r29
    22d8:	1f 92       	push	r1
    22da:	1f 92       	push	r1
    22dc:	cd b7       	in	r28, 0x3d	; 61
    22de:	de b7       	in	r29, 0x3e	; 62
    22e0:	8a 83       	std	Y+2, r24	; 0x02
	int res;
	char cbuf;

	xQueueSend(UsartTxQueue,&c,portMAX_DELAY);
    22e2:	20 e0       	ldi	r18, 0x00	; 0
    22e4:	4f ef       	ldi	r20, 0xFF	; 255
    22e6:	5f ef       	ldi	r21, 0xFF	; 255
    22e8:	be 01       	movw	r22, r28
    22ea:	6e 5f       	subi	r22, 0xFE	; 254
    22ec:	7f 4f       	sbci	r23, 0xFF	; 255
    22ee:	80 91 68 2e 	lds	r24, 0x2E68	; 0x802e68 <UsartTxQueue>
    22f2:	90 91 69 2e 	lds	r25, 0x2E69	; 0x802e69 <UsartTxQueue+0x1>
    22f6:	0e 94 ef 20 	call	0x41de	; 0x41de <xQueueGenericSend>

	if (USART.STATUS & (1<<5))
    22fa:	80 91 a1 0a 	lds	r24, 0x0AA1	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
    22fe:	85 ff       	sbrs	r24, 5
    2300:	0e c0       	rjmp	.+28     	; 0x231e <stdio_putchar+0x4a>
	{
		xQueueReceive(UsartTxQueue,&cbuf,0);
    2302:	40 e0       	ldi	r20, 0x00	; 0
    2304:	50 e0       	ldi	r21, 0x00	; 0
    2306:	be 01       	movw	r22, r28
    2308:	6f 5f       	subi	r22, 0xFF	; 255
    230a:	7f 4f       	sbci	r23, 0xFF	; 255
    230c:	80 91 68 2e 	lds	r24, 0x2E68	; 0x802e68 <UsartTxQueue>
    2310:	90 91 69 2e 	lds	r25, 0x2E69	; 0x802e69 <UsartTxQueue+0x1>
    2314:	0e 94 86 22 	call	0x450c	; 0x450c <xQueueReceive>
		USART.DATA=cbuf;
    2318:	89 81       	ldd	r24, Y+1	; 0x01
    231a:	80 93 a0 0a 	sts	0x0AA0, r24	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
	}
		
	return 0;
}
    231e:	80 e0       	ldi	r24, 0x00	; 0
    2320:	90 e0       	ldi	r25, 0x00	; 0
    2322:	0f 90       	pop	r0
    2324:	0f 90       	pop	r0
    2326:	df 91       	pop	r29
    2328:	cf 91       	pop	r28
    232a:	08 95       	ret

0000232c <DriverUSARTInit>:

uint8_t receiveStarted = 0;

void DriverUSARTInit(void)
{
	UsartTxQueue=xQueueCreate(UART_QUEUE_LENGTH,sizeof(char));
    232c:	40 e0       	ldi	r20, 0x00	; 0
    232e:	61 e0       	ldi	r22, 0x01	; 1
    2330:	80 e8       	ldi	r24, 0x80	; 128
    2332:	0e 94 ab 20 	call	0x4156	; 0x4156 <xQueueGenericCreate>
    2336:	80 93 68 2e 	sts	0x2E68, r24	; 0x802e68 <UsartTxQueue>
    233a:	90 93 69 2e 	sts	0x2E69, r25	; 0x802e69 <UsartTxQueue+0x1>
	UsartRxQueue=xQueueCreate(UART_QUEUE_LENGTH,sizeof(char));
    233e:	40 e0       	ldi	r20, 0x00	; 0
    2340:	61 e0       	ldi	r22, 0x01	; 1
    2342:	80 e8       	ldi	r24, 0x80	; 128
    2344:	0e 94 ab 20 	call	0x4156	; 0x4156 <xQueueGenericCreate>
    2348:	80 93 60 2e 	sts	0x2E60, r24	; 0x802e60 <UsartRxQueue>
    234c:	90 93 61 2e 	sts	0x2E61, r25	; 0x802e61 <UsartRxQueue+0x1>
		
	USART_PORT.DIRSET=0b00001000;	
    2350:	e0 e8       	ldi	r30, 0x80	; 128
    2352:	f6 e0       	ldi	r31, 0x06	; 6
    2354:	88 e0       	ldi	r24, 0x08	; 8
    2356:	81 83       	std	Z+1, r24	; 0x01
	USART_PORT.DIRCLR=0b00000100;
    2358:	84 e0       	ldi	r24, 0x04	; 4
    235a:	82 83       	std	Z+2, r24	; 0x02
	
	USART.CTRLA=0b00111000;
    235c:	e0 ea       	ldi	r30, 0xA0	; 160
    235e:	fa e0       	ldi	r31, 0x0A	; 10
    2360:	88 e3       	ldi	r24, 0x38	; 56
    2362:	83 83       	std	Z+3, r24	; 0x03
	USART.CTRLB=0b00011000; 
    2364:	88 e1       	ldi	r24, 0x18	; 24
    2366:	84 83       	std	Z+4, r24	; 0x04
	USART.CTRLC=0b00000011;
    2368:	83 e0       	ldi	r24, 0x03	; 3
    236a:	85 83       	std	Z+5, r24	; 0x05
	
	
	//TODO: change baud to 115200
	USART.BAUDCTRLA=0xE5; //BSEL=3301, BSCALE=-5 19200 baud
    236c:	85 ee       	ldi	r24, 0xE5	; 229
    236e:	86 83       	std	Z+6, r24	; 0x06
	USART.BAUDCTRLB=0xBC; 
    2370:	8c eb       	ldi	r24, 0xBC	; 188
    2372:	87 83       	std	Z+7, r24	; 0x07
	
	stdout=&UsartStdio;
    2374:	ec e7       	ldi	r30, 0x7C	; 124
    2376:	fe e2       	ldi	r31, 0x2E	; 46
    2378:	86 e0       	ldi	r24, 0x06	; 6
    237a:	90 e2       	ldi	r25, 0x20	; 32
    237c:	82 83       	std	Z+2, r24	; 0x02
    237e:	93 83       	std	Z+3, r25	; 0x03
	stdin=&UsartStdio;
    2380:	80 83       	st	Z, r24
    2382:	91 83       	std	Z+1, r25	; 0x01
    2384:	08 95       	ret

00002386 <__vector_60>:
}



ISR(USART_TXC_vect)
{
    2386:	1f 92       	push	r1
    2388:	0f 92       	push	r0
    238a:	0f b6       	in	r0, 0x3f	; 63
    238c:	0f 92       	push	r0
    238e:	11 24       	eor	r1, r1
    2390:	0b b6       	in	r0, 0x3b	; 59
    2392:	0f 92       	push	r0
    2394:	2f 93       	push	r18
    2396:	3f 93       	push	r19
    2398:	4f 93       	push	r20
    239a:	5f 93       	push	r21
    239c:	6f 93       	push	r22
    239e:	7f 93       	push	r23
    23a0:	8f 93       	push	r24
    23a2:	9f 93       	push	r25
    23a4:	af 93       	push	r26
    23a6:	bf 93       	push	r27
    23a8:	ef 93       	push	r30
    23aa:	ff 93       	push	r31
    23ac:	cf 93       	push	r28
    23ae:	df 93       	push	r29
    23b0:	1f 92       	push	r1
    23b2:	1f 92       	push	r1
    23b4:	cd b7       	in	r28, 0x3d	; 61
    23b6:	de b7       	in	r29, 0x3e	; 62
	char c;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    23b8:	19 82       	std	Y+1, r1	; 0x01
	if (xQueueReceiveFromISR(UsartTxQueue,&c,&xHigherPriorityTaskWoken)==pdPASS)
    23ba:	ae 01       	movw	r20, r28
    23bc:	4f 5f       	subi	r20, 0xFF	; 255
    23be:	5f 4f       	sbci	r21, 0xFF	; 255
    23c0:	be 01       	movw	r22, r28
    23c2:	6e 5f       	subi	r22, 0xFE	; 254
    23c4:	7f 4f       	sbci	r23, 0xFF	; 255
    23c6:	80 91 68 2e 	lds	r24, 0x2E68	; 0x802e68 <UsartTxQueue>
    23ca:	90 91 69 2e 	lds	r25, 0x2E69	; 0x802e69 <UsartTxQueue+0x1>
    23ce:	0e 94 fa 24 	call	0x49f4	; 0x49f4 <xQueueReceiveFromISR>
    23d2:	81 30       	cpi	r24, 0x01	; 1
    23d4:	d9 f0       	breq	.+54     	; 0x240c <__vector_60+0x86>
	{
		USART.DATA=c;	
	}
	
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    23d6:	89 81       	ldd	r24, Y+1	; 0x01
    23d8:	81 11       	cpse	r24, r1
    23da:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <vPortYieldISR>
}
    23de:	0f 90       	pop	r0
    23e0:	0f 90       	pop	r0
    23e2:	df 91       	pop	r29
    23e4:	cf 91       	pop	r28
    23e6:	ff 91       	pop	r31
    23e8:	ef 91       	pop	r30
    23ea:	bf 91       	pop	r27
    23ec:	af 91       	pop	r26
    23ee:	9f 91       	pop	r25
    23f0:	8f 91       	pop	r24
    23f2:	7f 91       	pop	r23
    23f4:	6f 91       	pop	r22
    23f6:	5f 91       	pop	r21
    23f8:	4f 91       	pop	r20
    23fa:	3f 91       	pop	r19
    23fc:	2f 91       	pop	r18
    23fe:	0f 90       	pop	r0
    2400:	0b be       	out	0x3b, r0	; 59
    2402:	0f 90       	pop	r0
    2404:	0f be       	out	0x3f, r0	; 63
    2406:	0f 90       	pop	r0
    2408:	1f 90       	pop	r1
    240a:	18 95       	reti
{
	char c;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
	if (xQueueReceiveFromISR(UsartTxQueue,&c,&xHigherPriorityTaskWoken)==pdPASS)
	{
		USART.DATA=c;	
    240c:	8a 81       	ldd	r24, Y+2	; 0x02
    240e:	80 93 a0 0a 	sts	0x0AA0, r24	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    2412:	e1 cf       	rjmp	.-62     	; 0x23d6 <__vector_60+0x50>

00002414 <__vector_58>:
}


//Check for delimiters in ISR
ISR(USART_RXC_vect)
{
    2414:	1f 92       	push	r1
    2416:	0f 92       	push	r0
    2418:	0f b6       	in	r0, 0x3f	; 63
    241a:	0f 92       	push	r0
    241c:	11 24       	eor	r1, r1
    241e:	0b b6       	in	r0, 0x3b	; 59
    2420:	0f 92       	push	r0
    2422:	2f 93       	push	r18
    2424:	3f 93       	push	r19
    2426:	4f 93       	push	r20
    2428:	5f 93       	push	r21
    242a:	6f 93       	push	r22
    242c:	7f 93       	push	r23
    242e:	8f 93       	push	r24
    2430:	9f 93       	push	r25
    2432:	af 93       	push	r26
    2434:	bf 93       	push	r27
    2436:	ef 93       	push	r30
    2438:	ff 93       	push	r31
    243a:	cf 93       	push	r28
    243c:	df 93       	push	r29
    243e:	1f 92       	push	r1
    2440:	1f 92       	push	r1
    2442:	cd b7       	in	r28, 0x3d	; 61
    2444:	de b7       	in	r29, 0x3e	; 62
	char c;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    2446:	19 82       	std	Y+1, r1	; 0x01
	
	c=USART.DATA;
    2448:	80 91 a0 0a 	lds	r24, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    244c:	8a 83       	std	Y+2, r24	; 0x02
	if (receiveStarted==1) {
    244e:	90 91 5b 2d 	lds	r25, 0x2D5B	; 0x802d5b <receiveStarted>
    2452:	91 30       	cpi	r25, 0x01	; 1
    2454:	c9 f0       	breq	.+50     	; 0x2488 <__vector_58+0x74>
			vTaskNotifyGiveFromISR(AresTaskHandle,&xHigherPriorityTaskWoken);
		} else {
			USART_RX_Queue_has_data = 1;
			xQueueSendToBackFromISR(UsartRxQueue,&c,&xHigherPriorityTaskWoken);
		}
	} else if (c==START_DELIMITER) {
    2456:	8b 35       	cpi	r24, 0x5B	; 91
    2458:	71 f1       	breq	.+92     	; 0x24b6 <__vector_58+0xa2>
		USART_RX_transmission_complete = 0;
	}
	// xQueueSendToBackFromISR(UsartRxQueue,&c,&xHigherPriorityTaskWoken);
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	
    245a:	0f 90       	pop	r0
    245c:	0f 90       	pop	r0
    245e:	df 91       	pop	r29
    2460:	cf 91       	pop	r28
    2462:	ff 91       	pop	r31
    2464:	ef 91       	pop	r30
    2466:	bf 91       	pop	r27
    2468:	af 91       	pop	r26
    246a:	9f 91       	pop	r25
    246c:	8f 91       	pop	r24
    246e:	7f 91       	pop	r23
    2470:	6f 91       	pop	r22
    2472:	5f 91       	pop	r21
    2474:	4f 91       	pop	r20
    2476:	3f 91       	pop	r19
    2478:	2f 91       	pop	r18
    247a:	0f 90       	pop	r0
    247c:	0b be       	out	0x3b, r0	; 59
    247e:	0f 90       	pop	r0
    2480:	0f be       	out	0x3f, r0	; 63
    2482:	0f 90       	pop	r0
    2484:	1f 90       	pop	r1
    2486:	18 95       	reti
	char c;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
	
	c=USART.DATA;
	if (receiveStarted==1) {
		if (c==END_DELIMITER) {
    2488:	8d 35       	cpi	r24, 0x5D	; 93
    248a:	d9 f0       	breq	.+54     	; 0x24c2 <__vector_58+0xae>
			receiveStarted=0;
			USART_RX_transmission_complete = 1;
			vTaskNotifyGiveFromISR(AresTaskHandle,&xHigherPriorityTaskWoken);
		} else {
			USART_RX_Queue_has_data = 1;
    248c:	90 93 5e 2e 	sts	0x2E5E, r25	; 0x802e5e <USART_RX_Queue_has_data>
			xQueueSendToBackFromISR(UsartRxQueue,&c,&xHigherPriorityTaskWoken);
    2490:	20 e0       	ldi	r18, 0x00	; 0
    2492:	ae 01       	movw	r20, r28
    2494:	4f 5f       	subi	r20, 0xFF	; 255
    2496:	5f 4f       	sbci	r21, 0xFF	; 255
    2498:	be 01       	movw	r22, r28
    249a:	6e 5f       	subi	r22, 0xFE	; 254
    249c:	7f 4f       	sbci	r23, 0xFF	; 255
    249e:	80 91 60 2e 	lds	r24, 0x2E60	; 0x802e60 <UsartRxQueue>
    24a2:	90 91 61 2e 	lds	r25, 0x2E61	; 0x802e61 <UsartRxQueue+0x1>
    24a6:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <xQueueGenericSendFromISR>
	} else if (c==START_DELIMITER) {
		receiveStarted=1;
		USART_RX_transmission_complete = 0;
	}
	// xQueueSendToBackFromISR(UsartRxQueue,&c,&xHigherPriorityTaskWoken);
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    24aa:	89 81       	ldd	r24, Y+1	; 0x01
    24ac:	88 23       	and	r24, r24
    24ae:	a9 f2       	breq	.-86     	; 0x245a <__vector_58+0x46>
    24b0:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <vPortYieldISR>
	
    24b4:	d2 cf       	rjmp	.-92     	; 0x245a <__vector_58+0x46>
		} else {
			USART_RX_Queue_has_data = 1;
			xQueueSendToBackFromISR(UsartRxQueue,&c,&xHigherPriorityTaskWoken);
		}
	} else if (c==START_DELIMITER) {
		receiveStarted=1;
    24b6:	81 e0       	ldi	r24, 0x01	; 1
    24b8:	80 93 5b 2d 	sts	0x2D5B, r24	; 0x802d5b <receiveStarted>
		USART_RX_transmission_complete = 0;
    24bc:	10 92 5f 2e 	sts	0x2E5F, r1	; 0x802e5f <USART_RX_transmission_complete>
    24c0:	cc cf       	rjmp	.-104    	; 0x245a <__vector_58+0x46>
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
	
	c=USART.DATA;
	if (receiveStarted==1) {
		if (c==END_DELIMITER) {
			receiveStarted=0;
    24c2:	10 92 5b 2d 	sts	0x2D5B, r1	; 0x802d5b <receiveStarted>
			USART_RX_transmission_complete = 1;
    24c6:	90 93 5f 2e 	sts	0x2E5F, r25	; 0x802e5f <USART_RX_transmission_complete>
			vTaskNotifyGiveFromISR(AresTaskHandle,&xHigherPriorityTaskWoken);
    24ca:	be 01       	movw	r22, r28
    24cc:	6f 5f       	subi	r22, 0xFF	; 255
    24ce:	7f 4f       	sbci	r23, 0xFF	; 255
    24d0:	80 91 62 2e 	lds	r24, 0x2E62	; 0x802e62 <AresTaskHandle>
    24d4:	90 91 63 2e 	lds	r25, 0x2E63	; 0x802e63 <AresTaskHandle+0x1>
    24d8:	0e 94 07 30 	call	0x600e	; 0x600e <vTaskNotifyGiveFromISR>
    24dc:	e6 cf       	rjmp	.-52     	; 0x24aa <__vector_58+0x96>

000024de <getSequenceStepEnables>:
	#ifdef VL53L0X_ASSERT_COMMS_ERROR
		configASSERT(res);
	#endif
	
	return res;
}
    24de:	ef 92       	push	r14
    24e0:	ff 92       	push	r15
    24e2:	0f 93       	push	r16
    24e4:	cf 93       	push	r28
    24e6:	df 93       	push	r29
    24e8:	00 d0       	rcall	.+0      	; 0x24ea <getSequenceStepEnables+0xc>
    24ea:	1f 92       	push	r1
    24ec:	cd b7       	in	r28, 0x3d	; 61
    24ee:	de b7       	in	r29, 0x3e	; 62
    24f0:	7c 01       	movw	r14, r24
    24f2:	81 e0       	ldi	r24, 0x01	; 1
    24f4:	89 83       	std	Y+1, r24	; 0x01
    24f6:	01 e0       	ldi	r16, 0x01	; 1
    24f8:	9e 01       	movw	r18, r28
    24fa:	2f 5f       	subi	r18, 0xFF	; 255
    24fc:	3f 4f       	sbci	r19, 0xFF	; 255
    24fe:	41 e0       	ldi	r20, 0x01	; 1
    2500:	b9 01       	movw	r22, r18
    2502:	89 e2       	ldi	r24, 0x29	; 41
    2504:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
    2508:	89 81       	ldd	r24, Y+1	; 0x01
    250a:	84 fb       	bst	r24, 4
    250c:	99 27       	eor	r25, r25
    250e:	90 f9       	bld	r25, 0
    2510:	f7 01       	movw	r30, r14
    2512:	90 83       	st	Z, r25
    2514:	83 fb       	bst	r24, 3
    2516:	99 27       	eor	r25, r25
    2518:	90 f9       	bld	r25, 0
    251a:	92 83       	std	Z+2, r25	; 0x02
    251c:	82 fb       	bst	r24, 2
    251e:	99 27       	eor	r25, r25
    2520:	90 f9       	bld	r25, 0
    2522:	91 83       	std	Z+1, r25	; 0x01
    2524:	86 fb       	bst	r24, 6
    2526:	99 27       	eor	r25, r25
    2528:	90 f9       	bld	r25, 0
    252a:	93 83       	std	Z+3, r25	; 0x03
    252c:	88 1f       	adc	r24, r24
    252e:	88 27       	eor	r24, r24
    2530:	88 1f       	adc	r24, r24
    2532:	84 83       	std	Z+4, r24	; 0x04
    2534:	24 96       	adiw	r28, 0x04	; 4
    2536:	cd bf       	out	0x3d, r28	; 61
    2538:	de bf       	out	0x3e, r29	; 62
    253a:	df 91       	pop	r29
    253c:	cf 91       	pop	r28
    253e:	0f 91       	pop	r16
    2540:	ff 90       	pop	r15
    2542:	ef 90       	pop	r14
    2544:	08 95       	ret

00002546 <performSingleRefCalibration>:
    2546:	0f 93       	push	r16
    2548:	1f 93       	push	r17
    254a:	cf 93       	push	r28
    254c:	df 93       	push	r29
    254e:	00 d0       	rcall	.+0      	; 0x2550 <performSingleRefCalibration+0xa>
    2550:	1f 92       	push	r1
    2552:	cd b7       	in	r28, 0x3d	; 61
    2554:	de b7       	in	r29, 0x3e	; 62
    2556:	19 82       	std	Y+1, r1	; 0x01
    2558:	81 60       	ori	r24, 0x01	; 1
    255a:	8a 83       	std	Y+2, r24	; 0x02
    255c:	42 e0       	ldi	r20, 0x02	; 2
    255e:	be 01       	movw	r22, r28
    2560:	6f 5f       	subi	r22, 0xFF	; 255
    2562:	7f 4f       	sbci	r23, 0xFF	; 255
    2564:	89 e2       	ldi	r24, 0x29	; 41
    2566:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
    256a:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    256e:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2572:	80 91 6e 2e 	lds	r24, 0x2E6E	; 0x802e6e <StatsTimer>
    2576:	90 91 6f 2e 	lds	r25, 0x2E6F	; 0x802e6f <StatsTimer+0x1>
    257a:	a0 91 70 2e 	lds	r26, 0x2E70	; 0x802e70 <StatsTimer+0x2>
    257e:	b0 91 71 2e 	lds	r27, 0x2E71	; 0x802e71 <StatsTimer+0x3>
    2582:	82 0f       	add	r24, r18
    2584:	93 1f       	adc	r25, r19
    2586:	a1 1d       	adc	r26, r1
    2588:	b1 1d       	adc	r27, r1
    258a:	80 93 5c 2d 	sts	0x2D5C, r24	; 0x802d5c <timeout_start_ticks>
    258e:	90 93 5d 2d 	sts	0x2D5D, r25	; 0x802d5d <timeout_start_ticks+0x1>
    2592:	a0 93 5e 2d 	sts	0x2D5E, r26	; 0x802d5e <timeout_start_ticks+0x2>
    2596:	b0 93 5f 2d 	sts	0x2D5F, r27	; 0x802d5f <timeout_start_ticks+0x3>
    259a:	13 e1       	ldi	r17, 0x13	; 19
    259c:	19 83       	std	Y+1, r17	; 0x01
    259e:	01 e0       	ldi	r16, 0x01	; 1
    25a0:	9e 01       	movw	r18, r28
    25a2:	2f 5f       	subi	r18, 0xFF	; 255
    25a4:	3f 4f       	sbci	r19, 0xFF	; 255
    25a6:	41 e0       	ldi	r20, 0x01	; 1
    25a8:	b9 01       	movw	r22, r18
    25aa:	89 e2       	ldi	r24, 0x29	; 41
    25ac:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
    25b0:	89 81       	ldd	r24, Y+1	; 0x01
    25b2:	87 70       	andi	r24, 0x07	; 7
    25b4:	99 f3       	breq	.-26     	; 0x259c <performSingleRefCalibration+0x56>
    25b6:	8b e0       	ldi	r24, 0x0B	; 11
    25b8:	89 83       	std	Y+1, r24	; 0x01
    25ba:	81 e0       	ldi	r24, 0x01	; 1
    25bc:	8a 83       	std	Y+2, r24	; 0x02
    25be:	42 e0       	ldi	r20, 0x02	; 2
    25c0:	be 01       	movw	r22, r28
    25c2:	6f 5f       	subi	r22, 0xFF	; 255
    25c4:	7f 4f       	sbci	r23, 0xFF	; 255
    25c6:	89 e2       	ldi	r24, 0x29	; 41
    25c8:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
    25cc:	19 82       	std	Y+1, r1	; 0x01
    25ce:	1a 82       	std	Y+2, r1	; 0x02
    25d0:	42 e0       	ldi	r20, 0x02	; 2
    25d2:	be 01       	movw	r22, r28
    25d4:	6f 5f       	subi	r22, 0xFF	; 255
    25d6:	7f 4f       	sbci	r23, 0xFF	; 255
    25d8:	89 e2       	ldi	r24, 0x29	; 41
    25da:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
    25de:	81 e0       	ldi	r24, 0x01	; 1
    25e0:	24 96       	adiw	r28, 0x04	; 4
    25e2:	cd bf       	out	0x3d, r28	; 61
    25e4:	de bf       	out	0x3e, r29	; 62
    25e6:	df 91       	pop	r29
    25e8:	cf 91       	pop	r28
    25ea:	1f 91       	pop	r17
    25ec:	0f 91       	pop	r16
    25ee:	08 95       	ret

000025f0 <readReg16Bit>:
    25f0:	ef 92       	push	r14
    25f2:	ff 92       	push	r15
    25f4:	0f 93       	push	r16
    25f6:	cf 93       	push	r28
    25f8:	df 93       	push	r29
    25fa:	00 d0       	rcall	.+0      	; 0x25fc <readReg16Bit+0xc>
    25fc:	1f 92       	push	r1
    25fe:	cd b7       	in	r28, 0x3d	; 61
    2600:	de b7       	in	r29, 0x3e	; 62
    2602:	7b 01       	movw	r14, r22
    2604:	89 83       	std	Y+1, r24	; 0x01
    2606:	02 e0       	ldi	r16, 0x02	; 2
    2608:	9e 01       	movw	r18, r28
    260a:	2f 5f       	subi	r18, 0xFF	; 255
    260c:	3f 4f       	sbci	r19, 0xFF	; 255
    260e:	41 e0       	ldi	r20, 0x01	; 1
    2610:	b9 01       	movw	r22, r18
    2612:	89 e2       	ldi	r24, 0x29	; 41
    2614:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
    2618:	e1 14       	cp	r14, r1
    261a:	f1 04       	cpc	r15, r1
    261c:	61 f0       	breq	.+24     	; 0x2636 <readReg16Bit+0x46>
    261e:	29 81       	ldd	r18, Y+1	; 0x01
    2620:	30 e0       	ldi	r19, 0x00	; 0
    2622:	9a 81       	ldd	r25, Y+2	; 0x02
    2624:	98 5f       	subi	r25, 0xF8	; 248
    2626:	02 c0       	rjmp	.+4      	; 0x262c <readReg16Bit+0x3c>
    2628:	22 0f       	add	r18, r18
    262a:	33 1f       	adc	r19, r19
    262c:	9a 95       	dec	r25
    262e:	e2 f7       	brpl	.-8      	; 0x2628 <readReg16Bit+0x38>
    2630:	f7 01       	movw	r30, r14
    2632:	20 83       	st	Z, r18
    2634:	31 83       	std	Z+1, r19	; 0x01
    2636:	24 96       	adiw	r28, 0x04	; 4
    2638:	cd bf       	out	0x3d, r28	; 61
    263a:	de bf       	out	0x3e, r29	; 62
    263c:	df 91       	pop	r29
    263e:	cf 91       	pop	r28
    2640:	0f 91       	pop	r16
    2642:	ff 90       	pop	r15
    2644:	ef 90       	pop	r14
    2646:	08 95       	ret

00002648 <getSequenceStepTimeouts.isra.1>:
    2648:	8f 92       	push	r8
    264a:	9f 92       	push	r9
    264c:	af 92       	push	r10
    264e:	bf 92       	push	r11
    2650:	cf 92       	push	r12
    2652:	df 92       	push	r13
    2654:	ef 92       	push	r14
    2656:	ff 92       	push	r15
    2658:	0f 93       	push	r16
    265a:	1f 93       	push	r17
    265c:	cf 93       	push	r28
    265e:	df 93       	push	r29
    2660:	00 d0       	rcall	.+0      	; 0x2662 <getSequenceStepTimeouts.isra.1+0x1a>
    2662:	00 d0       	rcall	.+0      	; 0x2664 <getSequenceStepTimeouts.isra.1+0x1c>
    2664:	cd b7       	in	r28, 0x3d	; 61
    2666:	de b7       	in	r29, 0x3e	; 62
    2668:	6c 01       	movw	r12, r24
    266a:	7b 01       	movw	r14, r22
    266c:	80 e5       	ldi	r24, 0x50	; 80
    266e:	89 83       	std	Y+1, r24	; 0x01
    2670:	01 e0       	ldi	r16, 0x01	; 1
    2672:	9e 01       	movw	r18, r28
    2674:	2f 5f       	subi	r18, 0xFF	; 255
    2676:	3f 4f       	sbci	r19, 0xFF	; 255
    2678:	41 e0       	ldi	r20, 0x01	; 1
    267a:	b9 01       	movw	r22, r18
    267c:	89 e2       	ldi	r24, 0x29	; 41
    267e:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
    2682:	89 81       	ldd	r24, Y+1	; 0x01
    2684:	8f 5f       	subi	r24, 0xFF	; 255
    2686:	88 0f       	add	r24, r24
    2688:	90 e0       	ldi	r25, 0x00	; 0
    268a:	f7 01       	movw	r30, r14
    268c:	80 83       	st	Z, r24
    268e:	91 83       	std	Z+1, r25	; 0x01
    2690:	86 e4       	ldi	r24, 0x46	; 70
    2692:	89 83       	std	Y+1, r24	; 0x01
    2694:	9e 01       	movw	r18, r28
    2696:	2f 5f       	subi	r18, 0xFF	; 255
    2698:	3f 4f       	sbci	r19, 0xFF	; 255
    269a:	41 e0       	ldi	r20, 0x01	; 1
    269c:	b9 01       	movw	r22, r18
    269e:	89 e2       	ldi	r24, 0x29	; 41
    26a0:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
    26a4:	09 81       	ldd	r16, Y+1	; 0x01
    26a6:	10 e0       	ldi	r17, 0x00	; 0
    26a8:	0f 5f       	subi	r16, 0xFF	; 255
    26aa:	1f 4f       	sbci	r17, 0xFF	; 255
    26ac:	f7 01       	movw	r30, r14
    26ae:	04 83       	std	Z+4, r16	; 0x04
    26b0:	15 83       	std	Z+5, r17	; 0x05
    26b2:	a0 81       	ld	r26, Z
    26b4:	b0 e0       	ldi	r27, 0x00	; 0
    26b6:	20 e0       	ldi	r18, 0x00	; 0
    26b8:	3f e2       	ldi	r19, 0x2F	; 47
    26ba:	4a e3       	ldi	r20, 0x3A	; 58
    26bc:	50 e0       	ldi	r21, 0x00	; 0
    26be:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <__muluhisi3>
    26c2:	6c 50       	subi	r22, 0x0C	; 12
    26c4:	7e 4f       	sbci	r23, 0xFE	; 254
    26c6:	8f 4f       	sbci	r24, 0xFF	; 255
    26c8:	9f 4f       	sbci	r25, 0xFF	; 255
    26ca:	38 ee       	ldi	r19, 0xE8	; 232
    26cc:	83 2e       	mov	r8, r19
    26ce:	33 e0       	ldi	r19, 0x03	; 3
    26d0:	93 2e       	mov	r9, r19
    26d2:	a1 2c       	mov	r10, r1
    26d4:	b1 2c       	mov	r11, r1
    26d6:	a5 01       	movw	r20, r10
    26d8:	94 01       	movw	r18, r8
    26da:	0e 94 b0 4b 	call	0x9760	; 0x9760 <__udivmodsi4>
    26de:	d8 01       	movw	r26, r16
    26e0:	0e 94 ec 4b 	call	0x97d8	; 0x97d8 <__mulshisi3>
    26e4:	6c 50       	subi	r22, 0x0C	; 12
    26e6:	7e 4f       	sbci	r23, 0xFE	; 254
    26e8:	8f 4f       	sbci	r24, 0xFF	; 255
    26ea:	9f 4f       	sbci	r25, 0xFF	; 255
    26ec:	a5 01       	movw	r20, r10
    26ee:	94 01       	movw	r18, r8
    26f0:	0e 94 b0 4b 	call	0x9760	; 0x9760 <__udivmodsi4>
    26f4:	f7 01       	movw	r30, r14
    26f6:	22 87       	std	Z+10, r18	; 0x0a
    26f8:	33 87       	std	Z+11, r19	; 0x0b
    26fa:	44 87       	std	Z+12, r20	; 0x0c
    26fc:	55 87       	std	Z+13, r21	; 0x0d
    26fe:	be 01       	movw	r22, r28
    2700:	6b 5f       	subi	r22, 0xFB	; 251
    2702:	7f 4f       	sbci	r23, 0xFF	; 255
    2704:	81 e5       	ldi	r24, 0x51	; 81
    2706:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <readReg16Bit>
    270a:	8d 81       	ldd	r24, Y+5	; 0x05
    270c:	9e 81       	ldd	r25, Y+6	; 0x06
    270e:	8c 01       	movw	r16, r24
    2710:	11 27       	eor	r17, r17
    2712:	02 c0       	rjmp	.+4      	; 0x2718 <getSequenceStepTimeouts.isra.1+0xd0>
    2714:	00 0f       	add	r16, r16
    2716:	11 1f       	adc	r17, r17
    2718:	9a 95       	dec	r25
    271a:	e2 f7       	brpl	.-8      	; 0x2714 <getSequenceStepTimeouts.isra.1+0xcc>
    271c:	0f 5f       	subi	r16, 0xFF	; 255
    271e:	1f 4f       	sbci	r17, 0xFF	; 255
    2720:	f7 01       	movw	r30, r14
    2722:	06 83       	std	Z+6, r16	; 0x06
    2724:	17 83       	std	Z+7, r17	; 0x07
    2726:	a0 81       	ld	r26, Z
    2728:	b0 e0       	ldi	r27, 0x00	; 0
    272a:	20 e0       	ldi	r18, 0x00	; 0
    272c:	3f e2       	ldi	r19, 0x2F	; 47
    272e:	4a e3       	ldi	r20, 0x3A	; 58
    2730:	50 e0       	ldi	r21, 0x00	; 0
    2732:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <__muluhisi3>
    2736:	6c 50       	subi	r22, 0x0C	; 12
    2738:	7e 4f       	sbci	r23, 0xFE	; 254
    273a:	8f 4f       	sbci	r24, 0xFF	; 255
    273c:	9f 4f       	sbci	r25, 0xFF	; 255
    273e:	a5 01       	movw	r20, r10
    2740:	94 01       	movw	r18, r8
    2742:	0e 94 b0 4b 	call	0x9760	; 0x9760 <__udivmodsi4>
    2746:	d8 01       	movw	r26, r16
    2748:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <__muluhisi3>
    274c:	6c 50       	subi	r22, 0x0C	; 12
    274e:	7e 4f       	sbci	r23, 0xFE	; 254
    2750:	8f 4f       	sbci	r24, 0xFF	; 255
    2752:	9f 4f       	sbci	r25, 0xFF	; 255
    2754:	a5 01       	movw	r20, r10
    2756:	94 01       	movw	r18, r8
    2758:	0e 94 b0 4b 	call	0x9760	; 0x9760 <__udivmodsi4>
    275c:	f7 01       	movw	r30, r14
    275e:	26 87       	std	Z+14, r18	; 0x0e
    2760:	37 87       	std	Z+15, r19	; 0x0f
    2762:	40 8b       	std	Z+16, r20	; 0x10
    2764:	51 8b       	std	Z+17, r21	; 0x11
    2766:	80 e7       	ldi	r24, 0x70	; 112
    2768:	89 83       	std	Y+1, r24	; 0x01
    276a:	01 e0       	ldi	r16, 0x01	; 1
    276c:	9e 01       	movw	r18, r28
    276e:	2f 5f       	subi	r18, 0xFF	; 255
    2770:	3f 4f       	sbci	r19, 0xFF	; 255
    2772:	41 e0       	ldi	r20, 0x01	; 1
    2774:	b9 01       	movw	r22, r18
    2776:	89 e2       	ldi	r24, 0x29	; 41
    2778:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
    277c:	89 81       	ldd	r24, Y+1	; 0x01
    277e:	8f 5f       	subi	r24, 0xFF	; 255
    2780:	88 0f       	add	r24, r24
    2782:	90 e0       	ldi	r25, 0x00	; 0
    2784:	f7 01       	movw	r30, r14
    2786:	82 83       	std	Z+2, r24	; 0x02
    2788:	93 83       	std	Z+3, r25	; 0x03
    278a:	be 01       	movw	r22, r28
    278c:	6b 5f       	subi	r22, 0xFB	; 251
    278e:	7f 4f       	sbci	r23, 0xFF	; 255
    2790:	81 e7       	ldi	r24, 0x71	; 113
    2792:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <readReg16Bit>
    2796:	8d 81       	ldd	r24, Y+5	; 0x05
    2798:	9e 81       	ldd	r25, Y+6	; 0x06
    279a:	8c 01       	movw	r16, r24
    279c:	11 27       	eor	r17, r17
    279e:	02 c0       	rjmp	.+4      	; 0x27a4 <getSequenceStepTimeouts.isra.1+0x15c>
    27a0:	00 0f       	add	r16, r16
    27a2:	11 1f       	adc	r17, r17
    27a4:	9a 95       	dec	r25
    27a6:	e2 f7       	brpl	.-8      	; 0x27a0 <getSequenceStepTimeouts.isra.1+0x158>
    27a8:	0f 5f       	subi	r16, 0xFF	; 255
    27aa:	1f 4f       	sbci	r17, 0xFF	; 255
    27ac:	f7 01       	movw	r30, r14
    27ae:	00 87       	std	Z+8, r16	; 0x08
    27b0:	11 87       	std	Z+9, r17	; 0x09
    27b2:	f6 01       	movw	r30, r12
    27b4:	80 81       	ld	r24, Z
    27b6:	88 23       	and	r24, r24
    27b8:	39 f0       	breq	.+14     	; 0x27c8 <getSequenceStepTimeouts.isra.1+0x180>
    27ba:	f7 01       	movw	r30, r14
    27bc:	86 81       	ldd	r24, Z+6	; 0x06
    27be:	97 81       	ldd	r25, Z+7	; 0x07
    27c0:	08 1b       	sub	r16, r24
    27c2:	19 0b       	sbc	r17, r25
    27c4:	00 87       	std	Z+8, r16	; 0x08
    27c6:	11 87       	std	Z+9, r17	; 0x09
    27c8:	f7 01       	movw	r30, r14
    27ca:	a2 81       	ldd	r26, Z+2	; 0x02
    27cc:	b0 e0       	ldi	r27, 0x00	; 0
    27ce:	20 e0       	ldi	r18, 0x00	; 0
    27d0:	3f e2       	ldi	r19, 0x2F	; 47
    27d2:	4a e3       	ldi	r20, 0x3A	; 58
    27d4:	50 e0       	ldi	r21, 0x00	; 0
    27d6:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <__muluhisi3>
    27da:	6c 50       	subi	r22, 0x0C	; 12
    27dc:	7e 4f       	sbci	r23, 0xFE	; 254
    27de:	8f 4f       	sbci	r24, 0xFF	; 255
    27e0:	9f 4f       	sbci	r25, 0xFF	; 255
    27e2:	28 ee       	ldi	r18, 0xE8	; 232
    27e4:	82 2e       	mov	r8, r18
    27e6:	23 e0       	ldi	r18, 0x03	; 3
    27e8:	92 2e       	mov	r9, r18
    27ea:	a1 2c       	mov	r10, r1
    27ec:	b1 2c       	mov	r11, r1
    27ee:	a5 01       	movw	r20, r10
    27f0:	94 01       	movw	r18, r8
    27f2:	0e 94 b0 4b 	call	0x9760	; 0x9760 <__udivmodsi4>
    27f6:	d8 01       	movw	r26, r16
    27f8:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <__muluhisi3>
    27fc:	6c 50       	subi	r22, 0x0C	; 12
    27fe:	7e 4f       	sbci	r23, 0xFE	; 254
    2800:	8f 4f       	sbci	r24, 0xFF	; 255
    2802:	9f 4f       	sbci	r25, 0xFF	; 255
    2804:	a5 01       	movw	r20, r10
    2806:	94 01       	movw	r18, r8
    2808:	0e 94 b0 4b 	call	0x9760	; 0x9760 <__udivmodsi4>
    280c:	f7 01       	movw	r30, r14
    280e:	22 8b       	std	Z+18, r18	; 0x12
    2810:	33 8b       	std	Z+19, r19	; 0x13
    2812:	44 8b       	std	Z+20, r20	; 0x14
    2814:	55 8b       	std	Z+21, r21	; 0x15
    2816:	26 96       	adiw	r28, 0x06	; 6
    2818:	cd bf       	out	0x3d, r28	; 61
    281a:	de bf       	out	0x3e, r29	; 62
    281c:	df 91       	pop	r29
    281e:	cf 91       	pop	r28
    2820:	1f 91       	pop	r17
    2822:	0f 91       	pop	r16
    2824:	ff 90       	pop	r15
    2826:	ef 90       	pop	r14
    2828:	df 90       	pop	r13
    282a:	cf 90       	pop	r12
    282c:	bf 90       	pop	r11
    282e:	af 90       	pop	r10
    2830:	9f 90       	pop	r9
    2832:	8f 90       	pop	r8
    2834:	08 95       	ret

00002836 <setMeasurementTimingBudget.part.4>:
    2836:	4f 92       	push	r4
    2838:	5f 92       	push	r5
    283a:	6f 92       	push	r6
    283c:	7f 92       	push	r7
    283e:	8f 92       	push	r8
    2840:	9f 92       	push	r9
    2842:	af 92       	push	r10
    2844:	bf 92       	push	r11
    2846:	cf 92       	push	r12
    2848:	df 92       	push	r13
    284a:	ef 92       	push	r14
    284c:	ff 92       	push	r15
    284e:	1f 93       	push	r17
    2850:	cf 93       	push	r28
    2852:	df 93       	push	r29
    2854:	cd b7       	in	r28, 0x3d	; 61
    2856:	de b7       	in	r29, 0x3e	; 62
    2858:	6f 97       	sbiw	r28, 0x1f	; 31
    285a:	cd bf       	out	0x3d, r28	; 61
    285c:	de bf       	out	0x3e, r29	; 62
    285e:	6b 01       	movw	r12, r22
    2860:	7c 01       	movw	r14, r24
    2862:	ce 01       	movw	r24, r28
    2864:	47 96       	adiw	r24, 0x17	; 23
    2866:	0e 94 6f 12 	call	0x24de	; 0x24de <getSequenceStepEnables>
    286a:	be 01       	movw	r22, r28
    286c:	6f 5f       	subi	r22, 0xFF	; 255
    286e:	7f 4f       	sbci	r23, 0xFF	; 255
    2870:	ce 01       	movw	r24, r28
    2872:	4a 96       	adiw	r24, 0x1a	; 26
    2874:	0e 94 24 13 	call	0x2648	; 0x2648 <getSequenceStepTimeouts.isra.1>
    2878:	8f 89       	ldd	r24, Y+23	; 0x17
    287a:	88 23       	and	r24, r24
    287c:	09 f4       	brne	.+2      	; 0x2880 <setMeasurementTimingBudget.part.4+0x4a>
    287e:	b0 c0       	rjmp	.+352    	; 0x29e0 <setMeasurementTimingBudget.part.4+0x1aa>
    2880:	8b 85       	ldd	r24, Y+11	; 0x0b
    2882:	9c 85       	ldd	r25, Y+12	; 0x0c
    2884:	ad 85       	ldd	r26, Y+13	; 0x0d
    2886:	be 85       	ldd	r27, Y+14	; 0x0e
    2888:	8c 57       	subi	r24, 0x7C	; 124
    288a:	92 4f       	sbci	r25, 0xF2	; 242
    288c:	af 4f       	sbci	r26, 0xFF	; 255
    288e:	bf 4f       	sbci	r27, 0xFF	; 255
    2890:	29 8d       	ldd	r18, Y+25	; 0x19
    2892:	22 23       	and	r18, r18
    2894:	09 f4       	brne	.+2      	; 0x2898 <setMeasurementTimingBudget.part.4+0x62>
    2896:	93 c0       	rjmp	.+294    	; 0x29be <setMeasurementTimingBudget.part.4+0x188>
    2898:	4b 85       	ldd	r20, Y+11	; 0x0b
    289a:	5c 85       	ldd	r21, Y+12	; 0x0c
    289c:	6d 85       	ldd	r22, Y+13	; 0x0d
    289e:	7e 85       	ldd	r23, Y+14	; 0x0e
    28a0:	4e 54       	subi	r20, 0x4E	; 78
    28a2:	5d 4f       	sbci	r21, 0xFD	; 253
    28a4:	6f 4f       	sbci	r22, 0xFF	; 255
    28a6:	7f 4f       	sbci	r23, 0xFF	; 255
    28a8:	44 0f       	add	r20, r20
    28aa:	55 1f       	adc	r21, r21
    28ac:	66 1f       	adc	r22, r22
    28ae:	77 1f       	adc	r23, r23
    28b0:	84 0f       	add	r24, r20
    28b2:	95 1f       	adc	r25, r21
    28b4:	a6 1f       	adc	r26, r22
    28b6:	b7 1f       	adc	r27, r23
    28b8:	1a 8d       	ldd	r17, Y+26	; 0x1a
    28ba:	11 23       	and	r17, r17
    28bc:	61 f0       	breq	.+24     	; 0x28d6 <setMeasurementTimingBudget.part.4+0xa0>
    28be:	4f 85       	ldd	r20, Y+15	; 0x0f
    28c0:	58 89       	ldd	r21, Y+16	; 0x10
    28c2:	69 89       	ldd	r22, Y+17	; 0x11
    28c4:	7a 89       	ldd	r23, Y+18	; 0x12
    28c6:	4c 56       	subi	r20, 0x6C	; 108
    28c8:	5d 4f       	sbci	r21, 0xFD	; 253
    28ca:	6f 4f       	sbci	r22, 0xFF	; 255
    28cc:	7f 4f       	sbci	r23, 0xFF	; 255
    28ce:	84 0f       	add	r24, r20
    28d0:	95 1f       	adc	r25, r21
    28d2:	a6 1f       	adc	r26, r22
    28d4:	b7 1f       	adc	r27, r23
    28d6:	2b 8d       	ldd	r18, Y+27	; 0x1b
    28d8:	22 23       	and	r18, r18
    28da:	09 f4       	brne	.+2      	; 0x28de <setMeasurementTimingBudget.part.4+0xa8>
    28dc:	9a c0       	rjmp	.+308    	; 0x2a12 <setMeasurementTimingBudget.part.4+0x1dc>
    28de:	2c 01       	movw	r4, r24
    28e0:	3d 01       	movw	r6, r26
    28e2:	26 e2       	ldi	r18, 0x26	; 38
    28e4:	42 0e       	add	r4, r18
    28e6:	22 e0       	ldi	r18, 0x02	; 2
    28e8:	52 1e       	adc	r5, r18
    28ea:	61 1c       	adc	r6, r1
    28ec:	71 1c       	adc	r7, r1
    28ee:	c4 14       	cp	r12, r4
    28f0:	d5 04       	cpc	r13, r5
    28f2:	e6 04       	cpc	r14, r6
    28f4:	f7 04       	cpc	r15, r7
    28f6:	08 f4       	brcc	.+2      	; 0x28fa <setMeasurementTimingBudget.part.4+0xc4>
    28f8:	78 c0       	rjmp	.+240    	; 0x29ea <setMeasurementTimingBudget.part.4+0x1b4>
    28fa:	ab 81       	ldd	r26, Y+3	; 0x03
    28fc:	b0 e0       	ldi	r27, 0x00	; 0
    28fe:	20 e0       	ldi	r18, 0x00	; 0
    2900:	3f e2       	ldi	r19, 0x2F	; 47
    2902:	4a e3       	ldi	r20, 0x3A	; 58
    2904:	50 e0       	ldi	r21, 0x00	; 0
    2906:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <__muluhisi3>
    290a:	4b 01       	movw	r8, r22
    290c:	5c 01       	movw	r10, r24
    290e:	24 ef       	ldi	r18, 0xF4	; 244
    2910:	82 0e       	add	r8, r18
    2912:	21 e0       	ldi	r18, 0x01	; 1
    2914:	92 1e       	adc	r9, r18
    2916:	a1 1c       	adc	r10, r1
    2918:	b1 1c       	adc	r11, r1
    291a:	a7 01       	movw	r20, r14
    291c:	96 01       	movw	r18, r12
    291e:	24 19       	sub	r18, r4
    2920:	35 09       	sbc	r19, r5
    2922:	46 09       	sbc	r20, r6
    2924:	57 09       	sbc	r21, r7
    2926:	a8 ee       	ldi	r26, 0xE8	; 232
    2928:	b3 e0       	ldi	r27, 0x03	; 3
    292a:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <__muluhisi3>
    292e:	2b 01       	movw	r4, r22
    2930:	3c 01       	movw	r6, r24
    2932:	c5 01       	movw	r24, r10
    2934:	b4 01       	movw	r22, r8
    2936:	20 ed       	ldi	r18, 0xD0	; 208
    2938:	37 e0       	ldi	r19, 0x07	; 7
    293a:	40 e0       	ldi	r20, 0x00	; 0
    293c:	50 e0       	ldi	r21, 0x00	; 0
    293e:	0e 94 b0 4b 	call	0x9760	; 0x9760 <__udivmodsi4>
    2942:	42 0e       	add	r4, r18
    2944:	53 1e       	adc	r5, r19
    2946:	64 1e       	adc	r6, r20
    2948:	75 1e       	adc	r7, r21
    294a:	c5 01       	movw	r24, r10
    294c:	b4 01       	movw	r22, r8
    294e:	28 ee       	ldi	r18, 0xE8	; 232
    2950:	33 e0       	ldi	r19, 0x03	; 3
    2952:	40 e0       	ldi	r20, 0x00	; 0
    2954:	50 e0       	ldi	r21, 0x00	; 0
    2956:	0e 94 b0 4b 	call	0x9760	; 0x9760 <__udivmodsi4>
    295a:	c3 01       	movw	r24, r6
    295c:	b2 01       	movw	r22, r4
    295e:	0e 94 b0 4b 	call	0x9760	; 0x9760 <__udivmodsi4>
    2962:	11 23       	and	r17, r17
    2964:	31 f0       	breq	.+12     	; 0x2972 <setMeasurementTimingBudget.part.4+0x13c>
    2966:	8f 81       	ldd	r24, Y+7	; 0x07
    2968:	98 85       	ldd	r25, Y+8	; 0x08
    296a:	28 0f       	add	r18, r24
    296c:	39 1f       	adc	r19, r25
    296e:	41 1d       	adc	r20, r1
    2970:	51 1d       	adc	r21, r1
    2972:	21 15       	cp	r18, r1
    2974:	31 05       	cpc	r19, r1
    2976:	41 05       	cpc	r20, r1
    2978:	51 05       	cpc	r21, r1
    297a:	09 f4       	brne	.+2      	; 0x297e <setMeasurementTimingBudget.part.4+0x148>
    297c:	4c c0       	rjmp	.+152    	; 0x2a16 <setMeasurementTimingBudget.part.4+0x1e0>
    297e:	da 01       	movw	r26, r20
    2980:	c9 01       	movw	r24, r18
    2982:	01 97       	sbiw	r24, 0x01	; 1
    2984:	a1 09       	sbc	r26, r1
    2986:	b1 09       	sbc	r27, r1
    2988:	ac 01       	movw	r20, r24
    298a:	bd 01       	movw	r22, r26
    298c:	44 27       	eor	r20, r20
    298e:	20 e0       	ldi	r18, 0x00	; 0
    2990:	30 e0       	ldi	r19, 0x00	; 0
    2992:	45 2b       	or	r20, r21
    2994:	46 2b       	or	r20, r22
    2996:	47 2b       	or	r20, r23
    2998:	79 f0       	breq	.+30     	; 0x29b8 <setMeasurementTimingBudget.part.4+0x182>
    299a:	b6 95       	lsr	r27
    299c:	a7 95       	ror	r26
    299e:	97 95       	ror	r25
    29a0:	87 95       	ror	r24
    29a2:	2f 5f       	subi	r18, 0xFF	; 255
    29a4:	3f 4f       	sbci	r19, 0xFF	; 255
    29a6:	ac 01       	movw	r20, r24
    29a8:	bd 01       	movw	r22, r26
    29aa:	44 27       	eor	r20, r20
    29ac:	45 2b       	or	r20, r21
    29ae:	46 2b       	or	r20, r22
    29b0:	47 2b       	or	r20, r23
    29b2:	99 f7       	brne	.-26     	; 0x299a <setMeasurementTimingBudget.part.4+0x164>
    29b4:	32 2f       	mov	r19, r18
    29b6:	22 27       	eor	r18, r18
    29b8:	82 2b       	or	r24, r18
    29ba:	93 2b       	or	r25, r19
    29bc:	2e c0       	rjmp	.+92     	; 0x2a1a <setMeasurementTimingBudget.part.4+0x1e4>
    29be:	28 8d       	ldd	r18, Y+24	; 0x18
    29c0:	22 23       	and	r18, r18
    29c2:	09 f4       	brne	.+2      	; 0x29c6 <setMeasurementTimingBudget.part.4+0x190>
    29c4:	79 cf       	rjmp	.-270    	; 0x28b8 <setMeasurementTimingBudget.part.4+0x82>
    29c6:	4b 85       	ldd	r20, Y+11	; 0x0b
    29c8:	5c 85       	ldd	r21, Y+12	; 0x0c
    29ca:	6d 85       	ldd	r22, Y+13	; 0x0d
    29cc:	7e 85       	ldd	r23, Y+14	; 0x0e
    29ce:	4c 56       	subi	r20, 0x6C	; 108
    29d0:	5d 4f       	sbci	r21, 0xFD	; 253
    29d2:	6f 4f       	sbci	r22, 0xFF	; 255
    29d4:	7f 4f       	sbci	r23, 0xFF	; 255
    29d6:	84 0f       	add	r24, r20
    29d8:	95 1f       	adc	r25, r21
    29da:	a6 1f       	adc	r26, r22
    29dc:	b7 1f       	adc	r27, r23
    29de:	6c cf       	rjmp	.-296    	; 0x28b8 <setMeasurementTimingBudget.part.4+0x82>
    29e0:	86 e3       	ldi	r24, 0x36	; 54
    29e2:	9b e0       	ldi	r25, 0x0B	; 11
    29e4:	a0 e0       	ldi	r26, 0x00	; 0
    29e6:	b0 e0       	ldi	r27, 0x00	; 0
    29e8:	53 cf       	rjmp	.-346    	; 0x2890 <setMeasurementTimingBudget.part.4+0x5a>
    29ea:	80 e0       	ldi	r24, 0x00	; 0
    29ec:	6f 96       	adiw	r28, 0x1f	; 31
    29ee:	cd bf       	out	0x3d, r28	; 61
    29f0:	de bf       	out	0x3e, r29	; 62
    29f2:	df 91       	pop	r29
    29f4:	cf 91       	pop	r28
    29f6:	1f 91       	pop	r17
    29f8:	ff 90       	pop	r15
    29fa:	ef 90       	pop	r14
    29fc:	df 90       	pop	r13
    29fe:	cf 90       	pop	r12
    2a00:	bf 90       	pop	r11
    2a02:	af 90       	pop	r10
    2a04:	9f 90       	pop	r9
    2a06:	8f 90       	pop	r8
    2a08:	7f 90       	pop	r7
    2a0a:	6f 90       	pop	r6
    2a0c:	5f 90       	pop	r5
    2a0e:	4f 90       	pop	r4
    2a10:	08 95       	ret
    2a12:	81 e0       	ldi	r24, 0x01	; 1
    2a14:	eb cf       	rjmp	.-42     	; 0x29ec <setMeasurementTimingBudget.part.4+0x1b6>
    2a16:	80 e0       	ldi	r24, 0x00	; 0
    2a18:	90 e0       	ldi	r25, 0x00	; 0
    2a1a:	21 e7       	ldi	r18, 0x71	; 113
    2a1c:	2c 8f       	std	Y+28, r18	; 0x1c
    2a1e:	9d 8f       	std	Y+29, r25	; 0x1d
    2a20:	8e 8f       	std	Y+30, r24	; 0x1e
    2a22:	43 e0       	ldi	r20, 0x03	; 3
    2a24:	be 01       	movw	r22, r28
    2a26:	64 5e       	subi	r22, 0xE4	; 228
    2a28:	7f 4f       	sbci	r23, 0xFF	; 255
    2a2a:	89 e2       	ldi	r24, 0x29	; 41
    2a2c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
    2a30:	c0 92 6a 2e 	sts	0x2E6A, r12	; 0x802e6a <measurement_timing_budget_us>
    2a34:	d0 92 6b 2e 	sts	0x2E6B, r13	; 0x802e6b <measurement_timing_budget_us+0x1>
    2a38:	e0 92 6c 2e 	sts	0x2E6C, r14	; 0x802e6c <measurement_timing_budget_us+0x2>
    2a3c:	f0 92 6d 2e 	sts	0x2E6D, r15	; 0x802e6d <measurement_timing_budget_us+0x3>
    2a40:	81 e0       	ldi	r24, 0x01	; 1
    2a42:	d4 cf       	rjmp	.-88     	; 0x29ec <setMeasurementTimingBudget.part.4+0x1b6>

00002a44 <DriverVL53L0XInit>:


uint8_t DriverVL53L0XInit(void)
{
    2a44:	2f 92       	push	r2
    2a46:	3f 92       	push	r3
    2a48:	4f 92       	push	r4
    2a4a:	5f 92       	push	r5
    2a4c:	6f 92       	push	r6
    2a4e:	7f 92       	push	r7
    2a50:	8f 92       	push	r8
    2a52:	9f 92       	push	r9
    2a54:	af 92       	push	r10
    2a56:	bf 92       	push	r11
    2a58:	cf 92       	push	r12
    2a5a:	df 92       	push	r13
    2a5c:	ef 92       	push	r14
    2a5e:	ff 92       	push	r15
    2a60:	0f 93       	push	r16
    2a62:	1f 93       	push	r17
    2a64:	cf 93       	push	r28
    2a66:	df 93       	push	r29
    2a68:	cd b7       	in	r28, 0x3d	; 61
    2a6a:	de b7       	in	r29, 0x3e	; 62
    2a6c:	a1 97       	sbiw	r28, 0x21	; 33
    2a6e:	cd bf       	out	0x3d, r28	; 61
    2a70:	de bf       	out	0x3e, r29	; 62
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2a72:	80 ec       	ldi	r24, 0xC0	; 192
    2a74:	89 83       	std	Y+1, r24	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2a76:	01 e0       	ldi	r16, 0x01	; 1
    2a78:	9e 01       	movw	r18, r28
    2a7a:	2f 5f       	subi	r18, 0xFF	; 255
    2a7c:	3f 4f       	sbci	r19, 0xFF	; 255
    2a7e:	41 e0       	ldi	r20, 0x01	; 1
    2a80:	b9 01       	movw	r22, r18
    2a82:	89 e2       	ldi	r24, 0x29	; 41
    2a84:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2a88:	99 81       	ldd	r25, Y+1	; 0x01
	uint8_t res;
	int a;
	
	//Check Model ID
	res=readReg(IDENTIFICATION_MODEL_ID,&Data);
	if (!res)
    2a8a:	88 23       	and	r24, r24
    2a8c:	09 f4       	brne	.+2      	; 0x2a90 <DriverVL53L0XInit+0x4c>
    2a8e:	ef c5       	rjmp	.+3038   	; 0x366e <DriverVL53L0XInit+0xc2a>
		#ifdef VL53L0X_DEBUG
			printf ("VL53L0X:Cannot access.\r\n");
		#endif
		return false;
	}
	if (Data != 0xEE)
    2a90:	9e 3e       	cpi	r25, 0xEE	; 238
    2a92:	d9 f0       	breq	.+54     	; 0x2aca <DriverVL53L0XInit+0x86>
	{
		#ifdef VL53L0X_DEBUG
			printf ("VL53L0X:Incorrect ID_MODEL_ID\r\n");
    2a94:	8b ec       	ldi	r24, 0xCB	; 203
    2a96:	93 e2       	ldi	r25, 0x23	; 35
    2a98:	0e 94 1b 51 	call	0xa236	; 0xa236 <puts>
		#endif
		return false;
    2a9c:	80 e0       	ldi	r24, 0x00	; 0
	writeReg(SYSTEM_SEQUENCE_CONFIG, 0xE8);

	// VL53L0X_PerformRefCalibration() end

	return true;
}
    2a9e:	a1 96       	adiw	r28, 0x21	; 33
    2aa0:	cd bf       	out	0x3d, r28	; 61
    2aa2:	de bf       	out	0x3e, r29	; 62
    2aa4:	df 91       	pop	r29
    2aa6:	cf 91       	pop	r28
    2aa8:	1f 91       	pop	r17
    2aaa:	0f 91       	pop	r16
    2aac:	ff 90       	pop	r15
    2aae:	ef 90       	pop	r14
    2ab0:	df 90       	pop	r13
    2ab2:	cf 90       	pop	r12
    2ab4:	bf 90       	pop	r11
    2ab6:	af 90       	pop	r10
    2ab8:	9f 90       	pop	r9
    2aba:	8f 90       	pop	r8
    2abc:	7f 90       	pop	r7
    2abe:	6f 90       	pop	r6
    2ac0:	5f 90       	pop	r5
    2ac2:	4f 90       	pop	r4
    2ac4:	3f 90       	pop	r3
    2ac6:	2f 90       	pop	r2
    2ac8:	08 95       	ret
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2aca:	88 e8       	ldi	r24, 0x88	; 136
    2acc:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2ace:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2ad0:	42 e0       	ldi	r20, 0x02	; 2
    2ad2:	be 01       	movw	r22, r28
    2ad4:	6f 5f       	subi	r22, 0xFF	; 255
    2ad6:	7f 4f       	sbci	r23, 0xFF	; 255
    2ad8:	89 e2       	ldi	r24, 0x29	; 41
    2ada:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2ade:	e0 e8       	ldi	r30, 0x80	; 128
    2ae0:	ee 2e       	mov	r14, r30
    2ae2:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2ae4:	11 e0       	ldi	r17, 0x01	; 1
    2ae6:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2ae8:	42 e0       	ldi	r20, 0x02	; 2
    2aea:	be 01       	movw	r22, r28
    2aec:	6f 5f       	subi	r22, 0xFF	; 255
    2aee:	7f 4f       	sbci	r23, 0xFF	; 255
    2af0:	89 e2       	ldi	r24, 0x29	; 41
    2af2:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2af6:	ff 24       	eor	r15, r15
    2af8:	fa 94       	dec	r15
    2afa:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    2afc:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2afe:	42 e0       	ldi	r20, 0x02	; 2
    2b00:	be 01       	movw	r22, r28
    2b02:	6f 5f       	subi	r22, 0xFF	; 255
    2b04:	7f 4f       	sbci	r23, 0xFF	; 255
    2b06:	89 e2       	ldi	r24, 0x29	; 41
    2b08:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2b0c:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    2b0e:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2b10:	42 e0       	ldi	r20, 0x02	; 2
    2b12:	be 01       	movw	r22, r28
    2b14:	6f 5f       	subi	r22, 0xFF	; 255
    2b16:	7f 4f       	sbci	r23, 0xFF	; 255
    2b18:	89 e2       	ldi	r24, 0x29	; 41
    2b1a:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2b1e:	81 e9       	ldi	r24, 0x91	; 145
    2b20:	89 83       	std	Y+1, r24	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2b22:	01 e0       	ldi	r16, 0x01	; 1
    2b24:	9e 01       	movw	r18, r28
    2b26:	2f 5f       	subi	r18, 0xFF	; 255
    2b28:	3f 4f       	sbci	r19, 0xFF	; 255
    2b2a:	41 e0       	ldi	r20, 0x01	; 1
    2b2c:	b9 01       	movw	r22, r18
    2b2e:	89 e2       	ldi	r24, 0x29	; 41
    2b30:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2b34:	89 81       	ldd	r24, Y+1	; 0x01
    2b36:	80 93 60 2d 	sts	0x2D60, r24	; 0x802d60 <stop_variable>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2b3a:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    2b3c:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2b3e:	42 e0       	ldi	r20, 0x02	; 2
    2b40:	be 01       	movw	r22, r28
    2b42:	6f 5f       	subi	r22, 0xFF	; 255
    2b44:	7f 4f       	sbci	r23, 0xFF	; 255
    2b46:	89 e2       	ldi	r24, 0x29	; 41
    2b48:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2b4c:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    2b4e:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2b50:	42 e0       	ldi	r20, 0x02	; 2
    2b52:	be 01       	movw	r22, r28
    2b54:	6f 5f       	subi	r22, 0xFF	; 255
    2b56:	7f 4f       	sbci	r23, 0xFF	; 255
    2b58:	89 e2       	ldi	r24, 0x29	; 41
    2b5a:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2b5e:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2b60:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2b62:	42 e0       	ldi	r20, 0x02	; 2
    2b64:	be 01       	movw	r22, r28
    2b66:	6f 5f       	subi	r22, 0xFF	; 255
    2b68:	7f 4f       	sbci	r23, 0xFF	; 255
    2b6a:	89 e2       	ldi	r24, 0x29	; 41
    2b6c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2b70:	f0 e6       	ldi	r31, 0x60	; 96
    2b72:	df 2e       	mov	r13, r31
    2b74:	d9 82       	std	Y+1, r13	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2b76:	9e 01       	movw	r18, r28
    2b78:	2f 5f       	subi	r18, 0xFF	; 255
    2b7a:	3f 4f       	sbci	r19, 0xFF	; 255
    2b7c:	41 e0       	ldi	r20, 0x01	; 1
    2b7e:	b9 01       	movw	r22, r18
    2b80:	89 e2       	ldi	r24, 0x29	; 41
    2b82:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2b86:	89 81       	ldd	r24, Y+1	; 0x01
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2b88:	d9 82       	std	Y+1, r13	; 0x01
	Buffer[1]=value;
    2b8a:	82 61       	ori	r24, 0x12	; 18
    2b8c:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2b8e:	42 e0       	ldi	r20, 0x02	; 2
    2b90:	be 01       	movw	r22, r28
    2b92:	6f 5f       	subi	r22, 0xFF	; 255
    2b94:	7f 4f       	sbci	r23, 0xFF	; 255
    2b96:	89 e2       	ldi	r24, 0x29	; 41
    2b98:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write a 16-bit register
uint8_t writeReg16Bit(uint8_t reg, uint16_t value)
{
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg,
    2b9c:	84 e4       	ldi	r24, 0x44	; 68
    2b9e:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value>>8;
    2ba0:	1a 82       	std	Y+2, r1	; 0x02
	Buffer[2]=value;
    2ba2:	80 e2       	ldi	r24, 0x20	; 32
    2ba4:	8b 83       	std	Y+3, r24	; 0x03
	res=TWIMWrite(VL53L0X_ADDR,Buffer,3);
    2ba6:	43 e0       	ldi	r20, 0x03	; 3
    2ba8:	be 01       	movw	r22, r28
    2baa:	6f 5f       	subi	r22, 0xFF	; 255
    2bac:	7f 4f       	sbci	r23, 0xFF	; 255
    2bae:	89 e2       	ldi	r24, 0x29	; 41
    2bb0:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2bb4:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2bb6:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2bb8:	42 e0       	ldi	r20, 0x02	; 2
    2bba:	be 01       	movw	r22, r28
    2bbc:	6f 5f       	subi	r22, 0xFF	; 255
    2bbe:	7f 4f       	sbci	r23, 0xFF	; 255
    2bc0:	89 e2       	ldi	r24, 0x29	; 41
    2bc2:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2bc6:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2bc8:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2bca:	42 e0       	ldi	r20, 0x02	; 2
    2bcc:	be 01       	movw	r22, r28
    2bce:	6f 5f       	subi	r22, 0xFF	; 255
    2bd0:	7f 4f       	sbci	r23, 0xFF	; 255
    2bd2:	89 e2       	ldi	r24, 0x29	; 41
    2bd4:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2bd8:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    2bda:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2bdc:	42 e0       	ldi	r20, 0x02	; 2
    2bde:	be 01       	movw	r22, r28
    2be0:	6f 5f       	subi	r22, 0xFF	; 255
    2be2:	7f 4f       	sbci	r23, 0xFF	; 255
    2be4:	89 e2       	ldi	r24, 0x29	; 41
    2be6:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2bea:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    2bec:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2bee:	42 e0       	ldi	r20, 0x02	; 2
    2bf0:	be 01       	movw	r22, r28
    2bf2:	6f 5f       	subi	r22, 0xFF	; 255
    2bf4:	7f 4f       	sbci	r23, 0xFF	; 255
    2bf6:	89 e2       	ldi	r24, 0x29	; 41
    2bf8:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2bfc:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    2bfe:	86 e0       	ldi	r24, 0x06	; 6
    2c00:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2c02:	42 e0       	ldi	r20, 0x02	; 2
    2c04:	be 01       	movw	r22, r28
    2c06:	6f 5f       	subi	r22, 0xFF	; 255
    2c08:	7f 4f       	sbci	r23, 0xFF	; 255
    2c0a:	89 e2       	ldi	r24, 0x29	; 41
    2c0c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2c10:	a3 e8       	ldi	r26, 0x83	; 131
    2c12:	da 2e       	mov	r13, r26
    2c14:	d9 82       	std	Y+1, r13	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2c16:	9e 01       	movw	r18, r28
    2c18:	2f 5f       	subi	r18, 0xFF	; 255
    2c1a:	3f 4f       	sbci	r19, 0xFF	; 255
    2c1c:	41 e0       	ldi	r20, 0x01	; 1
    2c1e:	b9 01       	movw	r22, r18
    2c20:	89 e2       	ldi	r24, 0x29	; 41
    2c22:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2c26:	89 81       	ldd	r24, Y+1	; 0x01
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2c28:	d9 82       	std	Y+1, r13	; 0x01
	Buffer[1]=value;
    2c2a:	84 60       	ori	r24, 0x04	; 4
    2c2c:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2c2e:	42 e0       	ldi	r20, 0x02	; 2
    2c30:	be 01       	movw	r22, r28
    2c32:	6f 5f       	subi	r22, 0xFF	; 255
    2c34:	7f 4f       	sbci	r23, 0xFF	; 255
    2c36:	89 e2       	ldi	r24, 0x29	; 41
    2c38:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2c3c:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    2c3e:	87 e0       	ldi	r24, 0x07	; 7
    2c40:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2c42:	42 e0       	ldi	r20, 0x02	; 2
    2c44:	be 01       	movw	r22, r28
    2c46:	6f 5f       	subi	r22, 0xFF	; 255
    2c48:	7f 4f       	sbci	r23, 0xFF	; 255
    2c4a:	89 e2       	ldi	r24, 0x29	; 41
    2c4c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2c50:	81 e8       	ldi	r24, 0x81	; 129
    2c52:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2c54:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2c56:	42 e0       	ldi	r20, 0x02	; 2
    2c58:	be 01       	movw	r22, r28
    2c5a:	6f 5f       	subi	r22, 0xFF	; 255
    2c5c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c5e:	89 e2       	ldi	r24, 0x29	; 41
    2c60:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2c64:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2c66:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2c68:	42 e0       	ldi	r20, 0x02	; 2
    2c6a:	be 01       	movw	r22, r28
    2c6c:	6f 5f       	subi	r22, 0xFF	; 255
    2c6e:	7f 4f       	sbci	r23, 0xFF	; 255
    2c70:	89 e2       	ldi	r24, 0x29	; 41
    2c72:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2c76:	84 e9       	ldi	r24, 0x94	; 148
    2c78:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2c7a:	8b e6       	ldi	r24, 0x6B	; 107
    2c7c:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2c7e:	42 e0       	ldi	r20, 0x02	; 2
    2c80:	be 01       	movw	r22, r28
    2c82:	6f 5f       	subi	r22, 0xFF	; 255
    2c84:	7f 4f       	sbci	r23, 0xFF	; 255
    2c86:	89 e2       	ldi	r24, 0x29	; 41
    2c88:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2c8c:	d9 82       	std	Y+1, r13	; 0x01
	Buffer[1]=value;
    2c8e:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2c90:	42 e0       	ldi	r20, 0x02	; 2
    2c92:	be 01       	movw	r22, r28
    2c94:	6f 5f       	subi	r22, 0xFF	; 255
    2c96:	7f 4f       	sbci	r23, 0xFF	; 255
    2c98:	89 e2       	ldi	r24, 0x29	; 41
    2c9a:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
	return true;
}

static void startTimeout(void)
{
	timeout_start_ticks=portGET_RUN_TIME_COUNTER_VALUE();
    2c9e:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2ca2:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2ca6:	80 91 6e 2e 	lds	r24, 0x2E6E	; 0x802e6e <StatsTimer>
    2caa:	90 91 6f 2e 	lds	r25, 0x2E6F	; 0x802e6f <StatsTimer+0x1>
    2cae:	a0 91 70 2e 	lds	r26, 0x2E70	; 0x802e70 <StatsTimer+0x2>
    2cb2:	b0 91 71 2e 	lds	r27, 0x2E71	; 0x802e71 <StatsTimer+0x3>
    2cb6:	82 0f       	add	r24, r18
    2cb8:	93 1f       	adc	r25, r19
    2cba:	a1 1d       	adc	r26, r1
    2cbc:	b1 1d       	adc	r27, r1
    2cbe:	80 93 5c 2d 	sts	0x2D5C, r24	; 0x802d5c <timeout_start_ticks>
    2cc2:	90 93 5d 2d 	sts	0x2D5D, r25	; 0x802d5d <timeout_start_ticks+0x1>
    2cc6:	a0 93 5e 2d 	sts	0x2D5E, r26	; 0x802d5e <timeout_start_ticks+0x2>
    2cca:	b0 93 5f 2d 	sts	0x2D5F, r27	; 0x802d5f <timeout_start_ticks+0x3>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2cce:	b3 e8       	ldi	r27, 0x83	; 131
    2cd0:	fb 2e       	mov	r15, r27
    2cd2:	13 e8       	ldi	r17, 0x83	; 131
    2cd4:	f9 82       	std	Y+1, r15	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2cd6:	01 e0       	ldi	r16, 0x01	; 1
    2cd8:	9e 01       	movw	r18, r28
    2cda:	2f 5f       	subi	r18, 0xFF	; 255
    2cdc:	3f 4f       	sbci	r19, 0xFF	; 255
    2cde:	41 e0       	ldi	r20, 0x01	; 1
    2ce0:	b9 01       	movw	r22, r18
    2ce2:	89 e2       	ldi	r24, 0x29	; 41
    2ce4:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2ce8:	89 81       	ldd	r24, Y+1	; 0x01
	startTimeout();
	
	while (1)
	{
		readReg(0x83,&Data);
		if (Data!=0x00) break;
    2cea:	88 23       	and	r24, r24
    2cec:	91 f3       	breq	.-28     	; 0x2cd2 <DriverVL53L0XInit+0x28e>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2cee:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2cf0:	dd 24       	eor	r13, r13
    2cf2:	d3 94       	inc	r13
    2cf4:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2cf6:	42 e0       	ldi	r20, 0x02	; 2
    2cf8:	be 01       	movw	r22, r28
    2cfa:	6f 5f       	subi	r22, 0xFF	; 255
    2cfc:	7f 4f       	sbci	r23, 0xFF	; 255
    2cfe:	89 e2       	ldi	r24, 0x29	; 41
    2d00:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2d04:	82 e9       	ldi	r24, 0x92	; 146
    2d06:	89 83       	std	Y+1, r24	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2d08:	9e 01       	movw	r18, r28
    2d0a:	2f 5f       	subi	r18, 0xFF	; 255
    2d0c:	3f 4f       	sbci	r19, 0xFF	; 255
    2d0e:	41 e0       	ldi	r20, 0x01	; 1
    2d10:	b9 01       	movw	r22, r18
    2d12:	89 e2       	ldi	r24, 0x29	; 41
    2d14:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2d18:	f9 80       	ldd	r15, Y+1	; 0x01
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d1a:	81 e8       	ldi	r24, 0x81	; 129
    2d1c:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2d1e:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d20:	42 e0       	ldi	r20, 0x02	; 2
    2d22:	be 01       	movw	r22, r28
    2d24:	6f 5f       	subi	r22, 0xFF	; 255
    2d26:	7f 4f       	sbci	r23, 0xFF	; 255
    2d28:	89 e2       	ldi	r24, 0x29	; 41
    2d2a:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d2e:	ee 24       	eor	r14, r14
    2d30:	ea 94       	dec	r14
    2d32:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2d34:	86 e0       	ldi	r24, 0x06	; 6
    2d36:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d38:	42 e0       	ldi	r20, 0x02	; 2
    2d3a:	be 01       	movw	r22, r28
    2d3c:	6f 5f       	subi	r22, 0xFF	; 255
    2d3e:	7f 4f       	sbci	r23, 0xFF	; 255
    2d40:	89 e2       	ldi	r24, 0x29	; 41
    2d42:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2d46:	19 83       	std	Y+1, r17	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2d48:	9e 01       	movw	r18, r28
    2d4a:	2f 5f       	subi	r18, 0xFF	; 255
    2d4c:	3f 4f       	sbci	r19, 0xFF	; 255
    2d4e:	41 e0       	ldi	r20, 0x01	; 1
    2d50:	b9 01       	movw	r22, r18
    2d52:	89 e2       	ldi	r24, 0x29	; 41
    2d54:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2d58:	89 81       	ldd	r24, Y+1	; 0x01
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d5a:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2d5c:	8b 7f       	andi	r24, 0xFB	; 251
    2d5e:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d60:	42 e0       	ldi	r20, 0x02	; 2
    2d62:	be 01       	movw	r22, r28
    2d64:	6f 5f       	subi	r22, 0xFF	; 255
    2d66:	7f 4f       	sbci	r23, 0xFF	; 255
    2d68:	89 e2       	ldi	r24, 0x29	; 41
    2d6a:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d6e:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2d70:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d72:	42 e0       	ldi	r20, 0x02	; 2
    2d74:	be 01       	movw	r22, r28
    2d76:	6f 5f       	subi	r22, 0xFF	; 255
    2d78:	7f 4f       	sbci	r23, 0xFF	; 255
    2d7a:	89 e2       	ldi	r24, 0x29	; 41
    2d7c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d80:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    2d82:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d84:	42 e0       	ldi	r20, 0x02	; 2
    2d86:	be 01       	movw	r22, r28
    2d88:	6f 5f       	subi	r22, 0xFF	; 255
    2d8a:	7f 4f       	sbci	r23, 0xFF	; 255
    2d8c:	89 e2       	ldi	r24, 0x29	; 41
    2d8e:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d92:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2d94:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d96:	42 e0       	ldi	r20, 0x02	; 2
    2d98:	be 01       	movw	r22, r28
    2d9a:	6f 5f       	subi	r22, 0xFF	; 255
    2d9c:	7f 4f       	sbci	r23, 0xFF	; 255
    2d9e:	89 e2       	ldi	r24, 0x29	; 41
    2da0:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2da4:	80 e8       	ldi	r24, 0x80	; 128
    2da6:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2da8:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2daa:	42 e0       	ldi	r20, 0x02	; 2
    2dac:	be 01       	movw	r22, r28
    2dae:	6f 5f       	subi	r22, 0xFF	; 255
    2db0:	7f 4f       	sbci	r23, 0xFF	; 255
    2db2:	89 e2       	ldi	r24, 0x29	; 41
    2db4:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// register, into the given array
uint8_t readMulti(uint8_t reg, uint8_t * dst, uint8_t count)
{
	uint8_t res;
	uint8_t Buffer[1];
	Buffer[0]=reg;
    2db8:	80 eb       	ldi	r24, 0xB0	; 176
    2dba:	89 83       	std	Y+1, r24	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,dst,count);
    2dbc:	06 e0       	ldi	r16, 0x06	; 6
    2dbe:	9e 01       	movw	r18, r28
    2dc0:	29 5e       	subi	r18, 0xE9	; 233
    2dc2:	3f 4f       	sbci	r19, 0xFF	; 255
    2dc4:	41 e0       	ldi	r20, 0x01	; 1
    2dc6:	be 01       	movw	r22, r28
    2dc8:	6f 5f       	subi	r22, 0xFF	; 255
    2dca:	7f 4f       	sbci	r23, 0xFF	; 255
    2dcc:	89 e2       	ldi	r24, 0x29	; 41
    2dce:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2dd2:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2dd4:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2dd6:	42 e0       	ldi	r20, 0x02	; 2
    2dd8:	be 01       	movw	r22, r28
    2dda:	6f 5f       	subi	r22, 0xFF	; 255
    2ddc:	7f 4f       	sbci	r23, 0xFF	; 255
    2dde:	89 e2       	ldi	r24, 0x29	; 41
    2de0:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2de4:	8f e4       	ldi	r24, 0x4F	; 79
    2de6:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2de8:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2dea:	42 e0       	ldi	r20, 0x02	; 2
    2dec:	be 01       	movw	r22, r28
    2dee:	6f 5f       	subi	r22, 0xFF	; 255
    2df0:	7f 4f       	sbci	r23, 0xFF	; 255
    2df2:	89 e2       	ldi	r24, 0x29	; 41
    2df4:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2df8:	8e e4       	ldi	r24, 0x4E	; 78
    2dfa:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2dfc:	8c e2       	ldi	r24, 0x2C	; 44
    2dfe:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2e00:	42 e0       	ldi	r20, 0x02	; 2
    2e02:	be 01       	movw	r22, r28
    2e04:	6f 5f       	subi	r22, 0xFF	; 255
    2e06:	7f 4f       	sbci	r23, 0xFF	; 255
    2e08:	89 e2       	ldi	r24, 0x29	; 41
    2e0a:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2e0e:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2e10:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2e12:	42 e0       	ldi	r20, 0x02	; 2
    2e14:	be 01       	movw	r22, r28
    2e16:	6f 5f       	subi	r22, 0xFF	; 255
    2e18:	7f 4f       	sbci	r23, 0xFF	; 255
    2e1a:	89 e2       	ldi	r24, 0x29	; 41
    2e1c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2e20:	86 eb       	ldi	r24, 0xB6	; 182
    2e22:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2e24:	84 eb       	ldi	r24, 0xB4	; 180
    2e26:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2e28:	42 e0       	ldi	r20, 0x02	; 2
    2e2a:	be 01       	movw	r22, r28
    2e2c:	6f 5f       	subi	r22, 0xFF	; 255
    2e2e:	7f 4f       	sbci	r23, 0xFF	; 255
    2e30:	89 e2       	ldi	r24, 0x29	; 41
    2e32:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
	writeReg(DYNAMIC_SPAD_REF_EN_START_OFFSET, 0x00);
	writeReg(DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);
	writeReg(0xFF, 0x00);
	writeReg(GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);

	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
    2e36:	f7 fc       	sbrc	r15, 7
    2e38:	20 c4       	rjmp	.+2112   	; 0x367a <DriverVL53L0XInit+0xc36>
    2e3a:	40 e0       	ldi	r20, 0x00	; 0
	uint8_t spads_enabled = 0;

	for (uint8_t i = 0; i < 48; i++)
    2e3c:	00 e0       	ldi	r16, 0x00	; 0
	writeReg(DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);
	writeReg(0xFF, 0x00);
	writeReg(GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);

	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
	uint8_t spads_enabled = 0;
    2e3e:	50 e0       	ldi	r21, 0x00	; 0
	{
		if (i < first_spad_to_enable || spads_enabled == spad_count)
		{
			// This bit is lower than the first one that should be enabled, or
			// (reference_spad_count) bits have already been enabled, so zero this bit
			ref_spad_map[i / 8] &= ~(1 << (i % 8));
    2e40:	21 e0       	ldi	r18, 0x01	; 1
    2e42:	30 e0       	ldi	r19, 0x00	; 0
	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
	uint8_t spads_enabled = 0;

	for (uint8_t i = 0; i < 48; i++)
	{
		if (i < first_spad_to_enable || spads_enabled == spad_count)
    2e44:	7f 2d       	mov	r23, r15
    2e46:	7f 77       	andi	r23, 0x7F	; 127
    2e48:	10 c0       	rjmp	.+32     	; 0x2e6a <DriverVL53L0XInit+0x426>
    2e4a:	57 17       	cp	r21, r23
    2e4c:	d1 f0       	breq	.+52     	; 0x2e82 <DriverVL53L0XInit+0x43e>
		{
			// This bit is lower than the first one that should be enabled, or
			// (reference_spad_count) bits have already been enabled, so zero this bit
			ref_spad_map[i / 8] &= ~(1 << (i % 8));
		}
		else if ((ref_spad_map[i / 8] >> (i % 8)) & 0x1)
    2e4e:	80 81       	ld	r24, Z
    2e50:	90 e0       	ldi	r25, 0x00	; 0
    2e52:	60 2f       	mov	r22, r16
    2e54:	67 70       	andi	r22, 0x07	; 7
    2e56:	02 c0       	rjmp	.+4      	; 0x2e5c <DriverVL53L0XInit+0x418>
    2e58:	95 95       	asr	r25
    2e5a:	87 95       	ror	r24
    2e5c:	6a 95       	dec	r22
    2e5e:	e2 f7       	brpl	.-8      	; 0x2e58 <DriverVL53L0XInit+0x414>
    2e60:	80 fd       	sbrc	r24, 0
		{
			spads_enabled++;
    2e62:	5f 5f       	subi	r21, 0xFF	; 255
	writeReg(GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);

	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
	uint8_t spads_enabled = 0;

	for (uint8_t i = 0; i < 48; i++)
    2e64:	0f 5f       	subi	r16, 0xFF	; 255
    2e66:	00 33       	cpi	r16, 0x30	; 48
    2e68:	e1 f0       	breq	.+56     	; 0x2ea2 <DriverVL53L0XInit+0x45e>
	{
		if (i < first_spad_to_enable || spads_enabled == spad_count)
		{
			// This bit is lower than the first one that should be enabled, or
			// (reference_spad_count) bits have already been enabled, so zero this bit
			ref_spad_map[i / 8] &= ~(1 << (i % 8));
    2e6a:	80 2f       	mov	r24, r16
    2e6c:	86 95       	lsr	r24
    2e6e:	86 95       	lsr	r24
    2e70:	86 95       	lsr	r24
    2e72:	e7 e1       	ldi	r30, 0x17	; 23
    2e74:	f0 e0       	ldi	r31, 0x00	; 0
    2e76:	ec 0f       	add	r30, r28
    2e78:	fd 1f       	adc	r31, r29
    2e7a:	e8 0f       	add	r30, r24
    2e7c:	f1 1d       	adc	r31, r1
	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
	uint8_t spads_enabled = 0;

	for (uint8_t i = 0; i < 48; i++)
	{
		if (i < first_spad_to_enable || spads_enabled == spad_count)
    2e7e:	04 17       	cp	r16, r20
    2e80:	20 f7       	brcc	.-56     	; 0x2e4a <DriverVL53L0XInit+0x406>
		{
			// This bit is lower than the first one that should be enabled, or
			// (reference_spad_count) bits have already been enabled, so zero this bit
			ref_spad_map[i / 8] &= ~(1 << (i % 8));
    2e82:	80 2f       	mov	r24, r16
    2e84:	87 70       	andi	r24, 0x07	; 7
    2e86:	d9 01       	movw	r26, r18
    2e88:	02 c0       	rjmp	.+4      	; 0x2e8e <DriverVL53L0XInit+0x44a>
    2e8a:	aa 0f       	add	r26, r26
    2e8c:	bb 1f       	adc	r27, r27
    2e8e:	8a 95       	dec	r24
    2e90:	e2 f7       	brpl	.-8      	; 0x2e8a <DriverVL53L0XInit+0x446>
    2e92:	cd 01       	movw	r24, r26
    2e94:	80 95       	com	r24
    2e96:	90 81       	ld	r25, Z
    2e98:	89 23       	and	r24, r25
    2e9a:	80 83       	st	Z, r24
	writeReg(GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);

	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
	uint8_t spads_enabled = 0;

	for (uint8_t i = 0; i < 48; i++)
    2e9c:	0f 5f       	subi	r16, 0xFF	; 255
    2e9e:	00 33       	cpi	r16, 0x30	; 48
    2ea0:	21 f7       	brne	.-56     	; 0x2e6a <DriverVL53L0XInit+0x426>
	uint8_t res;
	uint8_t Buffer[16];
	
	if (count>15) return -2;
	
	Buffer[0]=reg;
    2ea2:	80 eb       	ldi	r24, 0xB0	; 176
    2ea4:	89 83       	std	Y+1, r24	; 0x01
	memcpy(&Buffer[1],src,count);
    2ea6:	86 e0       	ldi	r24, 0x06	; 6
    2ea8:	fe 01       	movw	r30, r28
    2eaa:	77 96       	adiw	r30, 0x17	; 23
    2eac:	de 01       	movw	r26, r28
    2eae:	12 96       	adiw	r26, 0x02	; 2
    2eb0:	01 90       	ld	r0, Z+
    2eb2:	0d 92       	st	X+, r0
    2eb4:	8a 95       	dec	r24
    2eb6:	e1 f7       	brne	.-8      	; 0x2eb0 <DriverVL53L0XInit+0x46c>
	
	res=TWIMWrite(VL53L0X_ADDR,Buffer,count+1);
    2eb8:	47 e0       	ldi	r20, 0x07	; 7
    2eba:	be 01       	movw	r22, r28
    2ebc:	6f 5f       	subi	r22, 0xFF	; 255
    2ebe:	7f 4f       	sbci	r23, 0xFF	; 255
    2ec0:	89 e2       	ldi	r24, 0x29	; 41
    2ec2:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2ec6:	1f ef       	ldi	r17, 0xFF	; 255
    2ec8:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2eca:	ff 24       	eor	r15, r15
    2ecc:	f3 94       	inc	r15
    2ece:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2ed0:	42 e0       	ldi	r20, 0x02	; 2
    2ed2:	be 01       	movw	r22, r28
    2ed4:	6f 5f       	subi	r22, 0xFF	; 255
    2ed6:	7f 4f       	sbci	r23, 0xFF	; 255
    2ed8:	89 e2       	ldi	r24, 0x29	; 41
    2eda:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2ede:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    2ee0:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2ee2:	42 e0       	ldi	r20, 0x02	; 2
    2ee4:	be 01       	movw	r22, r28
    2ee6:	6f 5f       	subi	r22, 0xFF	; 255
    2ee8:	7f 4f       	sbci	r23, 0xFF	; 255
    2eea:	89 e2       	ldi	r24, 0x29	; 41
    2eec:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2ef0:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2ef2:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2ef4:	42 e0       	ldi	r20, 0x02	; 2
    2ef6:	be 01       	movw	r22, r28
    2ef8:	6f 5f       	subi	r22, 0xFF	; 255
    2efa:	7f 4f       	sbci	r23, 0xFF	; 255
    2efc:	89 e2       	ldi	r24, 0x29	; 41
    2efe:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f02:	39 e0       	ldi	r19, 0x09	; 9
    2f04:	b3 2e       	mov	r11, r19
    2f06:	b9 82       	std	Y+1, r11	; 0x01
	Buffer[1]=value;
    2f08:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f0a:	42 e0       	ldi	r20, 0x02	; 2
    2f0c:	be 01       	movw	r22, r28
    2f0e:	6f 5f       	subi	r22, 0xFF	; 255
    2f10:	7f 4f       	sbci	r23, 0xFF	; 255
    2f12:	89 e2       	ldi	r24, 0x29	; 41
    2f14:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f18:	80 e1       	ldi	r24, 0x10	; 16
    2f1a:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2f1c:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f1e:	42 e0       	ldi	r20, 0x02	; 2
    2f20:	be 01       	movw	r22, r28
    2f22:	6f 5f       	subi	r22, 0xFF	; 255
    2f24:	7f 4f       	sbci	r23, 0xFF	; 255
    2f26:	89 e2       	ldi	r24, 0x29	; 41
    2f28:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f2c:	81 e1       	ldi	r24, 0x11	; 17
    2f2e:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2f30:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f32:	42 e0       	ldi	r20, 0x02	; 2
    2f34:	be 01       	movw	r22, r28
    2f36:	6f 5f       	subi	r22, 0xFF	; 255
    2f38:	7f 4f       	sbci	r23, 0xFF	; 255
    2f3a:	89 e2       	ldi	r24, 0x29	; 41
    2f3c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f40:	84 e2       	ldi	r24, 0x24	; 36
    2f42:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2f44:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f46:	42 e0       	ldi	r20, 0x02	; 2
    2f48:	be 01       	movw	r22, r28
    2f4a:	6f 5f       	subi	r22, 0xFF	; 255
    2f4c:	7f 4f       	sbci	r23, 0xFF	; 255
    2f4e:	89 e2       	ldi	r24, 0x29	; 41
    2f50:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f54:	45 e2       	ldi	r20, 0x25	; 37
    2f56:	94 2e       	mov	r9, r20
    2f58:	99 82       	std	Y+1, r9	; 0x01
	Buffer[1]=value;
    2f5a:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f5c:	42 e0       	ldi	r20, 0x02	; 2
    2f5e:	be 01       	movw	r22, r28
    2f60:	6f 5f       	subi	r22, 0xFF	; 255
    2f62:	7f 4f       	sbci	r23, 0xFF	; 255
    2f64:	89 e2       	ldi	r24, 0x29	; 41
    2f66:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f6a:	85 e7       	ldi	r24, 0x75	; 117
    2f6c:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2f6e:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f70:	42 e0       	ldi	r20, 0x02	; 2
    2f72:	be 01       	movw	r22, r28
    2f74:	6f 5f       	subi	r22, 0xFF	; 255
    2f76:	7f 4f       	sbci	r23, 0xFF	; 255
    2f78:	89 e2       	ldi	r24, 0x29	; 41
    2f7a:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f7e:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2f80:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f82:	42 e0       	ldi	r20, 0x02	; 2
    2f84:	be 01       	movw	r22, r28
    2f86:	6f 5f       	subi	r22, 0xFF	; 255
    2f88:	7f 4f       	sbci	r23, 0xFF	; 255
    2f8a:	89 e2       	ldi	r24, 0x29	; 41
    2f8c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f90:	8e e4       	ldi	r24, 0x4E	; 78
    2f92:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2f94:	8c e2       	ldi	r24, 0x2C	; 44
    2f96:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f98:	42 e0       	ldi	r20, 0x02	; 2
    2f9a:	be 01       	movw	r22, r28
    2f9c:	6f 5f       	subi	r22, 0xFF	; 255
    2f9e:	7f 4f       	sbci	r23, 0xFF	; 255
    2fa0:	89 e2       	ldi	r24, 0x29	; 41
    2fa2:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2fa6:	58 e4       	ldi	r21, 0x48	; 72
    2fa8:	a5 2e       	mov	r10, r21
    2faa:	a9 82       	std	Y+1, r10	; 0x01
	Buffer[1]=value;
    2fac:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2fae:	42 e0       	ldi	r20, 0x02	; 2
    2fb0:	be 01       	movw	r22, r28
    2fb2:	6f 5f       	subi	r22, 0xFF	; 255
    2fb4:	7f 4f       	sbci	r23, 0xFF	; 255
    2fb6:	89 e2       	ldi	r24, 0x29	; 41
    2fb8:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2fbc:	09 83       	std	Y+1, r16	; 0x01
	Buffer[1]=value;
    2fbe:	60 e2       	ldi	r22, 0x20	; 32
    2fc0:	d6 2e       	mov	r13, r22
    2fc2:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2fc4:	42 e0       	ldi	r20, 0x02	; 2
    2fc6:	be 01       	movw	r22, r28
    2fc8:	6f 5f       	subi	r22, 0xFF	; 255
    2fca:	7f 4f       	sbci	r23, 0xFF	; 255
    2fcc:	89 e2       	ldi	r24, 0x29	; 41
    2fce:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2fd2:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2fd4:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2fd6:	42 e0       	ldi	r20, 0x02	; 2
    2fd8:	be 01       	movw	r22, r28
    2fda:	6f 5f       	subi	r22, 0xFF	; 255
    2fdc:	7f 4f       	sbci	r23, 0xFF	; 255
    2fde:	89 e2       	ldi	r24, 0x29	; 41
    2fe0:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2fe4:	09 83       	std	Y+1, r16	; 0x01
	Buffer[1]=value;
    2fe6:	ba 82       	std	Y+2, r11	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2fe8:	42 e0       	ldi	r20, 0x02	; 2
    2fea:	be 01       	movw	r22, r28
    2fec:	6f 5f       	subi	r22, 0xFF	; 255
    2fee:	7f 4f       	sbci	r23, 0xFF	; 255
    2ff0:	89 e2       	ldi	r24, 0x29	; 41
    2ff2:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2ff6:	84 e5       	ldi	r24, 0x54	; 84
    2ff8:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2ffa:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2ffc:	42 e0       	ldi	r20, 0x02	; 2
    2ffe:	be 01       	movw	r22, r28
    3000:	6f 5f       	subi	r22, 0xFF	; 255
    3002:	7f 4f       	sbci	r23, 0xFF	; 255
    3004:	89 e2       	ldi	r24, 0x29	; 41
    3006:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    300a:	71 e3       	ldi	r23, 0x31	; 49
    300c:	57 2e       	mov	r5, r23
    300e:	59 82       	std	Y+1, r5	; 0x01
	Buffer[1]=value;
    3010:	b4 e0       	ldi	r27, 0x04	; 4
    3012:	ba 83       	std	Y+2, r27	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3014:	42 e0       	ldi	r20, 0x02	; 2
    3016:	be 01       	movw	r22, r28
    3018:	6f 5f       	subi	r22, 0xFF	; 255
    301a:	7f 4f       	sbci	r23, 0xFF	; 255
    301c:	89 e2       	ldi	r24, 0x29	; 41
    301e:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3022:	e2 e3       	ldi	r30, 0x32	; 50
    3024:	8e 2e       	mov	r8, r30
    3026:	89 82       	std	Y+1, r8	; 0x01
	Buffer[1]=value;
    3028:	f3 e0       	ldi	r31, 0x03	; 3
    302a:	4f 2e       	mov	r4, r31
    302c:	4a 82       	std	Y+2, r4	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    302e:	42 e0       	ldi	r20, 0x02	; 2
    3030:	be 01       	movw	r22, r28
    3032:	6f 5f       	subi	r22, 0xFF	; 255
    3034:	7f 4f       	sbci	r23, 0xFF	; 255
    3036:	89 e2       	ldi	r24, 0x29	; 41
    3038:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    303c:	a0 e4       	ldi	r26, 0x40	; 64
    303e:	ea 2e       	mov	r14, r26
    3040:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    3042:	83 e8       	ldi	r24, 0x83	; 131
    3044:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3046:	42 e0       	ldi	r20, 0x02	; 2
    3048:	be 01       	movw	r22, r28
    304a:	6f 5f       	subi	r22, 0xFF	; 255
    304c:	7f 4f       	sbci	r23, 0xFF	; 255
    304e:	89 e2       	ldi	r24, 0x29	; 41
    3050:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3054:	b6 e4       	ldi	r27, 0x46	; 70
    3056:	6b 2e       	mov	r6, r27
    3058:	69 82       	std	Y+1, r6	; 0x01
	Buffer[1]=value;
    305a:	9a 82       	std	Y+2, r9	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    305c:	42 e0       	ldi	r20, 0x02	; 2
    305e:	be 01       	movw	r22, r28
    3060:	6f 5f       	subi	r22, 0xFF	; 255
    3062:	7f 4f       	sbci	r23, 0xFF	; 255
    3064:	89 e2       	ldi	r24, 0x29	; 41
    3066:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    306a:	80 e6       	ldi	r24, 0x60	; 96
    306c:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    306e:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3070:	42 e0       	ldi	r20, 0x02	; 2
    3072:	be 01       	movw	r22, r28
    3074:	6f 5f       	subi	r22, 0xFF	; 255
    3076:	7f 4f       	sbci	r23, 0xFF	; 255
    3078:	89 e2       	ldi	r24, 0x29	; 41
    307a:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    307e:	87 e2       	ldi	r24, 0x27	; 39
    3080:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3082:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3084:	42 e0       	ldi	r20, 0x02	; 2
    3086:	be 01       	movw	r22, r28
    3088:	6f 5f       	subi	r22, 0xFF	; 255
    308a:	7f 4f       	sbci	r23, 0xFF	; 255
    308c:	89 e2       	ldi	r24, 0x29	; 41
    308e:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3092:	80 e5       	ldi	r24, 0x50	; 80
    3094:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3096:	86 e0       	ldi	r24, 0x06	; 6
    3098:	28 2e       	mov	r2, r24
    309a:	2a 82       	std	Y+2, r2	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    309c:	42 e0       	ldi	r20, 0x02	; 2
    309e:	be 01       	movw	r22, r28
    30a0:	6f 5f       	subi	r22, 0xFF	; 255
    30a2:	7f 4f       	sbci	r23, 0xFF	; 255
    30a4:	89 e2       	ldi	r24, 0x29	; 41
    30a6:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    30aa:	81 e5       	ldi	r24, 0x51	; 81
    30ac:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    30ae:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    30b0:	42 e0       	ldi	r20, 0x02	; 2
    30b2:	be 01       	movw	r22, r28
    30b4:	6f 5f       	subi	r22, 0xFF	; 255
    30b6:	7f 4f       	sbci	r23, 0xFF	; 255
    30b8:	89 e2       	ldi	r24, 0x29	; 41
    30ba:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    30be:	82 e5       	ldi	r24, 0x52	; 82
    30c0:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    30c2:	86 e9       	ldi	r24, 0x96	; 150
    30c4:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    30c6:	42 e0       	ldi	r20, 0x02	; 2
    30c8:	be 01       	movw	r22, r28
    30ca:	6f 5f       	subi	r22, 0xFF	; 255
    30cc:	7f 4f       	sbci	r23, 0xFF	; 255
    30ce:	89 e2       	ldi	r24, 0x29	; 41
    30d0:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    30d4:	86 e5       	ldi	r24, 0x56	; 86
    30d6:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    30d8:	98 e0       	ldi	r25, 0x08	; 8
    30da:	99 2e       	mov	r9, r25
    30dc:	9a 82       	std	Y+2, r9	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    30de:	42 e0       	ldi	r20, 0x02	; 2
    30e0:	be 01       	movw	r22, r28
    30e2:	6f 5f       	subi	r22, 0xFF	; 255
    30e4:	7f 4f       	sbci	r23, 0xFF	; 255
    30e6:	89 e2       	ldi	r24, 0x29	; 41
    30e8:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    30ec:	87 e5       	ldi	r24, 0x57	; 87
    30ee:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    30f0:	0a 83       	std	Y+2, r16	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    30f2:	42 e0       	ldi	r20, 0x02	; 2
    30f4:	be 01       	movw	r22, r28
    30f6:	6f 5f       	subi	r22, 0xFF	; 255
    30f8:	7f 4f       	sbci	r23, 0xFF	; 255
    30fa:	89 e2       	ldi	r24, 0x29	; 41
    30fc:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3100:	81 e6       	ldi	r24, 0x61	; 97
    3102:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3104:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3106:	42 e0       	ldi	r20, 0x02	; 2
    3108:	be 01       	movw	r22, r28
    310a:	6f 5f       	subi	r22, 0xFF	; 255
    310c:	7f 4f       	sbci	r23, 0xFF	; 255
    310e:	89 e2       	ldi	r24, 0x29	; 41
    3110:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3114:	82 e6       	ldi	r24, 0x62	; 98
    3116:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3118:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    311a:	42 e0       	ldi	r20, 0x02	; 2
    311c:	be 01       	movw	r22, r28
    311e:	6f 5f       	subi	r22, 0xFF	; 255
    3120:	7f 4f       	sbci	r23, 0xFF	; 255
    3122:	89 e2       	ldi	r24, 0x29	; 41
    3124:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3128:	84 e6       	ldi	r24, 0x64	; 100
    312a:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    312c:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    312e:	42 e0       	ldi	r20, 0x02	; 2
    3130:	be 01       	movw	r22, r28
    3132:	6f 5f       	subi	r22, 0xFF	; 255
    3134:	7f 4f       	sbci	r23, 0xFF	; 255
    3136:	89 e2       	ldi	r24, 0x29	; 41
    3138:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    313c:	85 e6       	ldi	r24, 0x65	; 101
    313e:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3140:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3142:	42 e0       	ldi	r20, 0x02	; 2
    3144:	be 01       	movw	r22, r28
    3146:	6f 5f       	subi	r22, 0xFF	; 255
    3148:	7f 4f       	sbci	r23, 0xFF	; 255
    314a:	89 e2       	ldi	r24, 0x29	; 41
    314c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3150:	86 e6       	ldi	r24, 0x66	; 102
    3152:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3154:	80 ea       	ldi	r24, 0xA0	; 160
    3156:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3158:	42 e0       	ldi	r20, 0x02	; 2
    315a:	be 01       	movw	r22, r28
    315c:	6f 5f       	subi	r22, 0xFF	; 255
    315e:	7f 4f       	sbci	r23, 0xFF	; 255
    3160:	89 e2       	ldi	r24, 0x29	; 41
    3162:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3166:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    3168:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    316a:	42 e0       	ldi	r20, 0x02	; 2
    316c:	be 01       	movw	r22, r28
    316e:	6f 5f       	subi	r22, 0xFF	; 255
    3170:	7f 4f       	sbci	r23, 0xFF	; 255
    3172:	89 e2       	ldi	r24, 0x29	; 41
    3174:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3178:	82 e2       	ldi	r24, 0x22	; 34
    317a:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    317c:	8a 82       	std	Y+2, r8	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    317e:	42 e0       	ldi	r20, 0x02	; 2
    3180:	be 01       	movw	r22, r28
    3182:	6f 5f       	subi	r22, 0xFF	; 255
    3184:	7f 4f       	sbci	r23, 0xFF	; 255
    3186:	89 e2       	ldi	r24, 0x29	; 41
    3188:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    318c:	27 e4       	ldi	r18, 0x47	; 71
    318e:	82 2e       	mov	r8, r18
    3190:	89 82       	std	Y+1, r8	; 0x01
	Buffer[1]=value;
    3192:	84 e1       	ldi	r24, 0x14	; 20
    3194:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3196:	42 e0       	ldi	r20, 0x02	; 2
    3198:	be 01       	movw	r22, r28
    319a:	6f 5f       	subi	r22, 0xFF	; 255
    319c:	7f 4f       	sbci	r23, 0xFF	; 255
    319e:	89 e2       	ldi	r24, 0x29	; 41
    31a0:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    31a4:	89 e4       	ldi	r24, 0x49	; 73
    31a6:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    31a8:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    31aa:	42 e0       	ldi	r20, 0x02	; 2
    31ac:	be 01       	movw	r22, r28
    31ae:	6f 5f       	subi	r22, 0xFF	; 255
    31b0:	7f 4f       	sbci	r23, 0xFF	; 255
    31b2:	89 e2       	ldi	r24, 0x29	; 41
    31b4:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    31b8:	8a e4       	ldi	r24, 0x4A	; 74
    31ba:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    31bc:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    31be:	42 e0       	ldi	r20, 0x02	; 2
    31c0:	be 01       	movw	r22, r28
    31c2:	6f 5f       	subi	r22, 0xFF	; 255
    31c4:	7f 4f       	sbci	r23, 0xFF	; 255
    31c6:	89 e2       	ldi	r24, 0x29	; 41
    31c8:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    31cc:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    31ce:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    31d0:	42 e0       	ldi	r20, 0x02	; 2
    31d2:	be 01       	movw	r22, r28
    31d4:	6f 5f       	subi	r22, 0xFF	; 255
    31d6:	7f 4f       	sbci	r23, 0xFF	; 255
    31d8:	89 e2       	ldi	r24, 0x29	; 41
    31da:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    31de:	8a e7       	ldi	r24, 0x7A	; 122
    31e0:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    31e2:	2a e0       	ldi	r18, 0x0A	; 10
    31e4:	2a 83       	std	Y+2, r18	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    31e6:	42 e0       	ldi	r20, 0x02	; 2
    31e8:	be 01       	movw	r22, r28
    31ea:	6f 5f       	subi	r22, 0xFF	; 255
    31ec:	7f 4f       	sbci	r23, 0xFF	; 255
    31ee:	89 e2       	ldi	r24, 0x29	; 41
    31f0:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    31f4:	8b e7       	ldi	r24, 0x7B	; 123
    31f6:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    31f8:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    31fa:	42 e0       	ldi	r20, 0x02	; 2
    31fc:	be 01       	movw	r22, r28
    31fe:	6f 5f       	subi	r22, 0xFF	; 255
    3200:	7f 4f       	sbci	r23, 0xFF	; 255
    3202:	89 e2       	ldi	r24, 0x29	; 41
    3204:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3208:	88 e7       	ldi	r24, 0x78	; 120
    320a:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    320c:	81 e2       	ldi	r24, 0x21	; 33
    320e:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3210:	42 e0       	ldi	r20, 0x02	; 2
    3212:	be 01       	movw	r22, r28
    3214:	6f 5f       	subi	r22, 0xFF	; 255
    3216:	7f 4f       	sbci	r23, 0xFF	; 255
    3218:	89 e2       	ldi	r24, 0x29	; 41
    321a:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    321e:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    3220:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3222:	42 e0       	ldi	r20, 0x02	; 2
    3224:	be 01       	movw	r22, r28
    3226:	6f 5f       	subi	r22, 0xFF	; 255
    3228:	7f 4f       	sbci	r23, 0xFF	; 255
    322a:	89 e2       	ldi	r24, 0x29	; 41
    322c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3230:	83 e2       	ldi	r24, 0x23	; 35
    3232:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3234:	34 e3       	ldi	r19, 0x34	; 52
    3236:	33 2e       	mov	r3, r19
    3238:	3a 82       	std	Y+2, r3	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    323a:	42 e0       	ldi	r20, 0x02	; 2
    323c:	be 01       	movw	r22, r28
    323e:	6f 5f       	subi	r22, 0xFF	; 255
    3240:	7f 4f       	sbci	r23, 0xFF	; 255
    3242:	89 e2       	ldi	r24, 0x29	; 41
    3244:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3248:	82 e4       	ldi	r24, 0x42	; 66
    324a:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    324c:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    324e:	42 e0       	ldi	r20, 0x02	; 2
    3250:	be 01       	movw	r22, r28
    3252:	6f 5f       	subi	r22, 0xFF	; 255
    3254:	7f 4f       	sbci	r23, 0xFF	; 255
    3256:	89 e2       	ldi	r24, 0x29	; 41
    3258:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    325c:	44 e4       	ldi	r20, 0x44	; 68
    325e:	c4 2e       	mov	r12, r20
    3260:	c9 82       	std	Y+1, r12	; 0x01
	Buffer[1]=value;
    3262:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3264:	42 e0       	ldi	r20, 0x02	; 2
    3266:	be 01       	movw	r22, r28
    3268:	6f 5f       	subi	r22, 0xFF	; 255
    326a:	7f 4f       	sbci	r23, 0xFF	; 255
    326c:	89 e2       	ldi	r24, 0x29	; 41
    326e:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3272:	55 e4       	ldi	r21, 0x45	; 69
    3274:	75 2e       	mov	r7, r21
    3276:	79 82       	std	Y+1, r7	; 0x01
	Buffer[1]=value;
    3278:	86 e2       	ldi	r24, 0x26	; 38
    327a:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    327c:	42 e0       	ldi	r20, 0x02	; 2
    327e:	be 01       	movw	r22, r28
    3280:	6f 5f       	subi	r22, 0xFF	; 255
    3282:	7f 4f       	sbci	r23, 0xFF	; 255
    3284:	89 e2       	ldi	r24, 0x29	; 41
    3286:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    328a:	69 82       	std	Y+1, r6	; 0x01
	Buffer[1]=value;
    328c:	65 e0       	ldi	r22, 0x05	; 5
    328e:	66 2e       	mov	r6, r22
    3290:	6a 82       	std	Y+2, r6	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3292:	42 e0       	ldi	r20, 0x02	; 2
    3294:	be 01       	movw	r22, r28
    3296:	6f 5f       	subi	r22, 0xFF	; 255
    3298:	7f 4f       	sbci	r23, 0xFF	; 255
    329a:	89 e2       	ldi	r24, 0x29	; 41
    329c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    32a0:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    32a2:	ea 82       	std	Y+2, r14	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    32a4:	42 e0       	ldi	r20, 0x02	; 2
    32a6:	be 01       	movw	r22, r28
    32a8:	6f 5f       	subi	r22, 0xFF	; 255
    32aa:	7f 4f       	sbci	r23, 0xFF	; 255
    32ac:	89 e2       	ldi	r24, 0x29	; 41
    32ae:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    32b2:	8e e0       	ldi	r24, 0x0E	; 14
    32b4:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    32b6:	2a 82       	std	Y+2, r2	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    32b8:	42 e0       	ldi	r20, 0x02	; 2
    32ba:	be 01       	movw	r22, r28
    32bc:	6f 5f       	subi	r22, 0xFF	; 255
    32be:	7f 4f       	sbci	r23, 0xFF	; 255
    32c0:	89 e2       	ldi	r24, 0x29	; 41
    32c2:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    32c6:	d9 82       	std	Y+1, r13	; 0x01
	Buffer[1]=value;
    32c8:	8a e1       	ldi	r24, 0x1A	; 26
    32ca:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    32cc:	42 e0       	ldi	r20, 0x02	; 2
    32ce:	be 01       	movw	r22, r28
    32d0:	6f 5f       	subi	r22, 0xFF	; 255
    32d2:	7f 4f       	sbci	r23, 0xFF	; 255
    32d4:	89 e2       	ldi	r24, 0x29	; 41
    32d6:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    32da:	83 e4       	ldi	r24, 0x43	; 67
    32dc:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    32de:	ea 82       	std	Y+2, r14	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    32e0:	42 e0       	ldi	r20, 0x02	; 2
    32e2:	be 01       	movw	r22, r28
    32e4:	6f 5f       	subi	r22, 0xFF	; 255
    32e6:	7f 4f       	sbci	r23, 0xFF	; 255
    32e8:	89 e2       	ldi	r24, 0x29	; 41
    32ea:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    32ee:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    32f0:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    32f2:	42 e0       	ldi	r20, 0x02	; 2
    32f4:	be 01       	movw	r22, r28
    32f6:	6f 5f       	subi	r22, 0xFF	; 255
    32f8:	7f 4f       	sbci	r23, 0xFF	; 255
    32fa:	89 e2       	ldi	r24, 0x29	; 41
    32fc:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3300:	39 82       	std	Y+1, r3	; 0x01
	Buffer[1]=value;
    3302:	4a 82       	std	Y+2, r4	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3304:	42 e0       	ldi	r20, 0x02	; 2
    3306:	be 01       	movw	r22, r28
    3308:	6f 5f       	subi	r22, 0xFF	; 255
    330a:	7f 4f       	sbci	r23, 0xFF	; 255
    330c:	89 e2       	ldi	r24, 0x29	; 41
    330e:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3312:	85 e3       	ldi	r24, 0x35	; 53
    3314:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3316:	ca 82       	std	Y+2, r12	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3318:	42 e0       	ldi	r20, 0x02	; 2
    331a:	be 01       	movw	r22, r28
    331c:	6f 5f       	subi	r22, 0xFF	; 255
    331e:	7f 4f       	sbci	r23, 0xFF	; 255
    3320:	89 e2       	ldi	r24, 0x29	; 41
    3322:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3326:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    3328:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    332a:	42 e0       	ldi	r20, 0x02	; 2
    332c:	be 01       	movw	r22, r28
    332e:	6f 5f       	subi	r22, 0xFF	; 255
    3330:	7f 4f       	sbci	r23, 0xFF	; 255
    3332:	89 e2       	ldi	r24, 0x29	; 41
    3334:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3338:	59 82       	std	Y+1, r5	; 0x01
	Buffer[1]=value;
    333a:	84 e0       	ldi	r24, 0x04	; 4
    333c:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    333e:	42 e0       	ldi	r20, 0x02	; 2
    3340:	be 01       	movw	r22, r28
    3342:	6f 5f       	subi	r22, 0xFF	; 255
    3344:	7f 4f       	sbci	r23, 0xFF	; 255
    3346:	89 e2       	ldi	r24, 0x29	; 41
    3348:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    334c:	8b e4       	ldi	r24, 0x4B	; 75
    334e:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3350:	ba 82       	std	Y+2, r11	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3352:	42 e0       	ldi	r20, 0x02	; 2
    3354:	be 01       	movw	r22, r28
    3356:	6f 5f       	subi	r22, 0xFF	; 255
    3358:	7f 4f       	sbci	r23, 0xFF	; 255
    335a:	89 e2       	ldi	r24, 0x29	; 41
    335c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3360:	8c e4       	ldi	r24, 0x4C	; 76
    3362:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3364:	6a 82       	std	Y+2, r6	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3366:	42 e0       	ldi	r20, 0x02	; 2
    3368:	be 01       	movw	r22, r28
    336a:	6f 5f       	subi	r22, 0xFF	; 255
    336c:	7f 4f       	sbci	r23, 0xFF	; 255
    336e:	89 e2       	ldi	r24, 0x29	; 41
    3370:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3374:	8d e4       	ldi	r24, 0x4D	; 77
    3376:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3378:	a4 e0       	ldi	r26, 0x04	; 4
    337a:	aa 83       	std	Y+2, r26	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    337c:	42 e0       	ldi	r20, 0x02	; 2
    337e:	be 01       	movw	r22, r28
    3380:	6f 5f       	subi	r22, 0xFF	; 255
    3382:	7f 4f       	sbci	r23, 0xFF	; 255
    3384:	89 e2       	ldi	r24, 0x29	; 41
    3386:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    338a:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    338c:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    338e:	42 e0       	ldi	r20, 0x02	; 2
    3390:	be 01       	movw	r22, r28
    3392:	6f 5f       	subi	r22, 0xFF	; 255
    3394:	7f 4f       	sbci	r23, 0xFF	; 255
    3396:	89 e2       	ldi	r24, 0x29	; 41
    3398:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    339c:	c9 82       	std	Y+1, r12	; 0x01
	Buffer[1]=value;
    339e:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    33a0:	42 e0       	ldi	r20, 0x02	; 2
    33a2:	be 01       	movw	r22, r28
    33a4:	6f 5f       	subi	r22, 0xFF	; 255
    33a6:	7f 4f       	sbci	r23, 0xFF	; 255
    33a8:	89 e2       	ldi	r24, 0x29	; 41
    33aa:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    33ae:	79 82       	std	Y+1, r7	; 0x01
	Buffer[1]=value;
    33b0:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    33b2:	42 e0       	ldi	r20, 0x02	; 2
    33b4:	be 01       	movw	r22, r28
    33b6:	6f 5f       	subi	r22, 0xFF	; 255
    33b8:	7f 4f       	sbci	r23, 0xFF	; 255
    33ba:	89 e2       	ldi	r24, 0x29	; 41
    33bc:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    33c0:	89 82       	std	Y+1, r8	; 0x01
	Buffer[1]=value;
    33c2:	9a 82       	std	Y+2, r9	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    33c4:	42 e0       	ldi	r20, 0x02	; 2
    33c6:	be 01       	movw	r22, r28
    33c8:	6f 5f       	subi	r22, 0xFF	; 255
    33ca:	7f 4f       	sbci	r23, 0xFF	; 255
    33cc:	89 e2       	ldi	r24, 0x29	; 41
    33ce:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    33d2:	a9 82       	std	Y+1, r10	; 0x01
	Buffer[1]=value;
    33d4:	88 e2       	ldi	r24, 0x28	; 40
    33d6:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    33d8:	42 e0       	ldi	r20, 0x02	; 2
    33da:	be 01       	movw	r22, r28
    33dc:	6f 5f       	subi	r22, 0xFF	; 255
    33de:	7f 4f       	sbci	r23, 0xFF	; 255
    33e0:	89 e2       	ldi	r24, 0x29	; 41
    33e2:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    33e6:	87 e6       	ldi	r24, 0x67	; 103
    33e8:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    33ea:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    33ec:	42 e0       	ldi	r20, 0x02	; 2
    33ee:	be 01       	movw	r22, r28
    33f0:	6f 5f       	subi	r22, 0xFF	; 255
    33f2:	7f 4f       	sbci	r23, 0xFF	; 255
    33f4:	89 e2       	ldi	r24, 0x29	; 41
    33f6:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    33fa:	80 e7       	ldi	r24, 0x70	; 112
    33fc:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    33fe:	b4 e0       	ldi	r27, 0x04	; 4
    3400:	ba 83       	std	Y+2, r27	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3402:	42 e0       	ldi	r20, 0x02	; 2
    3404:	be 01       	movw	r22, r28
    3406:	6f 5f       	subi	r22, 0xFF	; 255
    3408:	7f 4f       	sbci	r23, 0xFF	; 255
    340a:	89 e2       	ldi	r24, 0x29	; 41
    340c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3410:	81 e7       	ldi	r24, 0x71	; 113
    3412:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3414:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3416:	42 e0       	ldi	r20, 0x02	; 2
    3418:	be 01       	movw	r22, r28
    341a:	6f 5f       	subi	r22, 0xFF	; 255
    341c:	7f 4f       	sbci	r23, 0xFF	; 255
    341e:	89 e2       	ldi	r24, 0x29	; 41
    3420:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3424:	82 e7       	ldi	r24, 0x72	; 114
    3426:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3428:	8e ef       	ldi	r24, 0xFE	; 254
    342a:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    342c:	42 e0       	ldi	r20, 0x02	; 2
    342e:	be 01       	movw	r22, r28
    3430:	6f 5f       	subi	r22, 0xFF	; 255
    3432:	7f 4f       	sbci	r23, 0xFF	; 255
    3434:	89 e2       	ldi	r24, 0x29	; 41
    3436:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    343a:	86 e7       	ldi	r24, 0x76	; 118
    343c:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    343e:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3440:	42 e0       	ldi	r20, 0x02	; 2
    3442:	be 01       	movw	r22, r28
    3444:	6f 5f       	subi	r22, 0xFF	; 255
    3446:	7f 4f       	sbci	r23, 0xFF	; 255
    3448:	89 e2       	ldi	r24, 0x29	; 41
    344a:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    344e:	87 e7       	ldi	r24, 0x77	; 119
    3450:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3452:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3454:	42 e0       	ldi	r20, 0x02	; 2
    3456:	be 01       	movw	r22, r28
    3458:	6f 5f       	subi	r22, 0xFF	; 255
    345a:	7f 4f       	sbci	r23, 0xFF	; 255
    345c:	89 e2       	ldi	r24, 0x29	; 41
    345e:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3462:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    3464:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3466:	42 e0       	ldi	r20, 0x02	; 2
    3468:	be 01       	movw	r22, r28
    346a:	6f 5f       	subi	r22, 0xFF	; 255
    346c:	7f 4f       	sbci	r23, 0xFF	; 255
    346e:	89 e2       	ldi	r24, 0x29	; 41
    3470:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3474:	8d e0       	ldi	r24, 0x0D	; 13
    3476:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3478:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    347a:	42 e0       	ldi	r20, 0x02	; 2
    347c:	be 01       	movw	r22, r28
    347e:	6f 5f       	subi	r22, 0xFF	; 255
    3480:	7f 4f       	sbci	r23, 0xFF	; 255
    3482:	89 e2       	ldi	r24, 0x29	; 41
    3484:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3488:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    348a:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    348c:	42 e0       	ldi	r20, 0x02	; 2
    348e:	be 01       	movw	r22, r28
    3490:	6f 5f       	subi	r22, 0xFF	; 255
    3492:	7f 4f       	sbci	r23, 0xFF	; 255
    3494:	89 e2       	ldi	r24, 0x29	; 41
    3496:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    349a:	70 e8       	ldi	r23, 0x80	; 128
    349c:	e7 2e       	mov	r14, r23
    349e:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    34a0:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    34a2:	42 e0       	ldi	r20, 0x02	; 2
    34a4:	be 01       	movw	r22, r28
    34a6:	6f 5f       	subi	r22, 0xFF	; 255
    34a8:	7f 4f       	sbci	r23, 0xFF	; 255
    34aa:	89 e2       	ldi	r24, 0x29	; 41
    34ac:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    34b0:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    34b2:	88 ef       	ldi	r24, 0xF8	; 248
    34b4:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    34b6:	42 e0       	ldi	r20, 0x02	; 2
    34b8:	be 01       	movw	r22, r28
    34ba:	6f 5f       	subi	r22, 0xFF	; 255
    34bc:	7f 4f       	sbci	r23, 0xFF	; 255
    34be:	89 e2       	ldi	r24, 0x29	; 41
    34c0:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    34c4:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    34c6:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    34c8:	42 e0       	ldi	r20, 0x02	; 2
    34ca:	be 01       	movw	r22, r28
    34cc:	6f 5f       	subi	r22, 0xFF	; 255
    34ce:	7f 4f       	sbci	r23, 0xFF	; 255
    34d0:	89 e2       	ldi	r24, 0x29	; 41
    34d2:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    34d6:	8e e8       	ldi	r24, 0x8E	; 142
    34d8:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    34da:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    34dc:	42 e0       	ldi	r20, 0x02	; 2
    34de:	be 01       	movw	r22, r28
    34e0:	6f 5f       	subi	r22, 0xFF	; 255
    34e2:	7f 4f       	sbci	r23, 0xFF	; 255
    34e4:	89 e2       	ldi	r24, 0x29	; 41
    34e6:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    34ea:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    34ec:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    34ee:	42 e0       	ldi	r20, 0x02	; 2
    34f0:	be 01       	movw	r22, r28
    34f2:	6f 5f       	subi	r22, 0xFF	; 255
    34f4:	7f 4f       	sbci	r23, 0xFF	; 255
    34f6:	89 e2       	ldi	r24, 0x29	; 41
    34f8:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    34fc:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    34fe:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3500:	42 e0       	ldi	r20, 0x02	; 2
    3502:	be 01       	movw	r22, r28
    3504:	6f 5f       	subi	r22, 0xFF	; 255
    3506:	7f 4f       	sbci	r23, 0xFF	; 255
    3508:	89 e2       	ldi	r24, 0x29	; 41
    350a:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    350e:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    3510:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3512:	42 e0       	ldi	r20, 0x02	; 2
    3514:	be 01       	movw	r22, r28
    3516:	6f 5f       	subi	r22, 0xFF	; 255
    3518:	7f 4f       	sbci	r23, 0xFF	; 255
    351a:	89 e2       	ldi	r24, 0x29	; 41
    351c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3520:	2a e0       	ldi	r18, 0x0A	; 10
    3522:	29 83       	std	Y+1, r18	; 0x01
	Buffer[1]=value;
    3524:	84 e0       	ldi	r24, 0x04	; 4
    3526:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3528:	42 e0       	ldi	r20, 0x02	; 2
    352a:	be 01       	movw	r22, r28
    352c:	6f 5f       	subi	r22, 0xFF	; 255
    352e:	7f 4f       	sbci	r23, 0xFF	; 255
    3530:	89 e2       	ldi	r24, 0x29	; 41
    3532:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    3536:	14 e8       	ldi	r17, 0x84	; 132
    3538:	19 83       	std	Y+1, r17	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    353a:	01 e0       	ldi	r16, 0x01	; 1
    353c:	9e 01       	movw	r18, r28
    353e:	2f 5f       	subi	r18, 0xFF	; 255
    3540:	3f 4f       	sbci	r19, 0xFF	; 255
    3542:	41 e0       	ldi	r20, 0x01	; 1
    3544:	b9 01       	movw	r22, r18
    3546:	89 e2       	ldi	r24, 0x29	; 41
    3548:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    354c:	89 81       	ldd	r24, Y+1	; 0x01
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    354e:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    3550:	8f 7e       	andi	r24, 0xEF	; 239
    3552:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3554:	42 e0       	ldi	r20, 0x02	; 2
    3556:	be 01       	movw	r22, r28
    3558:	6f 5f       	subi	r22, 0xFF	; 255
    355a:	7f 4f       	sbci	r23, 0xFF	; 255
    355c:	89 e2       	ldi	r24, 0x29	; 41
    355e:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3562:	8b e0       	ldi	r24, 0x0B	; 11
    3564:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3566:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3568:	42 e0       	ldi	r20, 0x02	; 2
    356a:	be 01       	movw	r22, r28
    356c:	6f 5f       	subi	r22, 0xFF	; 255
    356e:	7f 4f       	sbci	r23, 0xFF	; 255
    3570:	89 e2       	ldi	r24, 0x29	; 41
    3572:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
	uint16_t const PreRangeOverhead   = 660;
	uint16_t const FinalRangeOverhead = 550;

	// "Start and end overhead times always present"
	uint32_t budget_us = StartOverhead + EndOverhead;
	getSequenceStepEnables (&enables);
    3576:	ce 01       	movw	r24, r28
    3578:	4d 96       	adiw	r24, 0x1d	; 29
    357a:	0e 94 6f 12 	call	0x24de	; 0x24de <getSequenceStepEnables>
	getSequenceStepTimeouts(&enables, &timeouts);
    357e:	be 01       	movw	r22, r28
    3580:	6f 5f       	subi	r22, 0xFF	; 255
    3582:	7f 4f       	sbci	r23, 0xFF	; 255
    3584:	ce 01       	movw	r24, r28
    3586:	80 96       	adiw	r24, 0x20	; 32
    3588:	0e 94 24 13 	call	0x2648	; 0x2648 <getSequenceStepTimeouts.isra.1>

	if (enables.tcc)
    358c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    358e:	88 23       	and	r24, r24
    3590:	09 f4       	brne	.+2      	; 0x3594 <DriverVL53L0XInit+0xb50>
    3592:	86 c0       	rjmp	.+268    	; 0x36a0 <DriverVL53L0XInit+0xc5c>
	{
		budget_us += (timeouts.msrc_dss_tcc_us + TccOverhead);
    3594:	8b 85       	ldd	r24, Y+11	; 0x0b
    3596:	9c 85       	ldd	r25, Y+12	; 0x0c
    3598:	ad 85       	ldd	r26, Y+13	; 0x0d
    359a:	be 85       	ldd	r27, Y+14	; 0x0e
    359c:	8c 57       	subi	r24, 0x7C	; 124
    359e:	92 4f       	sbci	r25, 0xF2	; 242
    35a0:	af 4f       	sbci	r26, 0xFF	; 255
    35a2:	bf 4f       	sbci	r27, 0xFF	; 255
	}

	if (enables.dss)
    35a4:	2f 8d       	ldd	r18, Y+31	; 0x1f
    35a6:	22 23       	and	r18, r18
    35a8:	09 f4       	brne	.+2      	; 0x35ac <DriverVL53L0XInit+0xb68>
    35aa:	69 c0       	rjmp	.+210    	; 0x367e <DriverVL53L0XInit+0xc3a>
	{
		budget_us += 2 * (timeouts.msrc_dss_tcc_us + DssOverhead);
    35ac:	4b 85       	ldd	r20, Y+11	; 0x0b
    35ae:	5c 85       	ldd	r21, Y+12	; 0x0c
    35b0:	6d 85       	ldd	r22, Y+13	; 0x0d
    35b2:	7e 85       	ldd	r23, Y+14	; 0x0e
    35b4:	4e 54       	subi	r20, 0x4E	; 78
    35b6:	5d 4f       	sbci	r21, 0xFD	; 253
    35b8:	6f 4f       	sbci	r22, 0xFF	; 255
    35ba:	7f 4f       	sbci	r23, 0xFF	; 255
    35bc:	44 0f       	add	r20, r20
    35be:	55 1f       	adc	r21, r21
    35c0:	66 1f       	adc	r22, r22
    35c2:	77 1f       	adc	r23, r23
    35c4:	84 0f       	add	r24, r20
    35c6:	95 1f       	adc	r25, r21
    35c8:	a6 1f       	adc	r26, r22
    35ca:	b7 1f       	adc	r27, r23
	else if (enables.msrc)
	{
		budget_us += (timeouts.msrc_dss_tcc_us + MsrcOverhead);
	}

	if (enables.pre_range)
    35cc:	28 a1       	ldd	r18, Y+32	; 0x20
    35ce:	22 23       	and	r18, r18
    35d0:	61 f0       	breq	.+24     	; 0x35ea <DriverVL53L0XInit+0xba6>
	{
		budget_us += (timeouts.pre_range_us + PreRangeOverhead);
    35d2:	4f 85       	ldd	r20, Y+15	; 0x0f
    35d4:	58 89       	ldd	r21, Y+16	; 0x10
    35d6:	69 89       	ldd	r22, Y+17	; 0x11
    35d8:	7a 89       	ldd	r23, Y+18	; 0x12
    35da:	4c 56       	subi	r20, 0x6C	; 108
    35dc:	5d 4f       	sbci	r21, 0xFD	; 253
    35de:	6f 4f       	sbci	r22, 0xFF	; 255
    35e0:	7f 4f       	sbci	r23, 0xFF	; 255
    35e2:	84 0f       	add	r24, r20
    35e4:	95 1f       	adc	r25, r21
    35e6:	a6 1f       	adc	r26, r22
    35e8:	b7 1f       	adc	r27, r23
	}

	if (enables.final_range)
    35ea:	29 a1       	ldd	r18, Y+33	; 0x21
    35ec:	22 23       	and	r18, r18
    35ee:	61 f0       	breq	.+24     	; 0x3608 <DriverVL53L0XInit+0xbc4>
	{
		budget_us += (timeouts.final_range_us + FinalRangeOverhead);
    35f0:	4b 89       	ldd	r20, Y+19	; 0x13
    35f2:	5c 89       	ldd	r21, Y+20	; 0x14
    35f4:	6d 89       	ldd	r22, Y+21	; 0x15
    35f6:	7e 89       	ldd	r23, Y+22	; 0x16
    35f8:	4a 5d       	subi	r20, 0xDA	; 218
    35fa:	5d 4f       	sbci	r21, 0xFD	; 253
    35fc:	6f 4f       	sbci	r22, 0xFF	; 255
    35fe:	7f 4f       	sbci	r23, 0xFF	; 255
    3600:	84 0f       	add	r24, r20
    3602:	95 1f       	adc	r25, r21
    3604:	a6 1f       	adc	r26, r22
    3606:	b7 1f       	adc	r27, r23
	}

	measurement_timing_budget_us = budget_us; // store for internal reuse
    3608:	80 93 6a 2e 	sts	0x2E6A, r24	; 0x802e6a <measurement_timing_budget_us>
    360c:	90 93 6b 2e 	sts	0x2E6B, r25	; 0x802e6b <measurement_timing_budget_us+0x1>
    3610:	a0 93 6c 2e 	sts	0x2E6C, r26	; 0x802e6c <measurement_timing_budget_us+0x2>
    3614:	b0 93 6d 2e 	sts	0x2E6D, r27	; 0x802e6d <measurement_timing_budget_us+0x3>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3618:	81 e0       	ldi	r24, 0x01	; 1
    361a:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    361c:	88 ee       	ldi	r24, 0xE8	; 232
    361e:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3620:	42 e0       	ldi	r20, 0x02	; 2
    3622:	be 01       	movw	r22, r28
    3624:	6f 5f       	subi	r22, 0xFF	; 255
    3626:	7f 4f       	sbci	r23, 0xFF	; 255
    3628:	89 e2       	ldi	r24, 0x29	; 41
    362a:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
	writeReg(SYSTEM_SEQUENCE_CONFIG, 0xE8);

	// -- VL53L0X_SetSequenceStepEnable() end

	// "Recalculate timing budget"
	setMeasurementTimingBudget(measurement_timing_budget_us);
    362e:	60 91 6a 2e 	lds	r22, 0x2E6A	; 0x802e6a <measurement_timing_budget_us>
    3632:	70 91 6b 2e 	lds	r23, 0x2E6B	; 0x802e6b <measurement_timing_budget_us+0x1>
    3636:	80 91 6c 2e 	lds	r24, 0x2E6C	; 0x802e6c <measurement_timing_budget_us+0x2>
    363a:	90 91 6d 2e 	lds	r25, 0x2E6D	; 0x802e6d <measurement_timing_budget_us+0x3>
	uint16_t const PreRangeOverhead   = 660;
	uint16_t const FinalRangeOverhead = 550;

	uint32_t const MinTimingBudget = 20000;

	if (budget_us < MinTimingBudget) { return false; }
    363e:	60 32       	cpi	r22, 0x20	; 32
    3640:	ae e4       	ldi	r26, 0x4E	; 78
    3642:	7a 07       	cpc	r23, r26
    3644:	81 05       	cpc	r24, r1
    3646:	91 05       	cpc	r25, r1
    3648:	08 f0       	brcs	.+2      	; 0x364c <DriverVL53L0XInit+0xc08>
    364a:	4a c0       	rjmp	.+148    	; 0x36e0 <DriverVL53L0XInit+0xc9c>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    364c:	11 e0       	ldi	r17, 0x01	; 1
    364e:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    3650:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3652:	42 e0       	ldi	r20, 0x02	; 2
    3654:	be 01       	movw	r22, r28
    3656:	6f 5f       	subi	r22, 0xFF	; 255
    3658:	7f 4f       	sbci	r23, 0xFF	; 255
    365a:	89 e2       	ldi	r24, 0x29	; 41
    365c:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
	// VL53L0X_PerformRefCalibration() begin (VL53L0X_perform_ref_calibration())

	// -- VL53L0X_perform_vhv_calibration() begin

	writeReg(SYSTEM_SEQUENCE_CONFIG, 0x01);
	if (!performSingleRefCalibration(0x40)) { return false; }
    3660:	80 e4       	ldi	r24, 0x40	; 64
    3662:	0e 94 a3 12 	call	0x2546	; 0x2546 <performSingleRefCalibration>
    3666:	81 11       	cpse	r24, r1
    3668:	20 c0       	rjmp	.+64     	; 0x36aa <DriverVL53L0XInit+0xc66>
    366a:	80 e0       	ldi	r24, 0x00	; 0
    366c:	18 ca       	rjmp	.-3024   	; 0x2a9e <DriverVL53L0XInit+0x5a>
	//Check Model ID
	res=readReg(IDENTIFICATION_MODEL_ID,&Data);
	if (!res)
	{
		#ifdef VL53L0X_DEBUG
			printf ("VL53L0X:Cannot access.\r\n");
    366e:	83 eb       	ldi	r24, 0xB3	; 179
    3670:	93 e2       	ldi	r25, 0x23	; 35
    3672:	0e 94 1b 51 	call	0xa236	; 0xa236 <puts>
		#endif
		return false;
    3676:	80 e0       	ldi	r24, 0x00	; 0
    3678:	12 ca       	rjmp	.-3036   	; 0x2a9e <DriverVL53L0XInit+0x5a>
	writeReg(DYNAMIC_SPAD_REF_EN_START_OFFSET, 0x00);
	writeReg(DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);
	writeReg(0xFF, 0x00);
	writeReg(GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);

	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
    367a:	4c e0       	ldi	r20, 0x0C	; 12
    367c:	df cb       	rjmp	.-2114   	; 0x2e3c <DriverVL53L0XInit+0x3f8>

	if (enables.dss)
	{
		budget_us += 2 * (timeouts.msrc_dss_tcc_us + DssOverhead);
	}
	else if (enables.msrc)
    367e:	2e 8d       	ldd	r18, Y+30	; 0x1e
    3680:	22 23       	and	r18, r18
    3682:	09 f4       	brne	.+2      	; 0x3686 <DriverVL53L0XInit+0xc42>
    3684:	a3 cf       	rjmp	.-186    	; 0x35cc <DriverVL53L0XInit+0xb88>
	{
		budget_us += (timeouts.msrc_dss_tcc_us + MsrcOverhead);
    3686:	4b 85       	ldd	r20, Y+11	; 0x0b
    3688:	5c 85       	ldd	r21, Y+12	; 0x0c
    368a:	6d 85       	ldd	r22, Y+13	; 0x0d
    368c:	7e 85       	ldd	r23, Y+14	; 0x0e
    368e:	4c 56       	subi	r20, 0x6C	; 108
    3690:	5d 4f       	sbci	r21, 0xFD	; 253
    3692:	6f 4f       	sbci	r22, 0xFF	; 255
    3694:	7f 4f       	sbci	r23, 0xFF	; 255
    3696:	84 0f       	add	r24, r20
    3698:	95 1f       	adc	r25, r21
    369a:	a6 1f       	adc	r26, r22
    369c:	b7 1f       	adc	r27, r23
    369e:	96 cf       	rjmp	.-212    	; 0x35cc <DriverVL53L0XInit+0xb88>
	uint16_t const DssOverhead        = 690;
	uint16_t const PreRangeOverhead   = 660;
	uint16_t const FinalRangeOverhead = 550;

	// "Start and end overhead times always present"
	uint32_t budget_us = StartOverhead + EndOverhead;
    36a0:	86 e3       	ldi	r24, 0x36	; 54
    36a2:	9b e0       	ldi	r25, 0x0B	; 11
    36a4:	a0 e0       	ldi	r26, 0x00	; 0
    36a6:	b0 e0       	ldi	r27, 0x00	; 0
    36a8:	7d cf       	rjmp	.-262    	; 0x35a4 <DriverVL53L0XInit+0xb60>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    36aa:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    36ac:	82 e0       	ldi	r24, 0x02	; 2
    36ae:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    36b0:	42 e0       	ldi	r20, 0x02	; 2
    36b2:	be 01       	movw	r22, r28
    36b4:	6f 5f       	subi	r22, 0xFF	; 255
    36b6:	7f 4f       	sbci	r23, 0xFF	; 255
    36b8:	89 e2       	ldi	r24, 0x29	; 41
    36ba:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
	// -- VL53L0X_perform_vhv_calibration() end

	// -- VL53L0X_perform_phase_calibration() begin

	writeReg(SYSTEM_SEQUENCE_CONFIG, 0x02);
	if (!performSingleRefCalibration(0x00)) { return false; }
    36be:	80 e0       	ldi	r24, 0x00	; 0
    36c0:	0e 94 a3 12 	call	0x2546	; 0x2546 <performSingleRefCalibration>
    36c4:	88 23       	and	r24, r24
    36c6:	89 f2       	breq	.-94     	; 0x366a <DriverVL53L0XInit+0xc26>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    36c8:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    36ca:	88 ee       	ldi	r24, 0xE8	; 232
    36cc:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    36ce:	42 e0       	ldi	r20, 0x02	; 2
    36d0:	be 01       	movw	r22, r28
    36d2:	6f 5f       	subi	r22, 0xFF	; 255
    36d4:	7f 4f       	sbci	r23, 0xFF	; 255
    36d6:	89 e2       	ldi	r24, 0x29	; 41
    36d8:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
	// "restore the previous Sequence Config"
	writeReg(SYSTEM_SEQUENCE_CONFIG, 0xE8);

	// VL53L0X_PerformRefCalibration() end

	return true;
    36dc:	81 e0       	ldi	r24, 0x01	; 1
    36de:	df c9       	rjmp	.-3138   	; 0x2a9e <DriverVL53L0XInit+0x5a>
    36e0:	0e 94 1b 14 	call	0x2836	; 0x2836 <setMeasurementTimingBudget.part.4>
    36e4:	b3 cf       	rjmp	.-154    	; 0x364c <DriverVL53L0XInit+0xc08>

000036e6 <DriverVL53L0XReadContinuous>:

// Returns a range reading in millimeters when continuous mode is active
// (readRangeSingleMillimeters() also calls this function after starting a
// single-shot range measurement)
uint16_t DriverVL53L0XReadContinuous()
{
    36e6:	0f 93       	push	r16
    36e8:	1f 93       	push	r17
    36ea:	cf 93       	push	r28
    36ec:	df 93       	push	r29
    36ee:	00 d0       	rcall	.+0      	; 0x36f0 <DriverVL53L0XReadContinuous+0xa>
    36f0:	00 d0       	rcall	.+0      	; 0x36f2 <DriverVL53L0XReadContinuous+0xc>
    36f2:	cd b7       	in	r28, 0x3d	; 61
    36f4:	de b7       	in	r29, 0x3e	; 62
	return true;
}

static void startTimeout(void)
{
	timeout_start_ticks=portGET_RUN_TIME_COUNTER_VALUE();
    36f6:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    36fa:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    36fe:	80 91 6e 2e 	lds	r24, 0x2E6E	; 0x802e6e <StatsTimer>
    3702:	90 91 6f 2e 	lds	r25, 0x2E6F	; 0x802e6f <StatsTimer+0x1>
    3706:	a0 91 70 2e 	lds	r26, 0x2E70	; 0x802e70 <StatsTimer+0x2>
    370a:	b0 91 71 2e 	lds	r27, 0x2E71	; 0x802e71 <StatsTimer+0x3>
    370e:	82 0f       	add	r24, r18
    3710:	93 1f       	adc	r25, r19
    3712:	a1 1d       	adc	r26, r1
    3714:	b1 1d       	adc	r27, r1
    3716:	80 93 5c 2d 	sts	0x2D5C, r24	; 0x802d5c <timeout_start_ticks>
    371a:	90 93 5d 2d 	sts	0x2D5D, r25	; 0x802d5d <timeout_start_ticks+0x1>
    371e:	a0 93 5e 2d 	sts	0x2D5E, r26	; 0x802d5e <timeout_start_ticks+0x2>
    3722:	b0 93 5f 2d 	sts	0x2D5F, r27	; 0x802d5f <timeout_start_ticks+0x3>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    3726:	13 e1       	ldi	r17, 0x13	; 19
    3728:	19 83       	std	Y+1, r17	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    372a:	01 e0       	ldi	r16, 0x01	; 1
    372c:	9e 01       	movw	r18, r28
    372e:	2f 5f       	subi	r18, 0xFF	; 255
    3730:	3f 4f       	sbci	r19, 0xFF	; 255
    3732:	41 e0       	ldi	r20, 0x01	; 1
    3734:	b9 01       	movw	r22, r18
    3736:	89 e2       	ldi	r24, 0x29	; 41
    3738:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    373c:	89 81       	ldd	r24, Y+1	; 0x01
	
	
	while (1)
	{
		readReg(RESULT_INTERRUPT_STATUS,&Data);
		if ((Data & 0x07)!=0) break;
    373e:	87 70       	andi	r24, 0x07	; 7
    3740:	99 f3       	breq	.-26     	; 0x3728 <DriverVL53L0XReadContinuous+0x42>
			return 65535;
		}		
	}
	// assumptions: Linearity Corrective Gain is 1000 (default);
	// fractional ranging is not enabled
	readReg16Bit(RESULT_RANGE_STATUS+10,&Data16);
    3742:	be 01       	movw	r22, r28
    3744:	6b 5f       	subi	r22, 0xFB	; 251
    3746:	7f 4f       	sbci	r23, 0xFF	; 255
    3748:	8e e1       	ldi	r24, 0x1E	; 30
    374a:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <readReg16Bit>
	uint16_t range = Data16;
    374e:	0d 81       	ldd	r16, Y+5	; 0x05
    3750:	1e 81       	ldd	r17, Y+6	; 0x06
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3752:	8b e0       	ldi	r24, 0x0B	; 11
    3754:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3756:	81 e0       	ldi	r24, 0x01	; 1
    3758:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    375a:	42 e0       	ldi	r20, 0x02	; 2
    375c:	be 01       	movw	r22, r28
    375e:	6f 5f       	subi	r22, 0xFF	; 255
    3760:	7f 4f       	sbci	r23, 0xFF	; 255
    3762:	89 e2       	ldi	r24, 0x29	; 41
    3764:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
	uint16_t range = Data16;

	writeReg(SYSTEM_INTERRUPT_CLEAR, 0x01);

	return range;
}
    3768:	c8 01       	movw	r24, r16
    376a:	26 96       	adiw	r28, 0x06	; 6
    376c:	cd bf       	out	0x3d, r28	; 61
    376e:	de bf       	out	0x3e, r29	; 62
    3770:	df 91       	pop	r29
    3772:	cf 91       	pop	r28
    3774:	1f 91       	pop	r17
    3776:	0f 91       	pop	r16
    3778:	08 95       	ret

0000377a <DriverVL53L0XReadSingle>:

// Performs a single-shot range measurement and returns the reading in
// millimeters
// based on VL53L0X_PerformSingleRangingMeasurement()
uint16_t DriverVL53L0XReadSingle()
{
    377a:	ff 92       	push	r15
    377c:	0f 93       	push	r16
    377e:	1f 93       	push	r17
    3780:	cf 93       	push	r28
    3782:	df 93       	push	r29
    3784:	00 d0       	rcall	.+0      	; 0x3786 <DriverVL53L0XReadSingle+0xc>
    3786:	1f 92       	push	r1
    3788:	cd b7       	in	r28, 0x3d	; 61
    378a:	de b7       	in	r29, 0x3e	; 62
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    378c:	00 e8       	ldi	r16, 0x80	; 128
    378e:	09 83       	std	Y+1, r16	; 0x01
	Buffer[1]=value;
    3790:	11 e0       	ldi	r17, 0x01	; 1
    3792:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3794:	42 e0       	ldi	r20, 0x02	; 2
    3796:	be 01       	movw	r22, r28
    3798:	6f 5f       	subi	r22, 0xFF	; 255
    379a:	7f 4f       	sbci	r23, 0xFF	; 255
    379c:	89 e2       	ldi	r24, 0x29	; 41
    379e:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    37a2:	ff 24       	eor	r15, r15
    37a4:	fa 94       	dec	r15
    37a6:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    37a8:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    37aa:	42 e0       	ldi	r20, 0x02	; 2
    37ac:	be 01       	movw	r22, r28
    37ae:	6f 5f       	subi	r22, 0xFF	; 255
    37b0:	7f 4f       	sbci	r23, 0xFF	; 255
    37b2:	89 e2       	ldi	r24, 0x29	; 41
    37b4:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    37b8:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    37ba:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    37bc:	42 e0       	ldi	r20, 0x02	; 2
    37be:	be 01       	movw	r22, r28
    37c0:	6f 5f       	subi	r22, 0xFF	; 255
    37c2:	7f 4f       	sbci	r23, 0xFF	; 255
    37c4:	89 e2       	ldi	r24, 0x29	; 41
    37c6:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
	uint8_t Data;
	
	writeReg(0x80, 0x01);
	writeReg(0xFF, 0x01);
	writeReg(0x00, 0x00);
	writeReg(0x91, stop_variable);
    37ca:	80 91 60 2d 	lds	r24, 0x2D60	; 0x802d60 <stop_variable>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    37ce:	91 e9       	ldi	r25, 0x91	; 145
    37d0:	99 83       	std	Y+1, r25	; 0x01
	Buffer[1]=value;
    37d2:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    37d4:	42 e0       	ldi	r20, 0x02	; 2
    37d6:	be 01       	movw	r22, r28
    37d8:	6f 5f       	subi	r22, 0xFF	; 255
    37da:	7f 4f       	sbci	r23, 0xFF	; 255
    37dc:	89 e2       	ldi	r24, 0x29	; 41
    37de:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    37e2:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    37e4:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    37e6:	42 e0       	ldi	r20, 0x02	; 2
    37e8:	be 01       	movw	r22, r28
    37ea:	6f 5f       	subi	r22, 0xFF	; 255
    37ec:	7f 4f       	sbci	r23, 0xFF	; 255
    37ee:	89 e2       	ldi	r24, 0x29	; 41
    37f0:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    37f4:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    37f6:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    37f8:	42 e0       	ldi	r20, 0x02	; 2
    37fa:	be 01       	movw	r22, r28
    37fc:	6f 5f       	subi	r22, 0xFF	; 255
    37fe:	7f 4f       	sbci	r23, 0xFF	; 255
    3800:	89 e2       	ldi	r24, 0x29	; 41
    3802:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3806:	09 83       	std	Y+1, r16	; 0x01
	Buffer[1]=value;
    3808:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    380a:	42 e0       	ldi	r20, 0x02	; 2
    380c:	be 01       	movw	r22, r28
    380e:	6f 5f       	subi	r22, 0xFF	; 255
    3810:	7f 4f       	sbci	r23, 0xFF	; 255
    3812:	89 e2       	ldi	r24, 0x29	; 41
    3814:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3818:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    381a:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    381c:	42 e0       	ldi	r20, 0x02	; 2
    381e:	be 01       	movw	r22, r28
    3820:	6f 5f       	subi	r22, 0xFF	; 255
    3822:	7f 4f       	sbci	r23, 0xFF	; 255
    3824:	89 e2       	ldi	r24, 0x29	; 41
    3826:	0e 94 74 10 	call	0x20e8	; 0x20e8 <TWIMWrite>
	return true;
}

static void startTimeout(void)
{
	timeout_start_ticks=portGET_RUN_TIME_COUNTER_VALUE();
    382a:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    382e:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3832:	80 91 6e 2e 	lds	r24, 0x2E6E	; 0x802e6e <StatsTimer>
    3836:	90 91 6f 2e 	lds	r25, 0x2E6F	; 0x802e6f <StatsTimer+0x1>
    383a:	a0 91 70 2e 	lds	r26, 0x2E70	; 0x802e70 <StatsTimer+0x2>
    383e:	b0 91 71 2e 	lds	r27, 0x2E71	; 0x802e71 <StatsTimer+0x3>
    3842:	82 0f       	add	r24, r18
    3844:	93 1f       	adc	r25, r19
    3846:	a1 1d       	adc	r26, r1
    3848:	b1 1d       	adc	r27, r1
    384a:	80 93 5c 2d 	sts	0x2D5C, r24	; 0x802d5c <timeout_start_ticks>
    384e:	90 93 5d 2d 	sts	0x2D5D, r25	; 0x802d5d <timeout_start_ticks+0x1>
    3852:	a0 93 5e 2d 	sts	0x2D5E, r26	; 0x802d5e <timeout_start_ticks+0x2>
    3856:	b0 93 5f 2d 	sts	0x2D5F, r27	; 0x802d5f <timeout_start_ticks+0x3>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    385a:	19 82       	std	Y+1, r1	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    385c:	01 e0       	ldi	r16, 0x01	; 1
    385e:	9e 01       	movw	r18, r28
    3860:	2f 5f       	subi	r18, 0xFF	; 255
    3862:	3f 4f       	sbci	r19, 0xFF	; 255
    3864:	41 e0       	ldi	r20, 0x01	; 1
    3866:	b9 01       	movw	r22, r18
    3868:	89 e2       	ldi	r24, 0x29	; 41
    386a:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    386e:	89 81       	ldd	r24, Y+1	; 0x01
	startTimeout();
	
	while (1)
	{
		readReg(SYSRANGE_START,&Data);
		if (! (Data & 0x01)) break;
    3870:	80 fd       	sbrc	r24, 0
    3872:	f3 cf       	rjmp	.-26     	; 0x385a <DriverVL53L0XReadSingle+0xe0>
			did_timeout = true;
			return 65535;
		}
	}

	return DriverVL53L0XReadContinuous();
    3874:	0e 94 73 1b 	call	0x36e6	; 0x36e6 <DriverVL53L0XReadContinuous>
}
    3878:	24 96       	adiw	r28, 0x04	; 4
    387a:	cd bf       	out	0x3d, r28	; 61
    387c:	de bf       	out	0x3e, r29	; 62
    387e:	df 91       	pop	r29
    3880:	cf 91       	pop	r28
    3882:	1f 91       	pop	r17
    3884:	0f 91       	pop	r16
    3886:	ff 90       	pop	r15
    3888:	08 95       	ret

0000388a <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    388a:	0f 93       	push	r16
    388c:	1f 93       	push	r17
    388e:	cf 93       	push	r28
    3890:	df 93       	push	r29
    3892:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    3894:	0e 94 7f 29 	call	0x52fe	; 0x52fe <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    3898:	80 91 61 2d 	lds	r24, 0x2D61	; 0x802d61 <xHeapHasBeenInitialised.4135>
    389c:	81 11       	cpse	r24, r1
    389e:	21 c0       	rjmp	.+66     	; 0x38e2 <pvPortMalloc+0x58>
{
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    38a0:	e0 91 72 2e 	lds	r30, 0x2E72	; 0x802e72 <ucHeap>
    38a4:	f0 91 73 2e 	lds	r31, 0x2E73	; 0x802e73 <ucHeap+0x1>

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    38a8:	cf 01       	movw	r24, r30
    38aa:	01 96       	adiw	r24, 0x01	; 1
    38ac:	80 93 66 2d 	sts	0x2D66, r24	; 0x802d66 <xStart>
    38b0:	90 93 67 2d 	sts	0x2D67, r25	; 0x802d67 <xStart+0x1>
	xStart.xBlockSize = ( size_t ) 0;
    38b4:	10 92 68 2d 	sts	0x2D68, r1	; 0x802d68 <xStart+0x2>
    38b8:	10 92 69 2d 	sts	0x2D69, r1	; 0x802d69 <xStart+0x3>

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    38bc:	8f ef       	ldi	r24, 0xFF	; 255
    38be:	9f e3       	ldi	r25, 0x3F	; 63
    38c0:	80 93 64 2d 	sts	0x2D64, r24	; 0x802d64 <xEnd+0x2>
    38c4:	90 93 65 2d 	sts	0x2D65, r25	; 0x802d65 <xEnd+0x3>
	xEnd.pxNextFreeBlock = NULL;
    38c8:	10 92 62 2d 	sts	0x2D62, r1	; 0x802d62 <xEnd>
    38cc:	10 92 63 2d 	sts	0x2D63, r1	; 0x802d63 <xEnd+0x1>

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
    38d0:	83 83       	std	Z+3, r24	; 0x03
    38d2:	94 83       	std	Z+4, r25	; 0x04
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    38d4:	82 e6       	ldi	r24, 0x62	; 98
    38d6:	9d e2       	ldi	r25, 0x2D	; 45
    38d8:	81 83       	std	Z+1, r24	; 0x01
    38da:	92 83       	std	Z+2, r25	; 0x02
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
    38dc:	81 e0       	ldi	r24, 0x01	; 1
    38de:	80 93 61 2d 	sts	0x2D61, r24	; 0x802d61 <xHeapHasBeenInitialised.4135>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    38e2:	20 97       	sbiw	r28, 0x00	; 0
    38e4:	09 f4       	brne	.+2      	; 0x38e8 <pvPortMalloc+0x5e>
    38e6:	64 c0       	rjmp	.+200    	; 0x39b0 <pvPortMalloc+0x126>
		{
			xWantedSize += heapSTRUCT_SIZE;
    38e8:	ae 01       	movw	r20, r28
    38ea:	4c 5f       	subi	r20, 0xFC	; 252
    38ec:	5f 4f       	sbci	r21, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
    38ee:	23 96       	adiw	r28, 0x03	; 3
    38f0:	ce 3f       	cpi	r28, 0xFE	; 254
    38f2:	df 43       	sbci	r29, 0x3F	; 63
    38f4:	08 f0       	brcs	.+2      	; 0x38f8 <pvPortMalloc+0x6e>
    38f6:	5c c0       	rjmp	.+184    	; 0x39b0 <pvPortMalloc+0x126>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    38f8:	e0 91 66 2d 	lds	r30, 0x2D66	; 0x802d66 <xStart>
    38fc:	f0 91 67 2d 	lds	r31, 0x2D67	; 0x802d67 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    3900:	a6 e6       	ldi	r26, 0x66	; 102
    3902:	bd e2       	ldi	r27, 0x2D	; 45
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    3904:	06 c0       	rjmp	.+12     	; 0x3912 <pvPortMalloc+0x88>
    3906:	80 81       	ld	r24, Z
    3908:	91 81       	ldd	r25, Z+1	; 0x01
    390a:	00 97       	sbiw	r24, 0x00	; 0
    390c:	39 f0       	breq	.+14     	; 0x391c <pvPortMalloc+0x92>
    390e:	df 01       	movw	r26, r30
    3910:	fc 01       	movw	r30, r24
    3912:	22 81       	ldd	r18, Z+2	; 0x02
    3914:	33 81       	ldd	r19, Z+3	; 0x03
    3916:	24 17       	cp	r18, r20
    3918:	35 07       	cpc	r19, r21
    391a:	a8 f3       	brcs	.-22     	; 0x3906 <pvPortMalloc+0x7c>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    391c:	cd e2       	ldi	r28, 0x2D	; 45
    391e:	e2 36       	cpi	r30, 0x62	; 98
    3920:	fc 07       	cpc	r31, r28
    3922:	09 f4       	brne	.+2      	; 0x3926 <pvPortMalloc+0x9c>
    3924:	45 c0       	rjmp	.+138    	; 0x39b0 <pvPortMalloc+0x126>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    3926:	cd 91       	ld	r28, X+
    3928:	dc 91       	ld	r29, X
    392a:	11 97       	sbiw	r26, 0x01	; 1
    392c:	8e 01       	movw	r16, r28
    392e:	0c 5f       	subi	r16, 0xFC	; 252
    3930:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    3932:	80 81       	ld	r24, Z
    3934:	91 81       	ldd	r25, Z+1	; 0x01
    3936:	8d 93       	st	X+, r24
    3938:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    393a:	c9 01       	movw	r24, r18
    393c:	84 1b       	sub	r24, r20
    393e:	95 0b       	sbc	r25, r21
    3940:	89 30       	cpi	r24, 0x09	; 9
    3942:	91 05       	cpc	r25, r1
    3944:	00 f1       	brcs	.+64     	; 0x3986 <pvPortMalloc+0xfc>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    3946:	bf 01       	movw	r22, r30
    3948:	64 0f       	add	r22, r20
    394a:	75 1f       	adc	r23, r21

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    394c:	db 01       	movw	r26, r22
    394e:	12 96       	adiw	r26, 0x02	; 2
    3950:	8d 93       	st	X+, r24
    3952:	9c 93       	st	X, r25
    3954:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    3956:	42 83       	std	Z+2, r20	; 0x02
    3958:	53 83       	std	Z+3, r21	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    395a:	12 96       	adiw	r26, 0x02	; 2
    395c:	2d 91       	ld	r18, X+
    395e:	3c 91       	ld	r19, X
    3960:	13 97       	sbiw	r26, 0x03	; 3
    3962:	a6 e6       	ldi	r26, 0x66	; 102
    3964:	bd e2       	ldi	r27, 0x2D	; 45
    3966:	01 c0       	rjmp	.+2      	; 0x396a <pvPortMalloc+0xe0>
    3968:	df 01       	movw	r26, r30
    396a:	ed 91       	ld	r30, X+
    396c:	fc 91       	ld	r31, X
    396e:	11 97       	sbiw	r26, 0x01	; 1
    3970:	82 81       	ldd	r24, Z+2	; 0x02
    3972:	93 81       	ldd	r25, Z+3	; 0x03
    3974:	82 17       	cp	r24, r18
    3976:	93 07       	cpc	r25, r19
    3978:	b8 f3       	brcs	.-18     	; 0x3968 <pvPortMalloc+0xde>
    397a:	eb 01       	movw	r28, r22
    397c:	e8 83       	st	Y, r30
    397e:	f9 83       	std	Y+1, r31	; 0x01
    3980:	6d 93       	st	X+, r22
    3982:	7c 93       	st	X, r23

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
		{
			xWantedSize += heapSTRUCT_SIZE;
    3984:	9a 01       	movw	r18, r20

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
    3986:	80 91 14 20 	lds	r24, 0x2014	; 0x802014 <xFreeBytesRemaining>
    398a:	90 91 15 20 	lds	r25, 0x2015	; 0x802015 <xFreeBytesRemaining+0x1>
    398e:	82 1b       	sub	r24, r18
    3990:	93 0b       	sbc	r25, r19
    3992:	80 93 14 20 	sts	0x2014, r24	; 0x802014 <xFreeBytesRemaining>
    3996:	90 93 15 20 	sts	0x2015, r25	; 0x802015 <xFreeBytesRemaining+0x1>
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    399a:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
    399e:	01 15       	cp	r16, r1
    39a0:	11 05       	cpc	r17, r1
    39a2:	41 f0       	breq	.+16     	; 0x39b4 <pvPortMalloc+0x12a>
		}
	}
	#endif

	return pvReturn;
}
    39a4:	c8 01       	movw	r24, r16
    39a6:	df 91       	pop	r29
    39a8:	cf 91       	pop	r28
    39aa:	1f 91       	pop	r17
    39ac:	0f 91       	pop	r16
    39ae:	08 95       	ret
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    39b0:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>
	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
    39b4:	0e 94 7c 30 	call	0x60f8	; 0x60f8 <vApplicationMallocFailedHook>
    39b8:	00 e0       	ldi	r16, 0x00	; 0
    39ba:	10 e0       	ldi	r17, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
}
    39bc:	c8 01       	movw	r24, r16
    39be:	df 91       	pop	r29
    39c0:	cf 91       	pop	r28
    39c2:	1f 91       	pop	r17
    39c4:	0f 91       	pop	r16
    39c6:	08 95       	ret

000039c8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    39c8:	cf 93       	push	r28
    39ca:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    39cc:	00 97       	sbiw	r24, 0x00	; 0
    39ce:	21 f1       	breq	.+72     	; 0x3a18 <vPortFree+0x50>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    39d0:	ec 01       	movw	r28, r24
    39d2:	24 97       	sbiw	r28, 0x04	; 4

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    39d4:	0e 94 7f 29 	call	0x52fe	; 0x52fe <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    39d8:	4a 81       	ldd	r20, Y+2	; 0x02
    39da:	5b 81       	ldd	r21, Y+3	; 0x03
    39dc:	a6 e6       	ldi	r26, 0x66	; 102
    39de:	bd e2       	ldi	r27, 0x2D	; 45
    39e0:	01 c0       	rjmp	.+2      	; 0x39e4 <vPortFree+0x1c>
    39e2:	df 01       	movw	r26, r30
    39e4:	ed 91       	ld	r30, X+
    39e6:	fc 91       	ld	r31, X
    39e8:	11 97       	sbiw	r26, 0x01	; 1
    39ea:	22 81       	ldd	r18, Z+2	; 0x02
    39ec:	33 81       	ldd	r19, Z+3	; 0x03
    39ee:	24 17       	cp	r18, r20
    39f0:	35 07       	cpc	r19, r21
    39f2:	b8 f3       	brcs	.-18     	; 0x39e2 <vPortFree+0x1a>
    39f4:	e8 83       	st	Y, r30
    39f6:	f9 83       	std	Y+1, r31	; 0x01
    39f8:	cd 93       	st	X+, r28
    39fa:	dc 93       	st	X, r29
			xFreeBytesRemaining += pxLink->xBlockSize;
    39fc:	80 91 14 20 	lds	r24, 0x2014	; 0x802014 <xFreeBytesRemaining>
    3a00:	90 91 15 20 	lds	r25, 0x2015	; 0x802015 <xFreeBytesRemaining+0x1>
    3a04:	48 0f       	add	r20, r24
    3a06:	59 1f       	adc	r21, r25
    3a08:	40 93 14 20 	sts	0x2014, r20	; 0x802014 <xFreeBytesRemaining>
    3a0c:	50 93 15 20 	sts	0x2015, r21	; 0x802015 <xFreeBytesRemaining+0x1>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
	}
}
    3a10:	df 91       	pop	r29
    3a12:	cf 91       	pop	r28
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
			xFreeBytesRemaining += pxLink->xBlockSize;
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
    3a14:	0c 94 7b 2a 	jmp	0x54f6	; 0x54f6 <xTaskResumeAll>
	}
}
    3a18:	df 91       	pop	r29
    3a1a:	cf 91       	pop	r28
    3a1c:	08 95       	ret

00003a1e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    3a1e:	80 91 14 20 	lds	r24, 0x2014	; 0x802014 <xFreeBytesRemaining>
    3a22:	90 91 15 20 	lds	r25, 0x2015	; 0x802015 <xFreeBytesRemaining+0x1>
    3a26:	08 95       	ret

00003a28 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    3a28:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3a2a:	03 96       	adiw	r24, 0x03	; 3
    3a2c:	81 83       	std	Z+1, r24	; 0x01
    3a2e:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    3a30:	2f ef       	ldi	r18, 0xFF	; 255
    3a32:	3f ef       	ldi	r19, 0xFF	; 255
    3a34:	23 83       	std	Z+3, r18	; 0x03
    3a36:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3a38:	85 83       	std	Z+5, r24	; 0x05
    3a3a:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3a3c:	87 83       	std	Z+7, r24	; 0x07
    3a3e:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    3a40:	10 82       	st	Z, r1
    3a42:	08 95       	ret

00003a44 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    3a44:	fc 01       	movw	r30, r24
    3a46:	10 86       	std	Z+8, r1	; 0x08
    3a48:	11 86       	std	Z+9, r1	; 0x09
    3a4a:	08 95       	ret

00003a4c <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    3a4c:	cf 93       	push	r28
    3a4e:	df 93       	push	r29
    3a50:	9c 01       	movw	r18, r24
    3a52:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    3a54:	dc 01       	movw	r26, r24
    3a56:	11 96       	adiw	r26, 0x01	; 1
    3a58:	cd 91       	ld	r28, X+
    3a5a:	dc 91       	ld	r29, X
    3a5c:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    3a5e:	c2 83       	std	Z+2, r28	; 0x02
    3a60:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    3a62:	8c 81       	ldd	r24, Y+4	; 0x04
    3a64:	9d 81       	ldd	r25, Y+5	; 0x05
    3a66:	84 83       	std	Z+4, r24	; 0x04
    3a68:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    3a6a:	8c 81       	ldd	r24, Y+4	; 0x04
    3a6c:	9d 81       	ldd	r25, Y+5	; 0x05
    3a6e:	dc 01       	movw	r26, r24
    3a70:	12 96       	adiw	r26, 0x02	; 2
    3a72:	6d 93       	st	X+, r22
    3a74:	7c 93       	st	X, r23
    3a76:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    3a78:	6c 83       	std	Y+4, r22	; 0x04
    3a7a:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    3a7c:	20 87       	std	Z+8, r18	; 0x08
    3a7e:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    3a80:	f9 01       	movw	r30, r18
    3a82:	80 81       	ld	r24, Z
    3a84:	8f 5f       	subi	r24, 0xFF	; 255
    3a86:	80 83       	st	Z, r24
}
    3a88:	df 91       	pop	r29
    3a8a:	cf 91       	pop	r28
    3a8c:	08 95       	ret

00003a8e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    3a8e:	cf 93       	push	r28
    3a90:	df 93       	push	r29
    3a92:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    3a94:	48 81       	ld	r20, Y
    3a96:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    3a98:	4f 3f       	cpi	r20, 0xFF	; 255
    3a9a:	2f ef       	ldi	r18, 0xFF	; 255
    3a9c:	52 07       	cpc	r21, r18
    3a9e:	01 f1       	breq	.+64     	; 0x3ae0 <vListInsert+0x52>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    3aa0:	dc 01       	movw	r26, r24
    3aa2:	13 96       	adiw	r26, 0x03	; 3
    3aa4:	01 c0       	rjmp	.+2      	; 0x3aa8 <vListInsert+0x1a>
    3aa6:	df 01       	movw	r26, r30
    3aa8:	12 96       	adiw	r26, 0x02	; 2
    3aaa:	ed 91       	ld	r30, X+
    3aac:	fc 91       	ld	r31, X
    3aae:	13 97       	sbiw	r26, 0x03	; 3
    3ab0:	20 81       	ld	r18, Z
    3ab2:	31 81       	ldd	r19, Z+1	; 0x01
    3ab4:	42 17       	cp	r20, r18
    3ab6:	53 07       	cpc	r21, r19
    3ab8:	b0 f7       	brcc	.-20     	; 0x3aa6 <vListInsert+0x18>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    3aba:	ea 83       	std	Y+2, r30	; 0x02
    3abc:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3abe:	c4 83       	std	Z+4, r28	; 0x04
    3ac0:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    3ac2:	ac 83       	std	Y+4, r26	; 0x04
    3ac4:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    3ac6:	12 96       	adiw	r26, 0x02	; 2
    3ac8:	cd 93       	st	X+, r28
    3aca:	dc 93       	st	X, r29
    3acc:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    3ace:	88 87       	std	Y+8, r24	; 0x08
    3ad0:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    3ad2:	fc 01       	movw	r30, r24
    3ad4:	20 81       	ld	r18, Z
    3ad6:	2f 5f       	subi	r18, 0xFF	; 255
    3ad8:	20 83       	st	Z, r18
}
    3ada:	df 91       	pop	r29
    3adc:	cf 91       	pop	r28
    3ade:	08 95       	ret
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    3ae0:	fc 01       	movw	r30, r24
    3ae2:	a7 81       	ldd	r26, Z+7	; 0x07
    3ae4:	b0 85       	ldd	r27, Z+8	; 0x08
    3ae6:	12 96       	adiw	r26, 0x02	; 2
    3ae8:	ed 91       	ld	r30, X+
    3aea:	fc 91       	ld	r31, X
    3aec:	13 97       	sbiw	r26, 0x03	; 3
    3aee:	e5 cf       	rjmp	.-54     	; 0x3aba <vListInsert+0x2c>

00003af0 <uxListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    3af0:	cf 93       	push	r28
    3af2:	df 93       	push	r29
    3af4:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    3af6:	a0 85       	ldd	r26, Z+8	; 0x08
    3af8:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3afa:	22 81       	ldd	r18, Z+2	; 0x02
    3afc:	33 81       	ldd	r19, Z+3	; 0x03
    3afe:	84 81       	ldd	r24, Z+4	; 0x04
    3b00:	95 81       	ldd	r25, Z+5	; 0x05
    3b02:	e9 01       	movw	r28, r18
    3b04:	8c 83       	std	Y+4, r24	; 0x04
    3b06:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3b08:	84 81       	ldd	r24, Z+4	; 0x04
    3b0a:	95 81       	ldd	r25, Z+5	; 0x05
    3b0c:	ec 01       	movw	r28, r24
    3b0e:	2a 83       	std	Y+2, r18	; 0x02
    3b10:	3b 83       	std	Y+3, r19	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    3b12:	11 96       	adiw	r26, 0x01	; 1
    3b14:	2d 91       	ld	r18, X+
    3b16:	3c 91       	ld	r19, X
    3b18:	12 97       	sbiw	r26, 0x02	; 2
    3b1a:	e2 17       	cp	r30, r18
    3b1c:	f3 07       	cpc	r31, r19
    3b1e:	49 f0       	breq	.+18     	; 0x3b32 <uxListRemove+0x42>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    3b20:	10 86       	std	Z+8, r1	; 0x08
    3b22:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    3b24:	8c 91       	ld	r24, X
    3b26:	81 50       	subi	r24, 0x01	; 1
    3b28:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    3b2a:	8c 91       	ld	r24, X
}
    3b2c:	df 91       	pop	r29
    3b2e:	cf 91       	pop	r28
    3b30:	08 95       	ret
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    3b32:	11 96       	adiw	r26, 0x01	; 1
    3b34:	8d 93       	st	X+, r24
    3b36:	9c 93       	st	X, r25
    3b38:	12 97       	sbiw	r26, 0x02	; 2
    3b3a:	f2 cf       	rjmp	.-28     	; 0x3b20 <uxListRemove+0x30>

00003b3c <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    3b3c:	31 e1       	ldi	r19, 0x11	; 17
    3b3e:	fc 01       	movw	r30, r24
    3b40:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    3b42:	31 97       	sbiw	r30, 0x01	; 1
    3b44:	22 e2       	ldi	r18, 0x22	; 34
    3b46:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    3b48:	31 97       	sbiw	r30, 0x01	; 1
    3b4a:	a3 e3       	ldi	r26, 0x33	; 51
    3b4c:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3b4e:	31 97       	sbiw	r30, 0x01	; 1
    3b50:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3b52:	31 97       	sbiw	r30, 0x01	; 1
    3b54:	70 83       	st	Z, r23
	pxTopOfStack--;

#if defined(__AVR_3_BYTE_PC__) && __AVR_3_BYTE_PC__   //MCU's with more than 128kB of program memory: PC is 3 bytes
	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3b56:	31 97       	sbiw	r30, 0x01	; 1
    3b58:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    3b5a:	31 97       	sbiw	r30, 0x01	; 1
    3b5c:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    3b5e:	31 97       	sbiw	r30, 0x01	; 1
    3b60:	60 e8       	ldi	r22, 0x80	; 128
    3b62:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    3b64:	31 97       	sbiw	r30, 0x01	; 1
    3b66:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    3b68:	31 97       	sbiw	r30, 0x01	; 1
    3b6a:	62 e0       	ldi	r22, 0x02	; 2
    3b6c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    3b6e:	31 97       	sbiw	r30, 0x01	; 1
    3b70:	63 e0       	ldi	r22, 0x03	; 3
    3b72:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    3b74:	31 97       	sbiw	r30, 0x01	; 1
    3b76:	64 e0       	ldi	r22, 0x04	; 4
    3b78:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    3b7a:	31 97       	sbiw	r30, 0x01	; 1
    3b7c:	65 e0       	ldi	r22, 0x05	; 5
    3b7e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    3b80:	31 97       	sbiw	r30, 0x01	; 1
    3b82:	66 e0       	ldi	r22, 0x06	; 6
    3b84:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    3b86:	31 97       	sbiw	r30, 0x01	; 1
    3b88:	67 e0       	ldi	r22, 0x07	; 7
    3b8a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    3b8c:	31 97       	sbiw	r30, 0x01	; 1
    3b8e:	68 e0       	ldi	r22, 0x08	; 8
    3b90:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    3b92:	31 97       	sbiw	r30, 0x01	; 1
    3b94:	69 e0       	ldi	r22, 0x09	; 9
    3b96:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    3b98:	31 97       	sbiw	r30, 0x01	; 1
    3b9a:	60 e1       	ldi	r22, 0x10	; 16
    3b9c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    3b9e:	31 97       	sbiw	r30, 0x01	; 1
    3ba0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    3ba2:	31 97       	sbiw	r30, 0x01	; 1
    3ba4:	32 e1       	ldi	r19, 0x12	; 18
    3ba6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    3ba8:	31 97       	sbiw	r30, 0x01	; 1
    3baa:	33 e1       	ldi	r19, 0x13	; 19
    3bac:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    3bae:	31 97       	sbiw	r30, 0x01	; 1
    3bb0:	34 e1       	ldi	r19, 0x14	; 20
    3bb2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    3bb4:	31 97       	sbiw	r30, 0x01	; 1
    3bb6:	35 e1       	ldi	r19, 0x15	; 21
    3bb8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    3bba:	31 97       	sbiw	r30, 0x01	; 1
    3bbc:	36 e1       	ldi	r19, 0x16	; 22
    3bbe:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    3bc0:	31 97       	sbiw	r30, 0x01	; 1
    3bc2:	37 e1       	ldi	r19, 0x17	; 23
    3bc4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    3bc6:	31 97       	sbiw	r30, 0x01	; 1
    3bc8:	38 e1       	ldi	r19, 0x18	; 24
    3bca:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    3bcc:	31 97       	sbiw	r30, 0x01	; 1
    3bce:	39 e1       	ldi	r19, 0x19	; 25
    3bd0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    3bd2:	31 97       	sbiw	r30, 0x01	; 1
    3bd4:	30 e2       	ldi	r19, 0x20	; 32
    3bd6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    3bd8:	31 97       	sbiw	r30, 0x01	; 1
    3bda:	31 e2       	ldi	r19, 0x21	; 33
    3bdc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    3bde:	31 97       	sbiw	r30, 0x01	; 1
    3be0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    3be2:	31 97       	sbiw	r30, 0x01	; 1
    3be4:	23 e2       	ldi	r18, 0x23	; 35
    3be6:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3be8:	31 97       	sbiw	r30, 0x01	; 1
    3bea:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3bec:	31 97       	sbiw	r30, 0x01	; 1
    3bee:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    3bf0:	31 97       	sbiw	r30, 0x01	; 1
    3bf2:	26 e2       	ldi	r18, 0x26	; 38
    3bf4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    3bf6:	31 97       	sbiw	r30, 0x01	; 1
    3bf8:	27 e2       	ldi	r18, 0x27	; 39
    3bfa:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    3bfc:	31 97       	sbiw	r30, 0x01	; 1
    3bfe:	28 e2       	ldi	r18, 0x28	; 40
    3c00:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    3c02:	31 97       	sbiw	r30, 0x01	; 1
    3c04:	29 e2       	ldi	r18, 0x29	; 41
    3c06:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    3c08:	31 97       	sbiw	r30, 0x01	; 1
    3c0a:	20 e3       	ldi	r18, 0x30	; 48
    3c0c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    3c0e:	31 97       	sbiw	r30, 0x01	; 1
    3c10:	21 e3       	ldi	r18, 0x31	; 49
    3c12:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    3c14:	87 97       	sbiw	r24, 0x27	; 39
    3c16:	08 95       	ret

00003c18 <xPortStartScheduler>:
 */

static void prvSetupTimerInterrupt( void )
{
	//TCC0 is used as tick timer
	TCC0.CCA=65535;
    3c18:	e0 e0       	ldi	r30, 0x00	; 0
    3c1a:	f8 e0       	ldi	r31, 0x08	; 8
    3c1c:	8f ef       	ldi	r24, 0xFF	; 255
    3c1e:	9f ef       	ldi	r25, 0xFF	; 255
    3c20:	80 a7       	std	Z+40, r24	; 0x28
    3c22:	91 a7       	std	Z+41, r25	; 0x29
	TCC0.CTRLA=0b00000001; //DIV1
    3c24:	81 e0       	ldi	r24, 0x01	; 1
    3c26:	80 83       	st	Z, r24
	TCC0.CTRLB=1<<6;
    3c28:	90 e4       	ldi	r25, 0x40	; 64
    3c2a:	91 83       	std	Z+1, r25	; 0x01
	TCC0.INTCTRLA=0b00000001; //OVF priority LOW
    3c2c:	86 83       	std	Z+6, r24	; 0x06
	TCC0.INTCTRLB=0b00000001; //CCA priority LOW
    3c2e:	87 83       	std	Z+7, r24	; 0x07
	TCC0.PER=configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3c30:	80 e0       	ldi	r24, 0x00	; 0
    3c32:	9d e7       	ldi	r25, 0x7D	; 125
    3c34:	86 a3       	std	Z+38, r24	; 0x26
    3c36:	97 a3       	std	Z+39, r25	; 0x27
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3c38:	a0 91 08 2e 	lds	r26, 0x2E08	; 0x802e08 <pxCurrentTCB>
    3c3c:	b0 91 09 2e 	lds	r27, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    3c40:	cd 91       	ld	r28, X+
    3c42:	cd bf       	out	0x3d, r28	; 61
    3c44:	dd 91       	ld	r29, X+
    3c46:	de bf       	out	0x3e, r29	; 62
    3c48:	ff 91       	pop	r31
    3c4a:	ef 91       	pop	r30
    3c4c:	df 91       	pop	r29
    3c4e:	cf 91       	pop	r28
    3c50:	bf 91       	pop	r27
    3c52:	af 91       	pop	r26
    3c54:	9f 91       	pop	r25
    3c56:	8f 91       	pop	r24
    3c58:	7f 91       	pop	r23
    3c5a:	6f 91       	pop	r22
    3c5c:	5f 91       	pop	r21
    3c5e:	4f 91       	pop	r20
    3c60:	3f 91       	pop	r19
    3c62:	2f 91       	pop	r18
    3c64:	1f 91       	pop	r17
    3c66:	0f 91       	pop	r16
    3c68:	ff 90       	pop	r15
    3c6a:	ef 90       	pop	r14
    3c6c:	df 90       	pop	r13
    3c6e:	cf 90       	pop	r12
    3c70:	bf 90       	pop	r11
    3c72:	af 90       	pop	r10
    3c74:	9f 90       	pop	r9
    3c76:	8f 90       	pop	r8
    3c78:	7f 90       	pop	r7
    3c7a:	6f 90       	pop	r6
    3c7c:	5f 90       	pop	r5
    3c7e:	4f 90       	pop	r4
    3c80:	3f 90       	pop	r3
    3c82:	2f 90       	pop	r2
    3c84:	1f 90       	pop	r1
    3c86:	0f 90       	pop	r0
    3c88:	0f be       	out	0x3f, r0	; 63
    3c8a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3c8c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    3c8e:	81 e0       	ldi	r24, 0x01	; 1
    3c90:	08 95       	ret

00003c92 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3c92:	0f 92       	push	r0
    3c94:	0f b6       	in	r0, 0x3f	; 63
    3c96:	f8 94       	cli
    3c98:	0f 92       	push	r0
    3c9a:	1f 92       	push	r1
    3c9c:	11 24       	eor	r1, r1
    3c9e:	2f 92       	push	r2
    3ca0:	3f 92       	push	r3
    3ca2:	4f 92       	push	r4
    3ca4:	5f 92       	push	r5
    3ca6:	6f 92       	push	r6
    3ca8:	7f 92       	push	r7
    3caa:	8f 92       	push	r8
    3cac:	9f 92       	push	r9
    3cae:	af 92       	push	r10
    3cb0:	bf 92       	push	r11
    3cb2:	cf 92       	push	r12
    3cb4:	df 92       	push	r13
    3cb6:	ef 92       	push	r14
    3cb8:	ff 92       	push	r15
    3cba:	0f 93       	push	r16
    3cbc:	1f 93       	push	r17
    3cbe:	2f 93       	push	r18
    3cc0:	3f 93       	push	r19
    3cc2:	4f 93       	push	r20
    3cc4:	5f 93       	push	r21
    3cc6:	6f 93       	push	r22
    3cc8:	7f 93       	push	r23
    3cca:	8f 93       	push	r24
    3ccc:	9f 93       	push	r25
    3cce:	af 93       	push	r26
    3cd0:	bf 93       	push	r27
    3cd2:	cf 93       	push	r28
    3cd4:	df 93       	push	r29
    3cd6:	ef 93       	push	r30
    3cd8:	ff 93       	push	r31
    3cda:	a0 91 08 2e 	lds	r26, 0x2E08	; 0x802e08 <pxCurrentTCB>
    3cde:	b0 91 09 2e 	lds	r27, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    3ce2:	0d b6       	in	r0, 0x3d	; 61
    3ce4:	0d 92       	st	X+, r0
    3ce6:	0e b6       	in	r0, 0x3e	; 62
    3ce8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3cea:	0e 94 85 2b 	call	0x570a	; 0x570a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3cee:	a0 91 08 2e 	lds	r26, 0x2E08	; 0x802e08 <pxCurrentTCB>
    3cf2:	b0 91 09 2e 	lds	r27, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    3cf6:	cd 91       	ld	r28, X+
    3cf8:	cd bf       	out	0x3d, r28	; 61
    3cfa:	dd 91       	ld	r29, X+
    3cfc:	de bf       	out	0x3e, r29	; 62
    3cfe:	ff 91       	pop	r31
    3d00:	ef 91       	pop	r30
    3d02:	df 91       	pop	r29
    3d04:	cf 91       	pop	r28
    3d06:	bf 91       	pop	r27
    3d08:	af 91       	pop	r26
    3d0a:	9f 91       	pop	r25
    3d0c:	8f 91       	pop	r24
    3d0e:	7f 91       	pop	r23
    3d10:	6f 91       	pop	r22
    3d12:	5f 91       	pop	r21
    3d14:	4f 91       	pop	r20
    3d16:	3f 91       	pop	r19
    3d18:	2f 91       	pop	r18
    3d1a:	1f 91       	pop	r17
    3d1c:	0f 91       	pop	r16
    3d1e:	ff 90       	pop	r15
    3d20:	ef 90       	pop	r14
    3d22:	df 90       	pop	r13
    3d24:	cf 90       	pop	r12
    3d26:	bf 90       	pop	r11
    3d28:	af 90       	pop	r10
    3d2a:	9f 90       	pop	r9
    3d2c:	8f 90       	pop	r8
    3d2e:	7f 90       	pop	r7
    3d30:	6f 90       	pop	r6
    3d32:	5f 90       	pop	r5
    3d34:	4f 90       	pop	r4
    3d36:	3f 90       	pop	r3
    3d38:	2f 90       	pop	r2
    3d3a:	1f 90       	pop	r1
    3d3c:	0f 90       	pop	r0
    3d3e:	0f be       	out	0x3f, r0	; 63
    3d40:	0f 90       	pop	r0
	asm volatile ( "ret" );
    3d42:	08 95       	ret

00003d44 <vPortYieldISR>:
}*/

//void vPortYieldISR( void ) __attribute__ ( ( naked ) );
void vPortYieldISR( void )
{
	TCC0.CCA=TCC0.CNT+100;
    3d44:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3d48:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3d4c:	8c 59       	subi	r24, 0x9C	; 156
    3d4e:	9f 4f       	sbci	r25, 0xFF	; 255
    3d50:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    3d54:	90 93 29 08 	sts	0x0829, r25	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
	if (TCC0.CCA>=TCC0.PER) TCC0.CCA-= TCC0.PER;
    3d58:	20 91 28 08 	lds	r18, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    3d5c:	30 91 29 08 	lds	r19, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    3d60:	80 91 26 08 	lds	r24, 0x0826	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
    3d64:	90 91 27 08 	lds	r25, 0x0827	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
    3d68:	28 17       	cp	r18, r24
    3d6a:	39 07       	cpc	r19, r25
    3d6c:	70 f0       	brcs	.+28     	; 0x3d8a <vPortYieldISR+0x46>
    3d6e:	20 91 26 08 	lds	r18, 0x0826	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
    3d72:	30 91 27 08 	lds	r19, 0x0827	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
    3d76:	80 91 28 08 	lds	r24, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    3d7a:	90 91 29 08 	lds	r25, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    3d7e:	82 1b       	sub	r24, r18
    3d80:	93 0b       	sbc	r25, r19
    3d82:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    3d86:	90 93 29 08 	sts	0x0829, r25	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
	asm volatile ( "ret" );
    3d8a:	08 95       	ret

00003d8c <__vector_14>:
	 * the context is saved at the start of the ISR.  The tick
	 * count is incremented after the context is saved.
	 */	
	ISR(TCC0_OVF_vect,ISR_NAKED)
	{
		portSAVE_CONTEXT();
    3d8c:	0f 92       	push	r0
    3d8e:	0f b6       	in	r0, 0x3f	; 63
    3d90:	f8 94       	cli
    3d92:	0f 92       	push	r0
    3d94:	1f 92       	push	r1
    3d96:	11 24       	eor	r1, r1
    3d98:	2f 92       	push	r2
    3d9a:	3f 92       	push	r3
    3d9c:	4f 92       	push	r4
    3d9e:	5f 92       	push	r5
    3da0:	6f 92       	push	r6
    3da2:	7f 92       	push	r7
    3da4:	8f 92       	push	r8
    3da6:	9f 92       	push	r9
    3da8:	af 92       	push	r10
    3daa:	bf 92       	push	r11
    3dac:	cf 92       	push	r12
    3dae:	df 92       	push	r13
    3db0:	ef 92       	push	r14
    3db2:	ff 92       	push	r15
    3db4:	0f 93       	push	r16
    3db6:	1f 93       	push	r17
    3db8:	2f 93       	push	r18
    3dba:	3f 93       	push	r19
    3dbc:	4f 93       	push	r20
    3dbe:	5f 93       	push	r21
    3dc0:	6f 93       	push	r22
    3dc2:	7f 93       	push	r23
    3dc4:	8f 93       	push	r24
    3dc6:	9f 93       	push	r25
    3dc8:	af 93       	push	r26
    3dca:	bf 93       	push	r27
    3dcc:	cf 93       	push	r28
    3dce:	df 93       	push	r29
    3dd0:	ef 93       	push	r30
    3dd2:	ff 93       	push	r31
    3dd4:	a0 91 08 2e 	lds	r26, 0x2E08	; 0x802e08 <pxCurrentTCB>
    3dd8:	b0 91 09 2e 	lds	r27, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    3ddc:	0d b6       	in	r0, 0x3d	; 61
    3dde:	0d 92       	st	X+, r0
    3de0:	0e b6       	in	r0, 0x3e	; 62
    3de2:	0d 92       	st	X+, r0
		StatsTimer+=TCC0.PER;
    3de4:	20 91 26 08 	lds	r18, 0x0826	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
    3de8:	30 91 27 08 	lds	r19, 0x0827	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
    3dec:	80 91 6e 2e 	lds	r24, 0x2E6E	; 0x802e6e <StatsTimer>
    3df0:	90 91 6f 2e 	lds	r25, 0x2E6F	; 0x802e6f <StatsTimer+0x1>
    3df4:	a0 91 70 2e 	lds	r26, 0x2E70	; 0x802e70 <StatsTimer+0x2>
    3df8:	b0 91 71 2e 	lds	r27, 0x2E71	; 0x802e71 <StatsTimer+0x3>
    3dfc:	82 0f       	add	r24, r18
    3dfe:	93 1f       	adc	r25, r19
    3e00:	a1 1d       	adc	r26, r1
    3e02:	b1 1d       	adc	r27, r1
    3e04:	80 93 6e 2e 	sts	0x2E6E, r24	; 0x802e6e <StatsTimer>
    3e08:	90 93 6f 2e 	sts	0x2E6F, r25	; 0x802e6f <StatsTimer+0x1>
    3e0c:	a0 93 70 2e 	sts	0x2E70, r26	; 0x802e70 <StatsTimer+0x2>
    3e10:	b0 93 71 2e 	sts	0x2E71, r27	; 0x802e71 <StatsTimer+0x3>
		xTaskIncrementTick();
    3e14:	0e 94 a1 29 	call	0x5342	; 0x5342 <xTaskIncrementTick>
		vTaskSwitchContext();
    3e18:	0e 94 85 2b 	call	0x570a	; 0x570a <vTaskSwitchContext>
		portRESTORE_CONTEXT();
    3e1c:	a0 91 08 2e 	lds	r26, 0x2E08	; 0x802e08 <pxCurrentTCB>
    3e20:	b0 91 09 2e 	lds	r27, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    3e24:	cd 91       	ld	r28, X+
    3e26:	cd bf       	out	0x3d, r28	; 61
    3e28:	dd 91       	ld	r29, X+
    3e2a:	de bf       	out	0x3e, r29	; 62
    3e2c:	ff 91       	pop	r31
    3e2e:	ef 91       	pop	r30
    3e30:	df 91       	pop	r29
    3e32:	cf 91       	pop	r28
    3e34:	bf 91       	pop	r27
    3e36:	af 91       	pop	r26
    3e38:	9f 91       	pop	r25
    3e3a:	8f 91       	pop	r24
    3e3c:	7f 91       	pop	r23
    3e3e:	6f 91       	pop	r22
    3e40:	5f 91       	pop	r21
    3e42:	4f 91       	pop	r20
    3e44:	3f 91       	pop	r19
    3e46:	2f 91       	pop	r18
    3e48:	1f 91       	pop	r17
    3e4a:	0f 91       	pop	r16
    3e4c:	ff 90       	pop	r15
    3e4e:	ef 90       	pop	r14
    3e50:	df 90       	pop	r13
    3e52:	cf 90       	pop	r12
    3e54:	bf 90       	pop	r11
    3e56:	af 90       	pop	r10
    3e58:	9f 90       	pop	r9
    3e5a:	8f 90       	pop	r8
    3e5c:	7f 90       	pop	r7
    3e5e:	6f 90       	pop	r6
    3e60:	5f 90       	pop	r5
    3e62:	4f 90       	pop	r4
    3e64:	3f 90       	pop	r3
    3e66:	2f 90       	pop	r2
    3e68:	1f 90       	pop	r1
    3e6a:	0f 90       	pop	r0
    3e6c:	0f be       	out	0x3f, r0	; 63
    3e6e:	0f 90       	pop	r0

		asm volatile ( "reti" );
    3e70:	18 95       	reti

00003e72 <vConfigureTimerForRunTimeStats>:
 */

volatile uint32_t StatsTimer;

void vConfigureTimerForRunTimeStats(void)
{
    3e72:	08 95       	ret

00003e74 <__vector_16>:
	//TCC1.INTCTRLA=0b00000001; //OVF priority LOW
}

ISR(TCC0_CCA_vect,ISR_NAKED)
	{
	portSAVE_CONTEXT();
    3e74:	0f 92       	push	r0
    3e76:	0f b6       	in	r0, 0x3f	; 63
    3e78:	f8 94       	cli
    3e7a:	0f 92       	push	r0
    3e7c:	1f 92       	push	r1
    3e7e:	11 24       	eor	r1, r1
    3e80:	2f 92       	push	r2
    3e82:	3f 92       	push	r3
    3e84:	4f 92       	push	r4
    3e86:	5f 92       	push	r5
    3e88:	6f 92       	push	r6
    3e8a:	7f 92       	push	r7
    3e8c:	8f 92       	push	r8
    3e8e:	9f 92       	push	r9
    3e90:	af 92       	push	r10
    3e92:	bf 92       	push	r11
    3e94:	cf 92       	push	r12
    3e96:	df 92       	push	r13
    3e98:	ef 92       	push	r14
    3e9a:	ff 92       	push	r15
    3e9c:	0f 93       	push	r16
    3e9e:	1f 93       	push	r17
    3ea0:	2f 93       	push	r18
    3ea2:	3f 93       	push	r19
    3ea4:	4f 93       	push	r20
    3ea6:	5f 93       	push	r21
    3ea8:	6f 93       	push	r22
    3eaa:	7f 93       	push	r23
    3eac:	8f 93       	push	r24
    3eae:	9f 93       	push	r25
    3eb0:	af 93       	push	r26
    3eb2:	bf 93       	push	r27
    3eb4:	cf 93       	push	r28
    3eb6:	df 93       	push	r29
    3eb8:	ef 93       	push	r30
    3eba:	ff 93       	push	r31
    3ebc:	a0 91 08 2e 	lds	r26, 0x2E08	; 0x802e08 <pxCurrentTCB>
    3ec0:	b0 91 09 2e 	lds	r27, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    3ec4:	0d b6       	in	r0, 0x3d	; 61
    3ec6:	0d 92       	st	X+, r0
    3ec8:	0e b6       	in	r0, 0x3e	; 62
    3eca:	0d 92       	st	X+, r0
	TCC0.CCA=65535;
    3ecc:	8f ef       	ldi	r24, 0xFF	; 255
    3ece:	9f ef       	ldi	r25, 0xFF	; 255
    3ed0:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    3ed4:	90 93 29 08 	sts	0x0829, r25	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
	vTaskSwitchContext();
    3ed8:	0e 94 85 2b 	call	0x570a	; 0x570a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3edc:	a0 91 08 2e 	lds	r26, 0x2E08	; 0x802e08 <pxCurrentTCB>
    3ee0:	b0 91 09 2e 	lds	r27, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    3ee4:	cd 91       	ld	r28, X+
    3ee6:	cd bf       	out	0x3d, r28	; 61
    3ee8:	dd 91       	ld	r29, X+
    3eea:	de bf       	out	0x3e, r29	; 62
    3eec:	ff 91       	pop	r31
    3eee:	ef 91       	pop	r30
    3ef0:	df 91       	pop	r29
    3ef2:	cf 91       	pop	r28
    3ef4:	bf 91       	pop	r27
    3ef6:	af 91       	pop	r26
    3ef8:	9f 91       	pop	r25
    3efa:	8f 91       	pop	r24
    3efc:	7f 91       	pop	r23
    3efe:	6f 91       	pop	r22
    3f00:	5f 91       	pop	r21
    3f02:	4f 91       	pop	r20
    3f04:	3f 91       	pop	r19
    3f06:	2f 91       	pop	r18
    3f08:	1f 91       	pop	r17
    3f0a:	0f 91       	pop	r16
    3f0c:	ff 90       	pop	r15
    3f0e:	ef 90       	pop	r14
    3f10:	df 90       	pop	r13
    3f12:	cf 90       	pop	r12
    3f14:	bf 90       	pop	r11
    3f16:	af 90       	pop	r10
    3f18:	9f 90       	pop	r9
    3f1a:	8f 90       	pop	r8
    3f1c:	7f 90       	pop	r7
    3f1e:	6f 90       	pop	r6
    3f20:	5f 90       	pop	r5
    3f22:	4f 90       	pop	r4
    3f24:	3f 90       	pop	r3
    3f26:	2f 90       	pop	r2
    3f28:	1f 90       	pop	r1
    3f2a:	0f 90       	pop	r0
    3f2c:	0f be       	out	0x3f, r0	; 63
    3f2e:	0f 90       	pop	r0
	asm volatile ( "reti" );
    3f30:	18 95       	reti

00003f32 <prvCopyDataToQueue>:
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
    3f32:	0f 93       	push	r16
    3f34:	1f 93       	push	r17
    3f36:	cf 93       	push	r28
    3f38:	df 93       	push	r29
    3f3a:	ec 01       	movw	r28, r24
    3f3c:	04 2f       	mov	r16, r20
    3f3e:	1a 8d       	ldd	r17, Y+26	; 0x1a
    3f40:	4c 8d       	ldd	r20, Y+28	; 0x1c
    3f42:	41 11       	cpse	r20, r1
    3f44:	0d c0       	rjmp	.+26     	; 0x3f60 <prvCopyDataToQueue+0x2e>
    3f46:	88 81       	ld	r24, Y
    3f48:	99 81       	ldd	r25, Y+1	; 0x01
    3f4a:	89 2b       	or	r24, r25
    3f4c:	09 f4       	brne	.+2      	; 0x3f50 <prvCopyDataToQueue+0x1e>
    3f4e:	43 c0       	rjmp	.+134    	; 0x3fd6 <prvCopyDataToQueue+0xa4>
    3f50:	1f 5f       	subi	r17, 0xFF	; 255
    3f52:	80 e0       	ldi	r24, 0x00	; 0
    3f54:	1a 8f       	std	Y+26, r17	; 0x1a
    3f56:	df 91       	pop	r29
    3f58:	cf 91       	pop	r28
    3f5a:	1f 91       	pop	r17
    3f5c:	0f 91       	pop	r16
    3f5e:	08 95       	ret
    3f60:	50 e0       	ldi	r21, 0x00	; 0
    3f62:	01 11       	cpse	r16, r1
    3f64:	15 c0       	rjmp	.+42     	; 0x3f90 <prvCopyDataToQueue+0x5e>
    3f66:	8a 81       	ldd	r24, Y+2	; 0x02
    3f68:	9b 81       	ldd	r25, Y+3	; 0x03
    3f6a:	0e 94 0e 50 	call	0xa01c	; 0xa01c <memcpy>
    3f6e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3f70:	8a 81       	ldd	r24, Y+2	; 0x02
    3f72:	9b 81       	ldd	r25, Y+3	; 0x03
    3f74:	82 0f       	add	r24, r18
    3f76:	91 1d       	adc	r25, r1
    3f78:	8a 83       	std	Y+2, r24	; 0x02
    3f7a:	9b 83       	std	Y+3, r25	; 0x03
    3f7c:	2c 81       	ldd	r18, Y+4	; 0x04
    3f7e:	3d 81       	ldd	r19, Y+5	; 0x05
    3f80:	82 17       	cp	r24, r18
    3f82:	93 07       	cpc	r25, r19
    3f84:	28 f3       	brcs	.-54     	; 0x3f50 <prvCopyDataToQueue+0x1e>
    3f86:	88 81       	ld	r24, Y
    3f88:	99 81       	ldd	r25, Y+1	; 0x01
    3f8a:	8a 83       	std	Y+2, r24	; 0x02
    3f8c:	9b 83       	std	Y+3, r25	; 0x03
    3f8e:	e0 cf       	rjmp	.-64     	; 0x3f50 <prvCopyDataToQueue+0x1e>
    3f90:	8e 81       	ldd	r24, Y+6	; 0x06
    3f92:	9f 81       	ldd	r25, Y+7	; 0x07
    3f94:	0e 94 0e 50 	call	0xa01c	; 0xa01c <memcpy>
    3f98:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3f9a:	90 e0       	ldi	r25, 0x00	; 0
    3f9c:	91 95       	neg	r25
    3f9e:	81 95       	neg	r24
    3fa0:	91 09       	sbc	r25, r1
    3fa2:	2e 81       	ldd	r18, Y+6	; 0x06
    3fa4:	3f 81       	ldd	r19, Y+7	; 0x07
    3fa6:	28 0f       	add	r18, r24
    3fa8:	39 1f       	adc	r19, r25
    3faa:	2e 83       	std	Y+6, r18	; 0x06
    3fac:	3f 83       	std	Y+7, r19	; 0x07
    3fae:	48 81       	ld	r20, Y
    3fb0:	59 81       	ldd	r21, Y+1	; 0x01
    3fb2:	24 17       	cp	r18, r20
    3fb4:	35 07       	cpc	r19, r21
    3fb6:	30 f4       	brcc	.+12     	; 0x3fc4 <prvCopyDataToQueue+0x92>
    3fb8:	2c 81       	ldd	r18, Y+4	; 0x04
    3fba:	3d 81       	ldd	r19, Y+5	; 0x05
    3fbc:	82 0f       	add	r24, r18
    3fbe:	93 1f       	adc	r25, r19
    3fc0:	8e 83       	std	Y+6, r24	; 0x06
    3fc2:	9f 83       	std	Y+7, r25	; 0x07
    3fc4:	02 30       	cpi	r16, 0x02	; 2
    3fc6:	21 f6       	brne	.-120    	; 0x3f50 <prvCopyDataToQueue+0x1e>
    3fc8:	11 23       	and	r17, r17
    3fca:	11 f0       	breq	.+4      	; 0x3fd0 <prvCopyDataToQueue+0x9e>
    3fcc:	80 e0       	ldi	r24, 0x00	; 0
    3fce:	c2 cf       	rjmp	.-124    	; 0x3f54 <prvCopyDataToQueue+0x22>
    3fd0:	11 e0       	ldi	r17, 0x01	; 1
    3fd2:	80 e0       	ldi	r24, 0x00	; 0
    3fd4:	bf cf       	rjmp	.-130    	; 0x3f54 <prvCopyDataToQueue+0x22>
    3fd6:	8c 81       	ldd	r24, Y+4	; 0x04
    3fd8:	9d 81       	ldd	r25, Y+5	; 0x05
    3fda:	0e 94 79 2e 	call	0x5cf2	; 0x5cf2 <xTaskPriorityDisinherit>
    3fde:	1c 82       	std	Y+4, r1	; 0x04
    3fe0:	1d 82       	std	Y+5, r1	; 0x05
    3fe2:	1f 5f       	subi	r17, 0xFF	; 255
    3fe4:	b7 cf       	rjmp	.-146    	; 0x3f54 <prvCopyDataToQueue+0x22>

00003fe6 <prvCopyDataFromQueue>:
    3fe6:	fc 01       	movw	r30, r24
    3fe8:	cb 01       	movw	r24, r22
    3fea:	44 8d       	ldd	r20, Z+28	; 0x1c
    3fec:	44 23       	and	r20, r20
    3fee:	91 f0       	breq	.+36     	; 0x4014 <prvCopyDataFromQueue+0x2e>
    3ff0:	50 e0       	ldi	r21, 0x00	; 0
    3ff2:	66 81       	ldd	r22, Z+6	; 0x06
    3ff4:	77 81       	ldd	r23, Z+7	; 0x07
    3ff6:	64 0f       	add	r22, r20
    3ff8:	75 1f       	adc	r23, r21
    3ffa:	66 83       	std	Z+6, r22	; 0x06
    3ffc:	77 83       	std	Z+7, r23	; 0x07
    3ffe:	24 81       	ldd	r18, Z+4	; 0x04
    4000:	35 81       	ldd	r19, Z+5	; 0x05
    4002:	62 17       	cp	r22, r18
    4004:	73 07       	cpc	r23, r19
    4006:	20 f0       	brcs	.+8      	; 0x4010 <prvCopyDataFromQueue+0x2a>
    4008:	60 81       	ld	r22, Z
    400a:	71 81       	ldd	r23, Z+1	; 0x01
    400c:	66 83       	std	Z+6, r22	; 0x06
    400e:	77 83       	std	Z+7, r23	; 0x07
    4010:	0c 94 0e 50 	jmp	0xa01c	; 0xa01c <memcpy>
    4014:	08 95       	ret

00004016 <prvUnlockQueue>:
    4016:	ef 92       	push	r14
    4018:	ff 92       	push	r15
    401a:	0f 93       	push	r16
    401c:	1f 93       	push	r17
    401e:	cf 93       	push	r28
    4020:	8c 01       	movw	r16, r24
    4022:	0f b6       	in	r0, 0x3f	; 63
    4024:	f8 94       	cli
    4026:	0f 92       	push	r0
    4028:	fc 01       	movw	r30, r24
    402a:	c6 8d       	ldd	r28, Z+30	; 0x1e
    402c:	1c 16       	cp	r1, r28
    402e:	c4 f4       	brge	.+48     	; 0x4060 <prvUnlockQueue+0x4a>
    4030:	fc 01       	movw	r30, r24
    4032:	81 89       	ldd	r24, Z+17	; 0x11
    4034:	88 23       	and	r24, r24
    4036:	a1 f0       	breq	.+40     	; 0x4060 <prvUnlockQueue+0x4a>
    4038:	78 01       	movw	r14, r16
    403a:	f1 e1       	ldi	r31, 0x11	; 17
    403c:	ef 0e       	add	r14, r31
    403e:	f1 1c       	adc	r15, r1
    4040:	06 c0       	rjmp	.+12     	; 0x404e <prvUnlockQueue+0x38>
    4042:	c1 50       	subi	r28, 0x01	; 1
    4044:	69 f0       	breq	.+26     	; 0x4060 <prvUnlockQueue+0x4a>
    4046:	f8 01       	movw	r30, r16
    4048:	81 89       	ldd	r24, Z+17	; 0x11
    404a:	88 23       	and	r24, r24
    404c:	49 f0       	breq	.+18     	; 0x4060 <prvUnlockQueue+0x4a>
    404e:	c7 01       	movw	r24, r14
    4050:	0e 94 af 2b 	call	0x575e	; 0x575e <xTaskRemoveFromEventList>
    4054:	88 23       	and	r24, r24
    4056:	a9 f3       	breq	.-22     	; 0x4042 <prvUnlockQueue+0x2c>
    4058:	0e 94 68 2c 	call	0x58d0	; 0x58d0 <vTaskMissedYield>
    405c:	c1 50       	subi	r28, 0x01	; 1
    405e:	99 f7       	brne	.-26     	; 0x4046 <prvUnlockQueue+0x30>
    4060:	8f ef       	ldi	r24, 0xFF	; 255
    4062:	f8 01       	movw	r30, r16
    4064:	86 8f       	std	Z+30, r24	; 0x1e
    4066:	0f 90       	pop	r0
    4068:	0f be       	out	0x3f, r0	; 63
    406a:	0f b6       	in	r0, 0x3f	; 63
    406c:	f8 94       	cli
    406e:	0f 92       	push	r0
    4070:	c5 8d       	ldd	r28, Z+29	; 0x1d
    4072:	1c 16       	cp	r1, r28
    4074:	c4 f4       	brge	.+48     	; 0x40a6 <prvUnlockQueue+0x90>
    4076:	f8 01       	movw	r30, r16
    4078:	80 85       	ldd	r24, Z+8	; 0x08
    407a:	88 23       	and	r24, r24
    407c:	a1 f0       	breq	.+40     	; 0x40a6 <prvUnlockQueue+0x90>
    407e:	78 01       	movw	r14, r16
    4080:	f8 e0       	ldi	r31, 0x08	; 8
    4082:	ef 0e       	add	r14, r31
    4084:	f1 1c       	adc	r15, r1
    4086:	06 c0       	rjmp	.+12     	; 0x4094 <prvUnlockQueue+0x7e>
    4088:	c1 50       	subi	r28, 0x01	; 1
    408a:	69 f0       	breq	.+26     	; 0x40a6 <prvUnlockQueue+0x90>
    408c:	f8 01       	movw	r30, r16
    408e:	80 85       	ldd	r24, Z+8	; 0x08
    4090:	88 23       	and	r24, r24
    4092:	49 f0       	breq	.+18     	; 0x40a6 <prvUnlockQueue+0x90>
    4094:	c7 01       	movw	r24, r14
    4096:	0e 94 af 2b 	call	0x575e	; 0x575e <xTaskRemoveFromEventList>
    409a:	88 23       	and	r24, r24
    409c:	a9 f3       	breq	.-22     	; 0x4088 <prvUnlockQueue+0x72>
    409e:	0e 94 68 2c 	call	0x58d0	; 0x58d0 <vTaskMissedYield>
    40a2:	c1 50       	subi	r28, 0x01	; 1
    40a4:	99 f7       	brne	.-26     	; 0x408c <prvUnlockQueue+0x76>
    40a6:	8f ef       	ldi	r24, 0xFF	; 255
    40a8:	f8 01       	movw	r30, r16
    40aa:	85 8f       	std	Z+29, r24	; 0x1d
    40ac:	0f 90       	pop	r0
    40ae:	0f be       	out	0x3f, r0	; 63
    40b0:	cf 91       	pop	r28
    40b2:	1f 91       	pop	r17
    40b4:	0f 91       	pop	r16
    40b6:	ff 90       	pop	r15
    40b8:	ef 90       	pop	r14
    40ba:	08 95       	ret

000040bc <xQueueGenericReset>:
    40bc:	1f 93       	push	r17
    40be:	cf 93       	push	r28
    40c0:	df 93       	push	r29
    40c2:	ec 01       	movw	r28, r24
    40c4:	16 2f       	mov	r17, r22
    40c6:	89 2b       	or	r24, r25
    40c8:	09 f4       	brne	.+2      	; 0x40cc <xQueueGenericReset+0x10>
    40ca:	3e c0       	rjmp	.+124    	; 0x4148 <xQueueGenericReset+0x8c>
    40cc:	0f b6       	in	r0, 0x3f	; 63
    40ce:	f8 94       	cli
    40d0:	0f 92       	push	r0
    40d2:	48 81       	ld	r20, Y
    40d4:	59 81       	ldd	r21, Y+1	; 0x01
    40d6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    40d8:	6c 8d       	ldd	r22, Y+28	; 0x1c
    40da:	9a 01       	movw	r18, r20
    40dc:	86 9f       	mul	r24, r22
    40de:	20 0d       	add	r18, r0
    40e0:	31 1d       	adc	r19, r1
    40e2:	11 24       	eor	r1, r1
    40e4:	2c 83       	std	Y+4, r18	; 0x04
    40e6:	3d 83       	std	Y+5, r19	; 0x05
    40e8:	1a 8e       	std	Y+26, r1	; 0x1a
    40ea:	4a 83       	std	Y+2, r20	; 0x02
    40ec:	5b 83       	std	Y+3, r21	; 0x03
    40ee:	90 e0       	ldi	r25, 0x00	; 0
    40f0:	01 97       	sbiw	r24, 0x01	; 1
    40f2:	68 9f       	mul	r22, r24
    40f4:	90 01       	movw	r18, r0
    40f6:	69 9f       	mul	r22, r25
    40f8:	30 0d       	add	r19, r0
    40fa:	11 24       	eor	r1, r1
    40fc:	ca 01       	movw	r24, r20
    40fe:	82 0f       	add	r24, r18
    4100:	93 1f       	adc	r25, r19
    4102:	8e 83       	std	Y+6, r24	; 0x06
    4104:	9f 83       	std	Y+7, r25	; 0x07
    4106:	8f ef       	ldi	r24, 0xFF	; 255
    4108:	8d 8f       	std	Y+29, r24	; 0x1d
    410a:	8e 8f       	std	Y+30, r24	; 0x1e
    410c:	11 11       	cpse	r17, r1
    410e:	13 c0       	rjmp	.+38     	; 0x4136 <xQueueGenericReset+0x7a>
    4110:	88 85       	ldd	r24, Y+8	; 0x08
    4112:	81 11       	cpse	r24, r1
    4114:	07 c0       	rjmp	.+14     	; 0x4124 <xQueueGenericReset+0x68>
    4116:	0f 90       	pop	r0
    4118:	0f be       	out	0x3f, r0	; 63
    411a:	81 e0       	ldi	r24, 0x01	; 1
    411c:	df 91       	pop	r29
    411e:	cf 91       	pop	r28
    4120:	1f 91       	pop	r17
    4122:	08 95       	ret
    4124:	ce 01       	movw	r24, r28
    4126:	08 96       	adiw	r24, 0x08	; 8
    4128:	0e 94 af 2b 	call	0x575e	; 0x575e <xTaskRemoveFromEventList>
    412c:	88 23       	and	r24, r24
    412e:	99 f3       	breq	.-26     	; 0x4116 <xQueueGenericReset+0x5a>
    4130:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vPortYield>
    4134:	f0 cf       	rjmp	.-32     	; 0x4116 <xQueueGenericReset+0x5a>
    4136:	ce 01       	movw	r24, r28
    4138:	08 96       	adiw	r24, 0x08	; 8
    413a:	0e 94 14 1d 	call	0x3a28	; 0x3a28 <vListInitialise>
    413e:	ce 01       	movw	r24, r28
    4140:	41 96       	adiw	r24, 0x11	; 17
    4142:	0e 94 14 1d 	call	0x3a28	; 0x3a28 <vListInitialise>
    4146:	e7 cf       	rjmp	.-50     	; 0x4116 <xQueueGenericReset+0x5a>
    4148:	63 e0       	ldi	r22, 0x03	; 3
    414a:	71 e0       	ldi	r23, 0x01	; 1
    414c:	8a ee       	ldi	r24, 0xEA	; 234
    414e:	93 e2       	ldi	r25, 0x23	; 35
    4150:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    4154:	bb cf       	rjmp	.-138    	; 0x40cc <xQueueGenericReset+0x10>

00004156 <xQueueGenericCreate>:
    4156:	ff 92       	push	r15
    4158:	0f 93       	push	r16
    415a:	1f 93       	push	r17
    415c:	cf 93       	push	r28
    415e:	df 93       	push	r29
    4160:	18 2f       	mov	r17, r24
    4162:	06 2f       	mov	r16, r22
    4164:	f4 2e       	mov	r15, r20
    4166:	88 23       	and	r24, r24
    4168:	99 f1       	breq	.+102    	; 0x41d0 <xQueueGenericCreate+0x7a>
    416a:	00 23       	and	r16, r16
    416c:	d1 f0       	breq	.+52     	; 0x41a2 <xQueueGenericCreate+0x4c>
    416e:	10 9f       	mul	r17, r16
    4170:	c0 01       	movw	r24, r0
    4172:	11 24       	eor	r1, r1
    4174:	81 96       	adiw	r24, 0x21	; 33
    4176:	0e 94 45 1c 	call	0x388a	; 0x388a <pvPortMalloc>
    417a:	ec 01       	movw	r28, r24
    417c:	00 97       	sbiw	r24, 0x00	; 0
    417e:	51 f0       	breq	.+20     	; 0x4194 <xQueueGenericCreate+0x3e>
    4180:	81 96       	adiw	r24, 0x21	; 33
    4182:	88 83       	st	Y, r24
    4184:	99 83       	std	Y+1, r25	; 0x01
    4186:	1b 8f       	std	Y+27, r17	; 0x1b
    4188:	0c 8f       	std	Y+28, r16	; 0x1c
    418a:	61 e0       	ldi	r22, 0x01	; 1
    418c:	ce 01       	movw	r24, r28
    418e:	0e 94 5e 20 	call	0x40bc	; 0x40bc <xQueueGenericReset>
    4192:	f8 a2       	std	Y+32, r15	; 0x20
    4194:	ce 01       	movw	r24, r28
    4196:	df 91       	pop	r29
    4198:	cf 91       	pop	r28
    419a:	1f 91       	pop	r17
    419c:	0f 91       	pop	r16
    419e:	ff 90       	pop	r15
    41a0:	08 95       	ret
    41a2:	81 e2       	ldi	r24, 0x21	; 33
    41a4:	90 e0       	ldi	r25, 0x00	; 0
    41a6:	0e 94 45 1c 	call	0x388a	; 0x388a <pvPortMalloc>
    41aa:	ec 01       	movw	r28, r24
    41ac:	89 2b       	or	r24, r25
    41ae:	91 f3       	breq	.-28     	; 0x4194 <xQueueGenericCreate+0x3e>
    41b0:	c8 83       	st	Y, r28
    41b2:	d9 83       	std	Y+1, r29	; 0x01
    41b4:	1b 8f       	std	Y+27, r17	; 0x1b
    41b6:	0c 8f       	std	Y+28, r16	; 0x1c
    41b8:	61 e0       	ldi	r22, 0x01	; 1
    41ba:	ce 01       	movw	r24, r28
    41bc:	0e 94 5e 20 	call	0x40bc	; 0x40bc <xQueueGenericReset>
    41c0:	f8 a2       	std	Y+32, r15	; 0x20
    41c2:	ce 01       	movw	r24, r28
    41c4:	df 91       	pop	r29
    41c6:	cf 91       	pop	r28
    41c8:	1f 91       	pop	r17
    41ca:	0f 91       	pop	r16
    41cc:	ff 90       	pop	r15
    41ce:	08 95       	ret
    41d0:	66 e7       	ldi	r22, 0x76	; 118
    41d2:	71 e0       	ldi	r23, 0x01	; 1
    41d4:	8a ee       	ldi	r24, 0xEA	; 234
    41d6:	93 e2       	ldi	r25, 0x23	; 35
    41d8:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    41dc:	c6 cf       	rjmp	.-116    	; 0x416a <xQueueGenericCreate+0x14>

000041de <xQueueGenericSend>:
    41de:	bf 92       	push	r11
    41e0:	cf 92       	push	r12
    41e2:	df 92       	push	r13
    41e4:	ef 92       	push	r14
    41e6:	ff 92       	push	r15
    41e8:	0f 93       	push	r16
    41ea:	1f 93       	push	r17
    41ec:	cf 93       	push	r28
    41ee:	df 93       	push	r29
    41f0:	cd b7       	in	r28, 0x3d	; 61
    41f2:	de b7       	in	r29, 0x3e	; 62
    41f4:	25 97       	sbiw	r28, 0x05	; 5
    41f6:	cd bf       	out	0x3d, r28	; 61
    41f8:	de bf       	out	0x3e, r29	; 62
    41fa:	8c 01       	movw	r16, r24
    41fc:	6b 01       	movw	r12, r22
    41fe:	4c 83       	std	Y+4, r20	; 0x04
    4200:	5d 83       	std	Y+5, r21	; 0x05
    4202:	b2 2e       	mov	r11, r18
    4204:	89 2b       	or	r24, r25
    4206:	09 f4       	brne	.+2      	; 0x420a <xQueueGenericSend+0x2c>
    4208:	b2 c0       	rjmp	.+356    	; 0x436e <xQueueGenericSend+0x190>
    420a:	c1 14       	cp	r12, r1
    420c:	d1 04       	cpc	r13, r1
    420e:	09 f4       	brne	.+2      	; 0x4212 <xQueueGenericSend+0x34>
    4210:	a2 c0       	rjmp	.+324    	; 0x4356 <xQueueGenericSend+0x178>
    4212:	f2 e0       	ldi	r31, 0x02	; 2
    4214:	bf 16       	cp	r11, r31
    4216:	09 f4       	brne	.+2      	; 0x421a <xQueueGenericSend+0x3c>
    4218:	7d c0       	rjmp	.+250    	; 0x4314 <xQueueGenericSend+0x136>
    421a:	f8 01       	movw	r30, r16
    421c:	83 8d       	ldd	r24, Z+27	; 0x1b
    421e:	20 e0       	ldi	r18, 0x00	; 0
    4220:	78 01       	movw	r14, r16
    4222:	f8 e0       	ldi	r31, 0x08	; 8
    4224:	ef 0e       	add	r14, r31
    4226:	f1 1c       	adc	r15, r1
    4228:	10 c0       	rjmp	.+32     	; 0x424a <xQueueGenericSend+0x6c>
    422a:	6c 81       	ldd	r22, Y+4	; 0x04
    422c:	7d 81       	ldd	r23, Y+5	; 0x05
    422e:	c7 01       	movw	r24, r14
    4230:	0e 94 8f 2b 	call	0x571e	; 0x571e <vTaskPlaceOnEventList>
    4234:	c8 01       	movw	r24, r16
    4236:	0e 94 0b 20 	call	0x4016	; 0x4016 <prvUnlockQueue>
    423a:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>
    423e:	88 23       	and	r24, r24
    4240:	09 f4       	brne	.+2      	; 0x4244 <xQueueGenericSend+0x66>
    4242:	4a c0       	rjmp	.+148    	; 0x42d8 <xQueueGenericSend+0xfa>
    4244:	f8 01       	movw	r30, r16
    4246:	83 8d       	ldd	r24, Z+27	; 0x1b
    4248:	21 e0       	ldi	r18, 0x01	; 1
    424a:	0f b6       	in	r0, 0x3f	; 63
    424c:	f8 94       	cli
    424e:	0f 92       	push	r0
    4250:	f8 01       	movw	r30, r16
    4252:	92 8d       	ldd	r25, Z+26	; 0x1a
    4254:	98 17       	cp	r25, r24
    4256:	08 f4       	brcc	.+2      	; 0x425a <xQueueGenericSend+0x7c>
    4258:	42 c0       	rjmp	.+132    	; 0x42de <xQueueGenericSend+0x100>
    425a:	f2 e0       	ldi	r31, 0x02	; 2
    425c:	bf 16       	cp	r11, r31
    425e:	09 f4       	brne	.+2      	; 0x4262 <xQueueGenericSend+0x84>
    4260:	3e c0       	rjmp	.+124    	; 0x42de <xQueueGenericSend+0x100>
    4262:	8c 81       	ldd	r24, Y+4	; 0x04
    4264:	9d 81       	ldd	r25, Y+5	; 0x05
    4266:	89 2b       	or	r24, r25
    4268:	09 f4       	brne	.+2      	; 0x426c <xQueueGenericSend+0x8e>
    426a:	60 c0       	rjmp	.+192    	; 0x432c <xQueueGenericSend+0x14e>
    426c:	22 23       	and	r18, r18
    426e:	59 f1       	breq	.+86     	; 0x42c6 <xQueueGenericSend+0xe8>
    4270:	0f 90       	pop	r0
    4272:	0f be       	out	0x3f, r0	; 63
    4274:	0e 94 7f 29 	call	0x52fe	; 0x52fe <vTaskSuspendAll>
    4278:	0f b6       	in	r0, 0x3f	; 63
    427a:	f8 94       	cli
    427c:	0f 92       	push	r0
    427e:	f8 01       	movw	r30, r16
    4280:	85 8d       	ldd	r24, Z+29	; 0x1d
    4282:	8f 3f       	cpi	r24, 0xFF	; 255
    4284:	39 f1       	breq	.+78     	; 0x42d4 <xQueueGenericSend+0xf6>
    4286:	f8 01       	movw	r30, r16
    4288:	86 8d       	ldd	r24, Z+30	; 0x1e
    428a:	8f 3f       	cpi	r24, 0xFF	; 255
    428c:	09 f1       	breq	.+66     	; 0x42d0 <xQueueGenericSend+0xf2>
    428e:	0f 90       	pop	r0
    4290:	0f be       	out	0x3f, r0	; 63
    4292:	be 01       	movw	r22, r28
    4294:	6c 5f       	subi	r22, 0xFC	; 252
    4296:	7f 4f       	sbci	r23, 0xFF	; 255
    4298:	ce 01       	movw	r24, r28
    429a:	01 96       	adiw	r24, 0x01	; 1
    429c:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskCheckForTimeOut>
    42a0:	81 11       	cpse	r24, r1
    42a2:	48 c0       	rjmp	.+144    	; 0x4334 <xQueueGenericSend+0x156>
    42a4:	0f b6       	in	r0, 0x3f	; 63
    42a6:	f8 94       	cli
    42a8:	0f 92       	push	r0
    42aa:	f8 01       	movw	r30, r16
    42ac:	92 8d       	ldd	r25, Z+26	; 0x1a
    42ae:	0f 90       	pop	r0
    42b0:	0f be       	out	0x3f, r0	; 63
    42b2:	83 8d       	ldd	r24, Z+27	; 0x1b
    42b4:	98 17       	cp	r25, r24
    42b6:	09 f4       	brne	.+2      	; 0x42ba <xQueueGenericSend+0xdc>
    42b8:	b8 cf       	rjmp	.-144    	; 0x422a <xQueueGenericSend+0x4c>
    42ba:	c8 01       	movw	r24, r16
    42bc:	0e 94 0b 20 	call	0x4016	; 0x4016 <prvUnlockQueue>
    42c0:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>
    42c4:	bf cf       	rjmp	.-130    	; 0x4244 <xQueueGenericSend+0x66>
    42c6:	ce 01       	movw	r24, r28
    42c8:	01 96       	adiw	r24, 0x01	; 1
    42ca:	0e 94 06 2c 	call	0x580c	; 0x580c <vTaskInternalSetTimeOutState>
    42ce:	d0 cf       	rjmp	.-96     	; 0x4270 <xQueueGenericSend+0x92>
    42d0:	16 8e       	std	Z+30, r1	; 0x1e
    42d2:	dd cf       	rjmp	.-70     	; 0x428e <xQueueGenericSend+0xb0>
    42d4:	15 8e       	std	Z+29, r1	; 0x1d
    42d6:	d7 cf       	rjmp	.-82     	; 0x4286 <xQueueGenericSend+0xa8>
    42d8:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vPortYield>
    42dc:	b3 cf       	rjmp	.-154    	; 0x4244 <xQueueGenericSend+0x66>
    42de:	4b 2d       	mov	r20, r11
    42e0:	b6 01       	movw	r22, r12
    42e2:	c8 01       	movw	r24, r16
    42e4:	0e 94 99 1f 	call	0x3f32	; 0x3f32 <prvCopyDataToQueue>
    42e8:	f8 01       	movw	r30, r16
    42ea:	91 89       	ldd	r25, Z+17	; 0x11
    42ec:	91 11       	cpse	r25, r1
    42ee:	2c c0       	rjmp	.+88     	; 0x4348 <xQueueGenericSend+0x16a>
    42f0:	81 11       	cpse	r24, r1
    42f2:	27 c0       	rjmp	.+78     	; 0x4342 <xQueueGenericSend+0x164>
    42f4:	0f 90       	pop	r0
    42f6:	0f be       	out	0x3f, r0	; 63
    42f8:	81 e0       	ldi	r24, 0x01	; 1
    42fa:	25 96       	adiw	r28, 0x05	; 5
    42fc:	cd bf       	out	0x3d, r28	; 61
    42fe:	de bf       	out	0x3e, r29	; 62
    4300:	df 91       	pop	r29
    4302:	cf 91       	pop	r28
    4304:	1f 91       	pop	r17
    4306:	0f 91       	pop	r16
    4308:	ff 90       	pop	r15
    430a:	ef 90       	pop	r14
    430c:	df 90       	pop	r13
    430e:	cf 90       	pop	r12
    4310:	bf 90       	pop	r11
    4312:	08 95       	ret
    4314:	f8 01       	movw	r30, r16
    4316:	83 8d       	ldd	r24, Z+27	; 0x1b
    4318:	81 30       	cpi	r24, 0x01	; 1
    431a:	09 f4       	brne	.+2      	; 0x431e <xQueueGenericSend+0x140>
    431c:	80 cf       	rjmp	.-256    	; 0x421e <xQueueGenericSend+0x40>
    431e:	63 ef       	ldi	r22, 0xF3	; 243
    4320:	72 e0       	ldi	r23, 0x02	; 2
    4322:	8a ee       	ldi	r24, 0xEA	; 234
    4324:	93 e2       	ldi	r25, 0x23	; 35
    4326:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    432a:	77 cf       	rjmp	.-274    	; 0x421a <xQueueGenericSend+0x3c>
    432c:	0f 90       	pop	r0
    432e:	0f be       	out	0x3f, r0	; 63
    4330:	80 e0       	ldi	r24, 0x00	; 0
    4332:	e3 cf       	rjmp	.-58     	; 0x42fa <xQueueGenericSend+0x11c>
    4334:	c8 01       	movw	r24, r16
    4336:	0e 94 0b 20 	call	0x4016	; 0x4016 <prvUnlockQueue>
    433a:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>
    433e:	80 e0       	ldi	r24, 0x00	; 0
    4340:	dc cf       	rjmp	.-72     	; 0x42fa <xQueueGenericSend+0x11c>
    4342:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vPortYield>
    4346:	d6 cf       	rjmp	.-84     	; 0x42f4 <xQueueGenericSend+0x116>
    4348:	c8 01       	movw	r24, r16
    434a:	41 96       	adiw	r24, 0x11	; 17
    434c:	0e 94 af 2b 	call	0x575e	; 0x575e <xTaskRemoveFromEventList>
    4350:	88 23       	and	r24, r24
    4352:	81 f2       	breq	.-96     	; 0x42f4 <xQueueGenericSend+0x116>
    4354:	f6 cf       	rjmp	.-20     	; 0x4342 <xQueueGenericSend+0x164>
    4356:	f8 01       	movw	r30, r16
    4358:	84 8d       	ldd	r24, Z+28	; 0x1c
    435a:	88 23       	and	r24, r24
    435c:	09 f4       	brne	.+2      	; 0x4360 <xQueueGenericSend+0x182>
    435e:	59 cf       	rjmp	.-334    	; 0x4212 <xQueueGenericSend+0x34>
    4360:	62 ef       	ldi	r22, 0xF2	; 242
    4362:	72 e0       	ldi	r23, 0x02	; 2
    4364:	8a ee       	ldi	r24, 0xEA	; 234
    4366:	93 e2       	ldi	r25, 0x23	; 35
    4368:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    436c:	52 cf       	rjmp	.-348    	; 0x4212 <xQueueGenericSend+0x34>
    436e:	61 ef       	ldi	r22, 0xF1	; 241
    4370:	72 e0       	ldi	r23, 0x02	; 2
    4372:	8a ee       	ldi	r24, 0xEA	; 234
    4374:	93 e2       	ldi	r25, 0x23	; 35
    4376:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    437a:	47 cf       	rjmp	.-370    	; 0x420a <xQueueGenericSend+0x2c>

0000437c <xQueueCreateMutex>:
    437c:	cf 93       	push	r28
    437e:	df 93       	push	r29
    4380:	48 2f       	mov	r20, r24
    4382:	60 e0       	ldi	r22, 0x00	; 0
    4384:	81 e0       	ldi	r24, 0x01	; 1
    4386:	0e 94 ab 20 	call	0x4156	; 0x4156 <xQueueGenericCreate>
    438a:	ec 01       	movw	r28, r24
    438c:	00 97       	sbiw	r24, 0x00	; 0
    438e:	61 f0       	breq	.+24     	; 0x43a8 <xQueueCreateMutex+0x2c>
    4390:	1c 82       	std	Y+4, r1	; 0x04
    4392:	1d 82       	std	Y+5, r1	; 0x05
    4394:	18 82       	st	Y, r1
    4396:	19 82       	std	Y+1, r1	; 0x01
    4398:	1e 82       	std	Y+6, r1	; 0x06
    439a:	20 e0       	ldi	r18, 0x00	; 0
    439c:	40 e0       	ldi	r20, 0x00	; 0
    439e:	50 e0       	ldi	r21, 0x00	; 0
    43a0:	60 e0       	ldi	r22, 0x00	; 0
    43a2:	70 e0       	ldi	r23, 0x00	; 0
    43a4:	0e 94 ef 20 	call	0x41de	; 0x41de <xQueueGenericSend>
    43a8:	ce 01       	movw	r24, r28
    43aa:	df 91       	pop	r29
    43ac:	cf 91       	pop	r28
    43ae:	08 95       	ret

000043b0 <xQueueGenericSendFromISR>:
    43b0:	cf 92       	push	r12
    43b2:	df 92       	push	r13
    43b4:	ef 92       	push	r14
    43b6:	ff 92       	push	r15
    43b8:	0f 93       	push	r16
    43ba:	1f 93       	push	r17
    43bc:	cf 93       	push	r28
    43be:	df 93       	push	r29
    43c0:	ec 01       	movw	r28, r24
    43c2:	8b 01       	movw	r16, r22
    43c4:	6a 01       	movw	r12, r20
    43c6:	f2 2e       	mov	r15, r18
    43c8:	89 2b       	or	r24, r25
    43ca:	09 f4       	brne	.+2      	; 0x43ce <xQueueGenericSendFromISR+0x1e>
    43cc:	45 c0       	rjmp	.+138    	; 0x4458 <xQueueGenericSendFromISR+0xa8>
    43ce:	01 15       	cp	r16, r1
    43d0:	11 05       	cpc	r17, r1
    43d2:	c1 f1       	breq	.+112    	; 0x4444 <xQueueGenericSendFromISR+0x94>
    43d4:	82 e0       	ldi	r24, 0x02	; 2
    43d6:	f8 16       	cp	r15, r24
    43d8:	71 f0       	breq	.+28     	; 0x43f6 <xQueueGenericSendFromISR+0x46>
    43da:	9a 8d       	ldd	r25, Y+26	; 0x1a
    43dc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    43de:	98 17       	cp	r25, r24
    43e0:	a0 f0       	brcs	.+40     	; 0x440a <xQueueGenericSendFromISR+0x5a>
    43e2:	80 e0       	ldi	r24, 0x00	; 0
    43e4:	df 91       	pop	r29
    43e6:	cf 91       	pop	r28
    43e8:	1f 91       	pop	r17
    43ea:	0f 91       	pop	r16
    43ec:	ff 90       	pop	r15
    43ee:	ef 90       	pop	r14
    43f0:	df 90       	pop	r13
    43f2:	cf 90       	pop	r12
    43f4:	08 95       	ret
    43f6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    43f8:	81 30       	cpi	r24, 0x01	; 1
    43fa:	31 f0       	breq	.+12     	; 0x4408 <xQueueGenericSendFromISR+0x58>
    43fc:	65 ec       	ldi	r22, 0xC5	; 197
    43fe:	73 e0       	ldi	r23, 0x03	; 3
    4400:	8a ee       	ldi	r24, 0xEA	; 234
    4402:	93 e2       	ldi	r25, 0x23	; 35
    4404:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    4408:	8a 8d       	ldd	r24, Y+26	; 0x1a
    440a:	ee 8c       	ldd	r14, Y+30	; 0x1e
    440c:	4f 2d       	mov	r20, r15
    440e:	b8 01       	movw	r22, r16
    4410:	ce 01       	movw	r24, r28
    4412:	0e 94 99 1f 	call	0x3f32	; 0x3f32 <prvCopyDataToQueue>
    4416:	ef ef       	ldi	r30, 0xFF	; 255
    4418:	ee 16       	cp	r14, r30
    441a:	21 f0       	breq	.+8      	; 0x4424 <xQueueGenericSendFromISR+0x74>
    441c:	e3 94       	inc	r14
    441e:	ee 8e       	std	Y+30, r14	; 0x1e
    4420:	81 e0       	ldi	r24, 0x01	; 1
    4422:	e0 cf       	rjmp	.-64     	; 0x43e4 <xQueueGenericSendFromISR+0x34>
    4424:	89 89       	ldd	r24, Y+17	; 0x11
    4426:	88 23       	and	r24, r24
    4428:	d9 f3       	breq	.-10     	; 0x4420 <xQueueGenericSendFromISR+0x70>
    442a:	ce 01       	movw	r24, r28
    442c:	41 96       	adiw	r24, 0x11	; 17
    442e:	0e 94 af 2b 	call	0x575e	; 0x575e <xTaskRemoveFromEventList>
    4432:	88 23       	and	r24, r24
    4434:	a9 f3       	breq	.-22     	; 0x4420 <xQueueGenericSendFromISR+0x70>
    4436:	c1 14       	cp	r12, r1
    4438:	d1 04       	cpc	r13, r1
    443a:	91 f3       	breq	.-28     	; 0x4420 <xQueueGenericSendFromISR+0x70>
    443c:	81 e0       	ldi	r24, 0x01	; 1
    443e:	f6 01       	movw	r30, r12
    4440:	80 83       	st	Z, r24
    4442:	d0 cf       	rjmp	.-96     	; 0x43e4 <xQueueGenericSendFromISR+0x34>
    4444:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4446:	88 23       	and	r24, r24
    4448:	29 f2       	breq	.-118    	; 0x43d4 <xQueueGenericSendFromISR+0x24>
    444a:	64 ec       	ldi	r22, 0xC4	; 196
    444c:	73 e0       	ldi	r23, 0x03	; 3
    444e:	8a ee       	ldi	r24, 0xEA	; 234
    4450:	93 e2       	ldi	r25, 0x23	; 35
    4452:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    4456:	be cf       	rjmp	.-132    	; 0x43d4 <xQueueGenericSendFromISR+0x24>
    4458:	63 ec       	ldi	r22, 0xC3	; 195
    445a:	73 e0       	ldi	r23, 0x03	; 3
    445c:	8a ee       	ldi	r24, 0xEA	; 234
    445e:	93 e2       	ldi	r25, 0x23	; 35
    4460:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    4464:	b4 cf       	rjmp	.-152    	; 0x43ce <xQueueGenericSendFromISR+0x1e>

00004466 <xQueueGiveFromISR>:
    4466:	0f 93       	push	r16
    4468:	1f 93       	push	r17
    446a:	cf 93       	push	r28
    446c:	df 93       	push	r29
    446e:	ec 01       	movw	r28, r24
    4470:	8b 01       	movw	r16, r22
    4472:	89 2b       	or	r24, r25
    4474:	09 f4       	brne	.+2      	; 0x4478 <xQueueGiveFromISR+0x12>
    4476:	43 c0       	rjmp	.+134    	; 0x44fe <xQueueGiveFromISR+0x98>
    4478:	8c 8d       	ldd	r24, Y+28	; 0x1c
    447a:	81 11       	cpse	r24, r1
    447c:	1b c0       	rjmp	.+54     	; 0x44b4 <xQueueGiveFromISR+0x4e>
    447e:	88 81       	ld	r24, Y
    4480:	99 81       	ldd	r25, Y+1	; 0x01
    4482:	89 2b       	or	r24, r25
    4484:	09 f1       	breq	.+66     	; 0x44c8 <xQueueGiveFromISR+0x62>
    4486:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4488:	9b 8d       	ldd	r25, Y+27	; 0x1b
    448a:	89 17       	cp	r24, r25
    448c:	68 f4       	brcc	.+26     	; 0x44a8 <xQueueGiveFromISR+0x42>
    448e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4490:	8f 5f       	subi	r24, 0xFF	; 255
    4492:	8a 8f       	std	Y+26, r24	; 0x1a
    4494:	9f 3f       	cpi	r25, 0xFF	; 255
    4496:	19 f1       	breq	.+70     	; 0x44de <xQueueGiveFromISR+0x78>
    4498:	9f 5f       	subi	r25, 0xFF	; 255
    449a:	9e 8f       	std	Y+30, r25	; 0x1e
    449c:	81 e0       	ldi	r24, 0x01	; 1
    449e:	df 91       	pop	r29
    44a0:	cf 91       	pop	r28
    44a2:	1f 91       	pop	r17
    44a4:	0f 91       	pop	r16
    44a6:	08 95       	ret
    44a8:	80 e0       	ldi	r24, 0x00	; 0
    44aa:	df 91       	pop	r29
    44ac:	cf 91       	pop	r28
    44ae:	1f 91       	pop	r17
    44b0:	0f 91       	pop	r16
    44b2:	08 95       	ret
    44b4:	64 e6       	ldi	r22, 0x64	; 100
    44b6:	74 e0       	ldi	r23, 0x04	; 4
    44b8:	8a ee       	ldi	r24, 0xEA	; 234
    44ba:	93 e2       	ldi	r25, 0x23	; 35
    44bc:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    44c0:	88 81       	ld	r24, Y
    44c2:	99 81       	ldd	r25, Y+1	; 0x01
    44c4:	89 2b       	or	r24, r25
    44c6:	f9 f6       	brne	.-66     	; 0x4486 <xQueueGiveFromISR+0x20>
    44c8:	8c 81       	ldd	r24, Y+4	; 0x04
    44ca:	9d 81       	ldd	r25, Y+5	; 0x05
    44cc:	89 2b       	or	r24, r25
    44ce:	d9 f2       	breq	.-74     	; 0x4486 <xQueueGiveFromISR+0x20>
    44d0:	69 e6       	ldi	r22, 0x69	; 105
    44d2:	74 e0       	ldi	r23, 0x04	; 4
    44d4:	8a ee       	ldi	r24, 0xEA	; 234
    44d6:	93 e2       	ldi	r25, 0x23	; 35
    44d8:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    44dc:	d4 cf       	rjmp	.-88     	; 0x4486 <xQueueGiveFromISR+0x20>
    44de:	89 89       	ldd	r24, Y+17	; 0x11
    44e0:	88 23       	and	r24, r24
    44e2:	e1 f2       	breq	.-72     	; 0x449c <xQueueGiveFromISR+0x36>
    44e4:	ce 01       	movw	r24, r28
    44e6:	41 96       	adiw	r24, 0x11	; 17
    44e8:	0e 94 af 2b 	call	0x575e	; 0x575e <xTaskRemoveFromEventList>
    44ec:	88 23       	and	r24, r24
    44ee:	b1 f2       	breq	.-84     	; 0x449c <xQueueGiveFromISR+0x36>
    44f0:	01 15       	cp	r16, r1
    44f2:	11 05       	cpc	r17, r1
    44f4:	99 f2       	breq	.-90     	; 0x449c <xQueueGiveFromISR+0x36>
    44f6:	81 e0       	ldi	r24, 0x01	; 1
    44f8:	f8 01       	movw	r30, r16
    44fa:	80 83       	st	Z, r24
    44fc:	d0 cf       	rjmp	.-96     	; 0x449e <xQueueGiveFromISR+0x38>
    44fe:	60 e6       	ldi	r22, 0x60	; 96
    4500:	74 e0       	ldi	r23, 0x04	; 4
    4502:	8a ee       	ldi	r24, 0xEA	; 234
    4504:	93 e2       	ldi	r25, 0x23	; 35
    4506:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    450a:	b6 cf       	rjmp	.-148    	; 0x4478 <xQueueGiveFromISR+0x12>

0000450c <xQueueReceive>:
    450c:	af 92       	push	r10
    450e:	bf 92       	push	r11
    4510:	cf 92       	push	r12
    4512:	df 92       	push	r13
    4514:	ff 92       	push	r15
    4516:	0f 93       	push	r16
    4518:	1f 93       	push	r17
    451a:	cf 93       	push	r28
    451c:	df 93       	push	r29
    451e:	cd b7       	in	r28, 0x3d	; 61
    4520:	de b7       	in	r29, 0x3e	; 62
    4522:	25 97       	sbiw	r28, 0x05	; 5
    4524:	cd bf       	out	0x3d, r28	; 61
    4526:	de bf       	out	0x3e, r29	; 62
    4528:	8c 01       	movw	r16, r24
    452a:	5b 01       	movw	r10, r22
    452c:	4c 83       	std	Y+4, r20	; 0x04
    452e:	5d 83       	std	Y+5, r21	; 0x05
    4530:	89 2b       	or	r24, r25
    4532:	09 f4       	brne	.+2      	; 0x4536 <xQueueReceive+0x2a>
    4534:	a1 c0       	rjmp	.+322    	; 0x4678 <xQueueReceive+0x16c>
    4536:	a1 14       	cp	r10, r1
    4538:	b1 04       	cpc	r11, r1
    453a:	09 f4       	brne	.+2      	; 0x453e <xQueueReceive+0x32>
    453c:	91 c0       	rjmp	.+290    	; 0x4660 <xQueueReceive+0x154>
    453e:	20 e0       	ldi	r18, 0x00	; 0
    4540:	68 01       	movw	r12, r16
    4542:	f1 e1       	ldi	r31, 0x11	; 17
    4544:	cf 0e       	add	r12, r31
    4546:	d1 1c       	adc	r13, r1
    4548:	0f b6       	in	r0, 0x3f	; 63
    454a:	f8 94       	cli
    454c:	0f 92       	push	r0
    454e:	f8 01       	movw	r30, r16
    4550:	f2 8c       	ldd	r15, Z+26	; 0x1a
    4552:	f1 10       	cpse	r15, r1
    4554:	6a c0       	rjmp	.+212    	; 0x462a <xQueueReceive+0x11e>
    4556:	8c 81       	ldd	r24, Y+4	; 0x04
    4558:	9d 81       	ldd	r25, Y+5	; 0x05
    455a:	89 2b       	or	r24, r25
    455c:	09 f4       	brne	.+2      	; 0x4560 <xQueueReceive+0x54>
    455e:	73 c0       	rjmp	.+230    	; 0x4646 <xQueueReceive+0x13a>
    4560:	22 23       	and	r18, r18
    4562:	09 f4       	brne	.+2      	; 0x4566 <xQueueReceive+0x5a>
    4564:	59 c0       	rjmp	.+178    	; 0x4618 <xQueueReceive+0x10c>
    4566:	0f 90       	pop	r0
    4568:	0f be       	out	0x3f, r0	; 63
    456a:	0e 94 7f 29 	call	0x52fe	; 0x52fe <vTaskSuspendAll>
    456e:	0f b6       	in	r0, 0x3f	; 63
    4570:	f8 94       	cli
    4572:	0f 92       	push	r0
    4574:	f8 01       	movw	r30, r16
    4576:	85 8d       	ldd	r24, Z+29	; 0x1d
    4578:	8f 3f       	cpi	r24, 0xFF	; 255
    457a:	09 f4       	brne	.+2      	; 0x457e <xQueueReceive+0x72>
    457c:	54 c0       	rjmp	.+168    	; 0x4626 <xQueueReceive+0x11a>
    457e:	f8 01       	movw	r30, r16
    4580:	86 8d       	ldd	r24, Z+30	; 0x1e
    4582:	8f 3f       	cpi	r24, 0xFF	; 255
    4584:	09 f4       	brne	.+2      	; 0x4588 <xQueueReceive+0x7c>
    4586:	4d c0       	rjmp	.+154    	; 0x4622 <xQueueReceive+0x116>
    4588:	0f 90       	pop	r0
    458a:	0f be       	out	0x3f, r0	; 63
    458c:	be 01       	movw	r22, r28
    458e:	6c 5f       	subi	r22, 0xFC	; 252
    4590:	7f 4f       	sbci	r23, 0xFF	; 255
    4592:	ce 01       	movw	r24, r28
    4594:	01 96       	adiw	r24, 0x01	; 1
    4596:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskCheckForTimeOut>
    459a:	81 11       	cpse	r24, r1
    459c:	22 c0       	rjmp	.+68     	; 0x45e2 <xQueueReceive+0xd6>
    459e:	0f b6       	in	r0, 0x3f	; 63
    45a0:	f8 94       	cli
    45a2:	0f 92       	push	r0
    45a4:	f8 01       	movw	r30, r16
    45a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    45a8:	0f 90       	pop	r0
    45aa:	0f be       	out	0x3f, r0	; 63
    45ac:	81 11       	cpse	r24, r1
    45ae:	12 c0       	rjmp	.+36     	; 0x45d4 <xQueueReceive+0xc8>
    45b0:	6c 81       	ldd	r22, Y+4	; 0x04
    45b2:	7d 81       	ldd	r23, Y+5	; 0x05
    45b4:	c6 01       	movw	r24, r12
    45b6:	0e 94 8f 2b 	call	0x571e	; 0x571e <vTaskPlaceOnEventList>
    45ba:	c8 01       	movw	r24, r16
    45bc:	0e 94 0b 20 	call	0x4016	; 0x4016 <prvUnlockQueue>
    45c0:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>
    45c4:	88 23       	and	r24, r24
    45c6:	11 f0       	breq	.+4      	; 0x45cc <xQueueReceive+0xc0>
    45c8:	21 e0       	ldi	r18, 0x01	; 1
    45ca:	be cf       	rjmp	.-132    	; 0x4548 <xQueueReceive+0x3c>
    45cc:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vPortYield>
    45d0:	21 e0       	ldi	r18, 0x01	; 1
    45d2:	ba cf       	rjmp	.-140    	; 0x4548 <xQueueReceive+0x3c>
    45d4:	c8 01       	movw	r24, r16
    45d6:	0e 94 0b 20 	call	0x4016	; 0x4016 <prvUnlockQueue>
    45da:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>
    45de:	21 e0       	ldi	r18, 0x01	; 1
    45e0:	b3 cf       	rjmp	.-154    	; 0x4548 <xQueueReceive+0x3c>
    45e2:	c8 01       	movw	r24, r16
    45e4:	0e 94 0b 20 	call	0x4016	; 0x4016 <prvUnlockQueue>
    45e8:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>
    45ec:	0f b6       	in	r0, 0x3f	; 63
    45ee:	f8 94       	cli
    45f0:	0f 92       	push	r0
    45f2:	f8 01       	movw	r30, r16
    45f4:	82 8d       	ldd	r24, Z+26	; 0x1a
    45f6:	0f 90       	pop	r0
    45f8:	0f be       	out	0x3f, r0	; 63
    45fa:	81 11       	cpse	r24, r1
    45fc:	e5 cf       	rjmp	.-54     	; 0x45c8 <xQueueReceive+0xbc>
    45fe:	25 96       	adiw	r28, 0x05	; 5
    4600:	cd bf       	out	0x3d, r28	; 61
    4602:	de bf       	out	0x3e, r29	; 62
    4604:	df 91       	pop	r29
    4606:	cf 91       	pop	r28
    4608:	1f 91       	pop	r17
    460a:	0f 91       	pop	r16
    460c:	ff 90       	pop	r15
    460e:	df 90       	pop	r13
    4610:	cf 90       	pop	r12
    4612:	bf 90       	pop	r11
    4614:	af 90       	pop	r10
    4616:	08 95       	ret
    4618:	ce 01       	movw	r24, r28
    461a:	01 96       	adiw	r24, 0x01	; 1
    461c:	0e 94 06 2c 	call	0x580c	; 0x580c <vTaskInternalSetTimeOutState>
    4620:	a2 cf       	rjmp	.-188    	; 0x4566 <xQueueReceive+0x5a>
    4622:	16 8e       	std	Z+30, r1	; 0x1e
    4624:	b1 cf       	rjmp	.-158    	; 0x4588 <xQueueReceive+0x7c>
    4626:	15 8e       	std	Z+29, r1	; 0x1d
    4628:	aa cf       	rjmp	.-172    	; 0x457e <xQueueReceive+0x72>
    462a:	b5 01       	movw	r22, r10
    462c:	c8 01       	movw	r24, r16
    462e:	0e 94 f3 1f 	call	0x3fe6	; 0x3fe6 <prvCopyDataFromQueue>
    4632:	fa 94       	dec	r15
    4634:	f8 01       	movw	r30, r16
    4636:	f2 8e       	std	Z+26, r15	; 0x1a
    4638:	80 85       	ldd	r24, Z+8	; 0x08
    463a:	81 11       	cpse	r24, r1
    463c:	08 c0       	rjmp	.+16     	; 0x464e <xQueueReceive+0x142>
    463e:	0f 90       	pop	r0
    4640:	0f be       	out	0x3f, r0	; 63
    4642:	81 e0       	ldi	r24, 0x01	; 1
    4644:	dc cf       	rjmp	.-72     	; 0x45fe <xQueueReceive+0xf2>
    4646:	0f 90       	pop	r0
    4648:	0f be       	out	0x3f, r0	; 63
    464a:	80 e0       	ldi	r24, 0x00	; 0
    464c:	d8 cf       	rjmp	.-80     	; 0x45fe <xQueueReceive+0xf2>
    464e:	c8 01       	movw	r24, r16
    4650:	08 96       	adiw	r24, 0x08	; 8
    4652:	0e 94 af 2b 	call	0x575e	; 0x575e <xTaskRemoveFromEventList>
    4656:	88 23       	and	r24, r24
    4658:	91 f3       	breq	.-28     	; 0x463e <xQueueReceive+0x132>
    465a:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vPortYield>
    465e:	ef cf       	rjmp	.-34     	; 0x463e <xQueueReceive+0x132>
    4660:	f8 01       	movw	r30, r16
    4662:	84 8d       	ldd	r24, Z+28	; 0x1c
    4664:	88 23       	and	r24, r24
    4666:	09 f4       	brne	.+2      	; 0x466a <xQueueReceive+0x15e>
    4668:	6a cf       	rjmp	.-300    	; 0x453e <xQueueReceive+0x32>
    466a:	64 e0       	ldi	r22, 0x04	; 4
    466c:	75 e0       	ldi	r23, 0x05	; 5
    466e:	8a ee       	ldi	r24, 0xEA	; 234
    4670:	93 e2       	ldi	r25, 0x23	; 35
    4672:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    4676:	63 cf       	rjmp	.-314    	; 0x453e <xQueueReceive+0x32>
    4678:	60 e0       	ldi	r22, 0x00	; 0
    467a:	75 e0       	ldi	r23, 0x05	; 5
    467c:	8a ee       	ldi	r24, 0xEA	; 234
    467e:	93 e2       	ldi	r25, 0x23	; 35
    4680:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    4684:	58 cf       	rjmp	.-336    	; 0x4536 <xQueueReceive+0x2a>

00004686 <xQueueSemaphoreTake>:
    4686:	df 92       	push	r13
    4688:	ef 92       	push	r14
    468a:	ff 92       	push	r15
    468c:	0f 93       	push	r16
    468e:	1f 93       	push	r17
    4690:	cf 93       	push	r28
    4692:	df 93       	push	r29
    4694:	cd b7       	in	r28, 0x3d	; 61
    4696:	de b7       	in	r29, 0x3e	; 62
    4698:	25 97       	sbiw	r28, 0x05	; 5
    469a:	cd bf       	out	0x3d, r28	; 61
    469c:	de bf       	out	0x3e, r29	; 62
    469e:	8c 01       	movw	r16, r24
    46a0:	6c 83       	std	Y+4, r22	; 0x04
    46a2:	7d 83       	std	Y+5, r23	; 0x05
    46a4:	89 2b       	or	r24, r25
    46a6:	09 f4       	brne	.+2      	; 0x46aa <xQueueSemaphoreTake+0x24>
    46a8:	d0 c0       	rjmp	.+416    	; 0x484a <xQueueSemaphoreTake+0x1c4>
    46aa:	d8 01       	movw	r26, r16
    46ac:	5c 96       	adiw	r26, 0x1c	; 28
    46ae:	8c 91       	ld	r24, X
    46b0:	81 11       	cpse	r24, r1
    46b2:	bb c0       	rjmp	.+374    	; 0x482a <xQueueSemaphoreTake+0x1a4>
    46b4:	d1 2c       	mov	r13, r1
    46b6:	20 e0       	ldi	r18, 0x00	; 0
    46b8:	78 01       	movw	r14, r16
    46ba:	b1 e1       	ldi	r27, 0x11	; 17
    46bc:	eb 0e       	add	r14, r27
    46be:	f1 1c       	adc	r15, r1
    46c0:	0f b6       	in	r0, 0x3f	; 63
    46c2:	f8 94       	cli
    46c4:	0f 92       	push	r0
    46c6:	f8 01       	movw	r30, r16
    46c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    46ca:	81 11       	cpse	r24, r1
    46cc:	89 c0       	rjmp	.+274    	; 0x47e0 <xQueueSemaphoreTake+0x15a>
    46ce:	8c 81       	ldd	r24, Y+4	; 0x04
    46d0:	9d 81       	ldd	r25, Y+5	; 0x05
    46d2:	89 2b       	or	r24, r25
    46d4:	09 f4       	brne	.+2      	; 0x46d8 <xQueueSemaphoreTake+0x52>
    46d6:	9d c0       	rjmp	.+314    	; 0x4812 <xQueueSemaphoreTake+0x18c>
    46d8:	22 23       	and	r18, r18
    46da:	09 f4       	brne	.+2      	; 0x46de <xQueueSemaphoreTake+0x58>
    46dc:	5f c0       	rjmp	.+190    	; 0x479c <xQueueSemaphoreTake+0x116>
    46de:	0f 90       	pop	r0
    46e0:	0f be       	out	0x3f, r0	; 63
    46e2:	0e 94 7f 29 	call	0x52fe	; 0x52fe <vTaskSuspendAll>
    46e6:	0f b6       	in	r0, 0x3f	; 63
    46e8:	f8 94       	cli
    46ea:	0f 92       	push	r0
    46ec:	d8 01       	movw	r26, r16
    46ee:	5d 96       	adiw	r26, 0x1d	; 29
    46f0:	8c 91       	ld	r24, X
    46f2:	5d 97       	sbiw	r26, 0x1d	; 29
    46f4:	8f 3f       	cpi	r24, 0xFF	; 255
    46f6:	09 f4       	brne	.+2      	; 0x46fa <xQueueSemaphoreTake+0x74>
    46f8:	56 c0       	rjmp	.+172    	; 0x47a6 <xQueueSemaphoreTake+0x120>
    46fa:	f8 01       	movw	r30, r16
    46fc:	86 8d       	ldd	r24, Z+30	; 0x1e
    46fe:	8f 3f       	cpi	r24, 0xFF	; 255
    4700:	09 f4       	brne	.+2      	; 0x4704 <xQueueSemaphoreTake+0x7e>
    4702:	58 c0       	rjmp	.+176    	; 0x47b4 <xQueueSemaphoreTake+0x12e>
    4704:	0f 90       	pop	r0
    4706:	0f be       	out	0x3f, r0	; 63
    4708:	be 01       	movw	r22, r28
    470a:	6c 5f       	subi	r22, 0xFC	; 252
    470c:	7f 4f       	sbci	r23, 0xFF	; 255
    470e:	ce 01       	movw	r24, r28
    4710:	01 96       	adiw	r24, 0x01	; 1
    4712:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskCheckForTimeOut>
    4716:	81 11       	cpse	r24, r1
    4718:	23 c0       	rjmp	.+70     	; 0x4760 <xQueueSemaphoreTake+0xda>
    471a:	0f b6       	in	r0, 0x3f	; 63
    471c:	f8 94       	cli
    471e:	0f 92       	push	r0
    4720:	d8 01       	movw	r26, r16
    4722:	5a 96       	adiw	r26, 0x1a	; 26
    4724:	8c 91       	ld	r24, X
    4726:	5a 97       	sbiw	r26, 0x1a	; 26
    4728:	0f 90       	pop	r0
    472a:	0f be       	out	0x3f, r0	; 63
    472c:	81 11       	cpse	r24, r1
    472e:	44 c0       	rjmp	.+136    	; 0x47b8 <xQueueSemaphoreTake+0x132>
    4730:	f8 01       	movw	r30, r16
    4732:	80 81       	ld	r24, Z
    4734:	91 81       	ldd	r25, Z+1	; 0x01
    4736:	89 2b       	or	r24, r25
    4738:	09 f4       	brne	.+2      	; 0x473c <xQueueSemaphoreTake+0xb6>
    473a:	45 c0       	rjmp	.+138    	; 0x47c6 <xQueueSemaphoreTake+0x140>
    473c:	6c 81       	ldd	r22, Y+4	; 0x04
    473e:	7d 81       	ldd	r23, Y+5	; 0x05
    4740:	c7 01       	movw	r24, r14
    4742:	0e 94 8f 2b 	call	0x571e	; 0x571e <vTaskPlaceOnEventList>
    4746:	c8 01       	movw	r24, r16
    4748:	0e 94 0b 20 	call	0x4016	; 0x4016 <prvUnlockQueue>
    474c:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>
    4750:	88 23       	and	r24, r24
    4752:	11 f0       	breq	.+4      	; 0x4758 <xQueueSemaphoreTake+0xd2>
    4754:	21 e0       	ldi	r18, 0x01	; 1
    4756:	b4 cf       	rjmp	.-152    	; 0x46c0 <xQueueSemaphoreTake+0x3a>
    4758:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vPortYield>
    475c:	21 e0       	ldi	r18, 0x01	; 1
    475e:	b0 cf       	rjmp	.-160    	; 0x46c0 <xQueueSemaphoreTake+0x3a>
    4760:	c8 01       	movw	r24, r16
    4762:	0e 94 0b 20 	call	0x4016	; 0x4016 <prvUnlockQueue>
    4766:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>
    476a:	0f b6       	in	r0, 0x3f	; 63
    476c:	f8 94       	cli
    476e:	0f 92       	push	r0
    4770:	f8 01       	movw	r30, r16
    4772:	82 8d       	ldd	r24, Z+26	; 0x1a
    4774:	0f 90       	pop	r0
    4776:	0f be       	out	0x3f, r0	; 63
    4778:	81 11       	cpse	r24, r1
    477a:	ec cf       	rjmp	.-40     	; 0x4754 <xQueueSemaphoreTake+0xce>
    477c:	dd 20       	and	r13, r13
    477e:	09 f4       	brne	.+2      	; 0x4782 <xQueueSemaphoreTake+0xfc>
    4780:	72 c0       	rjmp	.+228    	; 0x4866 <xQueueSemaphoreTake+0x1e0>
    4782:	0f b6       	in	r0, 0x3f	; 63
    4784:	f8 94       	cli
    4786:	0f 92       	push	r0
    4788:	81 89       	ldd	r24, Z+17	; 0x11
    478a:	81 11       	cpse	r24, r1
    478c:	65 c0       	rjmp	.+202    	; 0x4858 <xQueueSemaphoreTake+0x1d2>
    478e:	60 e0       	ldi	r22, 0x00	; 0
    4790:	f8 01       	movw	r30, r16
    4792:	84 81       	ldd	r24, Z+4	; 0x04
    4794:	95 81       	ldd	r25, Z+5	; 0x05
    4796:	0e 94 d0 2e 	call	0x5da0	; 0x5da0 <vTaskPriorityDisinheritAfterTimeout>
    479a:	43 c0       	rjmp	.+134    	; 0x4822 <xQueueSemaphoreTake+0x19c>
    479c:	ce 01       	movw	r24, r28
    479e:	01 96       	adiw	r24, 0x01	; 1
    47a0:	0e 94 06 2c 	call	0x580c	; 0x580c <vTaskInternalSetTimeOutState>
    47a4:	9c cf       	rjmp	.-200    	; 0x46de <xQueueSemaphoreTake+0x58>
    47a6:	5d 96       	adiw	r26, 0x1d	; 29
    47a8:	1c 92       	st	X, r1
    47aa:	f8 01       	movw	r30, r16
    47ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    47ae:	8f 3f       	cpi	r24, 0xFF	; 255
    47b0:	09 f0       	breq	.+2      	; 0x47b4 <xQueueSemaphoreTake+0x12e>
    47b2:	a8 cf       	rjmp	.-176    	; 0x4704 <xQueueSemaphoreTake+0x7e>
    47b4:	16 8e       	std	Z+30, r1	; 0x1e
    47b6:	a6 cf       	rjmp	.-180    	; 0x4704 <xQueueSemaphoreTake+0x7e>
    47b8:	c8 01       	movw	r24, r16
    47ba:	0e 94 0b 20 	call	0x4016	; 0x4016 <prvUnlockQueue>
    47be:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>
    47c2:	21 e0       	ldi	r18, 0x01	; 1
    47c4:	7d cf       	rjmp	.-262    	; 0x46c0 <xQueueSemaphoreTake+0x3a>
    47c6:	0f b6       	in	r0, 0x3f	; 63
    47c8:	f8 94       	cli
    47ca:	0f 92       	push	r0
    47cc:	14 96       	adiw	r26, 0x04	; 4
    47ce:	8d 91       	ld	r24, X+
    47d0:	9c 91       	ld	r25, X
    47d2:	15 97       	sbiw	r26, 0x05	; 5
    47d4:	0e 94 06 2e 	call	0x5c0c	; 0x5c0c <xTaskPriorityInherit>
    47d8:	d8 2e       	mov	r13, r24
    47da:	0f 90       	pop	r0
    47dc:	0f be       	out	0x3f, r0	; 63
    47de:	ae cf       	rjmp	.-164    	; 0x473c <xQueueSemaphoreTake+0xb6>
    47e0:	81 50       	subi	r24, 0x01	; 1
    47e2:	82 8f       	std	Z+26, r24	; 0x1a
    47e4:	80 81       	ld	r24, Z
    47e6:	91 81       	ldd	r25, Z+1	; 0x01
    47e8:	89 2b       	or	r24, r25
    47ea:	09 f4       	brne	.+2      	; 0x47ee <xQueueSemaphoreTake+0x168>
    47ec:	3e c0       	rjmp	.+124    	; 0x486a <xQueueSemaphoreTake+0x1e4>
    47ee:	f8 01       	movw	r30, r16
    47f0:	80 85       	ldd	r24, Z+8	; 0x08
    47f2:	81 11       	cpse	r24, r1
    47f4:	21 c0       	rjmp	.+66     	; 0x4838 <xQueueSemaphoreTake+0x1b2>
    47f6:	0f 90       	pop	r0
    47f8:	0f be       	out	0x3f, r0	; 63
    47fa:	81 e0       	ldi	r24, 0x01	; 1
    47fc:	25 96       	adiw	r28, 0x05	; 5
    47fe:	cd bf       	out	0x3d, r28	; 61
    4800:	de bf       	out	0x3e, r29	; 62
    4802:	df 91       	pop	r29
    4804:	cf 91       	pop	r28
    4806:	1f 91       	pop	r17
    4808:	0f 91       	pop	r16
    480a:	ff 90       	pop	r15
    480c:	ef 90       	pop	r14
    480e:	df 90       	pop	r13
    4810:	08 95       	ret
    4812:	dd 20       	and	r13, r13
    4814:	31 f0       	breq	.+12     	; 0x4822 <xQueueSemaphoreTake+0x19c>
    4816:	61 ee       	ldi	r22, 0xE1	; 225
    4818:	75 e0       	ldi	r23, 0x05	; 5
    481a:	8a ee       	ldi	r24, 0xEA	; 234
    481c:	93 e2       	ldi	r25, 0x23	; 35
    481e:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    4822:	0f 90       	pop	r0
    4824:	0f be       	out	0x3f, r0	; 63
    4826:	80 e0       	ldi	r24, 0x00	; 0
    4828:	e9 cf       	rjmp	.-46     	; 0x47fc <xQueueSemaphoreTake+0x176>
    482a:	65 e9       	ldi	r22, 0x95	; 149
    482c:	75 e0       	ldi	r23, 0x05	; 5
    482e:	8a ee       	ldi	r24, 0xEA	; 234
    4830:	93 e2       	ldi	r25, 0x23	; 35
    4832:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    4836:	3e cf       	rjmp	.-388    	; 0x46b4 <xQueueSemaphoreTake+0x2e>
    4838:	c8 01       	movw	r24, r16
    483a:	08 96       	adiw	r24, 0x08	; 8
    483c:	0e 94 af 2b 	call	0x575e	; 0x575e <xTaskRemoveFromEventList>
    4840:	88 23       	and	r24, r24
    4842:	c9 f2       	breq	.-78     	; 0x47f6 <xQueueSemaphoreTake+0x170>
    4844:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vPortYield>
    4848:	d6 cf       	rjmp	.-84     	; 0x47f6 <xQueueSemaphoreTake+0x170>
    484a:	61 e9       	ldi	r22, 0x91	; 145
    484c:	75 e0       	ldi	r23, 0x05	; 5
    484e:	8a ee       	ldi	r24, 0xEA	; 234
    4850:	93 e2       	ldi	r25, 0x23	; 35
    4852:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    4856:	29 cf       	rjmp	.-430    	; 0x46aa <xQueueSemaphoreTake+0x24>
    4858:	06 88       	ldd	r0, Z+22	; 0x16
    485a:	f7 89       	ldd	r31, Z+23	; 0x17
    485c:	e0 2d       	mov	r30, r0
    485e:	80 81       	ld	r24, Z
    4860:	6a e0       	ldi	r22, 0x0A	; 10
    4862:	68 1b       	sub	r22, r24
    4864:	95 cf       	rjmp	.-214    	; 0x4790 <xQueueSemaphoreTake+0x10a>
    4866:	80 e0       	ldi	r24, 0x00	; 0
    4868:	c9 cf       	rjmp	.-110    	; 0x47fc <xQueueSemaphoreTake+0x176>
    486a:	0e 94 f5 2f 	call	0x5fea	; 0x5fea <pvTaskIncrementMutexHeldCount>
    486e:	d8 01       	movw	r26, r16
    4870:	14 96       	adiw	r26, 0x04	; 4
    4872:	8d 93       	st	X+, r24
    4874:	9c 93       	st	X, r25
    4876:	15 97       	sbiw	r26, 0x05	; 5
    4878:	ba cf       	rjmp	.-140    	; 0x47ee <xQueueSemaphoreTake+0x168>

0000487a <xQueuePeek>:
    487a:	cf 92       	push	r12
    487c:	df 92       	push	r13
    487e:	ef 92       	push	r14
    4880:	ff 92       	push	r15
    4882:	0f 93       	push	r16
    4884:	1f 93       	push	r17
    4886:	cf 93       	push	r28
    4888:	df 93       	push	r29
    488a:	cd b7       	in	r28, 0x3d	; 61
    488c:	de b7       	in	r29, 0x3e	; 62
    488e:	25 97       	sbiw	r28, 0x05	; 5
    4890:	cd bf       	out	0x3d, r28	; 61
    4892:	de bf       	out	0x3e, r29	; 62
    4894:	8c 01       	movw	r16, r24
    4896:	6b 01       	movw	r12, r22
    4898:	4c 83       	std	Y+4, r20	; 0x04
    489a:	5d 83       	std	Y+5, r21	; 0x05
    489c:	89 2b       	or	r24, r25
    489e:	09 f4       	brne	.+2      	; 0x48a2 <xQueuePeek+0x28>
    48a0:	a2 c0       	rjmp	.+324    	; 0x49e6 <xQueuePeek+0x16c>
    48a2:	c1 14       	cp	r12, r1
    48a4:	d1 04       	cpc	r13, r1
    48a6:	09 f4       	brne	.+2      	; 0x48aa <xQueuePeek+0x30>
    48a8:	92 c0       	rjmp	.+292    	; 0x49ce <xQueuePeek+0x154>
    48aa:	20 e0       	ldi	r18, 0x00	; 0
    48ac:	78 01       	movw	r14, r16
    48ae:	f1 e1       	ldi	r31, 0x11	; 17
    48b0:	ef 0e       	add	r14, r31
    48b2:	f1 1c       	adc	r15, r1
    48b4:	0f b6       	in	r0, 0x3f	; 63
    48b6:	f8 94       	cli
    48b8:	0f 92       	push	r0
    48ba:	f8 01       	movw	r30, r16
    48bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    48be:	81 11       	cpse	r24, r1
    48c0:	69 c0       	rjmp	.+210    	; 0x4994 <xQueuePeek+0x11a>
    48c2:	8c 81       	ldd	r24, Y+4	; 0x04
    48c4:	9d 81       	ldd	r25, Y+5	; 0x05
    48c6:	89 2b       	or	r24, r25
    48c8:	09 f4       	brne	.+2      	; 0x48cc <xQueuePeek+0x52>
    48ca:	74 c0       	rjmp	.+232    	; 0x49b4 <xQueuePeek+0x13a>
    48cc:	22 23       	and	r18, r18
    48ce:	09 f4       	brne	.+2      	; 0x48d2 <xQueuePeek+0x58>
    48d0:	58 c0       	rjmp	.+176    	; 0x4982 <xQueuePeek+0x108>
    48d2:	0f 90       	pop	r0
    48d4:	0f be       	out	0x3f, r0	; 63
    48d6:	0e 94 7f 29 	call	0x52fe	; 0x52fe <vTaskSuspendAll>
    48da:	0f b6       	in	r0, 0x3f	; 63
    48dc:	f8 94       	cli
    48de:	0f 92       	push	r0
    48e0:	f8 01       	movw	r30, r16
    48e2:	85 8d       	ldd	r24, Z+29	; 0x1d
    48e4:	8f 3f       	cpi	r24, 0xFF	; 255
    48e6:	09 f4       	brne	.+2      	; 0x48ea <xQueuePeek+0x70>
    48e8:	53 c0       	rjmp	.+166    	; 0x4990 <xQueuePeek+0x116>
    48ea:	f8 01       	movw	r30, r16
    48ec:	86 8d       	ldd	r24, Z+30	; 0x1e
    48ee:	8f 3f       	cpi	r24, 0xFF	; 255
    48f0:	09 f4       	brne	.+2      	; 0x48f4 <xQueuePeek+0x7a>
    48f2:	4c c0       	rjmp	.+152    	; 0x498c <xQueuePeek+0x112>
    48f4:	0f 90       	pop	r0
    48f6:	0f be       	out	0x3f, r0	; 63
    48f8:	be 01       	movw	r22, r28
    48fa:	6c 5f       	subi	r22, 0xFC	; 252
    48fc:	7f 4f       	sbci	r23, 0xFF	; 255
    48fe:	ce 01       	movw	r24, r28
    4900:	01 96       	adiw	r24, 0x01	; 1
    4902:	0e 94 11 2c 	call	0x5822	; 0x5822 <xTaskCheckForTimeOut>
    4906:	81 11       	cpse	r24, r1
    4908:	22 c0       	rjmp	.+68     	; 0x494e <xQueuePeek+0xd4>
    490a:	0f b6       	in	r0, 0x3f	; 63
    490c:	f8 94       	cli
    490e:	0f 92       	push	r0
    4910:	f8 01       	movw	r30, r16
    4912:	82 8d       	ldd	r24, Z+26	; 0x1a
    4914:	0f 90       	pop	r0
    4916:	0f be       	out	0x3f, r0	; 63
    4918:	81 11       	cpse	r24, r1
    491a:	12 c0       	rjmp	.+36     	; 0x4940 <xQueuePeek+0xc6>
    491c:	6c 81       	ldd	r22, Y+4	; 0x04
    491e:	7d 81       	ldd	r23, Y+5	; 0x05
    4920:	c7 01       	movw	r24, r14
    4922:	0e 94 8f 2b 	call	0x571e	; 0x571e <vTaskPlaceOnEventList>
    4926:	c8 01       	movw	r24, r16
    4928:	0e 94 0b 20 	call	0x4016	; 0x4016 <prvUnlockQueue>
    492c:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>
    4930:	88 23       	and	r24, r24
    4932:	11 f0       	breq	.+4      	; 0x4938 <xQueuePeek+0xbe>
    4934:	21 e0       	ldi	r18, 0x01	; 1
    4936:	be cf       	rjmp	.-132    	; 0x48b4 <xQueuePeek+0x3a>
    4938:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vPortYield>
    493c:	21 e0       	ldi	r18, 0x01	; 1
    493e:	ba cf       	rjmp	.-140    	; 0x48b4 <xQueuePeek+0x3a>
    4940:	c8 01       	movw	r24, r16
    4942:	0e 94 0b 20 	call	0x4016	; 0x4016 <prvUnlockQueue>
    4946:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>
    494a:	21 e0       	ldi	r18, 0x01	; 1
    494c:	b3 cf       	rjmp	.-154    	; 0x48b4 <xQueuePeek+0x3a>
    494e:	c8 01       	movw	r24, r16
    4950:	0e 94 0b 20 	call	0x4016	; 0x4016 <prvUnlockQueue>
    4954:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>
    4958:	0f b6       	in	r0, 0x3f	; 63
    495a:	f8 94       	cli
    495c:	0f 92       	push	r0
    495e:	f8 01       	movw	r30, r16
    4960:	82 8d       	ldd	r24, Z+26	; 0x1a
    4962:	0f 90       	pop	r0
    4964:	0f be       	out	0x3f, r0	; 63
    4966:	81 11       	cpse	r24, r1
    4968:	e5 cf       	rjmp	.-54     	; 0x4934 <xQueuePeek+0xba>
    496a:	25 96       	adiw	r28, 0x05	; 5
    496c:	cd bf       	out	0x3d, r28	; 61
    496e:	de bf       	out	0x3e, r29	; 62
    4970:	df 91       	pop	r29
    4972:	cf 91       	pop	r28
    4974:	1f 91       	pop	r17
    4976:	0f 91       	pop	r16
    4978:	ff 90       	pop	r15
    497a:	ef 90       	pop	r14
    497c:	df 90       	pop	r13
    497e:	cf 90       	pop	r12
    4980:	08 95       	ret
    4982:	ce 01       	movw	r24, r28
    4984:	01 96       	adiw	r24, 0x01	; 1
    4986:	0e 94 06 2c 	call	0x580c	; 0x580c <vTaskInternalSetTimeOutState>
    498a:	a3 cf       	rjmp	.-186    	; 0x48d2 <xQueuePeek+0x58>
    498c:	16 8e       	std	Z+30, r1	; 0x1e
    498e:	b2 cf       	rjmp	.-156    	; 0x48f4 <xQueuePeek+0x7a>
    4990:	15 8e       	std	Z+29, r1	; 0x1d
    4992:	ab cf       	rjmp	.-170    	; 0x48ea <xQueuePeek+0x70>
    4994:	e6 80       	ldd	r14, Z+6	; 0x06
    4996:	f7 80       	ldd	r15, Z+7	; 0x07
    4998:	b6 01       	movw	r22, r12
    499a:	c8 01       	movw	r24, r16
    499c:	0e 94 f3 1f 	call	0x3fe6	; 0x3fe6 <prvCopyDataFromQueue>
    49a0:	f8 01       	movw	r30, r16
    49a2:	e6 82       	std	Z+6, r14	; 0x06
    49a4:	f7 82       	std	Z+7, r15	; 0x07
    49a6:	81 89       	ldd	r24, Z+17	; 0x11
    49a8:	81 11       	cpse	r24, r1
    49aa:	08 c0       	rjmp	.+16     	; 0x49bc <xQueuePeek+0x142>
    49ac:	0f 90       	pop	r0
    49ae:	0f be       	out	0x3f, r0	; 63
    49b0:	81 e0       	ldi	r24, 0x01	; 1
    49b2:	db cf       	rjmp	.-74     	; 0x496a <xQueuePeek+0xf0>
    49b4:	0f 90       	pop	r0
    49b6:	0f be       	out	0x3f, r0	; 63
    49b8:	80 e0       	ldi	r24, 0x00	; 0
    49ba:	d7 cf       	rjmp	.-82     	; 0x496a <xQueuePeek+0xf0>
    49bc:	c8 01       	movw	r24, r16
    49be:	41 96       	adiw	r24, 0x11	; 17
    49c0:	0e 94 af 2b 	call	0x575e	; 0x575e <xTaskRemoveFromEventList>
    49c4:	88 23       	and	r24, r24
    49c6:	91 f3       	breq	.-28     	; 0x49ac <xQueuePeek+0x132>
    49c8:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vPortYield>
    49cc:	ef cf       	rjmp	.-34     	; 0x49ac <xQueuePeek+0x132>
    49ce:	f8 01       	movw	r30, r16
    49d0:	84 8d       	ldd	r24, Z+28	; 0x1c
    49d2:	88 23       	and	r24, r24
    49d4:	09 f4       	brne	.+2      	; 0x49d8 <xQueuePeek+0x15e>
    49d6:	69 cf       	rjmp	.-302    	; 0x48aa <xQueuePeek+0x30>
    49d8:	6c e6       	ldi	r22, 0x6C	; 108
    49da:	76 e0       	ldi	r23, 0x06	; 6
    49dc:	8a ee       	ldi	r24, 0xEA	; 234
    49de:	93 e2       	ldi	r25, 0x23	; 35
    49e0:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    49e4:	62 cf       	rjmp	.-316    	; 0x48aa <xQueuePeek+0x30>
    49e6:	68 e6       	ldi	r22, 0x68	; 104
    49e8:	76 e0       	ldi	r23, 0x06	; 6
    49ea:	8a ee       	ldi	r24, 0xEA	; 234
    49ec:	93 e2       	ldi	r25, 0x23	; 35
    49ee:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    49f2:	57 cf       	rjmp	.-338    	; 0x48a2 <xQueuePeek+0x28>

000049f4 <xQueueReceiveFromISR>:
    49f4:	cf 92       	push	r12
    49f6:	df 92       	push	r13
    49f8:	ef 92       	push	r14
    49fa:	ff 92       	push	r15
    49fc:	0f 93       	push	r16
    49fe:	1f 93       	push	r17
    4a00:	cf 93       	push	r28
    4a02:	df 93       	push	r29
    4a04:	ec 01       	movw	r28, r24
    4a06:	7b 01       	movw	r14, r22
    4a08:	6a 01       	movw	r12, r20
    4a0a:	89 2b       	or	r24, r25
    4a0c:	b9 f1       	breq	.+110    	; 0x4a7c <xQueueReceiveFromISR+0x88>
    4a0e:	e1 14       	cp	r14, r1
    4a10:	f1 04       	cpc	r15, r1
    4a12:	d1 f0       	breq	.+52     	; 0x4a48 <xQueueReceiveFromISR+0x54>
    4a14:	1a 8d       	ldd	r17, Y+26	; 0x1a
    4a16:	11 11       	cpse	r17, r1
    4a18:	0a c0       	rjmp	.+20     	; 0x4a2e <xQueueReceiveFromISR+0x3a>
    4a1a:	80 e0       	ldi	r24, 0x00	; 0
    4a1c:	df 91       	pop	r29
    4a1e:	cf 91       	pop	r28
    4a20:	1f 91       	pop	r17
    4a22:	0f 91       	pop	r16
    4a24:	ff 90       	pop	r15
    4a26:	ef 90       	pop	r14
    4a28:	df 90       	pop	r13
    4a2a:	cf 90       	pop	r12
    4a2c:	08 95       	ret
    4a2e:	0d 8d       	ldd	r16, Y+29	; 0x1d
    4a30:	b7 01       	movw	r22, r14
    4a32:	ce 01       	movw	r24, r28
    4a34:	0e 94 f3 1f 	call	0x3fe6	; 0x3fe6 <prvCopyDataFromQueue>
    4a38:	11 50       	subi	r17, 0x01	; 1
    4a3a:	1a 8f       	std	Y+26, r17	; 0x1a
    4a3c:	0f 3f       	cpi	r16, 0xFF	; 255
    4a3e:	71 f0       	breq	.+28     	; 0x4a5c <xQueueReceiveFromISR+0x68>
    4a40:	0f 5f       	subi	r16, 0xFF	; 255
    4a42:	0d 8f       	std	Y+29, r16	; 0x1d
    4a44:	81 e0       	ldi	r24, 0x01	; 1
    4a46:	ea cf       	rjmp	.-44     	; 0x4a1c <xQueueReceiveFromISR+0x28>
    4a48:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4a4a:	88 23       	and	r24, r24
    4a4c:	19 f3       	breq	.-58     	; 0x4a14 <xQueueReceiveFromISR+0x20>
    4a4e:	6c ef       	ldi	r22, 0xFC	; 252
    4a50:	76 e0       	ldi	r23, 0x06	; 6
    4a52:	8a ee       	ldi	r24, 0xEA	; 234
    4a54:	93 e2       	ldi	r25, 0x23	; 35
    4a56:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    4a5a:	dc cf       	rjmp	.-72     	; 0x4a14 <xQueueReceiveFromISR+0x20>
    4a5c:	88 85       	ldd	r24, Y+8	; 0x08
    4a5e:	88 23       	and	r24, r24
    4a60:	89 f3       	breq	.-30     	; 0x4a44 <xQueueReceiveFromISR+0x50>
    4a62:	ce 01       	movw	r24, r28
    4a64:	08 96       	adiw	r24, 0x08	; 8
    4a66:	0e 94 af 2b 	call	0x575e	; 0x575e <xTaskRemoveFromEventList>
    4a6a:	88 23       	and	r24, r24
    4a6c:	59 f3       	breq	.-42     	; 0x4a44 <xQueueReceiveFromISR+0x50>
    4a6e:	c1 14       	cp	r12, r1
    4a70:	d1 04       	cpc	r13, r1
    4a72:	41 f3       	breq	.-48     	; 0x4a44 <xQueueReceiveFromISR+0x50>
    4a74:	81 e0       	ldi	r24, 0x01	; 1
    4a76:	f6 01       	movw	r30, r12
    4a78:	80 83       	st	Z, r24
    4a7a:	d0 cf       	rjmp	.-96     	; 0x4a1c <xQueueReceiveFromISR+0x28>
    4a7c:	6b ef       	ldi	r22, 0xFB	; 251
    4a7e:	76 e0       	ldi	r23, 0x06	; 6
    4a80:	8a ee       	ldi	r24, 0xEA	; 234
    4a82:	93 e2       	ldi	r25, 0x23	; 35
    4a84:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    4a88:	c2 cf       	rjmp	.-124    	; 0x4a0e <xQueueReceiveFromISR+0x1a>

00004a8a <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    4a8a:	cf 93       	push	r28
    4a8c:	df 93       	push	r29
    4a8e:	ec 01       	movw	r28, r24
UBaseType_t uxReturn;

	configASSERT( xQueue );
    4a90:	89 2b       	or	r24, r25
    4a92:	49 f0       	breq	.+18     	; 0x4aa6 <uxQueueMessagesWaiting+0x1c>

	taskENTER_CRITICAL();
    4a94:	0f b6       	in	r0, 0x3f	; 63
    4a96:	f8 94       	cli
    4a98:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    4a9a:	8a 8d       	ldd	r24, Y+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    4a9c:	0f 90       	pop	r0
    4a9e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4aa0:	df 91       	pop	r29
    4aa2:	cf 91       	pop	r28
    4aa4:	08 95       	ret

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
UBaseType_t uxReturn;

	configASSERT( xQueue );
    4aa6:	6a e8       	ldi	r22, 0x8A	; 138
    4aa8:	77 e0       	ldi	r23, 0x07	; 7
    4aaa:	8a ee       	ldi	r24, 0xEA	; 234
    4aac:	93 e2       	ldi	r25, 0x23	; 35
    4aae:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    4ab2:	f0 cf       	rjmp	.-32     	; 0x4a94 <uxQueueMessagesWaiting+0xa>

00004ab4 <prvIdleTask>:
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4ab4:	20 c0       	rjmp	.+64     	; 0x4af6 <prvIdleTask+0x42>
    4ab6:	0f b6       	in	r0, 0x3f	; 63
    4ab8:	f8 94       	cli
    4aba:	0f 92       	push	r0
    4abc:	e0 91 8b 2d 	lds	r30, 0x2D8B	; 0x802d8b <xTasksWaitingTermination+0x5>
    4ac0:	f0 91 8c 2d 	lds	r31, 0x2D8C	; 0x802d8c <xTasksWaitingTermination+0x6>
    4ac4:	c6 81       	ldd	r28, Z+6	; 0x06
    4ac6:	d7 81       	ldd	r29, Z+7	; 0x07
    4ac8:	ce 01       	movw	r24, r28
    4aca:	02 96       	adiw	r24, 0x02	; 2
    4acc:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <uxListRemove>
    4ad0:	80 91 7b 2d 	lds	r24, 0x2D7B	; 0x802d7b <uxCurrentNumberOfTasks>
    4ad4:	81 50       	subi	r24, 0x01	; 1
    4ad6:	80 93 7b 2d 	sts	0x2D7B, r24	; 0x802d7b <uxCurrentNumberOfTasks>
    4ada:	80 91 85 2d 	lds	r24, 0x2D85	; 0x802d85 <uxDeletedTasksWaitingCleanUp>
    4ade:	81 50       	subi	r24, 0x01	; 1
    4ae0:	80 93 85 2d 	sts	0x2D85, r24	; 0x802d85 <uxDeletedTasksWaitingCleanUp>
    4ae4:	0f 90       	pop	r0
    4ae6:	0f be       	out	0x3f, r0	; 63
    4ae8:	8f 89       	ldd	r24, Y+23	; 0x17
    4aea:	98 8d       	ldd	r25, Y+24	; 0x18
    4aec:	0e 94 e4 1c 	call	0x39c8	; 0x39c8 <vPortFree>
    4af0:	ce 01       	movw	r24, r28
    4af2:	0e 94 e4 1c 	call	0x39c8	; 0x39c8 <vPortFree>
    4af6:	80 91 85 2d 	lds	r24, 0x2D85	; 0x802d85 <uxDeletedTasksWaitingCleanUp>
    4afa:	81 11       	cpse	r24, r1
    4afc:	dc cf       	rjmp	.-72     	; 0x4ab6 <prvIdleTask+0x2>
    4afe:	80 91 ae 2d 	lds	r24, 0x2DAE	; 0x802dae <pxReadyTasksLists>
    4b02:	82 30       	cpi	r24, 0x02	; 2
    4b04:	10 f0       	brcs	.+4      	; 0x4b0a <prvIdleTask+0x56>
    4b06:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vPortYield>
    4b0a:	0e 94 7b 30 	call	0x60f6	; 0x60f6 <vApplicationIdleHook>
    4b0e:	f3 cf       	rjmp	.-26     	; 0x4af6 <prvIdleTask+0x42>

00004b10 <prvWriteNameToBuffer>:
    4b10:	cf 93       	push	r28
    4b12:	df 93       	push	r29
    4b14:	ec 01       	movw	r28, r24
    4b16:	0e 94 1e 50 	call	0xa03c	; 0xa03c <strcpy>
    4b1a:	fe 01       	movw	r30, r28
    4b1c:	01 90       	ld	r0, Z+
    4b1e:	00 20       	and	r0, r0
    4b20:	e9 f7       	brne	.-6      	; 0x4b1c <prvWriteNameToBuffer+0xc>
    4b22:	31 97       	sbiw	r30, 0x01	; 1
    4b24:	ec 1b       	sub	r30, r28
    4b26:	fd 0b       	sbc	r31, r29
    4b28:	e7 30       	cpi	r30, 0x07	; 7
    4b2a:	f1 05       	cpc	r31, r1
    4b2c:	60 f4       	brcc	.+24     	; 0x4b46 <prvWriteNameToBuffer+0x36>
    4b2e:	ec 0f       	add	r30, r28
    4b30:	fd 1f       	adc	r31, r29
    4b32:	9e 01       	movw	r18, r28
    4b34:	29 5f       	subi	r18, 0xF9	; 249
    4b36:	3f 4f       	sbci	r19, 0xFF	; 255
    4b38:	80 e2       	ldi	r24, 0x20	; 32
    4b3a:	81 93       	st	Z+, r24
    4b3c:	e2 17       	cp	r30, r18
    4b3e:	f3 07       	cpc	r31, r19
    4b40:	e1 f7       	brne	.-8      	; 0x4b3a <prvWriteNameToBuffer+0x2a>
    4b42:	e7 e0       	ldi	r30, 0x07	; 7
    4b44:	f0 e0       	ldi	r31, 0x00	; 0
    4b46:	ce 01       	movw	r24, r28
    4b48:	8e 0f       	add	r24, r30
    4b4a:	9f 1f       	adc	r25, r31
    4b4c:	fc 01       	movw	r30, r24
    4b4e:	10 82       	st	Z, r1
    4b50:	df 91       	pop	r29
    4b52:	cf 91       	pop	r28
    4b54:	08 95       	ret

00004b56 <prvResetNextTaskUnblockTime.part.0>:
    4b56:	e0 91 9a 2d 	lds	r30, 0x2D9A	; 0x802d9a <pxDelayedTaskList>
    4b5a:	f0 91 9b 2d 	lds	r31, 0x2D9B	; 0x802d9b <pxDelayedTaskList+0x1>
    4b5e:	05 80       	ldd	r0, Z+5	; 0x05
    4b60:	f6 81       	ldd	r31, Z+6	; 0x06
    4b62:	e0 2d       	mov	r30, r0
    4b64:	06 80       	ldd	r0, Z+6	; 0x06
    4b66:	f7 81       	ldd	r31, Z+7	; 0x07
    4b68:	e0 2d       	mov	r30, r0
    4b6a:	82 81       	ldd	r24, Z+2	; 0x02
    4b6c:	93 81       	ldd	r25, Z+3	; 0x03
    4b6e:	80 93 71 2d 	sts	0x2D71, r24	; 0x802d71 <xNextTaskUnblockTime>
    4b72:	90 93 72 2d 	sts	0x2D72, r25	; 0x802d72 <xNextTaskUnblockTime+0x1>
    4b76:	08 95       	ret

00004b78 <prvTaskIsTaskSuspended>:
    4b78:	cf 93       	push	r28
    4b7a:	df 93       	push	r29
    4b7c:	ec 01       	movw	r28, r24
    4b7e:	89 2b       	or	r24, r25
    4b80:	99 f0       	breq	.+38     	; 0x4ba8 <prvTaskIsTaskSuspended+0x30>
    4b82:	8a 85       	ldd	r24, Y+10	; 0x0a
    4b84:	9b 85       	ldd	r25, Y+11	; 0x0b
    4b86:	8c 57       	subi	r24, 0x7C	; 124
    4b88:	9d 42       	sbci	r25, 0x2D	; 45
    4b8a:	21 f0       	breq	.+8      	; 0x4b94 <prvTaskIsTaskSuspended+0x1c>
    4b8c:	80 e0       	ldi	r24, 0x00	; 0
    4b8e:	df 91       	pop	r29
    4b90:	cf 91       	pop	r28
    4b92:	08 95       	ret
    4b94:	2c 89       	ldd	r18, Y+20	; 0x14
    4b96:	3d 89       	ldd	r19, Y+21	; 0x15
    4b98:	8d e2       	ldi	r24, 0x2D	; 45
    4b9a:	2f 38       	cpi	r18, 0x8F	; 143
    4b9c:	38 07       	cpc	r19, r24
    4b9e:	b1 f3       	breq	.-20     	; 0x4b8c <prvTaskIsTaskSuspended+0x14>
    4ba0:	81 e0       	ldi	r24, 0x01	; 1
    4ba2:	23 2b       	or	r18, r19
    4ba4:	99 f7       	brne	.-26     	; 0x4b8c <prvTaskIsTaskSuspended+0x14>
    4ba6:	f3 cf       	rjmp	.-26     	; 0x4b8e <prvTaskIsTaskSuspended+0x16>
    4ba8:	62 ef       	ldi	r22, 0xF2	; 242
    4baa:	76 e0       	ldi	r23, 0x06	; 6
    4bac:	8e ef       	ldi	r24, 0xFE	; 254
    4bae:	93 e2       	ldi	r25, 0x23	; 35
    4bb0:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    4bb4:	e6 cf       	rjmp	.-52     	; 0x4b82 <prvTaskIsTaskSuspended+0xa>

00004bb6 <prvAddCurrentTaskToDelayedList>:
    4bb6:	ff 92       	push	r15
    4bb8:	0f 93       	push	r16
    4bba:	1f 93       	push	r17
    4bbc:	cf 93       	push	r28
    4bbe:	df 93       	push	r29
    4bc0:	ec 01       	movw	r28, r24
    4bc2:	f6 2e       	mov	r15, r22
    4bc4:	00 91 79 2d 	lds	r16, 0x2D79	; 0x802d79 <xTickCount>
    4bc8:	10 91 7a 2d 	lds	r17, 0x2D7A	; 0x802d7a <xTickCount+0x1>
    4bcc:	80 91 08 2e 	lds	r24, 0x2E08	; 0x802e08 <pxCurrentTCB>
    4bd0:	90 91 09 2e 	lds	r25, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    4bd4:	02 96       	adiw	r24, 0x02	; 2
    4bd6:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <uxListRemove>
    4bda:	cf 3f       	cpi	r28, 0xFF	; 255
    4bdc:	8f ef       	ldi	r24, 0xFF	; 255
    4bde:	d8 07       	cpc	r29, r24
    4be0:	a9 f1       	breq	.+106    	; 0x4c4c <prvAddCurrentTaskToDelayedList+0x96>
    4be2:	c0 0f       	add	r28, r16
    4be4:	d1 1f       	adc	r29, r17
    4be6:	e0 91 08 2e 	lds	r30, 0x2E08	; 0x802e08 <pxCurrentTCB>
    4bea:	f0 91 09 2e 	lds	r31, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    4bee:	c2 83       	std	Z+2, r28	; 0x02
    4bf0:	d3 83       	std	Z+3, r29	; 0x03
    4bf2:	60 91 08 2e 	lds	r22, 0x2E08	; 0x802e08 <pxCurrentTCB>
    4bf6:	70 91 09 2e 	lds	r23, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    4bfa:	c0 17       	cp	r28, r16
    4bfc:	d1 07       	cpc	r29, r17
    4bfe:	c8 f0       	brcs	.+50     	; 0x4c32 <prvAddCurrentTaskToDelayedList+0x7c>
    4c00:	80 91 9a 2d 	lds	r24, 0x2D9A	; 0x802d9a <pxDelayedTaskList>
    4c04:	90 91 9b 2d 	lds	r25, 0x2D9B	; 0x802d9b <pxDelayedTaskList+0x1>
    4c08:	6e 5f       	subi	r22, 0xFE	; 254
    4c0a:	7f 4f       	sbci	r23, 0xFF	; 255
    4c0c:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <vListInsert>
    4c10:	80 91 71 2d 	lds	r24, 0x2D71	; 0x802d71 <xNextTaskUnblockTime>
    4c14:	90 91 72 2d 	lds	r25, 0x2D72	; 0x802d72 <xNextTaskUnblockTime+0x1>
    4c18:	c8 17       	cp	r28, r24
    4c1a:	d9 07       	cpc	r29, r25
    4c1c:	20 f4       	brcc	.+8      	; 0x4c26 <prvAddCurrentTaskToDelayedList+0x70>
    4c1e:	c0 93 71 2d 	sts	0x2D71, r28	; 0x802d71 <xNextTaskUnblockTime>
    4c22:	d0 93 72 2d 	sts	0x2D72, r29	; 0x802d72 <xNextTaskUnblockTime+0x1>
    4c26:	df 91       	pop	r29
    4c28:	cf 91       	pop	r28
    4c2a:	1f 91       	pop	r17
    4c2c:	0f 91       	pop	r16
    4c2e:	ff 90       	pop	r15
    4c30:	08 95       	ret
    4c32:	80 91 98 2d 	lds	r24, 0x2D98	; 0x802d98 <pxOverflowDelayedTaskList>
    4c36:	90 91 99 2d 	lds	r25, 0x2D99	; 0x802d99 <pxOverflowDelayedTaskList+0x1>
    4c3a:	6e 5f       	subi	r22, 0xFE	; 254
    4c3c:	7f 4f       	sbci	r23, 0xFF	; 255
    4c3e:	df 91       	pop	r29
    4c40:	cf 91       	pop	r28
    4c42:	1f 91       	pop	r17
    4c44:	0f 91       	pop	r16
    4c46:	ff 90       	pop	r15
    4c48:	0c 94 47 1d 	jmp	0x3a8e	; 0x3a8e <vListInsert>
    4c4c:	ff 20       	and	r15, r15
    4c4e:	49 f2       	breq	.-110    	; 0x4be2 <prvAddCurrentTaskToDelayedList+0x2c>
    4c50:	60 91 08 2e 	lds	r22, 0x2E08	; 0x802e08 <pxCurrentTCB>
    4c54:	70 91 09 2e 	lds	r23, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    4c58:	6e 5f       	subi	r22, 0xFE	; 254
    4c5a:	7f 4f       	sbci	r23, 0xFF	; 255
    4c5c:	8c e7       	ldi	r24, 0x7C	; 124
    4c5e:	9d e2       	ldi	r25, 0x2D	; 45
    4c60:	df 91       	pop	r29
    4c62:	cf 91       	pop	r28
    4c64:	1f 91       	pop	r17
    4c66:	0f 91       	pop	r16
    4c68:	ff 90       	pop	r15
    4c6a:	0c 94 26 1d 	jmp	0x3a4c	; 0x3a4c <vListInsertEnd>

00004c6e <vTaskSwitchContext.part.5>:
    4c6e:	0f 93       	push	r16
    4c70:	1f 93       	push	r17
    4c72:	cf 93       	push	r28
    4c74:	10 92 75 2d 	sts	0x2D75, r1	; 0x802d75 <xYieldPending>
    4c78:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    4c7c:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    4c80:	80 91 6e 2e 	lds	r24, 0x2E6E	; 0x802e6e <StatsTimer>
    4c84:	90 91 6f 2e 	lds	r25, 0x2E6F	; 0x802e6f <StatsTimer+0x1>
    4c88:	a0 91 70 2e 	lds	r26, 0x2E70	; 0x802e70 <StatsTimer+0x2>
    4c8c:	b0 91 71 2e 	lds	r27, 0x2E71	; 0x802e71 <StatsTimer+0x3>
    4c90:	82 0f       	add	r24, r18
    4c92:	93 1f       	adc	r25, r19
    4c94:	a1 1d       	adc	r26, r1
    4c96:	b1 1d       	adc	r27, r1
    4c98:	00 91 6a 2d 	lds	r16, 0x2D6A	; 0x802d6a <ulTaskSwitchedInTime>
    4c9c:	10 91 6b 2d 	lds	r17, 0x2D6B	; 0x802d6b <ulTaskSwitchedInTime+0x1>
    4ca0:	20 91 6c 2d 	lds	r18, 0x2D6C	; 0x802d6c <ulTaskSwitchedInTime+0x2>
    4ca4:	30 91 6d 2d 	lds	r19, 0x2D6D	; 0x802d6d <ulTaskSwitchedInTime+0x3>
    4ca8:	08 17       	cp	r16, r24
    4caa:	19 07       	cpc	r17, r25
    4cac:	2a 07       	cpc	r18, r26
    4cae:	3b 07       	cpc	r19, r27
    4cb0:	a0 f4       	brcc	.+40     	; 0x4cda <vTaskSwitchContext.part.5+0x6c>
    4cb2:	e0 91 08 2e 	lds	r30, 0x2E08	; 0x802e08 <pxCurrentTCB>
    4cb6:	f0 91 09 2e 	lds	r31, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    4cba:	47 a1       	ldd	r20, Z+39	; 0x27
    4cbc:	50 a5       	ldd	r21, Z+40	; 0x28
    4cbe:	61 a5       	ldd	r22, Z+41	; 0x29
    4cc0:	72 a5       	ldd	r23, Z+42	; 0x2a
    4cc2:	40 1b       	sub	r20, r16
    4cc4:	51 0b       	sbc	r21, r17
    4cc6:	62 0b       	sbc	r22, r18
    4cc8:	73 0b       	sbc	r23, r19
    4cca:	48 0f       	add	r20, r24
    4ccc:	59 1f       	adc	r21, r25
    4cce:	6a 1f       	adc	r22, r26
    4cd0:	7b 1f       	adc	r23, r27
    4cd2:	47 a3       	std	Z+39, r20	; 0x27
    4cd4:	50 a7       	std	Z+40, r21	; 0x28
    4cd6:	61 a7       	std	Z+41, r22	; 0x29
    4cd8:	72 a7       	std	Z+42, r23	; 0x2a
    4cda:	80 93 6a 2d 	sts	0x2D6A, r24	; 0x802d6a <ulTaskSwitchedInTime>
    4cde:	90 93 6b 2d 	sts	0x2D6B, r25	; 0x802d6b <ulTaskSwitchedInTime+0x1>
    4ce2:	a0 93 6c 2d 	sts	0x2D6C, r26	; 0x802d6c <ulTaskSwitchedInTime+0x2>
    4ce6:	b0 93 6d 2d 	sts	0x2D6D, r27	; 0x802d6d <ulTaskSwitchedInTime+0x3>
    4cea:	e0 91 08 2e 	lds	r30, 0x2E08	; 0x802e08 <pxCurrentTCB>
    4cee:	f0 91 09 2e 	lds	r31, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    4cf2:	07 88       	ldd	r0, Z+23	; 0x17
    4cf4:	f0 8d       	ldd	r31, Z+24	; 0x18
    4cf6:	e0 2d       	mov	r30, r0
    4cf8:	80 81       	ld	r24, Z
    4cfa:	91 81       	ldd	r25, Z+1	; 0x01
    4cfc:	a2 81       	ldd	r26, Z+2	; 0x02
    4cfe:	b3 81       	ldd	r27, Z+3	; 0x03
    4d00:	85 3a       	cpi	r24, 0xA5	; 165
    4d02:	95 4a       	sbci	r25, 0xA5	; 165
    4d04:	a5 4a       	sbci	r26, 0xA5	; 165
    4d06:	b5 4a       	sbci	r27, 0xA5	; 165
    4d08:	09 f4       	brne	.+2      	; 0x4d0c <vTaskSwitchContext.part.5+0x9e>
    4d0a:	4c c0       	rjmp	.+152    	; 0x4da4 <vTaskSwitchContext.part.5+0x136>
    4d0c:	60 91 08 2e 	lds	r22, 0x2E08	; 0x802e08 <pxCurrentTCB>
    4d10:	70 91 09 2e 	lds	r23, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    4d14:	80 91 08 2e 	lds	r24, 0x2E08	; 0x802e08 <pxCurrentTCB>
    4d18:	90 91 09 2e 	lds	r25, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    4d1c:	67 5e       	subi	r22, 0xE7	; 231
    4d1e:	7f 4f       	sbci	r23, 0xFF	; 255
    4d20:	0e 94 9b 30 	call	0x6136	; 0x6136 <vApplicationStackOverflowHook>
    4d24:	c0 91 78 2d 	lds	r28, 0x2D78	; 0x802d78 <uxTopReadyPriority>
    4d28:	8c 2f       	mov	r24, r28
    4d2a:	90 e0       	ldi	r25, 0x00	; 0
    4d2c:	9c 01       	movw	r18, r24
    4d2e:	22 0f       	add	r18, r18
    4d30:	33 1f       	adc	r19, r19
    4d32:	22 0f       	add	r18, r18
    4d34:	33 1f       	adc	r19, r19
    4d36:	22 0f       	add	r18, r18
    4d38:	33 1f       	adc	r19, r19
    4d3a:	f9 01       	movw	r30, r18
    4d3c:	e8 0f       	add	r30, r24
    4d3e:	f9 1f       	adc	r31, r25
    4d40:	e2 55       	subi	r30, 0x52	; 82
    4d42:	f2 4d       	sbci	r31, 0xD2	; 210
    4d44:	40 81       	ld	r20, Z
    4d46:	41 11       	cpse	r20, r1
    4d48:	0c c0       	rjmp	.+24     	; 0x4d62 <vTaskSwitchContext.part.5+0xf4>
    4d4a:	cc 23       	and	r28, r28
    4d4c:	11 f0       	breq	.+4      	; 0x4d52 <vTaskSwitchContext.part.5+0xe4>
    4d4e:	c1 50       	subi	r28, 0x01	; 1
    4d50:	eb cf       	rjmp	.-42     	; 0x4d28 <vTaskSwitchContext.part.5+0xba>
    4d52:	6c e8       	ldi	r22, 0x8C	; 140
    4d54:	7b e0       	ldi	r23, 0x0B	; 11
    4d56:	8e ef       	ldi	r24, 0xFE	; 254
    4d58:	93 e2       	ldi	r25, 0x23	; 35
    4d5a:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    4d5e:	c1 50       	subi	r28, 0x01	; 1
    4d60:	e3 cf       	rjmp	.-58     	; 0x4d28 <vTaskSwitchContext.part.5+0xba>
    4d62:	82 0f       	add	r24, r18
    4d64:	93 1f       	adc	r25, r19
    4d66:	dc 01       	movw	r26, r24
    4d68:	a2 55       	subi	r26, 0x52	; 82
    4d6a:	b2 4d       	sbci	r27, 0xD2	; 210
    4d6c:	11 96       	adiw	r26, 0x01	; 1
    4d6e:	ed 91       	ld	r30, X+
    4d70:	fc 91       	ld	r31, X
    4d72:	12 97       	sbiw	r26, 0x02	; 2
    4d74:	02 80       	ldd	r0, Z+2	; 0x02
    4d76:	f3 81       	ldd	r31, Z+3	; 0x03
    4d78:	e0 2d       	mov	r30, r0
    4d7a:	11 96       	adiw	r26, 0x01	; 1
    4d7c:	ed 93       	st	X+, r30
    4d7e:	fc 93       	st	X, r31
    4d80:	12 97       	sbiw	r26, 0x02	; 2
    4d82:	8f 54       	subi	r24, 0x4F	; 79
    4d84:	92 4d       	sbci	r25, 0xD2	; 210
    4d86:	e8 17       	cp	r30, r24
    4d88:	f9 07       	cpc	r31, r25
    4d8a:	59 f1       	breq	.+86     	; 0x4de2 <vTaskSwitchContext.part.5+0x174>
    4d8c:	86 81       	ldd	r24, Z+6	; 0x06
    4d8e:	97 81       	ldd	r25, Z+7	; 0x07
    4d90:	80 93 08 2e 	sts	0x2E08, r24	; 0x802e08 <pxCurrentTCB>
    4d94:	90 93 09 2e 	sts	0x2E09, r25	; 0x802e09 <pxCurrentTCB+0x1>
    4d98:	c0 93 78 2d 	sts	0x2D78, r28	; 0x802d78 <uxTopReadyPriority>
    4d9c:	cf 91       	pop	r28
    4d9e:	1f 91       	pop	r17
    4da0:	0f 91       	pop	r16
    4da2:	08 95       	ret
    4da4:	84 81       	ldd	r24, Z+4	; 0x04
    4da6:	95 81       	ldd	r25, Z+5	; 0x05
    4da8:	a6 81       	ldd	r26, Z+6	; 0x06
    4daa:	b7 81       	ldd	r27, Z+7	; 0x07
    4dac:	85 3a       	cpi	r24, 0xA5	; 165
    4dae:	95 4a       	sbci	r25, 0xA5	; 165
    4db0:	a5 4a       	sbci	r26, 0xA5	; 165
    4db2:	b5 4a       	sbci	r27, 0xA5	; 165
    4db4:	09 f0       	breq	.+2      	; 0x4db8 <vTaskSwitchContext.part.5+0x14a>
    4db6:	aa cf       	rjmp	.-172    	; 0x4d0c <vTaskSwitchContext.part.5+0x9e>
    4db8:	80 85       	ldd	r24, Z+8	; 0x08
    4dba:	91 85       	ldd	r25, Z+9	; 0x09
    4dbc:	a2 85       	ldd	r26, Z+10	; 0x0a
    4dbe:	b3 85       	ldd	r27, Z+11	; 0x0b
    4dc0:	85 3a       	cpi	r24, 0xA5	; 165
    4dc2:	95 4a       	sbci	r25, 0xA5	; 165
    4dc4:	a5 4a       	sbci	r26, 0xA5	; 165
    4dc6:	b5 4a       	sbci	r27, 0xA5	; 165
    4dc8:	09 f0       	breq	.+2      	; 0x4dcc <vTaskSwitchContext.part.5+0x15e>
    4dca:	a0 cf       	rjmp	.-192    	; 0x4d0c <vTaskSwitchContext.part.5+0x9e>
    4dcc:	84 85       	ldd	r24, Z+12	; 0x0c
    4dce:	95 85       	ldd	r25, Z+13	; 0x0d
    4dd0:	a6 85       	ldd	r26, Z+14	; 0x0e
    4dd2:	b7 85       	ldd	r27, Z+15	; 0x0f
    4dd4:	85 3a       	cpi	r24, 0xA5	; 165
    4dd6:	95 4a       	sbci	r25, 0xA5	; 165
    4dd8:	a5 4a       	sbci	r26, 0xA5	; 165
    4dda:	b5 4a       	sbci	r27, 0xA5	; 165
    4ddc:	09 f0       	breq	.+2      	; 0x4de0 <vTaskSwitchContext.part.5+0x172>
    4dde:	96 cf       	rjmp	.-212    	; 0x4d0c <vTaskSwitchContext.part.5+0x9e>
    4de0:	a1 cf       	rjmp	.-190    	; 0x4d24 <vTaskSwitchContext.part.5+0xb6>
    4de2:	02 80       	ldd	r0, Z+2	; 0x02
    4de4:	f3 81       	ldd	r31, Z+3	; 0x03
    4de6:	e0 2d       	mov	r30, r0
    4de8:	11 96       	adiw	r26, 0x01	; 1
    4dea:	ed 93       	st	X+, r30
    4dec:	fc 93       	st	X, r31
    4dee:	12 97       	sbiw	r26, 0x02	; 2
    4df0:	cd cf       	rjmp	.-102    	; 0x4d8c <vTaskSwitchContext.part.5+0x11e>

00004df2 <xTaskCreate>:
    4df2:	5f 92       	push	r5
    4df4:	6f 92       	push	r6
    4df6:	7f 92       	push	r7
    4df8:	8f 92       	push	r8
    4dfa:	9f 92       	push	r9
    4dfc:	af 92       	push	r10
    4dfe:	bf 92       	push	r11
    4e00:	cf 92       	push	r12
    4e02:	df 92       	push	r13
    4e04:	ef 92       	push	r14
    4e06:	ff 92       	push	r15
    4e08:	0f 93       	push	r16
    4e0a:	1f 93       	push	r17
    4e0c:	cf 93       	push	r28
    4e0e:	df 93       	push	r29
    4e10:	4c 01       	movw	r8, r24
    4e12:	eb 01       	movw	r28, r22
    4e14:	5a 01       	movw	r10, r20
    4e16:	39 01       	movw	r6, r18
    4e18:	50 2e       	mov	r5, r16
    4e1a:	ca 01       	movw	r24, r20
    4e1c:	0e 94 45 1c 	call	0x388a	; 0x388a <pvPortMalloc>
    4e20:	8c 01       	movw	r16, r24
    4e22:	89 2b       	or	r24, r25
    4e24:	09 f4       	brne	.+2      	; 0x4e28 <xTaskCreate+0x36>
    4e26:	de c0       	rjmp	.+444    	; 0x4fe4 <xTaskCreate+0x1f2>
    4e28:	80 e3       	ldi	r24, 0x30	; 48
    4e2a:	90 e0       	ldi	r25, 0x00	; 0
    4e2c:	0e 94 45 1c 	call	0x388a	; 0x388a <pvPortMalloc>
    4e30:	6c 01       	movw	r12, r24
    4e32:	00 97       	sbiw	r24, 0x00	; 0
    4e34:	09 f4       	brne	.+2      	; 0x4e38 <xTaskCreate+0x46>
    4e36:	d3 c0       	rjmp	.+422    	; 0x4fde <xTaskCreate+0x1ec>
    4e38:	dc 01       	movw	r26, r24
    4e3a:	57 96       	adiw	r26, 0x17	; 23
    4e3c:	0d 93       	st	X+, r16
    4e3e:	1c 93       	st	X, r17
    4e40:	58 97       	sbiw	r26, 0x18	; 24
    4e42:	20 97       	sbiw	r28, 0x00	; 0
    4e44:	09 f4       	brne	.+2      	; 0x4e48 <xTaskCreate+0x56>
    4e46:	d0 c0       	rjmp	.+416    	; 0x4fe8 <xTaskCreate+0x1f6>
    4e48:	c8 01       	movw	r24, r16
    4e4a:	a5 01       	movw	r20, r10
    4e4c:	65 ea       	ldi	r22, 0xA5	; 165
    4e4e:	70 e0       	ldi	r23, 0x00	; 0
    4e50:	0e 94 17 50 	call	0xa02e	; 0xa02e <memset>
    4e54:	f1 e0       	ldi	r31, 0x01	; 1
    4e56:	af 1a       	sub	r10, r31
    4e58:	b1 08       	sbc	r11, r1
    4e5a:	d6 01       	movw	r26, r12
    4e5c:	57 96       	adiw	r26, 0x17	; 23
    4e5e:	8d 91       	ld	r24, X+
    4e60:	9c 91       	ld	r25, X
    4e62:	58 97       	sbiw	r26, 0x18	; 24
    4e64:	a8 0e       	add	r10, r24
    4e66:	b9 1e       	adc	r11, r25
    4e68:	f6 01       	movw	r30, r12
    4e6a:	79 96       	adiw	r30, 0x19	; 25
    4e6c:	9e 01       	movw	r18, r28
    4e6e:	28 5f       	subi	r18, 0xF8	; 248
    4e70:	3f 4f       	sbci	r19, 0xFF	; 255
    4e72:	de 01       	movw	r26, r28
    4e74:	89 91       	ld	r24, Y+
    4e76:	81 93       	st	Z+, r24
    4e78:	8c 91       	ld	r24, X
    4e7a:	88 23       	and	r24, r24
    4e7c:	19 f0       	breq	.+6      	; 0x4e84 <xTaskCreate+0x92>
    4e7e:	c2 17       	cp	r28, r18
    4e80:	d3 07       	cpc	r29, r19
    4e82:	b9 f7       	brne	.-18     	; 0x4e72 <xTaskCreate+0x80>
    4e84:	f6 01       	movw	r30, r12
    4e86:	10 a2       	std	Z+32, r1	; 0x20
    4e88:	05 2d       	mov	r16, r5
    4e8a:	0a 30       	cpi	r16, 0x0A	; 10
    4e8c:	08 f0       	brcs	.+2      	; 0x4e90 <xTaskCreate+0x9e>
    4e8e:	a1 c0       	rjmp	.+322    	; 0x4fd2 <xTaskCreate+0x1e0>
    4e90:	d6 01       	movw	r26, r12
    4e92:	56 96       	adiw	r26, 0x16	; 22
    4e94:	0c 93       	st	X, r16
    4e96:	56 97       	sbiw	r26, 0x16	; 22
    4e98:	93 96       	adiw	r26, 0x23	; 35
    4e9a:	0c 93       	st	X, r16
    4e9c:	93 97       	sbiw	r26, 0x23	; 35
    4e9e:	94 96       	adiw	r26, 0x24	; 36
    4ea0:	1c 92       	st	X, r1
    4ea2:	e6 01       	movw	r28, r12
    4ea4:	22 96       	adiw	r28, 0x02	; 2
    4ea6:	ce 01       	movw	r24, r28
    4ea8:	0e 94 22 1d 	call	0x3a44	; 0x3a44 <vListInitialiseItem>
    4eac:	c6 01       	movw	r24, r12
    4eae:	0c 96       	adiw	r24, 0x0c	; 12
    4eb0:	0e 94 22 1d 	call	0x3a44	; 0x3a44 <vListInitialiseItem>
    4eb4:	f6 01       	movw	r30, r12
    4eb6:	c0 86       	std	Z+8, r12	; 0x08
    4eb8:	d1 86       	std	Z+9, r13	; 0x09
    4eba:	8a e0       	ldi	r24, 0x0A	; 10
    4ebc:	90 e0       	ldi	r25, 0x00	; 0
    4ebe:	80 1b       	sub	r24, r16
    4ec0:	91 09       	sbc	r25, r1
    4ec2:	84 87       	std	Z+12, r24	; 0x0c
    4ec4:	95 87       	std	Z+13, r25	; 0x0d
    4ec6:	c2 8a       	std	Z+18, r12	; 0x12
    4ec8:	d3 8a       	std	Z+19, r13	; 0x13
    4eca:	15 a2       	std	Z+37, r1	; 0x25
    4ecc:	16 a2       	std	Z+38, r1	; 0x26
    4ece:	17 a2       	std	Z+39, r1	; 0x27
    4ed0:	10 a6       	std	Z+40, r1	; 0x28
    4ed2:	11 a6       	std	Z+41, r1	; 0x29
    4ed4:	12 a6       	std	Z+42, r1	; 0x2a
    4ed6:	13 a6       	std	Z+43, r1	; 0x2b
    4ed8:	14 a6       	std	Z+44, r1	; 0x2c
    4eda:	15 a6       	std	Z+45, r1	; 0x2d
    4edc:	16 a6       	std	Z+46, r1	; 0x2e
    4ede:	17 a6       	std	Z+47, r1	; 0x2f
    4ee0:	a3 01       	movw	r20, r6
    4ee2:	b4 01       	movw	r22, r8
    4ee4:	c5 01       	movw	r24, r10
    4ee6:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <pxPortInitialiseStack>
    4eea:	d6 01       	movw	r26, r12
    4eec:	8d 93       	st	X+, r24
    4eee:	9c 93       	st	X, r25
    4ef0:	e1 14       	cp	r14, r1
    4ef2:	f1 04       	cpc	r15, r1
    4ef4:	19 f0       	breq	.+6      	; 0x4efc <xTaskCreate+0x10a>
    4ef6:	f7 01       	movw	r30, r14
    4ef8:	c0 82       	st	Z, r12
    4efa:	d1 82       	std	Z+1, r13	; 0x01
    4efc:	0f b6       	in	r0, 0x3f	; 63
    4efe:	f8 94       	cli
    4f00:	0f 92       	push	r0
    4f02:	80 91 7b 2d 	lds	r24, 0x2D7B	; 0x802d7b <uxCurrentNumberOfTasks>
    4f06:	8f 5f       	subi	r24, 0xFF	; 255
    4f08:	80 93 7b 2d 	sts	0x2D7B, r24	; 0x802d7b <uxCurrentNumberOfTasks>
    4f0c:	80 91 08 2e 	lds	r24, 0x2E08	; 0x802e08 <pxCurrentTCB>
    4f10:	90 91 09 2e 	lds	r25, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    4f14:	89 2b       	or	r24, r25
    4f16:	99 f0       	breq	.+38     	; 0x4f3e <xTaskCreate+0x14c>
    4f18:	80 91 77 2d 	lds	r24, 0x2D77	; 0x802d77 <xSchedulerRunning>
    4f1c:	81 11       	cpse	r24, r1
    4f1e:	18 c0       	rjmp	.+48     	; 0x4f50 <xTaskCreate+0x15e>
    4f20:	e0 91 08 2e 	lds	r30, 0x2E08	; 0x802e08 <pxCurrentTCB>
    4f24:	f0 91 09 2e 	lds	r31, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    4f28:	d6 01       	movw	r26, r12
    4f2a:	56 96       	adiw	r26, 0x16	; 22
    4f2c:	8c 91       	ld	r24, X
    4f2e:	96 89       	ldd	r25, Z+22	; 0x16
    4f30:	89 17       	cp	r24, r25
    4f32:	88 f0       	brcs	.+34     	; 0x4f56 <xTaskCreate+0x164>
    4f34:	c0 92 08 2e 	sts	0x2E08, r12	; 0x802e08 <pxCurrentTCB>
    4f38:	d0 92 09 2e 	sts	0x2E09, r13	; 0x802e09 <pxCurrentTCB+0x1>
    4f3c:	0c c0       	rjmp	.+24     	; 0x4f56 <xTaskCreate+0x164>
    4f3e:	c0 92 08 2e 	sts	0x2E08, r12	; 0x802e08 <pxCurrentTCB>
    4f42:	d0 92 09 2e 	sts	0x2E09, r13	; 0x802e09 <pxCurrentTCB+0x1>
    4f46:	80 91 7b 2d 	lds	r24, 0x2D7B	; 0x802d7b <uxCurrentNumberOfTasks>
    4f4a:	81 30       	cpi	r24, 0x01	; 1
    4f4c:	09 f4       	brne	.+2      	; 0x4f50 <xTaskCreate+0x15e>
    4f4e:	56 c0       	rjmp	.+172    	; 0x4ffc <xTaskCreate+0x20a>
    4f50:	d6 01       	movw	r26, r12
    4f52:	56 96       	adiw	r26, 0x16	; 22
    4f54:	8c 91       	ld	r24, X
    4f56:	90 91 73 2d 	lds	r25, 0x2D73	; 0x802d73 <uxTaskNumber>
    4f5a:	9f 5f       	subi	r25, 0xFF	; 255
    4f5c:	90 93 73 2d 	sts	0x2D73, r25	; 0x802d73 <uxTaskNumber>
    4f60:	f6 01       	movw	r30, r12
    4f62:	91 a3       	std	Z+33, r25	; 0x21
    4f64:	90 91 78 2d 	lds	r25, 0x2D78	; 0x802d78 <uxTopReadyPriority>
    4f68:	98 17       	cp	r25, r24
    4f6a:	80 f1       	brcs	.+96     	; 0x4fcc <xTaskCreate+0x1da>
    4f6c:	90 e0       	ldi	r25, 0x00	; 0
    4f6e:	9c 01       	movw	r18, r24
    4f70:	22 0f       	add	r18, r18
    4f72:	33 1f       	adc	r19, r19
    4f74:	22 0f       	add	r18, r18
    4f76:	33 1f       	adc	r19, r19
    4f78:	22 0f       	add	r18, r18
    4f7a:	33 1f       	adc	r19, r19
    4f7c:	82 0f       	add	r24, r18
    4f7e:	93 1f       	adc	r25, r19
    4f80:	be 01       	movw	r22, r28
    4f82:	82 55       	subi	r24, 0x52	; 82
    4f84:	92 4d       	sbci	r25, 0xD2	; 210
    4f86:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <vListInsertEnd>
    4f8a:	0f 90       	pop	r0
    4f8c:	0f be       	out	0x3f, r0	; 63
    4f8e:	80 91 77 2d 	lds	r24, 0x2D77	; 0x802d77 <xSchedulerRunning>
    4f92:	88 23       	and	r24, r24
    4f94:	51 f0       	breq	.+20     	; 0x4faa <xTaskCreate+0x1b8>
    4f96:	e0 91 08 2e 	lds	r30, 0x2E08	; 0x802e08 <pxCurrentTCB>
    4f9a:	f0 91 09 2e 	lds	r31, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    4f9e:	96 89       	ldd	r25, Z+22	; 0x16
    4fa0:	d6 01       	movw	r26, r12
    4fa2:	56 96       	adiw	r26, 0x16	; 22
    4fa4:	8c 91       	ld	r24, X
    4fa6:	98 17       	cp	r25, r24
    4fa8:	b0 f0       	brcs	.+44     	; 0x4fd6 <xTaskCreate+0x1e4>
    4faa:	81 e0       	ldi	r24, 0x01	; 1
    4fac:	df 91       	pop	r29
    4fae:	cf 91       	pop	r28
    4fb0:	1f 91       	pop	r17
    4fb2:	0f 91       	pop	r16
    4fb4:	ff 90       	pop	r15
    4fb6:	ef 90       	pop	r14
    4fb8:	df 90       	pop	r13
    4fba:	cf 90       	pop	r12
    4fbc:	bf 90       	pop	r11
    4fbe:	af 90       	pop	r10
    4fc0:	9f 90       	pop	r9
    4fc2:	8f 90       	pop	r8
    4fc4:	7f 90       	pop	r7
    4fc6:	6f 90       	pop	r6
    4fc8:	5f 90       	pop	r5
    4fca:	08 95       	ret
    4fcc:	80 93 78 2d 	sts	0x2D78, r24	; 0x802d78 <uxTopReadyPriority>
    4fd0:	cd cf       	rjmp	.-102    	; 0x4f6c <xTaskCreate+0x17a>
    4fd2:	09 e0       	ldi	r16, 0x09	; 9
    4fd4:	5d cf       	rjmp	.-326    	; 0x4e90 <xTaskCreate+0x9e>
    4fd6:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vPortYield>
    4fda:	81 e0       	ldi	r24, 0x01	; 1
    4fdc:	e7 cf       	rjmp	.-50     	; 0x4fac <xTaskCreate+0x1ba>
    4fde:	c8 01       	movw	r24, r16
    4fe0:	0e 94 e4 1c 	call	0x39c8	; 0x39c8 <vPortFree>
    4fe4:	8f ef       	ldi	r24, 0xFF	; 255
    4fe6:	e2 cf       	rjmp	.-60     	; 0x4fac <xTaskCreate+0x1ba>
    4fe8:	60 e6       	ldi	r22, 0x60	; 96
    4fea:	73 e0       	ldi	r23, 0x03	; 3
    4fec:	8e ef       	ldi	r24, 0xFE	; 254
    4fee:	93 e2       	ldi	r25, 0x23	; 35
    4ff0:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    4ff4:	f6 01       	movw	r30, r12
    4ff6:	87 89       	ldd	r24, Z+23	; 0x17
    4ff8:	90 8d       	ldd	r25, Z+24	; 0x18
    4ffa:	27 cf       	rjmp	.-434    	; 0x4e4a <xTaskCreate+0x58>
    4ffc:	0e ea       	ldi	r16, 0xAE	; 174
    4ffe:	1d e2       	ldi	r17, 0x2D	; 45
    5000:	58 e0       	ldi	r21, 0x08	; 8
    5002:	e5 2e       	mov	r14, r21
    5004:	5e e2       	ldi	r21, 0x2E	; 46
    5006:	f5 2e       	mov	r15, r21
    5008:	c8 01       	movw	r24, r16
    500a:	0e 94 14 1d 	call	0x3a28	; 0x3a28 <vListInitialise>
    500e:	07 5f       	subi	r16, 0xF7	; 247
    5010:	1f 4f       	sbci	r17, 0xFF	; 255
    5012:	e0 16       	cp	r14, r16
    5014:	f1 06       	cpc	r15, r17
    5016:	c1 f7       	brne	.-16     	; 0x5008 <xTaskCreate+0x216>
    5018:	85 ea       	ldi	r24, 0xA5	; 165
    501a:	9d e2       	ldi	r25, 0x2D	; 45
    501c:	0e 94 14 1d 	call	0x3a28	; 0x3a28 <vListInitialise>
    5020:	8c e9       	ldi	r24, 0x9C	; 156
    5022:	9d e2       	ldi	r25, 0x2D	; 45
    5024:	0e 94 14 1d 	call	0x3a28	; 0x3a28 <vListInitialise>
    5028:	8f e8       	ldi	r24, 0x8F	; 143
    502a:	9d e2       	ldi	r25, 0x2D	; 45
    502c:	0e 94 14 1d 	call	0x3a28	; 0x3a28 <vListInitialise>
    5030:	86 e8       	ldi	r24, 0x86	; 134
    5032:	9d e2       	ldi	r25, 0x2D	; 45
    5034:	0e 94 14 1d 	call	0x3a28	; 0x3a28 <vListInitialise>
    5038:	8c e7       	ldi	r24, 0x7C	; 124
    503a:	9d e2       	ldi	r25, 0x2D	; 45
    503c:	0e 94 14 1d 	call	0x3a28	; 0x3a28 <vListInitialise>
    5040:	85 ea       	ldi	r24, 0xA5	; 165
    5042:	9d e2       	ldi	r25, 0x2D	; 45
    5044:	80 93 9a 2d 	sts	0x2D9A, r24	; 0x802d9a <pxDelayedTaskList>
    5048:	90 93 9b 2d 	sts	0x2D9B, r25	; 0x802d9b <pxDelayedTaskList+0x1>
    504c:	8c e9       	ldi	r24, 0x9C	; 156
    504e:	9d e2       	ldi	r25, 0x2D	; 45
    5050:	80 93 98 2d 	sts	0x2D98, r24	; 0x802d98 <pxOverflowDelayedTaskList>
    5054:	90 93 99 2d 	sts	0x2D99, r25	; 0x802d99 <pxOverflowDelayedTaskList+0x1>
    5058:	f6 01       	movw	r30, r12
    505a:	86 89       	ldd	r24, Z+22	; 0x16
    505c:	7c cf       	rjmp	.-264    	; 0x4f56 <xTaskCreate+0x164>

0000505e <eTaskGetState>:
    505e:	cf 93       	push	r28
    5060:	df 93       	push	r29
    5062:	ec 01       	movw	r28, r24
    5064:	89 2b       	or	r24, r25
    5066:	09 f4       	brne	.+2      	; 0x506a <eTaskGetState+0xc>
    5068:	3a c0       	rjmp	.+116    	; 0x50de <eTaskGetState+0x80>
    506a:	80 91 08 2e 	lds	r24, 0x2E08	; 0x802e08 <pxCurrentTCB>
    506e:	90 91 09 2e 	lds	r25, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    5072:	c8 17       	cp	r28, r24
    5074:	d9 07       	cpc	r29, r25
    5076:	79 f1       	breq	.+94     	; 0x50d6 <eTaskGetState+0x78>
    5078:	0f b6       	in	r0, 0x3f	; 63
    507a:	f8 94       	cli
    507c:	0f 92       	push	r0
    507e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5080:	9b 85       	ldd	r25, Y+11	; 0x0b
    5082:	20 91 9a 2d 	lds	r18, 0x2D9A	; 0x802d9a <pxDelayedTaskList>
    5086:	30 91 9b 2d 	lds	r19, 0x2D9B	; 0x802d9b <pxDelayedTaskList+0x1>
    508a:	40 91 98 2d 	lds	r20, 0x2D98	; 0x802d98 <pxOverflowDelayedTaskList>
    508e:	50 91 99 2d 	lds	r21, 0x2D99	; 0x802d99 <pxOverflowDelayedTaskList+0x1>
    5092:	0f 90       	pop	r0
    5094:	0f be       	out	0x3f, r0	; 63
    5096:	82 17       	cp	r24, r18
    5098:	93 07       	cpc	r25, r19
    509a:	a9 f0       	breq	.+42     	; 0x50c6 <eTaskGetState+0x68>
    509c:	84 17       	cp	r24, r20
    509e:	95 07       	cpc	r25, r21
    50a0:	91 f0       	breq	.+36     	; 0x50c6 <eTaskGetState+0x68>
    50a2:	2d e2       	ldi	r18, 0x2D	; 45
    50a4:	8c 37       	cpi	r24, 0x7C	; 124
    50a6:	92 07       	cpc	r25, r18
    50a8:	51 f0       	breq	.+20     	; 0x50be <eTaskGetState+0x60>
    50aa:	2d e2       	ldi	r18, 0x2D	; 45
    50ac:	86 38       	cpi	r24, 0x86	; 134
    50ae:	92 07       	cpc	r25, r18
    50b0:	71 f0       	breq	.+28     	; 0x50ce <eTaskGetState+0x70>
    50b2:	89 2b       	or	r24, r25
    50b4:	61 f0       	breq	.+24     	; 0x50ce <eTaskGetState+0x70>
    50b6:	81 e0       	ldi	r24, 0x01	; 1
    50b8:	df 91       	pop	r29
    50ba:	cf 91       	pop	r28
    50bc:	08 95       	ret
    50be:	8c 89       	ldd	r24, Y+20	; 0x14
    50c0:	9d 89       	ldd	r25, Y+21	; 0x15
    50c2:	89 2b       	or	r24, r25
    50c4:	99 f0       	breq	.+38     	; 0x50ec <eTaskGetState+0x8e>
    50c6:	82 e0       	ldi	r24, 0x02	; 2
    50c8:	df 91       	pop	r29
    50ca:	cf 91       	pop	r28
    50cc:	08 95       	ret
    50ce:	84 e0       	ldi	r24, 0x04	; 4
    50d0:	df 91       	pop	r29
    50d2:	cf 91       	pop	r28
    50d4:	08 95       	ret
    50d6:	80 e0       	ldi	r24, 0x00	; 0
    50d8:	df 91       	pop	r29
    50da:	cf 91       	pop	r28
    50dc:	08 95       	ret
    50de:	6c e4       	ldi	r22, 0x4C	; 76
    50e0:	75 e0       	ldi	r23, 0x05	; 5
    50e2:	8e ef       	ldi	r24, 0xFE	; 254
    50e4:	93 e2       	ldi	r25, 0x23	; 35
    50e6:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    50ea:	bf cf       	rjmp	.-130    	; 0x506a <eTaskGetState+0xc>
    50ec:	8f a5       	ldd	r24, Y+47	; 0x2f
    50ee:	81 30       	cpi	r24, 0x01	; 1
    50f0:	51 f3       	breq	.-44     	; 0x50c6 <eTaskGetState+0x68>
    50f2:	83 e0       	ldi	r24, 0x03	; 3
    50f4:	e1 cf       	rjmp	.-62     	; 0x50b8 <eTaskGetState+0x5a>

000050f6 <vTaskSuspend>:
    50f6:	0f 93       	push	r16
    50f8:	1f 93       	push	r17
    50fa:	cf 93       	push	r28
    50fc:	df 93       	push	r29
    50fe:	ec 01       	movw	r28, r24
    5100:	0f b6       	in	r0, 0x3f	; 63
    5102:	f8 94       	cli
    5104:	0f 92       	push	r0
    5106:	89 2b       	or	r24, r25
    5108:	09 f4       	brne	.+2      	; 0x510c <vTaskSuspend+0x16>
    510a:	62 c0       	rjmp	.+196    	; 0x51d0 <vTaskSuspend+0xda>
    510c:	8e 01       	movw	r16, r28
    510e:	0e 5f       	subi	r16, 0xFE	; 254
    5110:	1f 4f       	sbci	r17, 0xFF	; 255
    5112:	c8 01       	movw	r24, r16
    5114:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <uxListRemove>
    5118:	8c 89       	ldd	r24, Y+20	; 0x14
    511a:	9d 89       	ldd	r25, Y+21	; 0x15
    511c:	89 2b       	or	r24, r25
    511e:	21 f0       	breq	.+8      	; 0x5128 <vTaskSuspend+0x32>
    5120:	ce 01       	movw	r24, r28
    5122:	0c 96       	adiw	r24, 0x0c	; 12
    5124:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <uxListRemove>
    5128:	b8 01       	movw	r22, r16
    512a:	8c e7       	ldi	r24, 0x7C	; 124
    512c:	9d e2       	ldi	r25, 0x2D	; 45
    512e:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <vListInsertEnd>
    5132:	8f a5       	ldd	r24, Y+47	; 0x2f
    5134:	81 30       	cpi	r24, 0x01	; 1
    5136:	21 f1       	breq	.+72     	; 0x5180 <vTaskSuspend+0x8a>
    5138:	0f 90       	pop	r0
    513a:	0f be       	out	0x3f, r0	; 63
    513c:	80 91 77 2d 	lds	r24, 0x2D77	; 0x802d77 <xSchedulerRunning>
    5140:	88 23       	and	r24, r24
    5142:	91 f0       	breq	.+36     	; 0x5168 <vTaskSuspend+0x72>
    5144:	0f b6       	in	r0, 0x3f	; 63
    5146:	f8 94       	cli
    5148:	0f 92       	push	r0
    514a:	e0 91 9a 2d 	lds	r30, 0x2D9A	; 0x802d9a <pxDelayedTaskList>
    514e:	f0 91 9b 2d 	lds	r31, 0x2D9B	; 0x802d9b <pxDelayedTaskList+0x1>
    5152:	80 81       	ld	r24, Z
    5154:	81 11       	cpse	r24, r1
    5156:	2b c0       	rjmp	.+86     	; 0x51ae <vTaskSuspend+0xb8>
    5158:	8f ef       	ldi	r24, 0xFF	; 255
    515a:	9f ef       	ldi	r25, 0xFF	; 255
    515c:	80 93 71 2d 	sts	0x2D71, r24	; 0x802d71 <xNextTaskUnblockTime>
    5160:	90 93 72 2d 	sts	0x2D72, r25	; 0x802d72 <xNextTaskUnblockTime+0x1>
    5164:	0f 90       	pop	r0
    5166:	0f be       	out	0x3f, r0	; 63
    5168:	80 91 08 2e 	lds	r24, 0x2E08	; 0x802e08 <pxCurrentTCB>
    516c:	90 91 09 2e 	lds	r25, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    5170:	c8 17       	cp	r28, r24
    5172:	d9 07       	cpc	r29, r25
    5174:	39 f0       	breq	.+14     	; 0x5184 <vTaskSuspend+0x8e>
    5176:	df 91       	pop	r29
    5178:	cf 91       	pop	r28
    517a:	1f 91       	pop	r17
    517c:	0f 91       	pop	r16
    517e:	08 95       	ret
    5180:	1f a6       	std	Y+47, r1	; 0x2f
    5182:	da cf       	rjmp	.-76     	; 0x5138 <vTaskSuspend+0x42>
    5184:	80 91 77 2d 	lds	r24, 0x2D77	; 0x802d77 <xSchedulerRunning>
    5188:	88 23       	and	r24, r24
    518a:	a1 f0       	breq	.+40     	; 0x51b4 <vTaskSuspend+0xbe>
    518c:	80 91 6e 2d 	lds	r24, 0x2D6E	; 0x802d6e <uxSchedulerSuspended>
    5190:	88 23       	and	r24, r24
    5192:	31 f0       	breq	.+12     	; 0x51a0 <vTaskSuspend+0xaa>
    5194:	68 ec       	ldi	r22, 0xC8	; 200
    5196:	76 e0       	ldi	r23, 0x06	; 6
    5198:	8e ef       	ldi	r24, 0xFE	; 254
    519a:	93 e2       	ldi	r25, 0x23	; 35
    519c:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    51a0:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vPortYield>
    51a4:	df 91       	pop	r29
    51a6:	cf 91       	pop	r28
    51a8:	1f 91       	pop	r17
    51aa:	0f 91       	pop	r16
    51ac:	08 95       	ret
    51ae:	0e 94 ab 25 	call	0x4b56	; 0x4b56 <prvResetNextTaskUnblockTime.part.0>
    51b2:	d8 cf       	rjmp	.-80     	; 0x5164 <vTaskSuspend+0x6e>
    51b4:	90 91 7c 2d 	lds	r25, 0x2D7C	; 0x802d7c <xSuspendedTaskList>
    51b8:	80 91 7b 2d 	lds	r24, 0x2D7B	; 0x802d7b <uxCurrentNumberOfTasks>
    51bc:	98 17       	cp	r25, r24
    51be:	99 f0       	breq	.+38     	; 0x51e6 <vTaskSuspend+0xf0>
    51c0:	80 91 6e 2d 	lds	r24, 0x2D6E	; 0x802d6e <uxSchedulerSuspended>
    51c4:	88 23       	and	r24, r24
    51c6:	49 f0       	breq	.+18     	; 0x51da <vTaskSuspend+0xe4>
    51c8:	81 e0       	ldi	r24, 0x01	; 1
    51ca:	80 93 75 2d 	sts	0x2D75, r24	; 0x802d75 <xYieldPending>
    51ce:	d3 cf       	rjmp	.-90     	; 0x5176 <vTaskSuspend+0x80>
    51d0:	c0 91 08 2e 	lds	r28, 0x2E08	; 0x802e08 <pxCurrentTCB>
    51d4:	d0 91 09 2e 	lds	r29, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    51d8:	99 cf       	rjmp	.-206    	; 0x510c <vTaskSuspend+0x16>
    51da:	df 91       	pop	r29
    51dc:	cf 91       	pop	r28
    51de:	1f 91       	pop	r17
    51e0:	0f 91       	pop	r16
    51e2:	0c 94 37 26 	jmp	0x4c6e	; 0x4c6e <vTaskSwitchContext.part.5>
    51e6:	10 92 08 2e 	sts	0x2E08, r1	; 0x802e08 <pxCurrentTCB>
    51ea:	10 92 09 2e 	sts	0x2E09, r1	; 0x802e09 <pxCurrentTCB+0x1>
    51ee:	c3 cf       	rjmp	.-122    	; 0x5176 <vTaskSuspend+0x80>

000051f0 <vTaskResume>:
    51f0:	0f 93       	push	r16
    51f2:	1f 93       	push	r17
    51f4:	cf 93       	push	r28
    51f6:	df 93       	push	r29
    51f8:	ec 01       	movw	r28, r24
    51fa:	89 2b       	or	r24, r25
    51fc:	09 f4       	brne	.+2      	; 0x5200 <vTaskResume+0x10>
    51fe:	3d c0       	rjmp	.+122    	; 0x527a <vTaskResume+0x8a>
    5200:	80 91 08 2e 	lds	r24, 0x2E08	; 0x802e08 <pxCurrentTCB>
    5204:	90 91 09 2e 	lds	r25, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    5208:	c8 17       	cp	r28, r24
    520a:	d9 07       	cpc	r29, r25
    520c:	51 f0       	breq	.+20     	; 0x5222 <vTaskResume+0x32>
    520e:	0f b6       	in	r0, 0x3f	; 63
    5210:	f8 94       	cli
    5212:	0f 92       	push	r0
    5214:	ce 01       	movw	r24, r28
    5216:	0e 94 bc 25 	call	0x4b78	; 0x4b78 <prvTaskIsTaskSuspended>
    521a:	81 11       	cpse	r24, r1
    521c:	07 c0       	rjmp	.+14     	; 0x522c <vTaskResume+0x3c>
    521e:	0f 90       	pop	r0
    5220:	0f be       	out	0x3f, r0	; 63
    5222:	df 91       	pop	r29
    5224:	cf 91       	pop	r28
    5226:	1f 91       	pop	r17
    5228:	0f 91       	pop	r16
    522a:	08 95       	ret
    522c:	8e 01       	movw	r16, r28
    522e:	0e 5f       	subi	r16, 0xFE	; 254
    5230:	1f 4f       	sbci	r17, 0xFF	; 255
    5232:	c8 01       	movw	r24, r16
    5234:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <uxListRemove>
    5238:	8e 89       	ldd	r24, Y+22	; 0x16
    523a:	90 91 78 2d 	lds	r25, 0x2D78	; 0x802d78 <uxTopReadyPriority>
    523e:	98 17       	cp	r25, r24
    5240:	10 f4       	brcc	.+4      	; 0x5246 <vTaskResume+0x56>
    5242:	80 93 78 2d 	sts	0x2D78, r24	; 0x802d78 <uxTopReadyPriority>
    5246:	90 e0       	ldi	r25, 0x00	; 0
    5248:	9c 01       	movw	r18, r24
    524a:	22 0f       	add	r18, r18
    524c:	33 1f       	adc	r19, r19
    524e:	22 0f       	add	r18, r18
    5250:	33 1f       	adc	r19, r19
    5252:	22 0f       	add	r18, r18
    5254:	33 1f       	adc	r19, r19
    5256:	82 0f       	add	r24, r18
    5258:	93 1f       	adc	r25, r19
    525a:	b8 01       	movw	r22, r16
    525c:	82 55       	subi	r24, 0x52	; 82
    525e:	92 4d       	sbci	r25, 0xD2	; 210
    5260:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <vListInsertEnd>
    5264:	e0 91 08 2e 	lds	r30, 0x2E08	; 0x802e08 <pxCurrentTCB>
    5268:	f0 91 09 2e 	lds	r31, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    526c:	9e 89       	ldd	r25, Y+22	; 0x16
    526e:	86 89       	ldd	r24, Z+22	; 0x16
    5270:	98 17       	cp	r25, r24
    5272:	a8 f2       	brcs	.-86     	; 0x521e <vTaskResume+0x2e>
    5274:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vPortYield>
    5278:	d2 cf       	rjmp	.-92     	; 0x521e <vTaskResume+0x2e>
    527a:	6c e1       	ldi	r22, 0x1C	; 28
    527c:	77 e0       	ldi	r23, 0x07	; 7
    527e:	8e ef       	ldi	r24, 0xFE	; 254
    5280:	93 e2       	ldi	r25, 0x23	; 35
    5282:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    5286:	80 91 08 2e 	lds	r24, 0x2E08	; 0x802e08 <pxCurrentTCB>
    528a:	90 91 09 2e 	lds	r25, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    528e:	c9 cf       	rjmp	.-110    	; 0x5222 <vTaskResume+0x32>

00005290 <vTaskStartScheduler>:
    5290:	ef 92       	push	r14
    5292:	ff 92       	push	r15
    5294:	0f 93       	push	r16
    5296:	8f e6       	ldi	r24, 0x6F	; 111
    5298:	e8 2e       	mov	r14, r24
    529a:	8d e2       	ldi	r24, 0x2D	; 45
    529c:	f8 2e       	mov	r15, r24
    529e:	00 e0       	ldi	r16, 0x00	; 0
    52a0:	20 e0       	ldi	r18, 0x00	; 0
    52a2:	30 e0       	ldi	r19, 0x00	; 0
    52a4:	40 e0       	ldi	r20, 0x00	; 0
    52a6:	51 e0       	ldi	r21, 0x01	; 1
    52a8:	62 e1       	ldi	r22, 0x12	; 18
    52aa:	74 e2       	ldi	r23, 0x24	; 36
    52ac:	8a e5       	ldi	r24, 0x5A	; 90
    52ae:	95 e2       	ldi	r25, 0x25	; 37
    52b0:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <xTaskCreate>
    52b4:	81 30       	cpi	r24, 0x01	; 1
    52b6:	79 f0       	breq	.+30     	; 0x52d6 <vTaskStartScheduler+0x46>
    52b8:	8f 3f       	cpi	r24, 0xFF	; 255
    52ba:	21 f0       	breq	.+8      	; 0x52c4 <vTaskStartScheduler+0x34>
    52bc:	0f 91       	pop	r16
    52be:	ff 90       	pop	r15
    52c0:	ef 90       	pop	r14
    52c2:	08 95       	ret
    52c4:	67 e0       	ldi	r22, 0x07	; 7
    52c6:	78 e0       	ldi	r23, 0x08	; 8
    52c8:	8e ef       	ldi	r24, 0xFE	; 254
    52ca:	93 e2       	ldi	r25, 0x23	; 35
    52cc:	0f 91       	pop	r16
    52ce:	ff 90       	pop	r15
    52d0:	ef 90       	pop	r14
    52d2:	0c 94 c5 30 	jmp	0x618a	; 0x618a <vAssertCalled>
    52d6:	f8 94       	cli
    52d8:	2f ef       	ldi	r18, 0xFF	; 255
    52da:	3f ef       	ldi	r19, 0xFF	; 255
    52dc:	20 93 71 2d 	sts	0x2D71, r18	; 0x802d71 <xNextTaskUnblockTime>
    52e0:	30 93 72 2d 	sts	0x2D72, r19	; 0x802d72 <xNextTaskUnblockTime+0x1>
    52e4:	80 93 77 2d 	sts	0x2D77, r24	; 0x802d77 <xSchedulerRunning>
    52e8:	10 92 79 2d 	sts	0x2D79, r1	; 0x802d79 <xTickCount>
    52ec:	10 92 7a 2d 	sts	0x2D7A, r1	; 0x802d7a <xTickCount+0x1>
    52f0:	0e 94 39 1f 	call	0x3e72	; 0x3e72 <vConfigureTimerForRunTimeStats>
    52f4:	0f 91       	pop	r16
    52f6:	ff 90       	pop	r15
    52f8:	ef 90       	pop	r14
    52fa:	0c 94 0c 1e 	jmp	0x3c18	; 0x3c18 <xPortStartScheduler>

000052fe <vTaskSuspendAll>:
    52fe:	80 91 6e 2d 	lds	r24, 0x2D6E	; 0x802d6e <uxSchedulerSuspended>
    5302:	8f 5f       	subi	r24, 0xFF	; 255
    5304:	80 93 6e 2d 	sts	0x2D6E, r24	; 0x802d6e <uxSchedulerSuspended>
    5308:	08 95       	ret

0000530a <xTaskGetTickCount>:
    530a:	0f b6       	in	r0, 0x3f	; 63
    530c:	f8 94       	cli
    530e:	0f 92       	push	r0
    5310:	80 91 79 2d 	lds	r24, 0x2D79	; 0x802d79 <xTickCount>
    5314:	90 91 7a 2d 	lds	r25, 0x2D7A	; 0x802d7a <xTickCount+0x1>
    5318:	0f 90       	pop	r0
    531a:	0f be       	out	0x3f, r0	; 63
    531c:	08 95       	ret

0000531e <xTaskGetIdleTaskHandle>:
    531e:	80 91 6f 2d 	lds	r24, 0x2D6F	; 0x802d6f <xIdleTaskHandle>
    5322:	90 91 70 2d 	lds	r25, 0x2D70	; 0x802d70 <xIdleTaskHandle+0x1>
    5326:	00 97       	sbiw	r24, 0x00	; 0
    5328:	09 f0       	breq	.+2      	; 0x532c <xTaskGetIdleTaskHandle+0xe>
    532a:	08 95       	ret
    532c:	6a ee       	ldi	r22, 0xEA	; 234
    532e:	79 e0       	ldi	r23, 0x09	; 9
    5330:	8e ef       	ldi	r24, 0xFE	; 254
    5332:	93 e2       	ldi	r25, 0x23	; 35
    5334:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    5338:	80 91 6f 2d 	lds	r24, 0x2D6F	; 0x802d6f <xIdleTaskHandle>
    533c:	90 91 70 2d 	lds	r25, 0x2D70	; 0x802d70 <xIdleTaskHandle+0x1>
    5340:	08 95       	ret

00005342 <xTaskIncrementTick>:
    5342:	df 92       	push	r13
    5344:	ef 92       	push	r14
    5346:	ff 92       	push	r15
    5348:	0f 93       	push	r16
    534a:	1f 93       	push	r17
    534c:	cf 93       	push	r28
    534e:	df 93       	push	r29
    5350:	80 91 6e 2d 	lds	r24, 0x2D6E	; 0x802d6e <uxSchedulerSuspended>
    5354:	81 11       	cpse	r24, r1
    5356:	b9 c0       	rjmp	.+370    	; 0x54ca <xTaskIncrementTick+0x188>
    5358:	e0 90 79 2d 	lds	r14, 0x2D79	; 0x802d79 <xTickCount>
    535c:	f0 90 7a 2d 	lds	r15, 0x2D7A	; 0x802d7a <xTickCount+0x1>
    5360:	8f ef       	ldi	r24, 0xFF	; 255
    5362:	e8 1a       	sub	r14, r24
    5364:	f8 0a       	sbc	r15, r24
    5366:	e0 92 79 2d 	sts	0x2D79, r14	; 0x802d79 <xTickCount>
    536a:	f0 92 7a 2d 	sts	0x2D7A, r15	; 0x802d7a <xTickCount+0x1>
    536e:	e1 14       	cp	r14, r1
    5370:	f1 04       	cpc	r15, r1
    5372:	49 f5       	brne	.+82     	; 0x53c6 <xTaskIncrementTick+0x84>
    5374:	e0 91 9a 2d 	lds	r30, 0x2D9A	; 0x802d9a <pxDelayedTaskList>
    5378:	f0 91 9b 2d 	lds	r31, 0x2D9B	; 0x802d9b <pxDelayedTaskList+0x1>
    537c:	80 81       	ld	r24, Z
    537e:	81 11       	cpse	r24, r1
    5380:	ab c0       	rjmp	.+342    	; 0x54d8 <xTaskIncrementTick+0x196>
    5382:	80 91 9a 2d 	lds	r24, 0x2D9A	; 0x802d9a <pxDelayedTaskList>
    5386:	90 91 9b 2d 	lds	r25, 0x2D9B	; 0x802d9b <pxDelayedTaskList+0x1>
    538a:	20 91 98 2d 	lds	r18, 0x2D98	; 0x802d98 <pxOverflowDelayedTaskList>
    538e:	30 91 99 2d 	lds	r19, 0x2D99	; 0x802d99 <pxOverflowDelayedTaskList+0x1>
    5392:	20 93 9a 2d 	sts	0x2D9A, r18	; 0x802d9a <pxDelayedTaskList>
    5396:	30 93 9b 2d 	sts	0x2D9B, r19	; 0x802d9b <pxDelayedTaskList+0x1>
    539a:	80 93 98 2d 	sts	0x2D98, r24	; 0x802d98 <pxOverflowDelayedTaskList>
    539e:	90 93 99 2d 	sts	0x2D99, r25	; 0x802d99 <pxOverflowDelayedTaskList+0x1>
    53a2:	80 91 74 2d 	lds	r24, 0x2D74	; 0x802d74 <xNumOfOverflows>
    53a6:	8f 5f       	subi	r24, 0xFF	; 255
    53a8:	80 93 74 2d 	sts	0x2D74, r24	; 0x802d74 <xNumOfOverflows>
    53ac:	e0 91 9a 2d 	lds	r30, 0x2D9A	; 0x802d9a <pxDelayedTaskList>
    53b0:	f0 91 9b 2d 	lds	r31, 0x2D9B	; 0x802d9b <pxDelayedTaskList+0x1>
    53b4:	80 81       	ld	r24, Z
    53b6:	81 11       	cpse	r24, r1
    53b8:	96 c0       	rjmp	.+300    	; 0x54e6 <xTaskIncrementTick+0x1a4>
    53ba:	8f ef       	ldi	r24, 0xFF	; 255
    53bc:	9f ef       	ldi	r25, 0xFF	; 255
    53be:	80 93 71 2d 	sts	0x2D71, r24	; 0x802d71 <xNextTaskUnblockTime>
    53c2:	90 93 72 2d 	sts	0x2D72, r25	; 0x802d72 <xNextTaskUnblockTime+0x1>
    53c6:	80 91 71 2d 	lds	r24, 0x2D71	; 0x802d71 <xNextTaskUnblockTime>
    53ca:	90 91 72 2d 	lds	r25, 0x2D72	; 0x802d72 <xNextTaskUnblockTime+0x1>
    53ce:	d1 2c       	mov	r13, r1
    53d0:	e8 16       	cp	r14, r24
    53d2:	f9 06       	cpc	r15, r25
    53d4:	08 f4       	brcc	.+2      	; 0x53d8 <xTaskIncrementTick+0x96>
    53d6:	53 c0       	rjmp	.+166    	; 0x547e <xTaskIncrementTick+0x13c>
    53d8:	e0 91 9a 2d 	lds	r30, 0x2D9A	; 0x802d9a <pxDelayedTaskList>
    53dc:	f0 91 9b 2d 	lds	r31, 0x2D9B	; 0x802d9b <pxDelayedTaskList+0x1>
    53e0:	80 81       	ld	r24, Z
    53e2:	88 23       	and	r24, r24
    53e4:	09 f4       	brne	.+2      	; 0x53e8 <xTaskIncrementTick+0xa6>
    53e6:	45 c0       	rjmp	.+138    	; 0x5472 <xTaskIncrementTick+0x130>
    53e8:	e0 91 9a 2d 	lds	r30, 0x2D9A	; 0x802d9a <pxDelayedTaskList>
    53ec:	f0 91 9b 2d 	lds	r31, 0x2D9B	; 0x802d9b <pxDelayedTaskList+0x1>
    53f0:	05 80       	ldd	r0, Z+5	; 0x05
    53f2:	f6 81       	ldd	r31, Z+6	; 0x06
    53f4:	e0 2d       	mov	r30, r0
    53f6:	c6 81       	ldd	r28, Z+6	; 0x06
    53f8:	d7 81       	ldd	r29, Z+7	; 0x07
    53fa:	8a 81       	ldd	r24, Y+2	; 0x02
    53fc:	9b 81       	ldd	r25, Y+3	; 0x03
    53fe:	e8 16       	cp	r14, r24
    5400:	f9 06       	cpc	r15, r25
    5402:	08 f4       	brcc	.+2      	; 0x5406 <xTaskIncrementTick+0xc4>
    5404:	73 c0       	rjmp	.+230    	; 0x54ec <xTaskIncrementTick+0x1aa>
    5406:	8e 01       	movw	r16, r28
    5408:	0e 5f       	subi	r16, 0xFE	; 254
    540a:	1f 4f       	sbci	r17, 0xFF	; 255
    540c:	c8 01       	movw	r24, r16
    540e:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <uxListRemove>
    5412:	8c 89       	ldd	r24, Y+20	; 0x14
    5414:	9d 89       	ldd	r25, Y+21	; 0x15
    5416:	89 2b       	or	r24, r25
    5418:	21 f0       	breq	.+8      	; 0x5422 <xTaskIncrementTick+0xe0>
    541a:	ce 01       	movw	r24, r28
    541c:	0c 96       	adiw	r24, 0x0c	; 12
    541e:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <uxListRemove>
    5422:	8e 89       	ldd	r24, Y+22	; 0x16
    5424:	90 91 78 2d 	lds	r25, 0x2D78	; 0x802d78 <uxTopReadyPriority>
    5428:	98 17       	cp	r25, r24
    542a:	10 f4       	brcc	.+4      	; 0x5430 <xTaskIncrementTick+0xee>
    542c:	80 93 78 2d 	sts	0x2D78, r24	; 0x802d78 <uxTopReadyPriority>
    5430:	90 e0       	ldi	r25, 0x00	; 0
    5432:	9c 01       	movw	r18, r24
    5434:	22 0f       	add	r18, r18
    5436:	33 1f       	adc	r19, r19
    5438:	22 0f       	add	r18, r18
    543a:	33 1f       	adc	r19, r19
    543c:	22 0f       	add	r18, r18
    543e:	33 1f       	adc	r19, r19
    5440:	82 0f       	add	r24, r18
    5442:	93 1f       	adc	r25, r19
    5444:	b8 01       	movw	r22, r16
    5446:	82 55       	subi	r24, 0x52	; 82
    5448:	92 4d       	sbci	r25, 0xD2	; 210
    544a:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <vListInsertEnd>
    544e:	e0 91 08 2e 	lds	r30, 0x2E08	; 0x802e08 <pxCurrentTCB>
    5452:	f0 91 09 2e 	lds	r31, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    5456:	9e 89       	ldd	r25, Y+22	; 0x16
    5458:	86 89       	ldd	r24, Z+22	; 0x16
    545a:	98 17       	cp	r25, r24
    545c:	08 f4       	brcc	.+2      	; 0x5460 <xTaskIncrementTick+0x11e>
    545e:	bc cf       	rjmp	.-136    	; 0x53d8 <xTaskIncrementTick+0x96>
    5460:	dd 24       	eor	r13, r13
    5462:	d3 94       	inc	r13
    5464:	e0 91 9a 2d 	lds	r30, 0x2D9A	; 0x802d9a <pxDelayedTaskList>
    5468:	f0 91 9b 2d 	lds	r31, 0x2D9B	; 0x802d9b <pxDelayedTaskList+0x1>
    546c:	80 81       	ld	r24, Z
    546e:	81 11       	cpse	r24, r1
    5470:	bb cf       	rjmp	.-138    	; 0x53e8 <xTaskIncrementTick+0xa6>
    5472:	8f ef       	ldi	r24, 0xFF	; 255
    5474:	9f ef       	ldi	r25, 0xFF	; 255
    5476:	80 93 71 2d 	sts	0x2D71, r24	; 0x802d71 <xNextTaskUnblockTime>
    547a:	90 93 72 2d 	sts	0x2D72, r25	; 0x802d72 <xNextTaskUnblockTime+0x1>
    547e:	e0 91 08 2e 	lds	r30, 0x2E08	; 0x802e08 <pxCurrentTCB>
    5482:	f0 91 09 2e 	lds	r31, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    5486:	86 89       	ldd	r24, Z+22	; 0x16
    5488:	90 e0       	ldi	r25, 0x00	; 0
    548a:	fc 01       	movw	r30, r24
    548c:	ee 0f       	add	r30, r30
    548e:	ff 1f       	adc	r31, r31
    5490:	ee 0f       	add	r30, r30
    5492:	ff 1f       	adc	r31, r31
    5494:	ee 0f       	add	r30, r30
    5496:	ff 1f       	adc	r31, r31
    5498:	8e 0f       	add	r24, r30
    549a:	9f 1f       	adc	r25, r31
    549c:	fc 01       	movw	r30, r24
    549e:	e2 55       	subi	r30, 0x52	; 82
    54a0:	f2 4d       	sbci	r31, 0xD2	; 210
    54a2:	80 81       	ld	r24, Z
    54a4:	82 30       	cpi	r24, 0x02	; 2
    54a6:	10 f0       	brcs	.+4      	; 0x54ac <xTaskIncrementTick+0x16a>
    54a8:	dd 24       	eor	r13, r13
    54aa:	d3 94       	inc	r13
    54ac:	80 91 75 2d 	lds	r24, 0x2D75	; 0x802d75 <xYieldPending>
    54b0:	88 23       	and	r24, r24
    54b2:	11 f0       	breq	.+4      	; 0x54b8 <xTaskIncrementTick+0x176>
    54b4:	dd 24       	eor	r13, r13
    54b6:	d3 94       	inc	r13
    54b8:	8d 2d       	mov	r24, r13
    54ba:	df 91       	pop	r29
    54bc:	cf 91       	pop	r28
    54be:	1f 91       	pop	r17
    54c0:	0f 91       	pop	r16
    54c2:	ff 90       	pop	r15
    54c4:	ef 90       	pop	r14
    54c6:	df 90       	pop	r13
    54c8:	08 95       	ret
    54ca:	80 91 76 2d 	lds	r24, 0x2D76	; 0x802d76 <uxPendedTicks>
    54ce:	8f 5f       	subi	r24, 0xFF	; 255
    54d0:	80 93 76 2d 	sts	0x2D76, r24	; 0x802d76 <uxPendedTicks>
    54d4:	d1 2c       	mov	r13, r1
    54d6:	ea cf       	rjmp	.-44     	; 0x54ac <xTaskIncrementTick+0x16a>
    54d8:	66 e6       	ldi	r22, 0x66	; 102
    54da:	7a e0       	ldi	r23, 0x0A	; 10
    54dc:	8e ef       	ldi	r24, 0xFE	; 254
    54de:	93 e2       	ldi	r25, 0x23	; 35
    54e0:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    54e4:	4e cf       	rjmp	.-356    	; 0x5382 <xTaskIncrementTick+0x40>
    54e6:	0e 94 ab 25 	call	0x4b56	; 0x4b56 <prvResetNextTaskUnblockTime.part.0>
    54ea:	6d cf       	rjmp	.-294    	; 0x53c6 <xTaskIncrementTick+0x84>
    54ec:	80 93 71 2d 	sts	0x2D71, r24	; 0x802d71 <xNextTaskUnblockTime>
    54f0:	90 93 72 2d 	sts	0x2D72, r25	; 0x802d72 <xNextTaskUnblockTime+0x1>
    54f4:	c4 cf       	rjmp	.-120    	; 0x547e <xTaskIncrementTick+0x13c>

000054f6 <xTaskResumeAll>:
    54f6:	ff 92       	push	r15
    54f8:	0f 93       	push	r16
    54fa:	1f 93       	push	r17
    54fc:	cf 93       	push	r28
    54fe:	df 93       	push	r29
    5500:	80 91 6e 2d 	lds	r24, 0x2D6E	; 0x802d6e <uxSchedulerSuspended>
    5504:	88 23       	and	r24, r24
    5506:	09 f4       	brne	.+2      	; 0x550a <xTaskResumeAll+0x14>
    5508:	77 c0       	rjmp	.+238    	; 0x55f8 <xTaskResumeAll+0x102>
    550a:	0f b6       	in	r0, 0x3f	; 63
    550c:	f8 94       	cli
    550e:	0f 92       	push	r0
    5510:	80 91 6e 2d 	lds	r24, 0x2D6E	; 0x802d6e <uxSchedulerSuspended>
    5514:	81 50       	subi	r24, 0x01	; 1
    5516:	80 93 6e 2d 	sts	0x2D6E, r24	; 0x802d6e <uxSchedulerSuspended>
    551a:	80 91 6e 2d 	lds	r24, 0x2D6E	; 0x802d6e <uxSchedulerSuspended>
    551e:	81 11       	cpse	r24, r1
    5520:	62 c0       	rjmp	.+196    	; 0x55e6 <xTaskResumeAll+0xf0>
    5522:	80 91 7b 2d 	lds	r24, 0x2D7B	; 0x802d7b <uxCurrentNumberOfTasks>
    5526:	88 23       	and	r24, r24
    5528:	09 f4       	brne	.+2      	; 0x552c <xTaskResumeAll+0x36>
    552a:	5d c0       	rjmp	.+186    	; 0x55e6 <xTaskResumeAll+0xf0>
    552c:	c0 e0       	ldi	r28, 0x00	; 0
    552e:	d0 e0       	ldi	r29, 0x00	; 0
    5530:	ff 24       	eor	r15, r15
    5532:	f3 94       	inc	r15
    5534:	80 91 8f 2d 	lds	r24, 0x2D8F	; 0x802d8f <xPendingReadyList>
    5538:	88 23       	and	r24, r24
    553a:	a1 f1       	breq	.+104    	; 0x55a4 <xTaskResumeAll+0xae>
    553c:	e0 91 94 2d 	lds	r30, 0x2D94	; 0x802d94 <xPendingReadyList+0x5>
    5540:	f0 91 95 2d 	lds	r31, 0x2D95	; 0x802d95 <xPendingReadyList+0x6>
    5544:	c6 81       	ldd	r28, Z+6	; 0x06
    5546:	d7 81       	ldd	r29, Z+7	; 0x07
    5548:	ce 01       	movw	r24, r28
    554a:	0c 96       	adiw	r24, 0x0c	; 12
    554c:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <uxListRemove>
    5550:	8e 01       	movw	r16, r28
    5552:	0e 5f       	subi	r16, 0xFE	; 254
    5554:	1f 4f       	sbci	r17, 0xFF	; 255
    5556:	c8 01       	movw	r24, r16
    5558:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <uxListRemove>
    555c:	8e 89       	ldd	r24, Y+22	; 0x16
    555e:	90 91 78 2d 	lds	r25, 0x2D78	; 0x802d78 <uxTopReadyPriority>
    5562:	98 17       	cp	r25, r24
    5564:	10 f4       	brcc	.+4      	; 0x556a <xTaskResumeAll+0x74>
    5566:	80 93 78 2d 	sts	0x2D78, r24	; 0x802d78 <uxTopReadyPriority>
    556a:	90 e0       	ldi	r25, 0x00	; 0
    556c:	9c 01       	movw	r18, r24
    556e:	22 0f       	add	r18, r18
    5570:	33 1f       	adc	r19, r19
    5572:	22 0f       	add	r18, r18
    5574:	33 1f       	adc	r19, r19
    5576:	22 0f       	add	r18, r18
    5578:	33 1f       	adc	r19, r19
    557a:	82 0f       	add	r24, r18
    557c:	93 1f       	adc	r25, r19
    557e:	b8 01       	movw	r22, r16
    5580:	82 55       	subi	r24, 0x52	; 82
    5582:	92 4d       	sbci	r25, 0xD2	; 210
    5584:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <vListInsertEnd>
    5588:	e0 91 08 2e 	lds	r30, 0x2E08	; 0x802e08 <pxCurrentTCB>
    558c:	f0 91 09 2e 	lds	r31, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    5590:	9e 89       	ldd	r25, Y+22	; 0x16
    5592:	86 89       	ldd	r24, Z+22	; 0x16
    5594:	98 17       	cp	r25, r24
    5596:	70 f2       	brcs	.-100    	; 0x5534 <xTaskResumeAll+0x3e>
    5598:	f0 92 75 2d 	sts	0x2D75, r15	; 0x802d75 <xYieldPending>
    559c:	80 91 8f 2d 	lds	r24, 0x2D8F	; 0x802d8f <xPendingReadyList>
    55a0:	81 11       	cpse	r24, r1
    55a2:	cc cf       	rjmp	.-104    	; 0x553c <xTaskResumeAll+0x46>
    55a4:	cd 2b       	or	r28, r29
    55a6:	69 f0       	breq	.+26     	; 0x55c2 <xTaskResumeAll+0xcc>
    55a8:	e0 91 9a 2d 	lds	r30, 0x2D9A	; 0x802d9a <pxDelayedTaskList>
    55ac:	f0 91 9b 2d 	lds	r31, 0x2D9B	; 0x802d9b <pxDelayedTaskList+0x1>
    55b0:	80 81       	ld	r24, Z
    55b2:	81 11       	cpse	r24, r1
    55b4:	2c c0       	rjmp	.+88     	; 0x560e <xTaskResumeAll+0x118>
    55b6:	8f ef       	ldi	r24, 0xFF	; 255
    55b8:	9f ef       	ldi	r25, 0xFF	; 255
    55ba:	80 93 71 2d 	sts	0x2D71, r24	; 0x802d71 <xNextTaskUnblockTime>
    55be:	90 93 72 2d 	sts	0x2D72, r25	; 0x802d72 <xNextTaskUnblockTime+0x1>
    55c2:	c0 91 76 2d 	lds	r28, 0x2D76	; 0x802d76 <uxPendedTicks>
    55c6:	cc 23       	and	r28, r28
    55c8:	51 f0       	breq	.+20     	; 0x55de <xTaskResumeAll+0xe8>
    55ca:	d1 e0       	ldi	r29, 0x01	; 1
    55cc:	0e 94 a1 29 	call	0x5342	; 0x5342 <xTaskIncrementTick>
    55d0:	81 11       	cpse	r24, r1
    55d2:	d0 93 75 2d 	sts	0x2D75, r29	; 0x802d75 <xYieldPending>
    55d6:	c1 50       	subi	r28, 0x01	; 1
    55d8:	c9 f7       	brne	.-14     	; 0x55cc <xTaskResumeAll+0xd6>
    55da:	10 92 76 2d 	sts	0x2D76, r1	; 0x802d76 <uxPendedTicks>
    55de:	80 91 75 2d 	lds	r24, 0x2D75	; 0x802d75 <xYieldPending>
    55e2:	81 11       	cpse	r24, r1
    55e4:	10 c0       	rjmp	.+32     	; 0x5606 <xTaskResumeAll+0x110>
    55e6:	80 e0       	ldi	r24, 0x00	; 0
    55e8:	0f 90       	pop	r0
    55ea:	0f be       	out	0x3f, r0	; 63
    55ec:	df 91       	pop	r29
    55ee:	cf 91       	pop	r28
    55f0:	1f 91       	pop	r17
    55f2:	0f 91       	pop	r16
    55f4:	ff 90       	pop	r15
    55f6:	08 95       	ret
    55f8:	6c e6       	ldi	r22, 0x6C	; 108
    55fa:	78 e0       	ldi	r23, 0x08	; 8
    55fc:	8e ef       	ldi	r24, 0xFE	; 254
    55fe:	93 e2       	ldi	r25, 0x23	; 35
    5600:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    5604:	82 cf       	rjmp	.-252    	; 0x550a <xTaskResumeAll+0x14>
    5606:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vPortYield>
    560a:	81 e0       	ldi	r24, 0x01	; 1
    560c:	ed cf       	rjmp	.-38     	; 0x55e8 <xTaskResumeAll+0xf2>
    560e:	0e 94 ab 25 	call	0x4b56	; 0x4b56 <prvResetNextTaskUnblockTime.part.0>
    5612:	d7 cf       	rjmp	.-82     	; 0x55c2 <xTaskResumeAll+0xcc>

00005614 <vTaskDelayUntil>:
    5614:	0f 93       	push	r16
    5616:	1f 93       	push	r17
    5618:	cf 93       	push	r28
    561a:	df 93       	push	r29
    561c:	8c 01       	movw	r16, r24
    561e:	eb 01       	movw	r28, r22
    5620:	89 2b       	or	r24, r25
    5622:	09 f4       	brne	.+2      	; 0x5626 <vTaskDelayUntil+0x12>
    5624:	46 c0       	rjmp	.+140    	; 0x56b2 <vTaskDelayUntil+0x9e>
    5626:	20 97       	sbiw	r28, 0x00	; 0
    5628:	e9 f1       	breq	.+122    	; 0x56a4 <vTaskDelayUntil+0x90>
    562a:	80 91 6e 2d 	lds	r24, 0x2D6E	; 0x802d6e <uxSchedulerSuspended>
    562e:	81 11       	cpse	r24, r1
    5630:	32 c0       	rjmp	.+100    	; 0x5696 <vTaskDelayUntil+0x82>
    5632:	80 91 6e 2d 	lds	r24, 0x2D6E	; 0x802d6e <uxSchedulerSuspended>
    5636:	8f 5f       	subi	r24, 0xFF	; 255
    5638:	80 93 6e 2d 	sts	0x2D6E, r24	; 0x802d6e <uxSchedulerSuspended>
    563c:	40 91 79 2d 	lds	r20, 0x2D79	; 0x802d79 <xTickCount>
    5640:	50 91 7a 2d 	lds	r21, 0x2D7A	; 0x802d7a <xTickCount+0x1>
    5644:	f8 01       	movw	r30, r16
    5646:	20 81       	ld	r18, Z
    5648:	31 81       	ldd	r19, Z+1	; 0x01
    564a:	ce 01       	movw	r24, r28
    564c:	82 0f       	add	r24, r18
    564e:	93 1f       	adc	r25, r19
    5650:	42 17       	cp	r20, r18
    5652:	53 07       	cpc	r21, r19
    5654:	88 f4       	brcc	.+34     	; 0x5678 <vTaskDelayUntil+0x64>
    5656:	82 17       	cp	r24, r18
    5658:	93 07       	cpc	r25, r19
    565a:	88 f0       	brcs	.+34     	; 0x567e <vTaskDelayUntil+0x6a>
    565c:	f8 01       	movw	r30, r16
    565e:	80 83       	st	Z, r24
    5660:	91 83       	std	Z+1, r25	; 0x01
    5662:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>
    5666:	81 11       	cpse	r24, r1
    5668:	02 c0       	rjmp	.+4      	; 0x566e <vTaskDelayUntil+0x5a>
    566a:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vPortYield>
    566e:	df 91       	pop	r29
    5670:	cf 91       	pop	r28
    5672:	1f 91       	pop	r17
    5674:	0f 91       	pop	r16
    5676:	08 95       	ret
    5678:	82 17       	cp	r24, r18
    567a:	93 07       	cpc	r25, r19
    567c:	18 f0       	brcs	.+6      	; 0x5684 <vTaskDelayUntil+0x70>
    567e:	48 17       	cp	r20, r24
    5680:	59 07       	cpc	r21, r25
    5682:	60 f7       	brcc	.-40     	; 0x565c <vTaskDelayUntil+0x48>
    5684:	f8 01       	movw	r30, r16
    5686:	80 83       	st	Z, r24
    5688:	91 83       	std	Z+1, r25	; 0x01
    568a:	60 e0       	ldi	r22, 0x00	; 0
    568c:	84 1b       	sub	r24, r20
    568e:	95 0b       	sbc	r25, r21
    5690:	0e 94 db 25 	call	0x4bb6	; 0x4bb6 <prvAddCurrentTaskToDelayedList>
    5694:	e6 cf       	rjmp	.-52     	; 0x5662 <vTaskDelayUntil+0x4e>
    5696:	6c ec       	ldi	r22, 0xCC	; 204
    5698:	74 e0       	ldi	r23, 0x04	; 4
    569a:	8e ef       	ldi	r24, 0xFE	; 254
    569c:	93 e2       	ldi	r25, 0x23	; 35
    569e:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    56a2:	c7 cf       	rjmp	.-114    	; 0x5632 <vTaskDelayUntil+0x1e>
    56a4:	6b ec       	ldi	r22, 0xCB	; 203
    56a6:	74 e0       	ldi	r23, 0x04	; 4
    56a8:	8e ef       	ldi	r24, 0xFE	; 254
    56aa:	93 e2       	ldi	r25, 0x23	; 35
    56ac:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    56b0:	bc cf       	rjmp	.-136    	; 0x562a <vTaskDelayUntil+0x16>
    56b2:	6a ec       	ldi	r22, 0xCA	; 202
    56b4:	74 e0       	ldi	r23, 0x04	; 4
    56b6:	8e ef       	ldi	r24, 0xFE	; 254
    56b8:	93 e2       	ldi	r25, 0x23	; 35
    56ba:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    56be:	b3 cf       	rjmp	.-154    	; 0x5626 <vTaskDelayUntil+0x12>

000056c0 <vTaskDelay>:
    56c0:	cf 93       	push	r28
    56c2:	df 93       	push	r29
    56c4:	ec 01       	movw	r28, r24
    56c6:	89 2b       	or	r24, r25
    56c8:	29 f4       	brne	.+10     	; 0x56d4 <vTaskDelay+0x14>
    56ca:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <vPortYield>
    56ce:	df 91       	pop	r29
    56d0:	cf 91       	pop	r28
    56d2:	08 95       	ret
    56d4:	80 91 6e 2d 	lds	r24, 0x2D6E	; 0x802d6e <uxSchedulerSuspended>
    56d8:	81 11       	cpse	r24, r1
    56da:	10 c0       	rjmp	.+32     	; 0x56fc <vTaskDelay+0x3c>
    56dc:	80 91 6e 2d 	lds	r24, 0x2D6E	; 0x802d6e <uxSchedulerSuspended>
    56e0:	8f 5f       	subi	r24, 0xFF	; 255
    56e2:	80 93 6e 2d 	sts	0x2D6E, r24	; 0x802d6e <uxSchedulerSuspended>
    56e6:	60 e0       	ldi	r22, 0x00	; 0
    56e8:	ce 01       	movw	r24, r28
    56ea:	0e 94 db 25 	call	0x4bb6	; 0x4bb6 <prvAddCurrentTaskToDelayedList>
    56ee:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>
    56f2:	88 23       	and	r24, r24
    56f4:	51 f3       	breq	.-44     	; 0x56ca <vTaskDelay+0xa>
    56f6:	df 91       	pop	r29
    56f8:	cf 91       	pop	r28
    56fa:	08 95       	ret
    56fc:	60 e2       	ldi	r22, 0x20	; 32
    56fe:	75 e0       	ldi	r23, 0x05	; 5
    5700:	8e ef       	ldi	r24, 0xFE	; 254
    5702:	93 e2       	ldi	r25, 0x23	; 35
    5704:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    5708:	e9 cf       	rjmp	.-46     	; 0x56dc <vTaskDelay+0x1c>

0000570a <vTaskSwitchContext>:
    570a:	80 91 6e 2d 	lds	r24, 0x2D6E	; 0x802d6e <uxSchedulerSuspended>
    570e:	81 11       	cpse	r24, r1
    5710:	02 c0       	rjmp	.+4      	; 0x5716 <vTaskSwitchContext+0xc>
    5712:	0c 94 37 26 	jmp	0x4c6e	; 0x4c6e <vTaskSwitchContext.part.5>
    5716:	81 e0       	ldi	r24, 0x01	; 1
    5718:	80 93 75 2d 	sts	0x2D75, r24	; 0x802d75 <xYieldPending>
    571c:	08 95       	ret

0000571e <vTaskPlaceOnEventList>:
    571e:	0f 93       	push	r16
    5720:	1f 93       	push	r17
    5722:	cf 93       	push	r28
    5724:	df 93       	push	r29
    5726:	ec 01       	movw	r28, r24
    5728:	8b 01       	movw	r16, r22
    572a:	89 2b       	or	r24, r25
    572c:	89 f0       	breq	.+34     	; 0x5750 <vTaskPlaceOnEventList+0x32>
    572e:	60 91 08 2e 	lds	r22, 0x2E08	; 0x802e08 <pxCurrentTCB>
    5732:	70 91 09 2e 	lds	r23, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    5736:	64 5f       	subi	r22, 0xF4	; 244
    5738:	7f 4f       	sbci	r23, 0xFF	; 255
    573a:	ce 01       	movw	r24, r28
    573c:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <vListInsert>
    5740:	61 e0       	ldi	r22, 0x01	; 1
    5742:	c8 01       	movw	r24, r16
    5744:	df 91       	pop	r29
    5746:	cf 91       	pop	r28
    5748:	1f 91       	pop	r17
    574a:	0f 91       	pop	r16
    574c:	0c 94 db 25 	jmp	0x4bb6	; 0x4bb6 <prvAddCurrentTaskToDelayedList>
    5750:	63 ea       	ldi	r22, 0xA3	; 163
    5752:	7b e0       	ldi	r23, 0x0B	; 11
    5754:	8e ef       	ldi	r24, 0xFE	; 254
    5756:	93 e2       	ldi	r25, 0x23	; 35
    5758:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    575c:	e8 cf       	rjmp	.-48     	; 0x572e <vTaskPlaceOnEventList+0x10>

0000575e <xTaskRemoveFromEventList>:
    575e:	0f 93       	push	r16
    5760:	1f 93       	push	r17
    5762:	cf 93       	push	r28
    5764:	df 93       	push	r29
    5766:	dc 01       	movw	r26, r24
    5768:	15 96       	adiw	r26, 0x05	; 5
    576a:	ed 91       	ld	r30, X+
    576c:	fc 91       	ld	r31, X
    576e:	16 97       	sbiw	r26, 0x06	; 6
    5770:	c6 81       	ldd	r28, Z+6	; 0x06
    5772:	d7 81       	ldd	r29, Z+7	; 0x07
    5774:	20 97       	sbiw	r28, 0x00	; 0
    5776:	09 f4       	brne	.+2      	; 0x577a <xTaskRemoveFromEventList+0x1c>
    5778:	42 c0       	rjmp	.+132    	; 0x57fe <xTaskRemoveFromEventList+0xa0>
    577a:	8e 01       	movw	r16, r28
    577c:	04 5f       	subi	r16, 0xF4	; 244
    577e:	1f 4f       	sbci	r17, 0xFF	; 255
    5780:	c8 01       	movw	r24, r16
    5782:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <uxListRemove>
    5786:	80 91 6e 2d 	lds	r24, 0x2D6E	; 0x802d6e <uxSchedulerSuspended>
    578a:	81 11       	cpse	r24, r1
    578c:	29 c0       	rjmp	.+82     	; 0x57e0 <xTaskRemoveFromEventList+0x82>
    578e:	0a 50       	subi	r16, 0x0A	; 10
    5790:	11 09       	sbc	r17, r1
    5792:	c8 01       	movw	r24, r16
    5794:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <uxListRemove>
    5798:	8e 89       	ldd	r24, Y+22	; 0x16
    579a:	90 91 78 2d 	lds	r25, 0x2D78	; 0x802d78 <uxTopReadyPriority>
    579e:	98 17       	cp	r25, r24
    57a0:	28 f1       	brcs	.+74     	; 0x57ec <xTaskRemoveFromEventList+0x8e>
    57a2:	90 e0       	ldi	r25, 0x00	; 0
    57a4:	9c 01       	movw	r18, r24
    57a6:	22 0f       	add	r18, r18
    57a8:	33 1f       	adc	r19, r19
    57aa:	22 0f       	add	r18, r18
    57ac:	33 1f       	adc	r19, r19
    57ae:	22 0f       	add	r18, r18
    57b0:	33 1f       	adc	r19, r19
    57b2:	82 0f       	add	r24, r18
    57b4:	93 1f       	adc	r25, r19
    57b6:	b8 01       	movw	r22, r16
    57b8:	82 55       	subi	r24, 0x52	; 82
    57ba:	92 4d       	sbci	r25, 0xD2	; 210
    57bc:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <vListInsertEnd>
    57c0:	e0 91 08 2e 	lds	r30, 0x2E08	; 0x802e08 <pxCurrentTCB>
    57c4:	f0 91 09 2e 	lds	r31, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    57c8:	9e 89       	ldd	r25, Y+22	; 0x16
    57ca:	86 89       	ldd	r24, Z+22	; 0x16
    57cc:	89 17       	cp	r24, r25
    57ce:	88 f4       	brcc	.+34     	; 0x57f2 <xTaskRemoveFromEventList+0x94>
    57d0:	81 e0       	ldi	r24, 0x01	; 1
    57d2:	80 93 75 2d 	sts	0x2D75, r24	; 0x802d75 <xYieldPending>
    57d6:	df 91       	pop	r29
    57d8:	cf 91       	pop	r28
    57da:	1f 91       	pop	r17
    57dc:	0f 91       	pop	r16
    57de:	08 95       	ret
    57e0:	b8 01       	movw	r22, r16
    57e2:	8f e8       	ldi	r24, 0x8F	; 143
    57e4:	9d e2       	ldi	r25, 0x2D	; 45
    57e6:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <vListInsertEnd>
    57ea:	ea cf       	rjmp	.-44     	; 0x57c0 <xTaskRemoveFromEventList+0x62>
    57ec:	80 93 78 2d 	sts	0x2D78, r24	; 0x802d78 <uxTopReadyPriority>
    57f0:	d8 cf       	rjmp	.-80     	; 0x57a2 <xTaskRemoveFromEventList+0x44>
    57f2:	80 e0       	ldi	r24, 0x00	; 0
    57f4:	df 91       	pop	r29
    57f6:	cf 91       	pop	r28
    57f8:	1f 91       	pop	r17
    57fa:	0f 91       	pop	r16
    57fc:	08 95       	ret
    57fe:	6e ef       	ldi	r22, 0xFE	; 254
    5800:	7b e0       	ldi	r23, 0x0B	; 11
    5802:	8e ef       	ldi	r24, 0xFE	; 254
    5804:	93 e2       	ldi	r25, 0x23	; 35
    5806:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    580a:	b7 cf       	rjmp	.-146    	; 0x577a <xTaskRemoveFromEventList+0x1c>

0000580c <vTaskInternalSetTimeOutState>:
    580c:	20 91 74 2d 	lds	r18, 0x2D74	; 0x802d74 <xNumOfOverflows>
    5810:	fc 01       	movw	r30, r24
    5812:	20 83       	st	Z, r18
    5814:	20 91 79 2d 	lds	r18, 0x2D79	; 0x802d79 <xTickCount>
    5818:	30 91 7a 2d 	lds	r19, 0x2D7A	; 0x802d7a <xTickCount+0x1>
    581c:	21 83       	std	Z+1, r18	; 0x01
    581e:	32 83       	std	Z+2, r19	; 0x02
    5820:	08 95       	ret

00005822 <xTaskCheckForTimeOut>:
    5822:	0f 93       	push	r16
    5824:	1f 93       	push	r17
    5826:	cf 93       	push	r28
    5828:	df 93       	push	r29
    582a:	ec 01       	movw	r28, r24
    582c:	8b 01       	movw	r16, r22
    582e:	89 2b       	or	r24, r25
    5830:	09 f4       	brne	.+2      	; 0x5834 <xTaskCheckForTimeOut+0x12>
    5832:	40 c0       	rjmp	.+128    	; 0x58b4 <xTaskCheckForTimeOut+0x92>
    5834:	01 15       	cp	r16, r1
    5836:	11 05       	cpc	r17, r1
    5838:	09 f4       	brne	.+2      	; 0x583c <xTaskCheckForTimeOut+0x1a>
    583a:	43 c0       	rjmp	.+134    	; 0x58c2 <xTaskCheckForTimeOut+0xa0>
    583c:	0f b6       	in	r0, 0x3f	; 63
    583e:	f8 94       	cli
    5840:	0f 92       	push	r0
    5842:	80 91 79 2d 	lds	r24, 0x2D79	; 0x802d79 <xTickCount>
    5846:	90 91 7a 2d 	lds	r25, 0x2D7A	; 0x802d7a <xTickCount+0x1>
    584a:	f8 01       	movw	r30, r16
    584c:	20 81       	ld	r18, Z
    584e:	31 81       	ldd	r19, Z+1	; 0x01
    5850:	2f 3f       	cpi	r18, 0xFF	; 255
    5852:	ff ef       	ldi	r31, 0xFF	; 255
    5854:	3f 07       	cpc	r19, r31
    5856:	61 f1       	breq	.+88     	; 0x58b0 <xTaskCheckForTimeOut+0x8e>
    5858:	49 81       	ldd	r20, Y+1	; 0x01
    585a:	5a 81       	ldd	r21, Y+2	; 0x02
    585c:	60 91 74 2d 	lds	r22, 0x2D74	; 0x802d74 <xNumOfOverflows>
    5860:	78 81       	ld	r23, Y
    5862:	76 17       	cp	r23, r22
    5864:	19 f0       	breq	.+6      	; 0x586c <xTaskCheckForTimeOut+0x4a>
    5866:	84 17       	cp	r24, r20
    5868:	95 07       	cpc	r25, r21
    586a:	80 f4       	brcc	.+32     	; 0x588c <xTaskCheckForTimeOut+0x6a>
    586c:	84 1b       	sub	r24, r20
    586e:	95 0b       	sbc	r25, r21
    5870:	82 17       	cp	r24, r18
    5872:	93 07       	cpc	r25, r19
    5874:	68 f0       	brcs	.+26     	; 0x5890 <xTaskCheckForTimeOut+0x6e>
    5876:	f8 01       	movw	r30, r16
    5878:	10 82       	st	Z, r1
    587a:	11 82       	std	Z+1, r1	; 0x01
    587c:	81 e0       	ldi	r24, 0x01	; 1
    587e:	0f 90       	pop	r0
    5880:	0f be       	out	0x3f, r0	; 63
    5882:	df 91       	pop	r29
    5884:	cf 91       	pop	r28
    5886:	1f 91       	pop	r17
    5888:	0f 91       	pop	r16
    588a:	08 95       	ret
    588c:	81 e0       	ldi	r24, 0x01	; 1
    588e:	f7 cf       	rjmp	.-18     	; 0x587e <xTaskCheckForTimeOut+0x5c>
    5890:	28 1b       	sub	r18, r24
    5892:	39 0b       	sbc	r19, r25
    5894:	f8 01       	movw	r30, r16
    5896:	20 83       	st	Z, r18
    5898:	31 83       	std	Z+1, r19	; 0x01
    589a:	80 91 74 2d 	lds	r24, 0x2D74	; 0x802d74 <xNumOfOverflows>
    589e:	88 83       	st	Y, r24
    58a0:	80 91 79 2d 	lds	r24, 0x2D79	; 0x802d79 <xTickCount>
    58a4:	90 91 7a 2d 	lds	r25, 0x2D7A	; 0x802d7a <xTickCount+0x1>
    58a8:	89 83       	std	Y+1, r24	; 0x01
    58aa:	9a 83       	std	Y+2, r25	; 0x02
    58ac:	80 e0       	ldi	r24, 0x00	; 0
    58ae:	e7 cf       	rjmp	.-50     	; 0x587e <xTaskCheckForTimeOut+0x5c>
    58b0:	80 e0       	ldi	r24, 0x00	; 0
    58b2:	e5 cf       	rjmp	.-54     	; 0x587e <xTaskCheckForTimeOut+0x5c>
    58b4:	69 e6       	ldi	r22, 0x69	; 105
    58b6:	7c e0       	ldi	r23, 0x0C	; 12
    58b8:	8e ef       	ldi	r24, 0xFE	; 254
    58ba:	93 e2       	ldi	r25, 0x23	; 35
    58bc:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    58c0:	b9 cf       	rjmp	.-142    	; 0x5834 <xTaskCheckForTimeOut+0x12>
    58c2:	6a e6       	ldi	r22, 0x6A	; 106
    58c4:	7c e0       	ldi	r23, 0x0C	; 12
    58c6:	8e ef       	ldi	r24, 0xFE	; 254
    58c8:	93 e2       	ldi	r25, 0x23	; 35
    58ca:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    58ce:	b6 cf       	rjmp	.-148    	; 0x583c <xTaskCheckForTimeOut+0x1a>

000058d0 <vTaskMissedYield>:
    58d0:	81 e0       	ldi	r24, 0x01	; 1
    58d2:	80 93 75 2d 	sts	0x2D75, r24	; 0x802d75 <xYieldPending>
    58d6:	08 95       	ret

000058d8 <vTaskGetInfo>:
    58d8:	ff 92       	push	r15
    58da:	0f 93       	push	r16
    58dc:	1f 93       	push	r17
    58de:	cf 93       	push	r28
    58e0:	df 93       	push	r29
    58e2:	8c 01       	movw	r16, r24
    58e4:	eb 01       	movw	r28, r22
    58e6:	f4 2e       	mov	r15, r20
    58e8:	89 2b       	or	r24, r25
    58ea:	09 f4       	brne	.+2      	; 0x58ee <vTaskGetInfo+0x16>
    58ec:	64 c0       	rjmp	.+200    	; 0x59b6 <vTaskGetInfo+0xde>
    58ee:	08 83       	st	Y, r16
    58f0:	19 83       	std	Y+1, r17	; 0x01
    58f2:	c8 01       	movw	r24, r16
    58f4:	49 96       	adiw	r24, 0x19	; 25
    58f6:	8a 83       	std	Y+2, r24	; 0x02
    58f8:	9b 83       	std	Y+3, r25	; 0x03
    58fa:	d8 01       	movw	r26, r16
    58fc:	56 96       	adiw	r26, 0x16	; 22
    58fe:	8c 91       	ld	r24, X
    5900:	56 97       	sbiw	r26, 0x16	; 22
    5902:	8e 83       	std	Y+6, r24	; 0x06
    5904:	57 96       	adiw	r26, 0x17	; 23
    5906:	8d 91       	ld	r24, X+
    5908:	9c 91       	ld	r25, X
    590a:	58 97       	sbiw	r26, 0x18	; 24
    590c:	8c 87       	std	Y+12, r24	; 0x0c
    590e:	9d 87       	std	Y+13, r25	; 0x0d
    5910:	91 96       	adiw	r26, 0x21	; 33
    5912:	8c 91       	ld	r24, X
    5914:	91 97       	sbiw	r26, 0x21	; 33
    5916:	8c 83       	std	Y+4, r24	; 0x04
    5918:	93 96       	adiw	r26, 0x23	; 35
    591a:	8c 91       	ld	r24, X
    591c:	93 97       	sbiw	r26, 0x23	; 35
    591e:	8f 83       	std	Y+7, r24	; 0x07
    5920:	97 96       	adiw	r26, 0x27	; 39
    5922:	8d 91       	ld	r24, X+
    5924:	9d 91       	ld	r25, X+
    5926:	0d 90       	ld	r0, X+
    5928:	bc 91       	ld	r27, X
    592a:	a0 2d       	mov	r26, r0
    592c:	88 87       	std	Y+8, r24	; 0x08
    592e:	99 87       	std	Y+9, r25	; 0x09
    5930:	aa 87       	std	Y+10, r26	; 0x0a
    5932:	bb 87       	std	Y+11, r27	; 0x0b
    5934:	25 30       	cpi	r18, 0x05	; 5
    5936:	09 f4       	brne	.+2      	; 0x593a <vTaskGetInfo+0x62>
    5938:	43 c0       	rjmp	.+134    	; 0x59c0 <vTaskGetInfo+0xe8>
    593a:	80 91 08 2e 	lds	r24, 0x2E08	; 0x802e08 <pxCurrentTCB>
    593e:	90 91 09 2e 	lds	r25, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    5942:	08 17       	cp	r16, r24
    5944:	19 07       	cpc	r17, r25
    5946:	09 f4       	brne	.+2      	; 0x594a <vTaskGetInfo+0x72>
    5948:	40 c0       	rjmp	.+128    	; 0x59ca <vTaskGetInfo+0xf2>
    594a:	2d 83       	std	Y+5, r18	; 0x05
    594c:	23 30       	cpi	r18, 0x03	; 3
    594e:	21 f1       	breq	.+72     	; 0x5998 <vTaskGetInfo+0xc0>
    5950:	ff 20       	and	r15, r15
    5952:	d1 f0       	breq	.+52     	; 0x5988 <vTaskGetInfo+0xb0>
    5954:	d8 01       	movw	r26, r16
    5956:	57 96       	adiw	r26, 0x17	; 23
    5958:	ed 91       	ld	r30, X+
    595a:	fc 91       	ld	r31, X
    595c:	58 97       	sbiw	r26, 0x18	; 24
    595e:	80 81       	ld	r24, Z
    5960:	85 3a       	cpi	r24, 0xA5	; 165
    5962:	a9 f5       	brne	.+106    	; 0x59ce <vTaskGetInfo+0xf6>
    5964:	31 96       	adiw	r30, 0x01	; 1
    5966:	80 e0       	ldi	r24, 0x00	; 0
    5968:	90 e0       	ldi	r25, 0x00	; 0
    596a:	dc 01       	movw	r26, r24
    596c:	01 96       	adiw	r24, 0x01	; 1
    596e:	a1 1d       	adc	r26, r1
    5970:	b1 1d       	adc	r27, r1
    5972:	21 91       	ld	r18, Z+
    5974:	25 3a       	cpi	r18, 0xA5	; 165
    5976:	d1 f3       	breq	.-12     	; 0x596c <vTaskGetInfo+0x94>
    5978:	8e 87       	std	Y+14, r24	; 0x0e
    597a:	9f 87       	std	Y+15, r25	; 0x0f
    597c:	df 91       	pop	r29
    597e:	cf 91       	pop	r28
    5980:	1f 91       	pop	r17
    5982:	0f 91       	pop	r16
    5984:	ff 90       	pop	r15
    5986:	08 95       	ret
    5988:	1e 86       	std	Y+14, r1	; 0x0e
    598a:	1f 86       	std	Y+15, r1	; 0x0f
    598c:	df 91       	pop	r29
    598e:	cf 91       	pop	r28
    5990:	1f 91       	pop	r17
    5992:	0f 91       	pop	r16
    5994:	ff 90       	pop	r15
    5996:	08 95       	ret
    5998:	80 91 6e 2d 	lds	r24, 0x2D6E	; 0x802d6e <uxSchedulerSuspended>
    599c:	8f 5f       	subi	r24, 0xFF	; 255
    599e:	80 93 6e 2d 	sts	0x2D6E, r24	; 0x802d6e <uxSchedulerSuspended>
    59a2:	f8 01       	movw	r30, r16
    59a4:	84 89       	ldd	r24, Z+20	; 0x14
    59a6:	95 89       	ldd	r25, Z+21	; 0x15
    59a8:	89 2b       	or	r24, r25
    59aa:	11 f0       	breq	.+4      	; 0x59b0 <vTaskGetInfo+0xd8>
    59ac:	82 e0       	ldi	r24, 0x02	; 2
    59ae:	8d 83       	std	Y+5, r24	; 0x05
    59b0:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>
    59b4:	cd cf       	rjmp	.-102    	; 0x5950 <vTaskGetInfo+0x78>
    59b6:	00 91 08 2e 	lds	r16, 0x2E08	; 0x802e08 <pxCurrentTCB>
    59ba:	10 91 09 2e 	lds	r17, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    59be:	97 cf       	rjmp	.-210    	; 0x58ee <vTaskGetInfo+0x16>
    59c0:	c8 01       	movw	r24, r16
    59c2:	0e 94 2f 28 	call	0x505e	; 0x505e <eTaskGetState>
    59c6:	8d 83       	std	Y+5, r24	; 0x05
    59c8:	c3 cf       	rjmp	.-122    	; 0x5950 <vTaskGetInfo+0x78>
    59ca:	1d 82       	std	Y+5, r1	; 0x05
    59cc:	c1 cf       	rjmp	.-126    	; 0x5950 <vTaskGetInfo+0x78>
    59ce:	80 e0       	ldi	r24, 0x00	; 0
    59d0:	90 e0       	ldi	r25, 0x00	; 0
    59d2:	d2 cf       	rjmp	.-92     	; 0x5978 <vTaskGetInfo+0xa0>

000059d4 <prvListTasksWithinSingleList.part.6>:
    59d4:	8f 92       	push	r8
    59d6:	9f 92       	push	r9
    59d8:	af 92       	push	r10
    59da:	bf 92       	push	r11
    59dc:	cf 92       	push	r12
    59de:	df 92       	push	r13
    59e0:	ef 92       	push	r14
    59e2:	ff 92       	push	r15
    59e4:	0f 93       	push	r16
    59e6:	1f 93       	push	r17
    59e8:	cf 93       	push	r28
    59ea:	df 93       	push	r29
    59ec:	5c 01       	movw	r10, r24
    59ee:	8b 01       	movw	r16, r22
    59f0:	d4 2f       	mov	r29, r20
    59f2:	db 01       	movw	r26, r22
    59f4:	11 96       	adiw	r26, 0x01	; 1
    59f6:	ed 91       	ld	r30, X+
    59f8:	fc 91       	ld	r31, X
    59fa:	12 97       	sbiw	r26, 0x02	; 2
    59fc:	02 80       	ldd	r0, Z+2	; 0x02
    59fe:	f3 81       	ldd	r31, Z+3	; 0x03
    5a00:	e0 2d       	mov	r30, r0
    5a02:	11 96       	adiw	r26, 0x01	; 1
    5a04:	ed 93       	st	X+, r30
    5a06:	fc 93       	st	X, r31
    5a08:	12 97       	sbiw	r26, 0x02	; 2
    5a0a:	7b 01       	movw	r14, r22
    5a0c:	b3 e0       	ldi	r27, 0x03	; 3
    5a0e:	eb 0e       	add	r14, r27
    5a10:	f1 1c       	adc	r15, r1
    5a12:	ee 15       	cp	r30, r14
    5a14:	ff 05       	cpc	r31, r15
    5a16:	e1 f1       	breq	.+120    	; 0x5a90 <prvListTasksWithinSingleList.part.6+0xbc>
    5a18:	c6 80       	ldd	r12, Z+6	; 0x06
    5a1a:	d7 80       	ldd	r13, Z+7	; 0x07
    5a1c:	c0 e0       	ldi	r28, 0x00	; 0
    5a1e:	16 c0       	rjmp	.+44     	; 0x5a4c <prvListTasksWithinSingleList.part.6+0x78>
    5a20:	86 80       	ldd	r8, Z+6	; 0x06
    5a22:	97 80       	ldd	r9, Z+7	; 0x07
    5a24:	b5 01       	movw	r22, r10
    5a26:	b0 e1       	ldi	r27, 0x10	; 16
    5a28:	cb 9f       	mul	r28, r27
    5a2a:	60 0d       	add	r22, r0
    5a2c:	71 1d       	adc	r23, r1
    5a2e:	11 24       	eor	r1, r1
    5a30:	2d 2f       	mov	r18, r29
    5a32:	41 e0       	ldi	r20, 0x01	; 1
    5a34:	c4 01       	movw	r24, r8
    5a36:	0e 94 6c 2c 	call	0x58d8	; 0x58d8 <vTaskGetInfo>
    5a3a:	cf 5f       	subi	r28, 0xFF	; 255
    5a3c:	c8 14       	cp	r12, r8
    5a3e:	d9 04       	cpc	r13, r9
    5a40:	c9 f0       	breq	.+50     	; 0x5a74 <prvListTasksWithinSingleList.part.6+0xa0>
    5a42:	d8 01       	movw	r26, r16
    5a44:	11 96       	adiw	r26, 0x01	; 1
    5a46:	ed 91       	ld	r30, X+
    5a48:	fc 91       	ld	r31, X
    5a4a:	12 97       	sbiw	r26, 0x02	; 2
    5a4c:	02 80       	ldd	r0, Z+2	; 0x02
    5a4e:	f3 81       	ldd	r31, Z+3	; 0x03
    5a50:	e0 2d       	mov	r30, r0
    5a52:	d8 01       	movw	r26, r16
    5a54:	11 96       	adiw	r26, 0x01	; 1
    5a56:	ed 93       	st	X+, r30
    5a58:	fc 93       	st	X, r31
    5a5a:	12 97       	sbiw	r26, 0x02	; 2
    5a5c:	ee 16       	cp	r14, r30
    5a5e:	ff 06       	cpc	r15, r31
    5a60:	f9 f6       	brne	.-66     	; 0x5a20 <prvListTasksWithinSingleList.part.6+0x4c>
    5a62:	15 96       	adiw	r26, 0x05	; 5
    5a64:	ed 91       	ld	r30, X+
    5a66:	fc 91       	ld	r31, X
    5a68:	16 97       	sbiw	r26, 0x06	; 6
    5a6a:	11 96       	adiw	r26, 0x01	; 1
    5a6c:	ed 93       	st	X+, r30
    5a6e:	fc 93       	st	X, r31
    5a70:	12 97       	sbiw	r26, 0x02	; 2
    5a72:	d6 cf       	rjmp	.-84     	; 0x5a20 <prvListTasksWithinSingleList.part.6+0x4c>
    5a74:	8c 2f       	mov	r24, r28
    5a76:	df 91       	pop	r29
    5a78:	cf 91       	pop	r28
    5a7a:	1f 91       	pop	r17
    5a7c:	0f 91       	pop	r16
    5a7e:	ff 90       	pop	r15
    5a80:	ef 90       	pop	r14
    5a82:	df 90       	pop	r13
    5a84:	cf 90       	pop	r12
    5a86:	bf 90       	pop	r11
    5a88:	af 90       	pop	r10
    5a8a:	9f 90       	pop	r9
    5a8c:	8f 90       	pop	r8
    5a8e:	08 95       	ret
    5a90:	02 80       	ldd	r0, Z+2	; 0x02
    5a92:	f3 81       	ldd	r31, Z+3	; 0x03
    5a94:	e0 2d       	mov	r30, r0
    5a96:	c0 cf       	rjmp	.-128    	; 0x5a18 <prvListTasksWithinSingleList.part.6+0x44>

00005a98 <uxTaskGetSystemState>:
    5a98:	ef 92       	push	r14
    5a9a:	ff 92       	push	r15
    5a9c:	0f 93       	push	r16
    5a9e:	1f 93       	push	r17
    5aa0:	cf 93       	push	r28
    5aa2:	df 93       	push	r29
    5aa4:	8c 01       	movw	r16, r24
    5aa6:	7a 01       	movw	r14, r20
    5aa8:	80 91 6e 2d 	lds	r24, 0x2D6E	; 0x802d6e <uxSchedulerSuspended>
    5aac:	8f 5f       	subi	r24, 0xFF	; 255
    5aae:	80 93 6e 2d 	sts	0x2D6E, r24	; 0x802d6e <uxSchedulerSuspended>
    5ab2:	80 91 7b 2d 	lds	r24, 0x2D7B	; 0x802d7b <uxCurrentNumberOfTasks>
    5ab6:	68 17       	cp	r22, r24
    5ab8:	08 f4       	brcc	.+2      	; 0x5abc <uxTaskGetSystemState+0x24>
    5aba:	66 c0       	rjmp	.+204    	; 0x5b88 <uxTaskGetSystemState+0xf0>
    5abc:	ca e0       	ldi	r28, 0x0A	; 10
    5abe:	d0 e0       	ldi	r29, 0x00	; 0
    5ac0:	04 c0       	rjmp	.+8      	; 0x5aca <uxTaskGetSystemState+0x32>
    5ac2:	80 e0       	ldi	r24, 0x00	; 0
    5ac4:	d8 0f       	add	r29, r24
    5ac6:	cc 23       	and	r28, r28
    5ac8:	f9 f0       	breq	.+62     	; 0x5b08 <uxTaskGetSystemState+0x70>
    5aca:	c1 50       	subi	r28, 0x01	; 1
    5acc:	6c 2f       	mov	r22, r28
    5ace:	70 e0       	ldi	r23, 0x00	; 0
    5ad0:	cb 01       	movw	r24, r22
    5ad2:	88 0f       	add	r24, r24
    5ad4:	99 1f       	adc	r25, r25
    5ad6:	88 0f       	add	r24, r24
    5ad8:	99 1f       	adc	r25, r25
    5ada:	88 0f       	add	r24, r24
    5adc:	99 1f       	adc	r25, r25
    5ade:	68 0f       	add	r22, r24
    5ae0:	79 1f       	adc	r23, r25
    5ae2:	fb 01       	movw	r30, r22
    5ae4:	e2 55       	subi	r30, 0x52	; 82
    5ae6:	f2 4d       	sbci	r31, 0xD2	; 210
    5ae8:	80 81       	ld	r24, Z
    5aea:	88 23       	and	r24, r24
    5aec:	51 f3       	breq	.-44     	; 0x5ac2 <uxTaskGetSystemState+0x2a>
    5aee:	41 e0       	ldi	r20, 0x01	; 1
    5af0:	bf 01       	movw	r22, r30
    5af2:	c8 01       	movw	r24, r16
    5af4:	20 e1       	ldi	r18, 0x10	; 16
    5af6:	d2 9f       	mul	r29, r18
    5af8:	80 0d       	add	r24, r0
    5afa:	91 1d       	adc	r25, r1
    5afc:	11 24       	eor	r1, r1
    5afe:	0e 94 ea 2c 	call	0x59d4	; 0x59d4 <prvListTasksWithinSingleList.part.6>
    5b02:	d8 0f       	add	r29, r24
    5b04:	c1 11       	cpse	r28, r1
    5b06:	e1 cf       	rjmp	.-62     	; 0x5aca <uxTaskGetSystemState+0x32>
    5b08:	e0 91 9a 2d 	lds	r30, 0x2D9A	; 0x802d9a <pxDelayedTaskList>
    5b0c:	f0 91 9b 2d 	lds	r31, 0x2D9B	; 0x802d9b <pxDelayedTaskList+0x1>
    5b10:	80 81       	ld	r24, Z
    5b12:	81 11       	cpse	r24, r1
    5b14:	3b c0       	rjmp	.+118    	; 0x5b8c <uxTaskGetSystemState+0xf4>
    5b16:	80 e0       	ldi	r24, 0x00	; 0
    5b18:	d8 0f       	add	r29, r24
    5b1a:	e0 91 98 2d 	lds	r30, 0x2D98	; 0x802d98 <pxOverflowDelayedTaskList>
    5b1e:	f0 91 99 2d 	lds	r31, 0x2D99	; 0x802d99 <pxOverflowDelayedTaskList+0x1>
    5b22:	80 81       	ld	r24, Z
    5b24:	81 11       	cpse	r24, r1
    5b26:	45 c0       	rjmp	.+138    	; 0x5bb2 <uxTaskGetSystemState+0x11a>
    5b28:	80 e0       	ldi	r24, 0x00	; 0
    5b2a:	d8 0f       	add	r29, r24
    5b2c:	80 91 86 2d 	lds	r24, 0x2D86	; 0x802d86 <xTasksWaitingTermination>
    5b30:	81 11       	cpse	r24, r1
    5b32:	4f c0       	rjmp	.+158    	; 0x5bd2 <uxTaskGetSystemState+0x13a>
    5b34:	80 e0       	ldi	r24, 0x00	; 0
    5b36:	d8 0f       	add	r29, r24
    5b38:	80 91 7c 2d 	lds	r24, 0x2D7C	; 0x802d7c <xSuspendedTaskList>
    5b3c:	81 11       	cpse	r24, r1
    5b3e:	5a c0       	rjmp	.+180    	; 0x5bf4 <uxTaskGetSystemState+0x15c>
    5b40:	80 e0       	ldi	r24, 0x00	; 0
    5b42:	d8 0f       	add	r29, r24
    5b44:	e1 14       	cp	r14, r1
    5b46:	f1 04       	cpc	r15, r1
    5b48:	a9 f0       	breq	.+42     	; 0x5b74 <uxTaskGetSystemState+0xdc>
    5b4a:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    5b4e:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    5b52:	80 91 6e 2e 	lds	r24, 0x2E6E	; 0x802e6e <StatsTimer>
    5b56:	90 91 6f 2e 	lds	r25, 0x2E6F	; 0x802e6f <StatsTimer+0x1>
    5b5a:	a0 91 70 2e 	lds	r26, 0x2E70	; 0x802e70 <StatsTimer+0x2>
    5b5e:	b0 91 71 2e 	lds	r27, 0x2E71	; 0x802e71 <StatsTimer+0x3>
    5b62:	82 0f       	add	r24, r18
    5b64:	93 1f       	adc	r25, r19
    5b66:	a1 1d       	adc	r26, r1
    5b68:	b1 1d       	adc	r27, r1
    5b6a:	f7 01       	movw	r30, r14
    5b6c:	80 83       	st	Z, r24
    5b6e:	91 83       	std	Z+1, r25	; 0x01
    5b70:	a2 83       	std	Z+2, r26	; 0x02
    5b72:	b3 83       	std	Z+3, r27	; 0x03
    5b74:	0e 94 7b 2a 	call	0x54f6	; 0x54f6 <xTaskResumeAll>
    5b78:	8d 2f       	mov	r24, r29
    5b7a:	df 91       	pop	r29
    5b7c:	cf 91       	pop	r28
    5b7e:	1f 91       	pop	r17
    5b80:	0f 91       	pop	r16
    5b82:	ff 90       	pop	r15
    5b84:	ef 90       	pop	r14
    5b86:	08 95       	ret
    5b88:	d0 e0       	ldi	r29, 0x00	; 0
    5b8a:	f4 cf       	rjmp	.-24     	; 0x5b74 <uxTaskGetSystemState+0xdc>
    5b8c:	42 e0       	ldi	r20, 0x02	; 2
    5b8e:	bf 01       	movw	r22, r30
    5b90:	c8 01       	movw	r24, r16
    5b92:	e0 e1       	ldi	r30, 0x10	; 16
    5b94:	de 9f       	mul	r29, r30
    5b96:	80 0d       	add	r24, r0
    5b98:	91 1d       	adc	r25, r1
    5b9a:	11 24       	eor	r1, r1
    5b9c:	0e 94 ea 2c 	call	0x59d4	; 0x59d4 <prvListTasksWithinSingleList.part.6>
    5ba0:	d8 0f       	add	r29, r24
    5ba2:	e0 91 98 2d 	lds	r30, 0x2D98	; 0x802d98 <pxOverflowDelayedTaskList>
    5ba6:	f0 91 99 2d 	lds	r31, 0x2D99	; 0x802d99 <pxOverflowDelayedTaskList+0x1>
    5baa:	80 81       	ld	r24, Z
    5bac:	88 23       	and	r24, r24
    5bae:	09 f4       	brne	.+2      	; 0x5bb2 <uxTaskGetSystemState+0x11a>
    5bb0:	bb cf       	rjmp	.-138    	; 0x5b28 <uxTaskGetSystemState+0x90>
    5bb2:	42 e0       	ldi	r20, 0x02	; 2
    5bb4:	bf 01       	movw	r22, r30
    5bb6:	c8 01       	movw	r24, r16
    5bb8:	f0 e1       	ldi	r31, 0x10	; 16
    5bba:	df 9f       	mul	r29, r31
    5bbc:	80 0d       	add	r24, r0
    5bbe:	91 1d       	adc	r25, r1
    5bc0:	11 24       	eor	r1, r1
    5bc2:	0e 94 ea 2c 	call	0x59d4	; 0x59d4 <prvListTasksWithinSingleList.part.6>
    5bc6:	d8 0f       	add	r29, r24
    5bc8:	80 91 86 2d 	lds	r24, 0x2D86	; 0x802d86 <xTasksWaitingTermination>
    5bcc:	88 23       	and	r24, r24
    5bce:	09 f4       	brne	.+2      	; 0x5bd2 <uxTaskGetSystemState+0x13a>
    5bd0:	b1 cf       	rjmp	.-158    	; 0x5b34 <uxTaskGetSystemState+0x9c>
    5bd2:	44 e0       	ldi	r20, 0x04	; 4
    5bd4:	66 e8       	ldi	r22, 0x86	; 134
    5bd6:	7d e2       	ldi	r23, 0x2D	; 45
    5bd8:	c8 01       	movw	r24, r16
    5bda:	20 e1       	ldi	r18, 0x10	; 16
    5bdc:	d2 9f       	mul	r29, r18
    5bde:	80 0d       	add	r24, r0
    5be0:	91 1d       	adc	r25, r1
    5be2:	11 24       	eor	r1, r1
    5be4:	0e 94 ea 2c 	call	0x59d4	; 0x59d4 <prvListTasksWithinSingleList.part.6>
    5be8:	d8 0f       	add	r29, r24
    5bea:	80 91 7c 2d 	lds	r24, 0x2D7C	; 0x802d7c <xSuspendedTaskList>
    5bee:	88 23       	and	r24, r24
    5bf0:	09 f4       	brne	.+2      	; 0x5bf4 <uxTaskGetSystemState+0x15c>
    5bf2:	a6 cf       	rjmp	.-180    	; 0x5b40 <uxTaskGetSystemState+0xa8>
    5bf4:	43 e0       	ldi	r20, 0x03	; 3
    5bf6:	6c e7       	ldi	r22, 0x7C	; 124
    5bf8:	7d e2       	ldi	r23, 0x2D	; 45
    5bfa:	c8 01       	movw	r24, r16
    5bfc:	e0 e1       	ldi	r30, 0x10	; 16
    5bfe:	de 9f       	mul	r29, r30
    5c00:	80 0d       	add	r24, r0
    5c02:	91 1d       	adc	r25, r1
    5c04:	11 24       	eor	r1, r1
    5c06:	0e 94 ea 2c 	call	0x59d4	; 0x59d4 <prvListTasksWithinSingleList.part.6>
    5c0a:	9b cf       	rjmp	.-202    	; 0x5b42 <uxTaskGetSystemState+0xaa>

00005c0c <xTaskPriorityInherit>:
    5c0c:	0f 93       	push	r16
    5c0e:	1f 93       	push	r17
    5c10:	cf 93       	push	r28
    5c12:	df 93       	push	r29
    5c14:	fc 01       	movw	r30, r24
    5c16:	89 2b       	or	r24, r25
    5c18:	09 f4       	brne	.+2      	; 0x5c1c <xTaskPriorityInherit+0x10>
    5c1a:	41 c0       	rjmp	.+130    	; 0x5c9e <xTaskPriorityInherit+0x92>
    5c1c:	26 89       	ldd	r18, Z+22	; 0x16
    5c1e:	a0 91 08 2e 	lds	r26, 0x2E08	; 0x802e08 <pxCurrentTCB>
    5c22:	b0 91 09 2e 	lds	r27, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    5c26:	56 96       	adiw	r26, 0x16	; 22
    5c28:	8c 91       	ld	r24, X
    5c2a:	28 17       	cp	r18, r24
    5c2c:	70 f5       	brcc	.+92     	; 0x5c8a <xTaskPriorityInherit+0x7e>
    5c2e:	84 85       	ldd	r24, Z+12	; 0x0c
    5c30:	95 85       	ldd	r25, Z+13	; 0x0d
    5c32:	97 fd       	sbrc	r25, 7
    5c34:	0c c0       	rjmp	.+24     	; 0x5c4e <xTaskPriorityInherit+0x42>
    5c36:	a0 91 08 2e 	lds	r26, 0x2E08	; 0x802e08 <pxCurrentTCB>
    5c3a:	b0 91 09 2e 	lds	r27, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    5c3e:	56 96       	adiw	r26, 0x16	; 22
    5c40:	3c 91       	ld	r19, X
    5c42:	8a e0       	ldi	r24, 0x0A	; 10
    5c44:	90 e0       	ldi	r25, 0x00	; 0
    5c46:	83 1b       	sub	r24, r19
    5c48:	91 09       	sbc	r25, r1
    5c4a:	84 87       	std	Z+12, r24	; 0x0c
    5c4c:	95 87       	std	Z+13, r25	; 0x0d
    5c4e:	30 e0       	ldi	r19, 0x00	; 0
    5c50:	c9 01       	movw	r24, r18
    5c52:	88 0f       	add	r24, r24
    5c54:	99 1f       	adc	r25, r25
    5c56:	88 0f       	add	r24, r24
    5c58:	99 1f       	adc	r25, r25
    5c5a:	88 0f       	add	r24, r24
    5c5c:	99 1f       	adc	r25, r25
    5c5e:	28 0f       	add	r18, r24
    5c60:	39 1f       	adc	r19, r25
    5c62:	22 55       	subi	r18, 0x52	; 82
    5c64:	32 4d       	sbci	r19, 0xD2	; 210
    5c66:	82 85       	ldd	r24, Z+10	; 0x0a
    5c68:	93 85       	ldd	r25, Z+11	; 0x0b
    5c6a:	82 17       	cp	r24, r18
    5c6c:	93 07       	cpc	r25, r19
    5c6e:	e9 f0       	breq	.+58     	; 0x5caa <xTaskPriorityInherit+0x9e>
    5c70:	a0 91 08 2e 	lds	r26, 0x2E08	; 0x802e08 <pxCurrentTCB>
    5c74:	b0 91 09 2e 	lds	r27, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    5c78:	56 96       	adiw	r26, 0x16	; 22
    5c7a:	8c 91       	ld	r24, X
    5c7c:	86 8b       	std	Z+22, r24	; 0x16
    5c7e:	81 e0       	ldi	r24, 0x01	; 1
    5c80:	df 91       	pop	r29
    5c82:	cf 91       	pop	r28
    5c84:	1f 91       	pop	r17
    5c86:	0f 91       	pop	r16
    5c88:	08 95       	ret
    5c8a:	a0 91 08 2e 	lds	r26, 0x2E08	; 0x802e08 <pxCurrentTCB>
    5c8e:	b0 91 09 2e 	lds	r27, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    5c92:	81 e0       	ldi	r24, 0x01	; 1
    5c94:	23 a1       	ldd	r18, Z+35	; 0x23
    5c96:	56 96       	adiw	r26, 0x16	; 22
    5c98:	9c 91       	ld	r25, X
    5c9a:	29 17       	cp	r18, r25
    5c9c:	88 f3       	brcs	.-30     	; 0x5c80 <xTaskPriorityInherit+0x74>
    5c9e:	80 e0       	ldi	r24, 0x00	; 0
    5ca0:	df 91       	pop	r29
    5ca2:	cf 91       	pop	r28
    5ca4:	1f 91       	pop	r17
    5ca6:	0f 91       	pop	r16
    5ca8:	08 95       	ret
    5caa:	8f 01       	movw	r16, r30
    5cac:	ef 01       	movw	r28, r30
    5cae:	22 96       	adiw	r28, 0x02	; 2
    5cb0:	ce 01       	movw	r24, r28
    5cb2:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <uxListRemove>
    5cb6:	e0 91 08 2e 	lds	r30, 0x2E08	; 0x802e08 <pxCurrentTCB>
    5cba:	f0 91 09 2e 	lds	r31, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    5cbe:	86 89       	ldd	r24, Z+22	; 0x16
    5cc0:	f8 01       	movw	r30, r16
    5cc2:	86 8b       	std	Z+22, r24	; 0x16
    5cc4:	90 91 78 2d 	lds	r25, 0x2D78	; 0x802d78 <uxTopReadyPriority>
    5cc8:	98 17       	cp	r25, r24
    5cca:	10 f4       	brcc	.+4      	; 0x5cd0 <xTaskPriorityInherit+0xc4>
    5ccc:	80 93 78 2d 	sts	0x2D78, r24	; 0x802d78 <uxTopReadyPriority>
    5cd0:	90 e0       	ldi	r25, 0x00	; 0
    5cd2:	9c 01       	movw	r18, r24
    5cd4:	22 0f       	add	r18, r18
    5cd6:	33 1f       	adc	r19, r19
    5cd8:	22 0f       	add	r18, r18
    5cda:	33 1f       	adc	r19, r19
    5cdc:	22 0f       	add	r18, r18
    5cde:	33 1f       	adc	r19, r19
    5ce0:	82 0f       	add	r24, r18
    5ce2:	93 1f       	adc	r25, r19
    5ce4:	be 01       	movw	r22, r28
    5ce6:	82 55       	subi	r24, 0x52	; 82
    5ce8:	92 4d       	sbci	r25, 0xD2	; 210
    5cea:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <vListInsertEnd>
    5cee:	81 e0       	ldi	r24, 0x01	; 1
    5cf0:	c7 cf       	rjmp	.-114    	; 0x5c80 <xTaskPriorityInherit+0x74>

00005cf2 <xTaskPriorityDisinherit>:
    5cf2:	0f 93       	push	r16
    5cf4:	1f 93       	push	r17
    5cf6:	cf 93       	push	r28
    5cf8:	df 93       	push	r29
    5cfa:	00 97       	sbiw	r24, 0x00	; 0
    5cfc:	c9 f0       	breq	.+50     	; 0x5d30 <xTaskPriorityDisinherit+0x3e>
    5cfe:	ec 01       	movw	r28, r24
    5d00:	80 91 08 2e 	lds	r24, 0x2E08	; 0x802e08 <pxCurrentTCB>
    5d04:	90 91 09 2e 	lds	r25, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    5d08:	c8 17       	cp	r28, r24
    5d0a:	d9 07       	cpc	r29, r25
    5d0c:	31 f0       	breq	.+12     	; 0x5d1a <xTaskPriorityDisinherit+0x28>
    5d0e:	6e e7       	ldi	r22, 0x7E	; 126
    5d10:	7f e0       	ldi	r23, 0x0F	; 15
    5d12:	8e ef       	ldi	r24, 0xFE	; 254
    5d14:	93 e2       	ldi	r25, 0x23	; 35
    5d16:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    5d1a:	8c a1       	ldd	r24, Y+36	; 0x24
    5d1c:	88 23       	and	r24, r24
    5d1e:	c1 f1       	breq	.+112    	; 0x5d90 <xTaskPriorityDisinherit+0x9e>
    5d20:	81 50       	subi	r24, 0x01	; 1
    5d22:	8c a3       	std	Y+36, r24	; 0x24
    5d24:	2e 89       	ldd	r18, Y+22	; 0x16
    5d26:	9b a1       	ldd	r25, Y+35	; 0x23
    5d28:	29 17       	cp	r18, r25
    5d2a:	11 f0       	breq	.+4      	; 0x5d30 <xTaskPriorityDisinherit+0x3e>
    5d2c:	88 23       	and	r24, r24
    5d2e:	31 f0       	breq	.+12     	; 0x5d3c <xTaskPriorityDisinherit+0x4a>
    5d30:	80 e0       	ldi	r24, 0x00	; 0
    5d32:	df 91       	pop	r29
    5d34:	cf 91       	pop	r28
    5d36:	1f 91       	pop	r17
    5d38:	0f 91       	pop	r16
    5d3a:	08 95       	ret
    5d3c:	8e 01       	movw	r16, r28
    5d3e:	0e 5f       	subi	r16, 0xFE	; 254
    5d40:	1f 4f       	sbci	r17, 0xFF	; 255
    5d42:	c8 01       	movw	r24, r16
    5d44:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <uxListRemove>
    5d48:	2b a1       	ldd	r18, Y+35	; 0x23
    5d4a:	2e 8b       	std	Y+22, r18	; 0x16
    5d4c:	82 2f       	mov	r24, r18
    5d4e:	90 e0       	ldi	r25, 0x00	; 0
    5d50:	4a e0       	ldi	r20, 0x0A	; 10
    5d52:	50 e0       	ldi	r21, 0x00	; 0
    5d54:	48 1b       	sub	r20, r24
    5d56:	59 0b       	sbc	r21, r25
    5d58:	4c 87       	std	Y+12, r20	; 0x0c
    5d5a:	5d 87       	std	Y+13, r21	; 0x0d
    5d5c:	30 91 78 2d 	lds	r19, 0x2D78	; 0x802d78 <uxTopReadyPriority>
    5d60:	32 17       	cp	r19, r18
    5d62:	10 f4       	brcc	.+4      	; 0x5d68 <xTaskPriorityDisinherit+0x76>
    5d64:	20 93 78 2d 	sts	0x2D78, r18	; 0x802d78 <uxTopReadyPriority>
    5d68:	9c 01       	movw	r18, r24
    5d6a:	22 0f       	add	r18, r18
    5d6c:	33 1f       	adc	r19, r19
    5d6e:	22 0f       	add	r18, r18
    5d70:	33 1f       	adc	r19, r19
    5d72:	22 0f       	add	r18, r18
    5d74:	33 1f       	adc	r19, r19
    5d76:	82 0f       	add	r24, r18
    5d78:	93 1f       	adc	r25, r19
    5d7a:	b8 01       	movw	r22, r16
    5d7c:	82 55       	subi	r24, 0x52	; 82
    5d7e:	92 4d       	sbci	r25, 0xD2	; 210
    5d80:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <vListInsertEnd>
    5d84:	81 e0       	ldi	r24, 0x01	; 1
    5d86:	df 91       	pop	r29
    5d88:	cf 91       	pop	r28
    5d8a:	1f 91       	pop	r17
    5d8c:	0f 91       	pop	r16
    5d8e:	08 95       	ret
    5d90:	6f e7       	ldi	r22, 0x7F	; 127
    5d92:	7f e0       	ldi	r23, 0x0F	; 15
    5d94:	8e ef       	ldi	r24, 0xFE	; 254
    5d96:	93 e2       	ldi	r25, 0x23	; 35
    5d98:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    5d9c:	8c a1       	ldd	r24, Y+36	; 0x24
    5d9e:	c0 cf       	rjmp	.-128    	; 0x5d20 <xTaskPriorityDisinherit+0x2e>

00005da0 <vTaskPriorityDisinheritAfterTimeout>:
    5da0:	0f 93       	push	r16
    5da2:	1f 93       	push	r17
    5da4:	cf 93       	push	r28
    5da6:	df 93       	push	r29
    5da8:	00 97       	sbiw	r24, 0x00	; 0
    5daa:	79 f0       	breq	.+30     	; 0x5dca <vTaskPriorityDisinheritAfterTimeout+0x2a>
    5dac:	16 2f       	mov	r17, r22
    5dae:	ec 01       	movw	r28, r24
    5db0:	8c a1       	ldd	r24, Y+36	; 0x24
    5db2:	88 23       	and	r24, r24
    5db4:	09 f4       	brne	.+2      	; 0x5db8 <vTaskPriorityDisinheritAfterTimeout+0x18>
    5db6:	54 c0       	rjmp	.+168    	; 0x5e60 <vTaskPriorityDisinheritAfterTimeout+0xc0>
    5db8:	0b a1       	ldd	r16, Y+35	; 0x23
    5dba:	01 17       	cp	r16, r17
    5dbc:	58 f0       	brcs	.+22     	; 0x5dd4 <vTaskPriorityDisinheritAfterTimeout+0x34>
    5dbe:	8e 89       	ldd	r24, Y+22	; 0x16
    5dc0:	80 17       	cp	r24, r16
    5dc2:	19 f0       	breq	.+6      	; 0x5dca <vTaskPriorityDisinheritAfterTimeout+0x2a>
    5dc4:	9c a1       	ldd	r25, Y+36	; 0x24
    5dc6:	91 30       	cpi	r25, 0x01	; 1
    5dc8:	39 f0       	breq	.+14     	; 0x5dd8 <vTaskPriorityDisinheritAfterTimeout+0x38>
    5dca:	df 91       	pop	r29
    5dcc:	cf 91       	pop	r28
    5dce:	1f 91       	pop	r17
    5dd0:	0f 91       	pop	r16
    5dd2:	08 95       	ret
    5dd4:	01 2f       	mov	r16, r17
    5dd6:	f3 cf       	rjmp	.-26     	; 0x5dbe <vTaskPriorityDisinheritAfterTimeout+0x1e>
    5dd8:	20 91 08 2e 	lds	r18, 0x2E08	; 0x802e08 <pxCurrentTCB>
    5ddc:	30 91 09 2e 	lds	r19, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    5de0:	c2 17       	cp	r28, r18
    5de2:	d3 07       	cpc	r29, r19
    5de4:	09 f4       	brne	.+2      	; 0x5de8 <vTaskPriorityDisinheritAfterTimeout+0x48>
    5de6:	43 c0       	rjmp	.+134    	; 0x5e6e <vTaskPriorityDisinheritAfterTimeout+0xce>
    5de8:	0e 8b       	std	Y+22, r16	; 0x16
    5dea:	2c 85       	ldd	r18, Y+12	; 0x0c
    5dec:	3d 85       	ldd	r19, Y+13	; 0x0d
    5dee:	37 fd       	sbrc	r19, 7
    5df0:	06 c0       	rjmp	.+12     	; 0x5dfe <vTaskPriorityDisinheritAfterTimeout+0x5e>
    5df2:	2a e0       	ldi	r18, 0x0A	; 10
    5df4:	30 e0       	ldi	r19, 0x00	; 0
    5df6:	20 1b       	sub	r18, r16
    5df8:	31 09       	sbc	r19, r1
    5dfa:	2c 87       	std	Y+12, r18	; 0x0c
    5dfc:	3d 87       	std	Y+13, r19	; 0x0d
    5dfe:	90 e0       	ldi	r25, 0x00	; 0
    5e00:	9c 01       	movw	r18, r24
    5e02:	22 0f       	add	r18, r18
    5e04:	33 1f       	adc	r19, r19
    5e06:	22 0f       	add	r18, r18
    5e08:	33 1f       	adc	r19, r19
    5e0a:	22 0f       	add	r18, r18
    5e0c:	33 1f       	adc	r19, r19
    5e0e:	82 0f       	add	r24, r18
    5e10:	93 1f       	adc	r25, r19
    5e12:	82 55       	subi	r24, 0x52	; 82
    5e14:	92 4d       	sbci	r25, 0xD2	; 210
    5e16:	2a 85       	ldd	r18, Y+10	; 0x0a
    5e18:	3b 85       	ldd	r19, Y+11	; 0x0b
    5e1a:	28 17       	cp	r18, r24
    5e1c:	39 07       	cpc	r19, r25
    5e1e:	a9 f6       	brne	.-86     	; 0x5dca <vTaskPriorityDisinheritAfterTimeout+0x2a>
    5e20:	8e 01       	movw	r16, r28
    5e22:	0e 5f       	subi	r16, 0xFE	; 254
    5e24:	1f 4f       	sbci	r17, 0xFF	; 255
    5e26:	c8 01       	movw	r24, r16
    5e28:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <uxListRemove>
    5e2c:	8e 89       	ldd	r24, Y+22	; 0x16
    5e2e:	90 91 78 2d 	lds	r25, 0x2D78	; 0x802d78 <uxTopReadyPriority>
    5e32:	98 17       	cp	r25, r24
    5e34:	10 f4       	brcc	.+4      	; 0x5e3a <vTaskPriorityDisinheritAfterTimeout+0x9a>
    5e36:	80 93 78 2d 	sts	0x2D78, r24	; 0x802d78 <uxTopReadyPriority>
    5e3a:	90 e0       	ldi	r25, 0x00	; 0
    5e3c:	9c 01       	movw	r18, r24
    5e3e:	22 0f       	add	r18, r18
    5e40:	33 1f       	adc	r19, r19
    5e42:	22 0f       	add	r18, r18
    5e44:	33 1f       	adc	r19, r19
    5e46:	22 0f       	add	r18, r18
    5e48:	33 1f       	adc	r19, r19
    5e4a:	82 0f       	add	r24, r18
    5e4c:	93 1f       	adc	r25, r19
    5e4e:	b8 01       	movw	r22, r16
    5e50:	82 55       	subi	r24, 0x52	; 82
    5e52:	92 4d       	sbci	r25, 0xD2	; 210
    5e54:	df 91       	pop	r29
    5e56:	cf 91       	pop	r28
    5e58:	1f 91       	pop	r17
    5e5a:	0f 91       	pop	r16
    5e5c:	0c 94 26 1d 	jmp	0x3a4c	; 0x3a4c <vListInsertEnd>
    5e60:	6d ec       	ldi	r22, 0xCD	; 205
    5e62:	7f e0       	ldi	r23, 0x0F	; 15
    5e64:	8e ef       	ldi	r24, 0xFE	; 254
    5e66:	93 e2       	ldi	r25, 0x23	; 35
    5e68:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    5e6c:	a5 cf       	rjmp	.-182    	; 0x5db8 <vTaskPriorityDisinheritAfterTimeout+0x18>
    5e6e:	68 ee       	ldi	r22, 0xE8	; 232
    5e70:	7f e0       	ldi	r23, 0x0F	; 15
    5e72:	8e ef       	ldi	r24, 0xFE	; 254
    5e74:	93 e2       	ldi	r25, 0x23	; 35
    5e76:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    5e7a:	8e 89       	ldd	r24, Y+22	; 0x16
    5e7c:	b5 cf       	rjmp	.-150    	; 0x5de8 <vTaskPriorityDisinheritAfterTimeout+0x48>

00005e7e <vTaskGetRunTimeStats>:
    5e7e:	2f 92       	push	r2
    5e80:	3f 92       	push	r3
    5e82:	4f 92       	push	r4
    5e84:	5f 92       	push	r5
    5e86:	6f 92       	push	r6
    5e88:	7f 92       	push	r7
    5e8a:	8f 92       	push	r8
    5e8c:	9f 92       	push	r9
    5e8e:	af 92       	push	r10
    5e90:	bf 92       	push	r11
    5e92:	cf 92       	push	r12
    5e94:	df 92       	push	r13
    5e96:	ef 92       	push	r14
    5e98:	ff 92       	push	r15
    5e9a:	0f 93       	push	r16
    5e9c:	1f 93       	push	r17
    5e9e:	cf 93       	push	r28
    5ea0:	df 93       	push	r29
    5ea2:	00 d0       	rcall	.+0      	; 0x5ea4 <vTaskGetRunTimeStats+0x26>
    5ea4:	1f 92       	push	r1
    5ea6:	cd b7       	in	r28, 0x3d	; 61
    5ea8:	de b7       	in	r29, 0x3e	; 62
    5eaa:	8c 01       	movw	r16, r24
    5eac:	fc 01       	movw	r30, r24
    5eae:	10 82       	st	Z, r1
    5eb0:	f0 90 7b 2d 	lds	r15, 0x2D7B	; 0x802d7b <uxCurrentNumberOfTasks>
    5eb4:	80 91 7b 2d 	lds	r24, 0x2D7B	; 0x802d7b <uxCurrentNumberOfTasks>
    5eb8:	f0 e1       	ldi	r31, 0x10	; 16
    5eba:	8f 9f       	mul	r24, r31
    5ebc:	c0 01       	movw	r24, r0
    5ebe:	11 24       	eor	r1, r1
    5ec0:	0e 94 45 1c 	call	0x388a	; 0x388a <pvPortMalloc>
    5ec4:	5c 01       	movw	r10, r24
    5ec6:	00 97       	sbiw	r24, 0x00	; 0
    5ec8:	09 f4       	brne	.+2      	; 0x5ecc <vTaskGetRunTimeStats+0x4e>
    5eca:	79 c0       	rjmp	.+242    	; 0x5fbe <vTaskGetRunTimeStats+0x140>
    5ecc:	ae 01       	movw	r20, r28
    5ece:	4f 5f       	subi	r20, 0xFF	; 255
    5ed0:	5f 4f       	sbci	r21, 0xFF	; 255
    5ed2:	6f 2d       	mov	r22, r15
    5ed4:	0e 94 4c 2d 	call	0x5a98	; 0x5a98 <uxTaskGetSystemState>
    5ed8:	88 2e       	mov	r8, r24
    5eda:	69 81       	ldd	r22, Y+1	; 0x01
    5edc:	7a 81       	ldd	r23, Y+2	; 0x02
    5ede:	8b 81       	ldd	r24, Y+3	; 0x03
    5ee0:	9c 81       	ldd	r25, Y+4	; 0x04
    5ee2:	24 e6       	ldi	r18, 0x64	; 100
    5ee4:	30 e0       	ldi	r19, 0x00	; 0
    5ee6:	40 e0       	ldi	r20, 0x00	; 0
    5ee8:	50 e0       	ldi	r21, 0x00	; 0
    5eea:	0e 94 b0 4b 	call	0x9760	; 0x9760 <__udivmodsi4>
    5eee:	29 83       	std	Y+1, r18	; 0x01
    5ef0:	3a 83       	std	Y+2, r19	; 0x02
    5ef2:	4b 83       	std	Y+3, r20	; 0x03
    5ef4:	5c 83       	std	Y+4, r21	; 0x04
    5ef6:	21 15       	cp	r18, r1
    5ef8:	31 05       	cpc	r19, r1
    5efa:	41 05       	cpc	r20, r1
    5efc:	51 05       	cpc	r21, r1
    5efe:	09 f4       	brne	.+2      	; 0x5f02 <vTaskGetRunTimeStats+0x84>
    5f00:	5b c0       	rjmp	.+182    	; 0x5fb8 <vTaskGetRunTimeStats+0x13a>
    5f02:	88 20       	and	r8, r8
    5f04:	09 f4       	brne	.+2      	; 0x5f08 <vTaskGetRunTimeStats+0x8a>
    5f06:	58 c0       	rjmp	.+176    	; 0x5fb8 <vTaskGetRunTimeStats+0x13a>
    5f08:	75 01       	movw	r14, r10
    5f0a:	91 2c       	mov	r9, r1
    5f0c:	84 e3       	ldi	r24, 0x34	; 52
    5f0e:	c8 2e       	mov	r12, r24
    5f10:	84 e2       	ldi	r24, 0x24	; 36
    5f12:	d8 2e       	mov	r13, r24
    5f14:	96 e2       	ldi	r25, 0x26	; 38
    5f16:	29 2e       	mov	r2, r25
    5f18:	94 e2       	ldi	r25, 0x24	; 36
    5f1a:	39 2e       	mov	r3, r25
    5f1c:	26 c0       	rjmp	.+76     	; 0x5f6a <vTaskGetRunTimeStats+0xec>
    5f1e:	7f 92       	push	r7
    5f20:	6f 92       	push	r6
    5f22:	5f 92       	push	r5
    5f24:	4f 92       	push	r4
    5f26:	f7 01       	movw	r30, r14
    5f28:	83 85       	ldd	r24, Z+11	; 0x0b
    5f2a:	8f 93       	push	r24
    5f2c:	82 85       	ldd	r24, Z+10	; 0x0a
    5f2e:	8f 93       	push	r24
    5f30:	81 85       	ldd	r24, Z+9	; 0x09
    5f32:	8f 93       	push	r24
    5f34:	80 85       	ldd	r24, Z+8	; 0x08
    5f36:	8f 93       	push	r24
    5f38:	3f 92       	push	r3
    5f3a:	2f 92       	push	r2
    5f3c:	1f 93       	push	r17
    5f3e:	0f 93       	push	r16
    5f40:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
    5f44:	cd bf       	out	0x3d, r28	; 61
    5f46:	de bf       	out	0x3e, r29	; 62
    5f48:	f8 01       	movw	r30, r16
    5f4a:	01 90       	ld	r0, Z+
    5f4c:	00 20       	and	r0, r0
    5f4e:	e9 f7       	brne	.-6      	; 0x5f4a <vTaskGetRunTimeStats+0xcc>
    5f50:	8f 01       	movw	r16, r30
    5f52:	01 50       	subi	r16, 0x01	; 1
    5f54:	11 09       	sbc	r17, r1
    5f56:	93 94       	inc	r9
    5f58:	90 e1       	ldi	r25, 0x10	; 16
    5f5a:	e9 0e       	add	r14, r25
    5f5c:	f1 1c       	adc	r15, r1
    5f5e:	89 14       	cp	r8, r9
    5f60:	59 f1       	breq	.+86     	; 0x5fb8 <vTaskGetRunTimeStats+0x13a>
    5f62:	29 81       	ldd	r18, Y+1	; 0x01
    5f64:	3a 81       	ldd	r19, Y+2	; 0x02
    5f66:	4b 81       	ldd	r20, Y+3	; 0x03
    5f68:	5c 81       	ldd	r21, Y+4	; 0x04
    5f6a:	f7 01       	movw	r30, r14
    5f6c:	60 85       	ldd	r22, Z+8	; 0x08
    5f6e:	71 85       	ldd	r23, Z+9	; 0x09
    5f70:	82 85       	ldd	r24, Z+10	; 0x0a
    5f72:	93 85       	ldd	r25, Z+11	; 0x0b
    5f74:	0e 94 b0 4b 	call	0x9760	; 0x9760 <__udivmodsi4>
    5f78:	29 01       	movw	r4, r18
    5f7a:	3a 01       	movw	r6, r20
    5f7c:	f7 01       	movw	r30, r14
    5f7e:	62 81       	ldd	r22, Z+2	; 0x02
    5f80:	73 81       	ldd	r23, Z+3	; 0x03
    5f82:	c8 01       	movw	r24, r16
    5f84:	0e 94 88 25 	call	0x4b10	; 0x4b10 <prvWriteNameToBuffer>
    5f88:	8c 01       	movw	r16, r24
    5f8a:	41 14       	cp	r4, r1
    5f8c:	51 04       	cpc	r5, r1
    5f8e:	61 04       	cpc	r6, r1
    5f90:	71 04       	cpc	r7, r1
    5f92:	29 f6       	brne	.-118    	; 0x5f1e <vTaskGetRunTimeStats+0xa0>
    5f94:	f7 01       	movw	r30, r14
    5f96:	83 85       	ldd	r24, Z+11	; 0x0b
    5f98:	8f 93       	push	r24
    5f9a:	82 85       	ldd	r24, Z+10	; 0x0a
    5f9c:	8f 93       	push	r24
    5f9e:	81 85       	ldd	r24, Z+9	; 0x09
    5fa0:	8f 93       	push	r24
    5fa2:	80 85       	ldd	r24, Z+8	; 0x08
    5fa4:	8f 93       	push	r24
    5fa6:	df 92       	push	r13
    5fa8:	cf 92       	push	r12
    5faa:	1f 93       	push	r17
    5fac:	0f 93       	push	r16
    5fae:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
    5fb2:	cd bf       	out	0x3d, r28	; 61
    5fb4:	de bf       	out	0x3e, r29	; 62
    5fb6:	c8 cf       	rjmp	.-112    	; 0x5f48 <vTaskGetRunTimeStats+0xca>
    5fb8:	c5 01       	movw	r24, r10
    5fba:	0e 94 e4 1c 	call	0x39c8	; 0x39c8 <vPortFree>
    5fbe:	24 96       	adiw	r28, 0x04	; 4
    5fc0:	cd bf       	out	0x3d, r28	; 61
    5fc2:	de bf       	out	0x3e, r29	; 62
    5fc4:	df 91       	pop	r29
    5fc6:	cf 91       	pop	r28
    5fc8:	1f 91       	pop	r17
    5fca:	0f 91       	pop	r16
    5fcc:	ff 90       	pop	r15
    5fce:	ef 90       	pop	r14
    5fd0:	df 90       	pop	r13
    5fd2:	cf 90       	pop	r12
    5fd4:	bf 90       	pop	r11
    5fd6:	af 90       	pop	r10
    5fd8:	9f 90       	pop	r9
    5fda:	8f 90       	pop	r8
    5fdc:	7f 90       	pop	r7
    5fde:	6f 90       	pop	r6
    5fe0:	5f 90       	pop	r5
    5fe2:	4f 90       	pop	r4
    5fe4:	3f 90       	pop	r3
    5fe6:	2f 90       	pop	r2
    5fe8:	08 95       	ret

00005fea <pvTaskIncrementMutexHeldCount>:
    5fea:	80 91 08 2e 	lds	r24, 0x2E08	; 0x802e08 <pxCurrentTCB>
    5fee:	90 91 09 2e 	lds	r25, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    5ff2:	89 2b       	or	r24, r25
    5ff4:	39 f0       	breq	.+14     	; 0x6004 <pvTaskIncrementMutexHeldCount+0x1a>
    5ff6:	e0 91 08 2e 	lds	r30, 0x2E08	; 0x802e08 <pxCurrentTCB>
    5ffa:	f0 91 09 2e 	lds	r31, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    5ffe:	84 a1       	ldd	r24, Z+36	; 0x24
    6000:	8f 5f       	subi	r24, 0xFF	; 255
    6002:	84 a3       	std	Z+36, r24	; 0x24
    6004:	80 91 08 2e 	lds	r24, 0x2E08	; 0x802e08 <pxCurrentTCB>
    6008:	90 91 09 2e 	lds	r25, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    600c:	08 95       	ret

0000600e <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    600e:	ef 92       	push	r14
    6010:	ff 92       	push	r15
    6012:	0f 93       	push	r16
    6014:	1f 93       	push	r17
    6016:	cf 93       	push	r28
    6018:	df 93       	push	r29
    601a:	ec 01       	movw	r28, r24
    601c:	8b 01       	movw	r16, r22
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
    601e:	89 2b       	or	r24, r25
    6020:	09 f4       	brne	.+2      	; 0x6024 <vTaskNotifyGiveFromISR+0x16>
    6022:	62 c0       	rjmp	.+196    	; 0x60e8 <vTaskNotifyGiveFromISR+0xda>

		pxTCB = xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    6024:	2f a5       	ldd	r18, Y+47	; 0x2f
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    6026:	82 e0       	ldi	r24, 0x02	; 2
    6028:	8f a7       	std	Y+47, r24	; 0x2f

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    602a:	8b a5       	ldd	r24, Y+43	; 0x2b
    602c:	9c a5       	ldd	r25, Y+44	; 0x2c
    602e:	ad a5       	ldd	r26, Y+45	; 0x2d
    6030:	be a5       	ldd	r27, Y+46	; 0x2e
    6032:	01 96       	adiw	r24, 0x01	; 1
    6034:	a1 1d       	adc	r26, r1
    6036:	b1 1d       	adc	r27, r1
    6038:	8b a7       	std	Y+43, r24	; 0x2b
    603a:	9c a7       	std	Y+44, r25	; 0x2c
    603c:	ad a7       	std	Y+45, r26	; 0x2d
    603e:	be a7       	std	Y+46, r27	; 0x2e

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    6040:	21 30       	cpi	r18, 0x01	; 1
    6042:	39 f0       	breq	.+14     	; 0x6052 <vTaskNotifyGiveFromISR+0x44>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    6044:	df 91       	pop	r29
    6046:	cf 91       	pop	r28
    6048:	1f 91       	pop	r17
    604a:	0f 91       	pop	r16
    604c:	ff 90       	pop	r15
    604e:	ef 90       	pop	r14
    6050:	08 95       	ret
			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
    6052:	8c 89       	ldd	r24, Y+20	; 0x14
    6054:	9d 89       	ldd	r25, Y+21	; 0x15
    6056:	89 2b       	or	r24, r25
    6058:	31 f0       	breq	.+12     	; 0x6066 <vTaskNotifyGiveFromISR+0x58>
    605a:	66 e3       	ldi	r22, 0x36	; 54
    605c:	73 e1       	ldi	r23, 0x13	; 19
    605e:	8e ef       	ldi	r24, 0xFE	; 254
    6060:	93 e2       	ldi	r25, 0x23	; 35
    6062:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6066:	80 91 6e 2d 	lds	r24, 0x2D6E	; 0x802d6e <uxSchedulerSuspended>
    606a:	88 23       	and	r24, r24
    606c:	f9 f0       	breq	.+62     	; 0x60ac <vTaskNotifyGiveFromISR+0x9e>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    606e:	be 01       	movw	r22, r28
    6070:	64 5f       	subi	r22, 0xF4	; 244
    6072:	7f 4f       	sbci	r23, 0xFF	; 255
    6074:	8f e8       	ldi	r24, 0x8F	; 143
    6076:	9d e2       	ldi	r25, 0x2D	; 45
    6078:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    607c:	e0 91 08 2e 	lds	r30, 0x2E08	; 0x802e08 <pxCurrentTCB>
    6080:	f0 91 09 2e 	lds	r31, 0x2E09	; 0x802e09 <pxCurrentTCB+0x1>
    6084:	9e 89       	ldd	r25, Y+22	; 0x16
    6086:	86 89       	ldd	r24, Z+22	; 0x16
    6088:	89 17       	cp	r24, r25
    608a:	e0 f6       	brcc	.-72     	; 0x6044 <vTaskNotifyGiveFromISR+0x36>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    608c:	01 15       	cp	r16, r1
    608e:	11 05       	cpc	r17, r1
    6090:	19 f0       	breq	.+6      	; 0x6098 <vTaskNotifyGiveFromISR+0x8a>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    6092:	81 e0       	ldi	r24, 0x01	; 1
    6094:	f8 01       	movw	r30, r16
    6096:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    6098:	81 e0       	ldi	r24, 0x01	; 1
    609a:	80 93 75 2d 	sts	0x2D75, r24	; 0x802d75 <xYieldPending>
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    609e:	df 91       	pop	r29
    60a0:	cf 91       	pop	r28
    60a2:	1f 91       	pop	r17
    60a4:	0f 91       	pop	r16
    60a6:	ff 90       	pop	r15
    60a8:	ef 90       	pop	r14
    60aa:	08 95       	ret
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    60ac:	7e 01       	movw	r14, r28
    60ae:	82 e0       	ldi	r24, 0x02	; 2
    60b0:	e8 0e       	add	r14, r24
    60b2:	f1 1c       	adc	r15, r1
    60b4:	c7 01       	movw	r24, r14
    60b6:	0e 94 78 1d 	call	0x3af0	; 0x3af0 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    60ba:	8e 89       	ldd	r24, Y+22	; 0x16
    60bc:	90 91 78 2d 	lds	r25, 0x2D78	; 0x802d78 <uxTopReadyPriority>
    60c0:	98 17       	cp	r25, r24
    60c2:	10 f4       	brcc	.+4      	; 0x60c8 <vTaskNotifyGiveFromISR+0xba>
    60c4:	80 93 78 2d 	sts	0x2D78, r24	; 0x802d78 <uxTopReadyPriority>
    60c8:	90 e0       	ldi	r25, 0x00	; 0
    60ca:	9c 01       	movw	r18, r24
    60cc:	22 0f       	add	r18, r18
    60ce:	33 1f       	adc	r19, r19
    60d0:	22 0f       	add	r18, r18
    60d2:	33 1f       	adc	r19, r19
    60d4:	22 0f       	add	r18, r18
    60d6:	33 1f       	adc	r19, r19
    60d8:	82 0f       	add	r24, r18
    60da:	93 1f       	adc	r25, r19
    60dc:	b7 01       	movw	r22, r14
    60de:	82 55       	subi	r24, 0x52	; 82
    60e0:	92 4d       	sbci	r25, 0xD2	; 210
    60e2:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <vListInsertEnd>
    60e6:	ca cf       	rjmp	.-108    	; 0x607c <vTaskNotifyGiveFromISR+0x6e>
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
    60e8:	60 e1       	ldi	r22, 0x10	; 16
    60ea:	73 e1       	ldi	r23, 0x13	; 19
    60ec:	8e ef       	ldi	r24, 0xFE	; 254
    60ee:	93 e2       	ldi	r25, 0x23	; 35
    60f0:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    60f4:	97 cf       	rjmp	.-210    	; 0x6024 <vTaskNotifyGiveFromISR+0x16>

000060f6 <vApplicationIdleHook>:
#define SET_ERR_LED() PORTA.OUTSET=1<<7
#define CLR_ERR_LED() PORTA.OUTCLR=1<<7


void vApplicationIdleHook( void )
{
    60f6:	08 95       	ret

000060f8 <vApplicationMallocFailedHook>:
	
}

void vApplicationMallocFailedHook(void)
{
	taskDISABLE_INTERRUPTS();
    60f8:	f8 94       	cli
	DbgPrint ("ERROR: memory allocation failed\r\n");
    60fa:	81 e4       	ldi	r24, 0x41	; 65
    60fc:	94 e2       	ldi	r25, 0x24	; 36
    60fe:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <DbgPrint>
	CFG_ERR_LED();
    6102:	80 e8       	ldi	r24, 0x80	; 128
    6104:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	while (1)
	{
		SET_ERR_LED();
    6108:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    610c:	2f ef       	ldi	r18, 0xFF	; 255
    610e:	33 ec       	ldi	r19, 0xC3	; 195
    6110:	99 e0       	ldi	r25, 0x09	; 9
    6112:	21 50       	subi	r18, 0x01	; 1
    6114:	30 40       	sbci	r19, 0x00	; 0
    6116:	90 40       	sbci	r25, 0x00	; 0
    6118:	e1 f7       	brne	.-8      	; 0x6112 <vApplicationMallocFailedHook+0x1a>
    611a:	00 c0       	rjmp	.+0      	; 0x611c <vApplicationMallocFailedHook+0x24>
    611c:	00 00       	nop
		_delay_ms(100);
		CLR_ERR_LED();
    611e:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    6122:	2f ef       	ldi	r18, 0xFF	; 255
    6124:	33 ec       	ldi	r19, 0xC3	; 195
    6126:	99 e0       	ldi	r25, 0x09	; 9
    6128:	21 50       	subi	r18, 0x01	; 1
    612a:	30 40       	sbci	r19, 0x00	; 0
    612c:	90 40       	sbci	r25, 0x00	; 0
    612e:	e1 f7       	brne	.-8      	; 0x6128 <vApplicationMallocFailedHook+0x30>
    6130:	00 c0       	rjmp	.+0      	; 0x6132 <vApplicationMallocFailedHook+0x3a>
    6132:	00 00       	nop
    6134:	e9 cf       	rjmp	.-46     	; 0x6108 <vApplicationMallocFailedHook+0x10>

00006136 <vApplicationStackOverflowHook>:
}



void vApplicationStackOverflowHook( TaskHandle_t xTask,signed char *pcTaskName )
{
    6136:	eb 01       	movw	r28, r22
	taskDISABLE_INTERRUPTS();
    6138:	f8 94       	cli
	CFG_ERR_LED();
    613a:	80 e8       	ldi	r24, 0x80	; 128
    613c:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	DbgPrint("STACK overflow in task ");
    6140:	83 e6       	ldi	r24, 0x63	; 99
    6142:	94 e2       	ldi	r25, 0x24	; 36
    6144:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <DbgPrint>
	DbgPrintn(pcTaskName,10);
    6148:	6a e0       	ldi	r22, 0x0A	; 10
    614a:	70 e0       	ldi	r23, 0x00	; 0
    614c:	ce 01       	movw	r24, r28
    614e:	0e 94 03 06 	call	0xc06	; 0xc06 <DbgPrintn>
	DbgPrint("\r\n");
    6152:	8e e3       	ldi	r24, 0x3E	; 62
    6154:	94 e2       	ldi	r25, 0x24	; 36
    6156:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <DbgPrint>
	while (1)
	{
		SET_ERR_LED();
    615a:	80 e8       	ldi	r24, 0x80	; 128
    615c:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
    6160:	2f ef       	ldi	r18, 0xFF	; 255
    6162:	33 ed       	ldi	r19, 0xD3	; 211
    6164:	90 e3       	ldi	r25, 0x30	; 48
    6166:	21 50       	subi	r18, 0x01	; 1
    6168:	30 40       	sbci	r19, 0x00	; 0
    616a:	90 40       	sbci	r25, 0x00	; 0
    616c:	e1 f7       	brne	.-8      	; 0x6166 <vApplicationStackOverflowHook+0x30>
    616e:	00 c0       	rjmp	.+0      	; 0x6170 <vApplicationStackOverflowHook+0x3a>
    6170:	00 00       	nop
		_delay_ms(500);
		CLR_ERR_LED();
    6172:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    6176:	2f ef       	ldi	r18, 0xFF	; 255
    6178:	33 ed       	ldi	r19, 0xD3	; 211
    617a:	90 e3       	ldi	r25, 0x30	; 48
    617c:	21 50       	subi	r18, 0x01	; 1
    617e:	30 40       	sbci	r19, 0x00	; 0
    6180:	90 40       	sbci	r25, 0x00	; 0
    6182:	e1 f7       	brne	.-8      	; 0x617c <vApplicationStackOverflowHook+0x46>
    6184:	00 c0       	rjmp	.+0      	; 0x6186 <vApplicationStackOverflowHook+0x50>
    6186:	00 00       	nop
    6188:	e9 cf       	rjmp	.-46     	; 0x615c <vApplicationStackOverflowHook+0x26>

0000618a <vAssertCalled>:
		_delay_ms(500);
	}
}

void vAssertCalled( char *File, int Line)
{
    618a:	8c 01       	movw	r16, r24
    618c:	eb 01       	movw	r28, r22
	taskDISABLE_INTERRUPTS();	
    618e:	f8 94       	cli
	CFG_ERR_LED();
    6190:	80 e8       	ldi	r24, 0x80	; 128
    6192:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	DbgPrint("Assert in file ");
    6196:	8b e7       	ldi	r24, 0x7B	; 123
    6198:	94 e2       	ldi	r25, 0x24	; 36
    619a:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <DbgPrint>
	DbgPrintn(File,100);
    619e:	64 e6       	ldi	r22, 0x64	; 100
    61a0:	70 e0       	ldi	r23, 0x00	; 0
    61a2:	c8 01       	movw	r24, r16
    61a4:	0e 94 03 06 	call	0xc06	; 0xc06 <DbgPrintn>
	DbgPrint(", line nr ");
    61a8:	8b e8       	ldi	r24, 0x8B	; 139
    61aa:	94 e2       	ldi	r25, 0x24	; 36
    61ac:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <DbgPrint>
	DbgPrintInt(Line);
    61b0:	ce 01       	movw	r24, r28
    61b2:	0e 94 28 06 	call	0xc50	; 0xc50 <DbgPrintInt>
	DbgPrint("\r\n");
    61b6:	8e e3       	ldi	r24, 0x3E	; 62
    61b8:	94 e2       	ldi	r25, 0x24	; 36
    61ba:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <DbgPrint>

	while (1)
	{
		SET_ERR_LED();
    61be:	80 e8       	ldi	r24, 0x80	; 128
    61c0:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
    61c4:	2f ef       	ldi	r18, 0xFF	; 255
    61c6:	33 ec       	ldi	r19, 0xC3	; 195
    61c8:	99 e0       	ldi	r25, 0x09	; 9
    61ca:	21 50       	subi	r18, 0x01	; 1
    61cc:	30 40       	sbci	r19, 0x00	; 0
    61ce:	90 40       	sbci	r25, 0x00	; 0
    61d0:	e1 f7       	brne	.-8      	; 0x61ca <vAssertCalled+0x40>
    61d2:	00 c0       	rjmp	.+0      	; 0x61d4 <vAssertCalled+0x4a>
    61d4:	00 00       	nop
		_delay_ms(100);
		CLR_ERR_LED();
    61d6:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    61da:	2f ef       	ldi	r18, 0xFF	; 255
    61dc:	33 ed       	ldi	r19, 0xD3	; 211
    61de:	90 e3       	ldi	r25, 0x30	; 48
    61e0:	21 50       	subi	r18, 0x01	; 1
    61e2:	30 40       	sbci	r19, 0x00	; 0
    61e4:	90 40       	sbci	r25, 0x00	; 0
    61e6:	e1 f7       	brne	.-8      	; 0x61e0 <vAssertCalled+0x56>
    61e8:	00 c0       	rjmp	.+0      	; 0x61ea <vAssertCalled+0x60>
    61ea:	00 00       	nop
    61ec:	e9 cf       	rjmp	.-46     	; 0x61c0 <vAssertCalled+0x36>

000061ee <main>:

uint8_t *ucHeap;

int main(void)
{
	DriverSysClkXtalInit();	//Clock init
    61ee:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <DriverSysClkXtalInit>
	//Allocate FreeRTOS heap
	ucHeap=malloc(configTOTAL_HEAP_SIZE);
    61f2:	80 e0       	ldi	r24, 0x00	; 0
    61f4:	90 e4       	ldi	r25, 0x40	; 64
    61f6:	0e 94 f4 4b 	call	0x97e8	; 0x97e8 <malloc>
    61fa:	80 93 72 2e 	sts	0x2E72, r24	; 0x802e72 <ucHeap>
    61fe:	90 93 73 2e 	sts	0x2E73, r25	; 0x802e73 <ucHeap+0x1>
	if (ucHeap==NULL) while(1);
    6202:	89 2b       	or	r24, r25
    6204:	59 f0       	breq	.+22     	; 0x621c <main+0x2e>
	
	//Enable interrupts
	PMIC.CTRL=0b111;		
    6206:	87 e0       	ldi	r24, 0x07	; 7
    6208:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    620c:	78 94       	sei
	
	//Init startup task
	InitStartupTask();
    620e:	0e 94 19 43 	call	0x8632	; 0x8632 <InitStartupTask>
	
	//Start scheduler loop
	vTaskStartScheduler();	
    6212:	0e 94 48 29 	call	0x5290	; 0x5290 <vTaskStartScheduler>

	return 0;
}
    6216:	80 e0       	ldi	r24, 0x00	; 0
    6218:	90 e0       	ldi	r25, 0x00	; 0
    621a:	08 95       	ret
    621c:	ff cf       	rjmp	.-2      	; 0x621c <main+0x2e>

0000621e <cmpfunc>:
int cmpfunc (const void * a, const void * b) {
	TaskStatus_t *TaskA, *TaskB;
	TaskA=(TaskStatus_t *) a;
	TaskB=(TaskStatus_t *) b;
	
	if (TaskA->pxStackBase<TaskB->pxStackBase) return -1;
    621e:	fc 01       	movw	r30, r24
    6220:	44 85       	ldd	r20, Z+12	; 0x0c
    6222:	55 85       	ldd	r21, Z+13	; 0x0d
    6224:	fb 01       	movw	r30, r22
    6226:	24 85       	ldd	r18, Z+12	; 0x0c
    6228:	35 85       	ldd	r19, Z+13	; 0x0d
    622a:	42 17       	cp	r20, r18
    622c:	53 07       	cpc	r21, r19
    622e:	40 f0       	brcs	.+16     	; 0x6240 <cmpfunc+0x22>
    6230:	81 e0       	ldi	r24, 0x01	; 1
    6232:	90 e0       	ldi	r25, 0x00	; 0
    6234:	24 17       	cp	r18, r20
    6236:	35 07       	cpc	r19, r21
    6238:	08 f4       	brcc	.+2      	; 0x623c <cmpfunc+0x1e>
	else if (TaskA->pxStackBase>TaskB->pxStackBase) return 1;
	else return 0;
	
}
    623a:	08 95       	ret
int cmpfunc (const void * a, const void * b) {
	TaskStatus_t *TaskA, *TaskB;
	TaskA=(TaskStatus_t *) a;
	TaskB=(TaskStatus_t *) b;
	
	if (TaskA->pxStackBase<TaskB->pxStackBase) return -1;
    623c:	80 e0       	ldi	r24, 0x00	; 0
    623e:	08 95       	ret
    6240:	8f ef       	ldi	r24, 0xFF	; 255
    6242:	9f ef       	ldi	r25, 0xFF	; 255
	else if (TaskA->pxStackBase>TaskB->pxStackBase) return 1;
	else return 0;
	
}
    6244:	08 95       	ret

00006246 <MemMap>:

void MemMap()
{
    6246:	5f 92       	push	r5
    6248:	6f 92       	push	r6
    624a:	7f 92       	push	r7
    624c:	8f 92       	push	r8
    624e:	9f 92       	push	r9
    6250:	af 92       	push	r10
    6252:	bf 92       	push	r11
    6254:	cf 92       	push	r12
    6256:	df 92       	push	r13
    6258:	ef 92       	push	r14
    625a:	ff 92       	push	r15
    625c:	0f 93       	push	r16
    625e:	1f 93       	push	r17
    6260:	cf 93       	push	r28
    6262:	df 93       	push	r29
    6264:	cd b7       	in	r28, 0x3d	; 61
    6266:	de b7       	in	r29, 0x3e	; 62
    6268:	c0 54       	subi	r28, 0x40	; 64
    626a:	d1 40       	sbci	r29, 0x01	; 1
    626c:	cd bf       	out	0x3d, r28	; 61
    626e:	de bf       	out	0x3e, r29	; 62
	uint8_t a;
	TaskStatus_t TaskStatusArray[MAX_TASKS];
	int TCBSize;
	
	
	NumTasks=uxTaskGetSystemState(TaskStatusArray,MAX_TASKS,NULL);
    6270:	40 e0       	ldi	r20, 0x00	; 0
    6272:	50 e0       	ldi	r21, 0x00	; 0
    6274:	64 e1       	ldi	r22, 0x14	; 20
    6276:	ce 01       	movw	r24, r28
    6278:	01 96       	adiw	r24, 0x01	; 1
    627a:	0e 94 4c 2d 	call	0x5a98	; 0x5a98 <uxTaskGetSystemState>
    627e:	88 2e       	mov	r8, r24
    6280:	91 2c       	mov	r9, r1
	qsort(TaskStatusArray, NumTasks, sizeof(TaskStatus_t), cmpfunc);
    6282:	2f e0       	ldi	r18, 0x0F	; 15
    6284:	31 e3       	ldi	r19, 0x31	; 49
    6286:	40 e1       	ldi	r20, 0x10	; 16
    6288:	50 e0       	ldi	r21, 0x00	; 0
    628a:	b4 01       	movw	r22, r8
    628c:	ce 01       	movw	r24, r28
    628e:	01 96       	adiw	r24, 0x01	; 1
    6290:	0e 94 5c 4d 	call	0x9ab8	; 0x9ab8 <qsort>
	
	printf("MEMORY MAP:\r\n");
    6294:	86 e9       	ldi	r24, 0x96	; 150
    6296:	94 e2       	ldi	r25, 0x24	; 36
    6298:	0e 94 1b 51 	call	0xa236	; 0xa236 <puts>
	printf("-----------\r\n");
    629c:	83 ea       	ldi	r24, 0xA3	; 163
    629e:	94 e2       	ldi	r25, 0x24	; 36
    62a0:	0e 94 1b 51 	call	0xa236	; 0xa236 <puts>
	printf("IO registers start:\t\t\t0x%04x\r\n",MEM_IO_REGS_START);
    62a4:	1f 92       	push	r1
    62a6:	1f 92       	push	r1
    62a8:	1f 92       	push	r1
    62aa:	1f 92       	push	r1
    62ac:	80 eb       	ldi	r24, 0xB0	; 176
    62ae:	94 e2       	ldi	r25, 0x24	; 36
    62b0:	9f 93       	push	r25
    62b2:	8f 93       	push	r24
    62b4:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
	printf("IO registers end:\t\t\t0x%04x\r\n",MEM_IO_REGS_STOP);
    62b8:	1f 92       	push	r1
    62ba:	1f 92       	push	r1
    62bc:	8f e0       	ldi	r24, 0x0F	; 15
    62be:	8f 93       	push	r24
    62c0:	1f ef       	ldi	r17, 0xFF	; 255
    62c2:	1f 93       	push	r17
    62c4:	8f ec       	ldi	r24, 0xCF	; 207
    62c6:	94 e2       	ldi	r25, 0x24	; 36
    62c8:	9f 93       	push	r25
    62ca:	8f 93       	push	r24
    62cc:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
	printf("EEPROM start:\t\t\t\t0x%04x\r\n",MEM_EEPROM_START);
    62d0:	1f 92       	push	r1
    62d2:	1f 92       	push	r1
    62d4:	80 e1       	ldi	r24, 0x10	; 16
    62d6:	8f 93       	push	r24
    62d8:	1f 92       	push	r1
    62da:	8c ee       	ldi	r24, 0xEC	; 236
    62dc:	94 e2       	ldi	r25, 0x24	; 36
    62de:	9f 93       	push	r25
    62e0:	8f 93       	push	r24
    62e2:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
	printf("EEPROM end:\t\t\t\t0x%04x\r\n",MEM_EEPROM_STOP);
    62e6:	1f 92       	push	r1
    62e8:	1f 92       	push	r1
    62ea:	8f e1       	ldi	r24, 0x1F	; 31
    62ec:	8f 93       	push	r24
    62ee:	1f 93       	push	r17
    62f0:	86 e0       	ldi	r24, 0x06	; 6
    62f2:	95 e2       	ldi	r25, 0x25	; 37
    62f4:	9f 93       	push	r25
    62f6:	8f 93       	push	r24
    62f8:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
	printf("SRAM start:\t\t\t\t0x%04x\r\n",MEM_SRAM_START);
    62fc:	1f 92       	push	r1
    62fe:	1f 92       	push	r1
    6300:	80 e2       	ldi	r24, 0x20	; 32
    6302:	8f 93       	push	r24
    6304:	1f 92       	push	r1
    6306:	8e e1       	ldi	r24, 0x1E	; 30
    6308:	95 e2       	ldi	r25, 0x25	; 37
    630a:	9f 93       	push	r25
    630c:	8f 93       	push	r24
    630e:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
	printf ("\t.DATA start:\t\t\t0x%04x\r\n",__data_start);
    6312:	80 e0       	ldi	r24, 0x00	; 0
    6314:	90 e2       	ldi	r25, 0x20	; 32
    6316:	9f 93       	push	r25
    6318:	8f 93       	push	r24
    631a:	86 e3       	ldi	r24, 0x36	; 54
    631c:	95 e2       	ldi	r25, 0x25	; 37
    631e:	9f 93       	push	r25
    6320:	8f 93       	push	r24
    6322:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
	printf ("\t.DATA end:\t\t\t0x%04x\r\n",__data_end-1);
    6326:	cd bf       	out	0x3d, r28	; 61
    6328:	de bf       	out	0x3e, r29	; 62
    632a:	8b ee       	ldi	r24, 0xEB	; 235
    632c:	98 e2       	ldi	r25, 0x28	; 40
    632e:	9f 93       	push	r25
    6330:	8f 93       	push	r24
    6332:	8f e4       	ldi	r24, 0x4F	; 79
    6334:	95 e2       	ldi	r25, 0x25	; 37
    6336:	9f 93       	push	r25
    6338:	8f 93       	push	r24
    633a:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
	printf ("\t.BSS start:\t\t\t0x%04x\r\n",__bss_start);
    633e:	8c ee       	ldi	r24, 0xEC	; 236
    6340:	98 e2       	ldi	r25, 0x28	; 40
    6342:	9f 93       	push	r25
    6344:	8f 93       	push	r24
    6346:	86 e6       	ldi	r24, 0x66	; 102
    6348:	95 e2       	ldi	r25, 0x25	; 37
    634a:	9f 93       	push	r25
    634c:	8f 93       	push	r24
    634e:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
	printf ("\t.BSS end:\t\t\t0x%04x\r\n",__bss_end-1);
    6352:	83 e8       	ldi	r24, 0x83	; 131
    6354:	9e e2       	ldi	r25, 0x2E	; 46
    6356:	9f 93       	push	r25
    6358:	8f 93       	push	r24
    635a:	8e e7       	ldi	r24, 0x7E	; 126
    635c:	95 e2       	ldi	r25, 0x25	; 37
    635e:	9f 93       	push	r25
    6360:	8f 93       	push	r24
    6362:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
	printf ("\t.HEAP start:\t\t\t0x%04x\r\n",ucHeap);
    6366:	80 91 73 2e 	lds	r24, 0x2E73	; 0x802e73 <ucHeap+0x1>
    636a:	8f 93       	push	r24
    636c:	80 91 72 2e 	lds	r24, 0x2E72	; 0x802e72 <ucHeap>
    6370:	8f 93       	push	r24
    6372:	84 e9       	ldi	r24, 0x94	; 148
    6374:	95 e2       	ldi	r25, 0x25	; 37
    6376:	9f 93       	push	r25
    6378:	8f 93       	push	r24
    637a:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
	
	for (a=0;a<NumTasks;a++)
    637e:	cd bf       	out	0x3d, r28	; 61
    6380:	de bf       	out	0x3e, r29	; 62
    6382:	81 14       	cp	r8, r1
    6384:	91 04       	cpc	r9, r1
    6386:	09 f4       	brne	.+2      	; 0x638a <MemMap+0x144>
    6388:	52 c0       	rjmp	.+164    	; 0x642e <MemMap+0x1e8>
    638a:	00 e0       	ldi	r16, 0x00	; 0
    638c:	10 e0       	ldi	r17, 0x00	; 0
    638e:	51 2c       	mov	r5, r1
	{
		printf ("\tTask name: %s\r\n",TaskStatusArray[a].pcTaskName);
    6390:	90 e2       	ldi	r25, 0x20	; 32
    6392:	a9 2e       	mov	r10, r25
    6394:	96 e2       	ldi	r25, 0x26	; 38
    6396:	b9 2e       	mov	r11, r25
		printf ("\t\tSTACK end:\t\t0x%04x\r\n",TaskStatusArray[a].pxStackBase);
    6398:	21 e3       	ldi	r18, 0x31	; 49
    639a:	c2 2e       	mov	r12, r18
    639c:	26 e2       	ldi	r18, 0x26	; 38
    639e:	d2 2e       	mov	r13, r18
		printf ("\t\tTCB start:\t\t0x%04x\r\n",TaskStatusArray[a].xHandle);
    63a0:	38 e4       	ldi	r19, 0x48	; 72
    63a2:	e3 2e       	mov	r14, r19
    63a4:	36 e2       	ldi	r19, 0x26	; 38
    63a6:	f3 2e       	mov	r15, r19
		TCBSize=(*(uint16_t *) ((uint16_t) (TaskStatusArray[a].xHandle)-2))-4;
		printf ("\t\tTCB end:\t\t0x%04x\r\n",(uint16_t)(TaskStatusArray[a].xHandle)+TCBSize-1);
    63a8:	4f e5       	ldi	r20, 0x5F	; 95
    63aa:	64 2e       	mov	r6, r20
    63ac:	46 e2       	ldi	r20, 0x26	; 38
    63ae:	74 2e       	mov	r7, r20
	printf ("\t.BSS end:\t\t\t0x%04x\r\n",__bss_end-1);
	printf ("\t.HEAP start:\t\t\t0x%04x\r\n",ucHeap);
	
	for (a=0;a<NumTasks;a++)
	{
		printf ("\tTask name: %s\r\n",TaskStatusArray[a].pcTaskName);
    63b0:	02 95       	swap	r16
    63b2:	12 95       	swap	r17
    63b4:	10 7f       	andi	r17, 0xF0	; 240
    63b6:	10 27       	eor	r17, r16
    63b8:	00 7f       	andi	r16, 0xF0	; 240
    63ba:	10 27       	eor	r17, r16
    63bc:	e1 e0       	ldi	r30, 0x01	; 1
    63be:	f0 e0       	ldi	r31, 0x00	; 0
    63c0:	ec 0f       	add	r30, r28
    63c2:	fd 1f       	adc	r31, r29
    63c4:	0e 0f       	add	r16, r30
    63c6:	1f 1f       	adc	r17, r31
    63c8:	f8 01       	movw	r30, r16
    63ca:	83 81       	ldd	r24, Z+3	; 0x03
    63cc:	8f 93       	push	r24
    63ce:	82 81       	ldd	r24, Z+2	; 0x02
    63d0:	8f 93       	push	r24
    63d2:	bf 92       	push	r11
    63d4:	af 92       	push	r10
    63d6:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
		printf ("\t\tSTACK end:\t\t0x%04x\r\n",TaskStatusArray[a].pxStackBase);
    63da:	f8 01       	movw	r30, r16
    63dc:	85 85       	ldd	r24, Z+13	; 0x0d
    63de:	8f 93       	push	r24
    63e0:	84 85       	ldd	r24, Z+12	; 0x0c
    63e2:	8f 93       	push	r24
    63e4:	df 92       	push	r13
    63e6:	cf 92       	push	r12
    63e8:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
		printf ("\t\tTCB start:\t\t0x%04x\r\n",TaskStatusArray[a].xHandle);
    63ec:	f8 01       	movw	r30, r16
    63ee:	81 81       	ldd	r24, Z+1	; 0x01
    63f0:	8f 93       	push	r24
    63f2:	80 81       	ld	r24, Z
    63f4:	8f 93       	push	r24
    63f6:	ff 92       	push	r15
    63f8:	ef 92       	push	r14
    63fa:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
		TCBSize=(*(uint16_t *) ((uint16_t) (TaskStatusArray[a].xHandle)-2))-4;
    63fe:	f8 01       	movw	r30, r16
    6400:	80 81       	ld	r24, Z
    6402:	91 81       	ldd	r25, Z+1	; 0x01
    6404:	fc 01       	movw	r30, r24
    6406:	32 97       	sbiw	r30, 0x02	; 2
		printf ("\t\tTCB end:\t\t0x%04x\r\n",(uint16_t)(TaskStatusArray[a].xHandle)+TCBSize-1);
    6408:	05 97       	sbiw	r24, 0x05	; 5
    640a:	20 81       	ld	r18, Z
    640c:	31 81       	ldd	r19, Z+1	; 0x01
    640e:	82 0f       	add	r24, r18
    6410:	93 1f       	adc	r25, r19
    6412:	9f 93       	push	r25
    6414:	8f 93       	push	r24
    6416:	7f 92       	push	r7
    6418:	6f 92       	push	r6
    641a:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
	printf ("\t.DATA end:\t\t\t0x%04x\r\n",__data_end-1);
	printf ("\t.BSS start:\t\t\t0x%04x\r\n",__bss_start);
	printf ("\t.BSS end:\t\t\t0x%04x\r\n",__bss_end-1);
	printf ("\t.HEAP start:\t\t\t0x%04x\r\n",ucHeap);
	
	for (a=0;a<NumTasks;a++)
    641e:	53 94       	inc	r5
    6420:	05 2d       	mov	r16, r5
    6422:	10 e0       	ldi	r17, 0x00	; 0
    6424:	cd bf       	out	0x3d, r28	; 61
    6426:	de bf       	out	0x3e, r29	; 62
    6428:	08 15       	cp	r16, r8
    642a:	19 05       	cpc	r17, r9
    642c:	0c f2       	brlt	.-126    	; 0x63b0 <MemMap+0x16a>
		TCBSize=(*(uint16_t *) ((uint16_t) (TaskStatusArray[a].xHandle)-2))-4;
		printf ("\t\tTCB end:\t\t0x%04x\r\n",(uint16_t)(TaskStatusArray[a].xHandle)+TCBSize-1);
	}
	
	
	printf ("\t.HEAP end:\t\t\t0x%04x\r\n",ucHeap+configTOTAL_HEAP_SIZE-1);
    642e:	80 91 72 2e 	lds	r24, 0x2E72	; 0x802e72 <ucHeap>
    6432:	90 91 73 2e 	lds	r25, 0x2E73	; 0x802e73 <ucHeap+0x1>
    6436:	81 50       	subi	r24, 0x01	; 1
    6438:	90 4c       	sbci	r25, 0xC0	; 192
    643a:	9f 93       	push	r25
    643c:	8f 93       	push	r24
    643e:	8d ea       	ldi	r24, 0xAD	; 173
    6440:	95 e2       	ldi	r25, 0x25	; 37
    6442:	9f 93       	push	r25
    6444:	8f 93       	push	r24
    6446:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
	printf ("\t.Bare metal STACK end:\t\t0x%04x\r\n",ucHeap+configTOTAL_HEAP_SIZE);
    644a:	80 91 72 2e 	lds	r24, 0x2E72	; 0x802e72 <ucHeap>
    644e:	90 91 73 2e 	lds	r25, 0x2E73	; 0x802e73 <ucHeap+0x1>
    6452:	90 5c       	subi	r25, 0xC0	; 192
    6454:	9f 93       	push	r25
    6456:	8f 93       	push	r24
    6458:	84 ec       	ldi	r24, 0xC4	; 196
    645a:	95 e2       	ldi	r25, 0x25	; 37
    645c:	9f 93       	push	r25
    645e:	8f 93       	push	r24
    6460:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
	printf ("\t.Bare metal STACK start:\t0x%04x\r\n",MEM_SRAM_STOP);
    6464:	1f 92       	push	r1
    6466:	1f 92       	push	r1
    6468:	0f e9       	ldi	r16, 0x9F	; 159
    646a:	0f 93       	push	r16
    646c:	1f ef       	ldi	r17, 0xFF	; 255
    646e:	1f 93       	push	r17
    6470:	86 ee       	ldi	r24, 0xE6	; 230
    6472:	95 e2       	ldi	r25, 0x25	; 37
    6474:	9f 93       	push	r25
    6476:	8f 93       	push	r24
    6478:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
	printf("SRAM stop:\t\t\t\t0x%04x\r\n",MEM_SRAM_STOP);
    647c:	1f 92       	push	r1
    647e:	1f 92       	push	r1
    6480:	0f 93       	push	r16
    6482:	1f 93       	push	r17
    6484:	89 e0       	ldi	r24, 0x09	; 9
    6486:	96 e2       	ldi	r25, 0x26	; 38
    6488:	9f 93       	push	r25
    648a:	8f 93       	push	r24
    648c:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
	
	printf("-----------\r\n");
    6490:	83 ea       	ldi	r24, 0xA3	; 163
    6492:	94 e2       	ldi	r25, 0x24	; 36
    6494:	0e 94 1b 51 	call	0xa236	; 0xa236 <puts>
}
    6498:	cd bf       	out	0x3d, r28	; 61
    649a:	de bf       	out	0x3e, r29	; 62
    649c:	c0 5c       	subi	r28, 0xC0	; 192
    649e:	de 4f       	sbci	r29, 0xFE	; 254
    64a0:	cd bf       	out	0x3d, r28	; 61
    64a2:	de bf       	out	0x3e, r29	; 62
    64a4:	df 91       	pop	r29
    64a6:	cf 91       	pop	r28
    64a8:	1f 91       	pop	r17
    64aa:	0f 91       	pop	r16
    64ac:	ff 90       	pop	r15
    64ae:	ef 90       	pop	r14
    64b0:	df 90       	pop	r13
    64b2:	cf 90       	pop	r12
    64b4:	bf 90       	pop	r11
    64b6:	af 90       	pop	r10
    64b8:	9f 90       	pop	r9
    64ba:	8f 90       	pop	r8
    64bc:	7f 90       	pop	r7
    64be:	6f 90       	pop	r6
    64c0:	5f 90       	pop	r5
    64c2:	08 95       	ret

000064c4 <WorkerADC>:
	ADCQueue=xQueueCreate(1,sizeof(ADCStruct));
	xTaskCreate( WorkerADC, "ADC", 512, NULL, tskIDLE_PRIORITY+2, NULL );
}

void WorkerADC(void *pvParameters)
{
    64c4:	cf 93       	push	r28
    64c6:	df 93       	push	r29
    64c8:	cd b7       	in	r28, 0x3d	; 61
    64ca:	de b7       	in	r29, 0x3e	; 62
    64cc:	2a 97       	sbiw	r28, 0x0a	; 10
    64ce:	cd bf       	out	0x3d, r28	; 61
    64d0:	de bf       	out	0x3e, r29	; 62
	TickType_t xLastWakeTime;
	const TickType_t xPeriod = 10;
	ADCStruct ADCData;
	
	DriverLedSet(0b0111);
    64d2:	87 e0       	ldi	r24, 0x07	; 7
    64d4:	0e 94 94 06 	call	0xd28	; 0xd28 <DriverLedSet>
	
	xLastWakeTime=xTaskGetTickCount();
    64d8:	0e 94 85 29 	call	0x530a	; 0x530a <xTaskGetTickCount>
    64dc:	89 87       	std	Y+9, r24	; 0x09
    64de:	9a 87       	std	Y+10, r25	; 0x0a
	while(1)
	{
		ADCData.PhotoL=DriverAdcGetCh(0,4);
    64e0:	64 e0       	ldi	r22, 0x04	; 4
    64e2:	80 e0       	ldi	r24, 0x00	; 0
    64e4:	0e 94 ad 03 	call	0x75a	; 0x75a <DriverAdcGetCh>
    64e8:	89 83       	std	Y+1, r24	; 0x01
    64ea:	9a 83       	std	Y+2, r25	; 0x02
		ADCData.PhotoM=DriverAdcGetCh(1,4);
    64ec:	64 e0       	ldi	r22, 0x04	; 4
    64ee:	81 e0       	ldi	r24, 0x01	; 1
    64f0:	0e 94 ad 03 	call	0x75a	; 0x75a <DriverAdcGetCh>
    64f4:	8b 83       	std	Y+3, r24	; 0x03
    64f6:	9c 83       	std	Y+4, r25	; 0x04
		ADCData.PhotoR=DriverAdcGetCh(2,4);
    64f8:	64 e0       	ldi	r22, 0x04	; 4
    64fa:	82 e0       	ldi	r24, 0x02	; 2
    64fc:	0e 94 ad 03 	call	0x75a	; 0x75a <DriverAdcGetCh>
    6500:	8d 83       	std	Y+5, r24	; 0x05
    6502:	9e 83       	std	Y+6, r25	; 0x06
		ADCData.Potmeter=DriverAdcGetCh(3,4);
    6504:	64 e0       	ldi	r22, 0x04	; 4
    6506:	83 e0       	ldi	r24, 0x03	; 3
    6508:	0e 94 ad 03 	call	0x75a	; 0x75a <DriverAdcGetCh>
    650c:	8f 83       	std	Y+7, r24	; 0x07
    650e:	98 87       	std	Y+8, r25	; 0x08
		xQueueOverwrite(ADCQueue,&ADCData);
    6510:	22 e0       	ldi	r18, 0x02	; 2
    6512:	40 e0       	ldi	r20, 0x00	; 0
    6514:	50 e0       	ldi	r21, 0x00	; 0
    6516:	be 01       	movw	r22, r28
    6518:	6f 5f       	subi	r22, 0xFF	; 255
    651a:	7f 4f       	sbci	r23, 0xFF	; 255
    651c:	80 91 74 2e 	lds	r24, 0x2E74	; 0x802e74 <ADCQueue>
    6520:	90 91 75 2e 	lds	r25, 0x2E75	; 0x802e75 <ADCQueue+0x1>
    6524:	0e 94 ef 20 	call	0x41de	; 0x41de <xQueueGenericSend>
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    6528:	6a e0       	ldi	r22, 0x0A	; 10
    652a:	70 e0       	ldi	r23, 0x00	; 0
    652c:	ce 01       	movw	r24, r28
    652e:	09 96       	adiw	r24, 0x09	; 9
    6530:	0e 94 0a 2b 	call	0x5614	; 0x5614 <vTaskDelayUntil>
    6534:	d5 cf       	rjmp	.-86     	; 0x64e0 <WorkerADC+0x1c>

00006536 <InitADCTask>:

void WorkerADC(void *pvParameters);

//Function definitions
void InitADCTask()
{
    6536:	ef 92       	push	r14
    6538:	ff 92       	push	r15
    653a:	0f 93       	push	r16
	ADCQueue=xQueueCreate(1,sizeof(ADCStruct));
    653c:	40 e0       	ldi	r20, 0x00	; 0
    653e:	68 e0       	ldi	r22, 0x08	; 8
    6540:	81 e0       	ldi	r24, 0x01	; 1
    6542:	0e 94 ab 20 	call	0x4156	; 0x4156 <xQueueGenericCreate>
    6546:	80 93 74 2e 	sts	0x2E74, r24	; 0x802e74 <ADCQueue>
    654a:	90 93 75 2e 	sts	0x2E75, r25	; 0x802e75 <ADCQueue+0x1>
	xTaskCreate( WorkerADC, "ADC", 512, NULL, tskIDLE_PRIORITY+2, NULL );
    654e:	e1 2c       	mov	r14, r1
    6550:	f1 2c       	mov	r15, r1
    6552:	02 e0       	ldi	r16, 0x02	; 2
    6554:	20 e0       	ldi	r18, 0x00	; 0
    6556:	30 e0       	ldi	r19, 0x00	; 0
    6558:	40 e0       	ldi	r20, 0x00	; 0
    655a:	52 e0       	ldi	r21, 0x02	; 2
    655c:	64 e7       	ldi	r22, 0x74	; 116
    655e:	76 e2       	ldi	r23, 0x26	; 38
    6560:	82 e6       	ldi	r24, 0x62	; 98
    6562:	92 e3       	ldi	r25, 0x32	; 50
    6564:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <xTaskCreate>
}
    6568:	0f 91       	pop	r16
    656a:	ff 90       	pop	r15
    656c:	ef 90       	pop	r14
    656e:	08 95       	ret

00006570 <GetADCData>:
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
	}
}

ADCStruct GetADCData(void)
{
    6570:	cf 93       	push	r28
    6572:	df 93       	push	r29
    6574:	cd b7       	in	r28, 0x3d	; 61
    6576:	de b7       	in	r29, 0x3e	; 62
    6578:	60 97       	sbiw	r28, 0x10	; 16
    657a:	cd bf       	out	0x3d, r28	; 61
    657c:	de bf       	out	0x3e, r29	; 62
	ADCStruct ADCData;
	xQueuePeek(ADCQueue,&ADCData,portMAX_DELAY);
    657e:	4f ef       	ldi	r20, 0xFF	; 255
    6580:	5f ef       	ldi	r21, 0xFF	; 255
    6582:	be 01       	movw	r22, r28
    6584:	67 5f       	subi	r22, 0xF7	; 247
    6586:	7f 4f       	sbci	r23, 0xFF	; 255
    6588:	80 91 74 2e 	lds	r24, 0x2E74	; 0x802e74 <ADCQueue>
    658c:	90 91 75 2e 	lds	r25, 0x2E75	; 0x802e75 <ADCQueue+0x1>
    6590:	0e 94 3d 24 	call	0x487a	; 0x487a <xQueuePeek>
	return ADCData;
    6594:	88 e0       	ldi	r24, 0x08	; 8
    6596:	fe 01       	movw	r30, r28
    6598:	39 96       	adiw	r30, 0x09	; 9
    659a:	de 01       	movw	r26, r28
    659c:	11 96       	adiw	r26, 0x01	; 1
    659e:	01 90       	ld	r0, Z+
    65a0:	0d 92       	st	X+, r0
    65a2:	8a 95       	dec	r24
    65a4:	e1 f7       	brne	.-8      	; 0x659e <GetADCData+0x2e>
    65a6:	29 81       	ldd	r18, Y+1	; 0x01
    65a8:	3a 81       	ldd	r19, Y+2	; 0x02
    65aa:	4b 81       	ldd	r20, Y+3	; 0x03
    65ac:	5c 81       	ldd	r21, Y+4	; 0x04
    65ae:	6d 81       	ldd	r22, Y+5	; 0x05
    65b0:	7e 81       	ldd	r23, Y+6	; 0x06
    65b2:	8f 81       	ldd	r24, Y+7	; 0x07
    65b4:	98 85       	ldd	r25, Y+8	; 0x08
    65b6:	60 96       	adiw	r28, 0x10	; 16
    65b8:	cd bf       	out	0x3d, r28	; 61
    65ba:	de bf       	out	0x3e, r29	; 62
    65bc:	df 91       	pop	r29
    65be:	cf 91       	pop	r28
    65c0:	08 95       	ret

000065c2 <WorkerGyro>:
	xTaskCreate( WorkerGyro, "gyro", 256, NULL, tskIDLE_PRIORITY+3, NULL );	
	GyroSema=xSemaphoreCreateMutex();
}

static void WorkerGyro(void *pvParameters)
{
    65c2:	cf 93       	push	r28
    65c4:	df 93       	push	r29
    65c6:	00 d0       	rcall	.+0      	; 0x65c8 <WorkerGyro+0x6>
    65c8:	1f 92       	push	r1
    65ca:	cd b7       	in	r28, 0x3d	; 61
    65cc:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime;
	const TickType_t xPeriod = 10;
	float GyroYawOffset;
	float OldYawRate=0;
	
	DriverMPU6050Init();	//Initialize IMU
    65ce:	0e 94 cb 09 	call	0x1396	; 0x1396 <DriverMPU6050Init>
	xLastWakeTime=xTaskGetTickCount();
    65d2:	0e 94 85 29 	call	0x530a	; 0x530a <xTaskGetTickCount>
    65d6:	89 83       	std	Y+1, r24	; 0x01
    65d8:	9a 83       	std	Y+2, r25	; 0x02
	
	vTaskDelay(200);
    65da:	88 ec       	ldi	r24, 0xC8	; 200
    65dc:	90 e0       	ldi	r25, 0x00	; 0
    65de:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
	DriverMPU6050GyroGet(NULL,NULL,&Gz);
    65e2:	ae 01       	movw	r20, r28
    65e4:	4d 5f       	subi	r20, 0xFD	; 253
    65e6:	5f 4f       	sbci	r21, 0xFF	; 255
    65e8:	60 e0       	ldi	r22, 0x00	; 0
    65ea:	70 e0       	ldi	r23, 0x00	; 0
    65ec:	80 e0       	ldi	r24, 0x00	; 0
    65ee:	90 e0       	ldi	r25, 0x00	; 0
    65f0:	0e 94 4b 0a 	call	0x1496	; 0x1496 <DriverMPU6050GyroGet>
	GyroYawOffset=(float) Gz*RATE_CST;
    65f4:	6b 81       	ldd	r22, Y+3	; 0x03
    65f6:	7c 81       	ldd	r23, Y+4	; 0x04
    65f8:	07 2e       	mov	r0, r23
    65fa:	00 0c       	add	r0, r0
    65fc:	88 0b       	sbc	r24, r24
    65fe:	99 0b       	sbc	r25, r25
    6600:	0e 94 c6 46 	call	0x8d8c	; 0x8d8c <__floatsisf>
    6604:	2d e2       	ldi	r18, 0x2D	; 45
    6606:	33 e2       	ldi	r19, 0x23	; 35
    6608:	4a ef       	ldi	r20, 0xFA	; 250
    660a:	5b e3       	ldi	r21, 0x3B	; 59
    660c:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    6610:	4b 01       	movw	r8, r22
    6612:	5c 01       	movw	r10, r24
{
	int16_t Gz;
	TickType_t xLastWakeTime;
	const TickType_t xPeriod = 10;
	float GyroYawOffset;
	float OldYawRate=0;
    6614:	61 2c       	mov	r6, r1
    6616:	71 2c       	mov	r7, r1
    6618:	c1 2c       	mov	r12, r1
    661a:	d1 2c       	mov	r13, r1
    661c:	0e c0       	rjmp	.+28     	; 0x663a <WorkerGyro+0x78>
		
		OldYawRate=GlobYawRate;
		
		xSemaphoreGive(GyroSema);
		if (GlobYawRate>0) 
			GyroYawOffset+=0.001;
    661e:	c5 01       	movw	r24, r10
    6620:	b4 01       	movw	r22, r8
    6622:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <__addsf3>
    6626:	4b 01       	movw	r8, r22
    6628:	5c 01       	movw	r10, r24
		else
			GyroYawOffset-=0.001;
		
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    662a:	6a e0       	ldi	r22, 0x0A	; 10
    662c:	70 e0       	ldi	r23, 0x00	; 0
    662e:	ce 01       	movw	r24, r28
    6630:	01 96       	adiw	r24, 0x01	; 1
    6632:	0e 94 0a 2b 	call	0x5614	; 0x5614 <vTaskDelayUntil>
		GlobYawRate-=GyroYawOffset;
		
		//Integration to yaw angle
		GlobYaw+=((GlobYawRate/100)+(OldYawRate/100))/2;
		
		OldYawRate=GlobYawRate;
    6636:	37 01       	movw	r6, r14
    6638:	68 01       	movw	r12, r16
	GyroYawOffset=(float) Gz*RATE_CST;

	
	while (1)
	{		
		DriverMPU6050GyroGet(NULL,NULL,&Gz);
    663a:	ae 01       	movw	r20, r28
    663c:	4d 5f       	subi	r20, 0xFD	; 253
    663e:	5f 4f       	sbci	r21, 0xFF	; 255
    6640:	60 e0       	ldi	r22, 0x00	; 0
    6642:	70 e0       	ldi	r23, 0x00	; 0
    6644:	80 e0       	ldi	r24, 0x00	; 0
    6646:	90 e0       	ldi	r25, 0x00	; 0
    6648:	0e 94 4b 0a 	call	0x1496	; 0x1496 <DriverMPU6050GyroGet>
		xSemaphoreTake(GyroSema,portMAX_DELAY);
    664c:	6f ef       	ldi	r22, 0xFF	; 255
    664e:	7f ef       	ldi	r23, 0xFF	; 255
    6650:	80 91 12 2e 	lds	r24, 0x2E12	; 0x802e12 <GyroSema>
    6654:	90 91 13 2e 	lds	r25, 0x2E13	; 0x802e13 <GyroSema+0x1>
    6658:	0e 94 43 23 	call	0x4686	; 0x4686 <xQueueSemaphoreTake>
		GlobYawRate=(float) Gz*RATE_CST;
		GlobYawRate-=GyroYawOffset;
    665c:	6b 81       	ldd	r22, Y+3	; 0x03
    665e:	7c 81       	ldd	r23, Y+4	; 0x04
    6660:	07 2e       	mov	r0, r23
    6662:	00 0c       	add	r0, r0
    6664:	88 0b       	sbc	r24, r24
    6666:	99 0b       	sbc	r25, r25
    6668:	0e 94 c6 46 	call	0x8d8c	; 0x8d8c <__floatsisf>
    666c:	2d e2       	ldi	r18, 0x2D	; 45
    666e:	33 e2       	ldi	r19, 0x23	; 35
    6670:	4a ef       	ldi	r20, 0xFA	; 250
    6672:	5b e3       	ldi	r21, 0x3B	; 59
    6674:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    6678:	a5 01       	movw	r20, r10
    667a:	94 01       	movw	r18, r8
    667c:	0e 94 aa 45 	call	0x8b54	; 0x8b54 <__subsf3>
    6680:	7b 01       	movw	r14, r22
    6682:	8c 01       	movw	r16, r24
    6684:	cb 01       	movw	r24, r22
    6686:	d8 01       	movw	r26, r16
    6688:	80 93 0e 2e 	sts	0x2E0E, r24	; 0x802e0e <GlobYawRate>
    668c:	90 93 0f 2e 	sts	0x2E0F, r25	; 0x802e0f <GlobYawRate+0x1>
    6690:	a0 93 10 2e 	sts	0x2E10, r26	; 0x802e10 <GlobYawRate+0x2>
    6694:	b0 93 11 2e 	sts	0x2E11, r27	; 0x802e11 <GlobYawRate+0x3>
		
		//Integration to yaw angle
		GlobYaw+=((GlobYawRate/100)+(OldYawRate/100))/2;
    6698:	20 e0       	ldi	r18, 0x00	; 0
    669a:	30 e0       	ldi	r19, 0x00	; 0
    669c:	48 ec       	ldi	r20, 0xC8	; 200
    669e:	52 e4       	ldi	r21, 0x42	; 66
    66a0:	b7 01       	movw	r22, r14
    66a2:	c8 01       	movw	r24, r16
    66a4:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    66a8:	1b 01       	movw	r2, r22
    66aa:	2c 01       	movw	r4, r24
    66ac:	20 e0       	ldi	r18, 0x00	; 0
    66ae:	30 e0       	ldi	r19, 0x00	; 0
    66b0:	48 ec       	ldi	r20, 0xC8	; 200
    66b2:	52 e4       	ldi	r21, 0x42	; 66
    66b4:	b3 01       	movw	r22, r6
    66b6:	c6 01       	movw	r24, r12
    66b8:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    66bc:	9b 01       	movw	r18, r22
    66be:	ac 01       	movw	r20, r24
    66c0:	c2 01       	movw	r24, r4
    66c2:	b1 01       	movw	r22, r2
    66c4:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <__addsf3>
    66c8:	20 e0       	ldi	r18, 0x00	; 0
    66ca:	30 e0       	ldi	r19, 0x00	; 0
    66cc:	40 e0       	ldi	r20, 0x00	; 0
    66ce:	5f e3       	ldi	r21, 0x3F	; 63
    66d0:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    66d4:	9b 01       	movw	r18, r22
    66d6:	ac 01       	movw	r20, r24
    66d8:	60 91 0a 2e 	lds	r22, 0x2E0A	; 0x802e0a <GlobYaw>
    66dc:	70 91 0b 2e 	lds	r23, 0x2E0B	; 0x802e0b <GlobYaw+0x1>
    66e0:	80 91 0c 2e 	lds	r24, 0x2E0C	; 0x802e0c <GlobYaw+0x2>
    66e4:	90 91 0d 2e 	lds	r25, 0x2E0D	; 0x802e0d <GlobYaw+0x3>
    66e8:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <__addsf3>
    66ec:	60 93 0a 2e 	sts	0x2E0A, r22	; 0x802e0a <GlobYaw>
    66f0:	70 93 0b 2e 	sts	0x2E0B, r23	; 0x802e0b <GlobYaw+0x1>
    66f4:	80 93 0c 2e 	sts	0x2E0C, r24	; 0x802e0c <GlobYaw+0x2>
    66f8:	90 93 0d 2e 	sts	0x2E0D, r25	; 0x802e0d <GlobYaw+0x3>
		
		OldYawRate=GlobYawRate;
		
		xSemaphoreGive(GyroSema);
    66fc:	20 e0       	ldi	r18, 0x00	; 0
    66fe:	40 e0       	ldi	r20, 0x00	; 0
    6700:	50 e0       	ldi	r21, 0x00	; 0
    6702:	60 e0       	ldi	r22, 0x00	; 0
    6704:	70 e0       	ldi	r23, 0x00	; 0
    6706:	80 91 12 2e 	lds	r24, 0x2E12	; 0x802e12 <GyroSema>
    670a:	90 91 13 2e 	lds	r25, 0x2E13	; 0x802e13 <GyroSema+0x1>
    670e:	0e 94 ef 20 	call	0x41de	; 0x41de <xQueueGenericSend>
		if (GlobYawRate>0) 
    6712:	20 e0       	ldi	r18, 0x00	; 0
    6714:	30 e0       	ldi	r19, 0x00	; 0
    6716:	a9 01       	movw	r20, r18
    6718:	60 91 0e 2e 	lds	r22, 0x2E0E	; 0x802e0e <GlobYawRate>
    671c:	70 91 0f 2e 	lds	r23, 0x2E0F	; 0x802e0f <GlobYawRate+0x1>
    6720:	80 91 10 2e 	lds	r24, 0x2E10	; 0x802e10 <GlobYawRate+0x2>
    6724:	90 91 11 2e 	lds	r25, 0x2E11	; 0x802e11 <GlobYawRate+0x3>
    6728:	0e 94 76 47 	call	0x8eec	; 0x8eec <__gesf2>
			GyroYawOffset+=0.001;
    672c:	2f e6       	ldi	r18, 0x6F	; 111
    672e:	32 e1       	ldi	r19, 0x12	; 18
    6730:	43 e8       	ldi	r20, 0x83	; 131
    6732:	5a e3       	ldi	r21, 0x3A	; 58
		GlobYaw+=((GlobYawRate/100)+(OldYawRate/100))/2;
		
		OldYawRate=GlobYawRate;
		
		xSemaphoreGive(GyroSema);
		if (GlobYawRate>0) 
    6734:	18 16       	cp	r1, r24
    6736:	0c f4       	brge	.+2      	; 0x673a <WorkerGyro+0x178>
    6738:	72 cf       	rjmp	.-284    	; 0x661e <WorkerGyro+0x5c>
			GyroYawOffset+=0.001;
		else
			GyroYawOffset-=0.001;
    673a:	c5 01       	movw	r24, r10
    673c:	b4 01       	movw	r22, r8
    673e:	0e 94 aa 45 	call	0x8b54	; 0x8b54 <__subsf3>
    6742:	4b 01       	movw	r8, r22
    6744:	5c 01       	movw	r10, r24
    6746:	71 cf       	rjmp	.-286    	; 0x662a <WorkerGyro+0x68>

00006748 <InitGyroTask>:
//Private function prototypes
static void WorkerGyro(void *pvParameters);

//Function definitions
void InitGyroTask()
{
    6748:	ef 92       	push	r14
    674a:	ff 92       	push	r15
    674c:	0f 93       	push	r16
	xTaskCreate( WorkerGyro, "gyro", 256, NULL, tskIDLE_PRIORITY+3, NULL );	
    674e:	e1 2c       	mov	r14, r1
    6750:	f1 2c       	mov	r15, r1
    6752:	03 e0       	ldi	r16, 0x03	; 3
    6754:	20 e0       	ldi	r18, 0x00	; 0
    6756:	30 e0       	ldi	r19, 0x00	; 0
    6758:	40 e0       	ldi	r20, 0x00	; 0
    675a:	51 e0       	ldi	r21, 0x01	; 1
    675c:	68 e7       	ldi	r22, 0x78	; 120
    675e:	76 e2       	ldi	r23, 0x26	; 38
    6760:	81 ee       	ldi	r24, 0xE1	; 225
    6762:	92 e3       	ldi	r25, 0x32	; 50
    6764:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <xTaskCreate>
	GyroSema=xSemaphoreCreateMutex();
    6768:	81 e0       	ldi	r24, 0x01	; 1
    676a:	0e 94 be 21 	call	0x437c	; 0x437c <xQueueCreateMutex>
    676e:	80 93 12 2e 	sts	0x2E12, r24	; 0x802e12 <GyroSema>
    6772:	90 93 13 2e 	sts	0x2E13, r25	; 0x802e13 <GyroSema+0x1>
}
    6776:	0f 91       	pop	r16
    6778:	ff 90       	pop	r15
    677a:	ef 90       	pop	r14
    677c:	08 95       	ret

0000677e <GyroGet>:
	}

}

void GyroGet(float *YawRate, float *Yaw)
{
    677e:	0f 93       	push	r16
    6780:	1f 93       	push	r17
    6782:	cf 93       	push	r28
    6784:	df 93       	push	r29
    6786:	8c 01       	movw	r16, r24
    6788:	eb 01       	movw	r28, r22
		xSemaphoreTake(GyroSema,portMAX_DELAY);
    678a:	6f ef       	ldi	r22, 0xFF	; 255
    678c:	7f ef       	ldi	r23, 0xFF	; 255
    678e:	80 91 12 2e 	lds	r24, 0x2E12	; 0x802e12 <GyroSema>
    6792:	90 91 13 2e 	lds	r25, 0x2E13	; 0x802e13 <GyroSema+0x1>
    6796:	0e 94 43 23 	call	0x4686	; 0x4686 <xQueueSemaphoreTake>
		if (YawRate!=NULL) *YawRate=GlobYawRate;
    679a:	01 15       	cp	r16, r1
    679c:	11 05       	cpc	r17, r1
    679e:	69 f0       	breq	.+26     	; 0x67ba <GyroGet+0x3c>
    67a0:	80 91 0e 2e 	lds	r24, 0x2E0E	; 0x802e0e <GlobYawRate>
    67a4:	90 91 0f 2e 	lds	r25, 0x2E0F	; 0x802e0f <GlobYawRate+0x1>
    67a8:	a0 91 10 2e 	lds	r26, 0x2E10	; 0x802e10 <GlobYawRate+0x2>
    67ac:	b0 91 11 2e 	lds	r27, 0x2E11	; 0x802e11 <GlobYawRate+0x3>
    67b0:	f8 01       	movw	r30, r16
    67b2:	80 83       	st	Z, r24
    67b4:	91 83       	std	Z+1, r25	; 0x01
    67b6:	a2 83       	std	Z+2, r26	; 0x02
    67b8:	b3 83       	std	Z+3, r27	; 0x03
		if (Yaw!=NULL) *Yaw=GlobYaw;
    67ba:	20 97       	sbiw	r28, 0x00	; 0
    67bc:	61 f0       	breq	.+24     	; 0x67d6 <GyroGet+0x58>
    67be:	80 91 0a 2e 	lds	r24, 0x2E0A	; 0x802e0a <GlobYaw>
    67c2:	90 91 0b 2e 	lds	r25, 0x2E0B	; 0x802e0b <GlobYaw+0x1>
    67c6:	a0 91 0c 2e 	lds	r26, 0x2E0C	; 0x802e0c <GlobYaw+0x2>
    67ca:	b0 91 0d 2e 	lds	r27, 0x2E0D	; 0x802e0d <GlobYaw+0x3>
    67ce:	88 83       	st	Y, r24
    67d0:	99 83       	std	Y+1, r25	; 0x01
    67d2:	aa 83       	std	Y+2, r26	; 0x02
    67d4:	bb 83       	std	Y+3, r27	; 0x03
		xSemaphoreGive(GyroSema);
    67d6:	20 e0       	ldi	r18, 0x00	; 0
    67d8:	40 e0       	ldi	r20, 0x00	; 0
    67da:	50 e0       	ldi	r21, 0x00	; 0
    67dc:	60 e0       	ldi	r22, 0x00	; 0
    67de:	70 e0       	ldi	r23, 0x00	; 0
    67e0:	80 91 12 2e 	lds	r24, 0x2E12	; 0x802e12 <GyroSema>
    67e4:	90 91 13 2e 	lds	r25, 0x2E13	; 0x802e13 <GyroSema+0x1>
	
}
    67e8:	df 91       	pop	r29
    67ea:	cf 91       	pop	r28
    67ec:	1f 91       	pop	r17
    67ee:	0f 91       	pop	r16
void GyroGet(float *YawRate, float *Yaw)
{
		xSemaphoreTake(GyroSema,portMAX_DELAY);
		if (YawRate!=NULL) *YawRate=GlobYawRate;
		if (Yaw!=NULL) *Yaw=GlobYaw;
		xSemaphoreGive(GyroSema);
    67f0:	0c 94 ef 20 	jmp	0x41de	; 0x41de <xQueueGenericSend>

000067f4 <IPSGetPosition>:
        vTaskDelayUntil( &xLastWakeTime, xPeriod );
    }
}

void IPSGetPosition(float *PosX, float *PosY, float *PosZ)
{
    67f4:	ef 92       	push	r14
    67f6:	ff 92       	push	r15
    67f8:	0f 93       	push	r16
    67fa:	1f 93       	push	r17
    67fc:	cf 93       	push	r28
    67fe:	df 93       	push	r29
    6800:	7c 01       	movw	r14, r24
    6802:	8b 01       	movw	r16, r22
    6804:	ea 01       	movw	r28, r20
    xSemaphoreTake(IPS_Sema,portMAX_DELAY);
    6806:	6f ef       	ldi	r22, 0xFF	; 255
    6808:	7f ef       	ldi	r23, 0xFF	; 255
    680a:	80 91 2c 2e 	lds	r24, 0x2E2C	; 0x802e2c <IPS_Sema>
    680e:	90 91 2d 2e 	lds	r25, 0x2E2D	; 0x802e2d <IPS_Sema+0x1>
    6812:	0e 94 43 23 	call	0x4686	; 0x4686 <xQueueSemaphoreTake>
    if (PosX != NULL) *PosX = GlobPosX;
    6816:	e1 14       	cp	r14, r1
    6818:	f1 04       	cpc	r15, r1
    681a:	69 f0       	breq	.+26     	; 0x6836 <IPSGetPosition+0x42>
    681c:	80 91 28 2e 	lds	r24, 0x2E28	; 0x802e28 <GlobPosX>
    6820:	90 91 29 2e 	lds	r25, 0x2E29	; 0x802e29 <GlobPosX+0x1>
    6824:	a0 91 2a 2e 	lds	r26, 0x2E2A	; 0x802e2a <GlobPosX+0x2>
    6828:	b0 91 2b 2e 	lds	r27, 0x2E2B	; 0x802e2b <GlobPosX+0x3>
    682c:	f7 01       	movw	r30, r14
    682e:	80 83       	st	Z, r24
    6830:	91 83       	std	Z+1, r25	; 0x01
    6832:	a2 83       	std	Z+2, r26	; 0x02
    6834:	b3 83       	std	Z+3, r27	; 0x03
    if (PosY != NULL) *PosY = GlobPosY;
    6836:	01 15       	cp	r16, r1
    6838:	11 05       	cpc	r17, r1
    683a:	69 f0       	breq	.+26     	; 0x6856 <IPSGetPosition+0x62>
    683c:	80 91 24 2e 	lds	r24, 0x2E24	; 0x802e24 <GlobPosY>
    6840:	90 91 25 2e 	lds	r25, 0x2E25	; 0x802e25 <GlobPosY+0x1>
    6844:	a0 91 26 2e 	lds	r26, 0x2E26	; 0x802e26 <GlobPosY+0x2>
    6848:	b0 91 27 2e 	lds	r27, 0x2E27	; 0x802e27 <GlobPosY+0x3>
    684c:	f8 01       	movw	r30, r16
    684e:	80 83       	st	Z, r24
    6850:	91 83       	std	Z+1, r25	; 0x01
    6852:	a2 83       	std	Z+2, r26	; 0x02
    6854:	b3 83       	std	Z+3, r27	; 0x03
    if (PosZ != NULL) *PosZ = GlobPosZ;
    6856:	20 97       	sbiw	r28, 0x00	; 0
    6858:	61 f0       	breq	.+24     	; 0x6872 <IPSGetPosition+0x7e>
    685a:	80 91 20 2e 	lds	r24, 0x2E20	; 0x802e20 <GlobPosZ>
    685e:	90 91 21 2e 	lds	r25, 0x2E21	; 0x802e21 <GlobPosZ+0x1>
    6862:	a0 91 22 2e 	lds	r26, 0x2E22	; 0x802e22 <GlobPosZ+0x2>
    6866:	b0 91 23 2e 	lds	r27, 0x2E23	; 0x802e23 <GlobPosZ+0x3>
    686a:	88 83       	st	Y, r24
    686c:	99 83       	std	Y+1, r25	; 0x01
    686e:	aa 83       	std	Y+2, r26	; 0x02
    6870:	bb 83       	std	Y+3, r27	; 0x03
    xSemaphoreGive(IPS_Sema);
    6872:	20 e0       	ldi	r18, 0x00	; 0
    6874:	40 e0       	ldi	r20, 0x00	; 0
    6876:	50 e0       	ldi	r21, 0x00	; 0
    6878:	60 e0       	ldi	r22, 0x00	; 0
    687a:	70 e0       	ldi	r23, 0x00	; 0
    687c:	80 91 2c 2e 	lds	r24, 0x2E2C	; 0x802e2c <IPS_Sema>
    6880:	90 91 2d 2e 	lds	r25, 0x2E2D	; 0x802e2d <IPS_Sema+0x1>
}
    6884:	df 91       	pop	r29
    6886:	cf 91       	pop	r28
    6888:	1f 91       	pop	r17
    688a:	0f 91       	pop	r16
    688c:	ff 90       	pop	r15
    688e:	ef 90       	pop	r14
{
    xSemaphoreTake(IPS_Sema,portMAX_DELAY);
    if (PosX != NULL) *PosX = GlobPosX;
    if (PosY != NULL) *PosY = GlobPosY;
    if (PosZ != NULL) *PosZ = GlobPosZ;
    xSemaphoreGive(IPS_Sema);
    6890:	0c 94 ef 20 	jmp	0x41de	; 0x41de <xQueueGenericSend>

00006894 <IPSGetVelocity>:
}

void IPSGetVelocity(float *VelX, float *VelY, float *VelZ)
{
    6894:	ef 92       	push	r14
    6896:	ff 92       	push	r15
    6898:	0f 93       	push	r16
    689a:	1f 93       	push	r17
    689c:	cf 93       	push	r28
    689e:	df 93       	push	r29
    68a0:	7c 01       	movw	r14, r24
    68a2:	8b 01       	movw	r16, r22
    68a4:	ea 01       	movw	r28, r20
	xSemaphoreTake(IPS_Sema,portMAX_DELAY);
    68a6:	6f ef       	ldi	r22, 0xFF	; 255
    68a8:	7f ef       	ldi	r23, 0xFF	; 255
    68aa:	80 91 2c 2e 	lds	r24, 0x2E2C	; 0x802e2c <IPS_Sema>
    68ae:	90 91 2d 2e 	lds	r25, 0x2E2D	; 0x802e2d <IPS_Sema+0x1>
    68b2:	0e 94 43 23 	call	0x4686	; 0x4686 <xQueueSemaphoreTake>
	if (VelX != NULL) *VelX = GlobVelX;
    68b6:	e1 14       	cp	r14, r1
    68b8:	f1 04       	cpc	r15, r1
    68ba:	29 f0       	breq	.+10     	; 0x68c6 <IPSGetVelocity+0x32>
    68bc:	f7 01       	movw	r30, r14
    68be:	10 82       	st	Z, r1
    68c0:	11 82       	std	Z+1, r1	; 0x01
    68c2:	12 82       	std	Z+2, r1	; 0x02
    68c4:	13 82       	std	Z+3, r1	; 0x03
	if (VelY != NULL) *VelY = GlobVelY;
    68c6:	01 15       	cp	r16, r1
    68c8:	11 05       	cpc	r17, r1
    68ca:	29 f0       	breq	.+10     	; 0x68d6 <IPSGetVelocity+0x42>
    68cc:	f8 01       	movw	r30, r16
    68ce:	10 82       	st	Z, r1
    68d0:	11 82       	std	Z+1, r1	; 0x01
    68d2:	12 82       	std	Z+2, r1	; 0x02
    68d4:	13 82       	std	Z+3, r1	; 0x03
	if (VelZ != NULL) *VelZ = GlobVelZ;
    68d6:	20 97       	sbiw	r28, 0x00	; 0
    68d8:	21 f0       	breq	.+8      	; 0x68e2 <IPSGetVelocity+0x4e>
    68da:	18 82       	st	Y, r1
    68dc:	19 82       	std	Y+1, r1	; 0x01
    68de:	1a 82       	std	Y+2, r1	; 0x02
    68e0:	1b 82       	std	Y+3, r1	; 0x03
	xSemaphoreGive(IPS_Sema);
    68e2:	20 e0       	ldi	r18, 0x00	; 0
    68e4:	40 e0       	ldi	r20, 0x00	; 0
    68e6:	50 e0       	ldi	r21, 0x00	; 0
    68e8:	60 e0       	ldi	r22, 0x00	; 0
    68ea:	70 e0       	ldi	r23, 0x00	; 0
    68ec:	80 91 2c 2e 	lds	r24, 0x2E2C	; 0x802e2c <IPS_Sema>
    68f0:	90 91 2d 2e 	lds	r25, 0x2E2D	; 0x802e2d <IPS_Sema+0x1>
}
    68f4:	df 91       	pop	r29
    68f6:	cf 91       	pop	r28
    68f8:	1f 91       	pop	r17
    68fa:	0f 91       	pop	r16
    68fc:	ff 90       	pop	r15
    68fe:	ef 90       	pop	r14
{
	xSemaphoreTake(IPS_Sema,portMAX_DELAY);
	if (VelX != NULL) *VelX = GlobVelX;
	if (VelY != NULL) *VelY = GlobVelY;
	if (VelZ != NULL) *VelZ = GlobVelZ;
	xSemaphoreGive(IPS_Sema);
    6900:	0c 94 ef 20 	jmp	0x41de	; 0x41de <xQueueGenericSend>

00006904 <IPSGetAcceleration>:
}

void IPSGetAcceleration(float *Ax, float *Ay, float *Az)
{
    6904:	ef 92       	push	r14
    6906:	ff 92       	push	r15
    6908:	0f 93       	push	r16
    690a:	1f 93       	push	r17
    690c:	cf 93       	push	r28
    690e:	df 93       	push	r29
    6910:	7c 01       	movw	r14, r24
    6912:	8b 01       	movw	r16, r22
    6914:	ea 01       	movw	r28, r20
    xSemaphoreTake(IPS_Sema,portMAX_DELAY);
    6916:	6f ef       	ldi	r22, 0xFF	; 255
    6918:	7f ef       	ldi	r23, 0xFF	; 255
    691a:	80 91 2c 2e 	lds	r24, 0x2E2C	; 0x802e2c <IPS_Sema>
    691e:	90 91 2d 2e 	lds	r25, 0x2E2D	; 0x802e2d <IPS_Sema+0x1>
    6922:	0e 94 43 23 	call	0x4686	; 0x4686 <xQueueSemaphoreTake>
    if (Ax != NULL) *Ax = GlobAccX;
    6926:	e1 14       	cp	r14, r1
    6928:	f1 04       	cpc	r15, r1
    692a:	69 f0       	breq	.+26     	; 0x6946 <IPSGetAcceleration+0x42>
    692c:	80 91 1c 2e 	lds	r24, 0x2E1C	; 0x802e1c <GlobAccX>
    6930:	90 91 1d 2e 	lds	r25, 0x2E1D	; 0x802e1d <GlobAccX+0x1>
    6934:	a0 91 1e 2e 	lds	r26, 0x2E1E	; 0x802e1e <GlobAccX+0x2>
    6938:	b0 91 1f 2e 	lds	r27, 0x2E1F	; 0x802e1f <GlobAccX+0x3>
    693c:	f7 01       	movw	r30, r14
    693e:	80 83       	st	Z, r24
    6940:	91 83       	std	Z+1, r25	; 0x01
    6942:	a2 83       	std	Z+2, r26	; 0x02
    6944:	b3 83       	std	Z+3, r27	; 0x03
    if (Ay != NULL) *Ay = GlobAccY;
    6946:	01 15       	cp	r16, r1
    6948:	11 05       	cpc	r17, r1
    694a:	69 f0       	breq	.+26     	; 0x6966 <IPSGetAcceleration+0x62>
    694c:	80 91 18 2e 	lds	r24, 0x2E18	; 0x802e18 <GlobAccY>
    6950:	90 91 19 2e 	lds	r25, 0x2E19	; 0x802e19 <GlobAccY+0x1>
    6954:	a0 91 1a 2e 	lds	r26, 0x2E1A	; 0x802e1a <GlobAccY+0x2>
    6958:	b0 91 1b 2e 	lds	r27, 0x2E1B	; 0x802e1b <GlobAccY+0x3>
    695c:	f8 01       	movw	r30, r16
    695e:	80 83       	st	Z, r24
    6960:	91 83       	std	Z+1, r25	; 0x01
    6962:	a2 83       	std	Z+2, r26	; 0x02
    6964:	b3 83       	std	Z+3, r27	; 0x03
    if (Az != NULL) *Az = GlobAccZ;
    6966:	20 97       	sbiw	r28, 0x00	; 0
    6968:	61 f0       	breq	.+24     	; 0x6982 <IPSGetAcceleration+0x7e>
    696a:	80 91 14 2e 	lds	r24, 0x2E14	; 0x802e14 <GlobAccZ>
    696e:	90 91 15 2e 	lds	r25, 0x2E15	; 0x802e15 <GlobAccZ+0x1>
    6972:	a0 91 16 2e 	lds	r26, 0x2E16	; 0x802e16 <GlobAccZ+0x2>
    6976:	b0 91 17 2e 	lds	r27, 0x2E17	; 0x802e17 <GlobAccZ+0x3>
    697a:	88 83       	st	Y, r24
    697c:	99 83       	std	Y+1, r25	; 0x01
    697e:	aa 83       	std	Y+2, r26	; 0x02
    6980:	bb 83       	std	Y+3, r27	; 0x03
    xSemaphoreGive(IPS_Sema);
    6982:	20 e0       	ldi	r18, 0x00	; 0
    6984:	40 e0       	ldi	r20, 0x00	; 0
    6986:	50 e0       	ldi	r21, 0x00	; 0
    6988:	60 e0       	ldi	r22, 0x00	; 0
    698a:	70 e0       	ldi	r23, 0x00	; 0
    698c:	80 91 2c 2e 	lds	r24, 0x2E2C	; 0x802e2c <IPS_Sema>
    6990:	90 91 2d 2e 	lds	r25, 0x2E2D	; 0x802e2d <IPS_Sema+0x1>
}
    6994:	df 91       	pop	r29
    6996:	cf 91       	pop	r28
    6998:	1f 91       	pop	r17
    699a:	0f 91       	pop	r16
    699c:	ff 90       	pop	r15
    699e:	ef 90       	pop	r14
{
    xSemaphoreTake(IPS_Sema,portMAX_DELAY);
    if (Ax != NULL) *Ax = GlobAccX;
    if (Ay != NULL) *Ay = GlobAccY;
    if (Az != NULL) *Az = GlobAccZ;
    xSemaphoreGive(IPS_Sema);
    69a0:	0c 94 ef 20 	jmp	0x41de	; 0x41de <xQueueGenericSend>

000069a4 <WorkerLineFollowerDirect>:
{
	vTaskSuspend(LineFollowerDirectTaskHandle);
}

static void WorkerLineFollowerDirect(void *pvParameters)
{
    69a4:	cf 93       	push	r28
    69a6:	df 93       	push	r29
    69a8:	cd b7       	in	r28, 0x3d	; 61
    69aa:	de b7       	in	r29, 0x3e	; 62
    69ac:	2a 97       	sbiw	r28, 0x0a	; 10
    69ae:	cd bf       	out	0x3d, r28	; 61
    69b0:	de bf       	out	0x3e, r29	; 62
	{
		xLastWakeTime=xTaskGetTickCount();

		ADCData=GetADCData();
		Diff=(float) (ADCData.PhotoL-ADCData.PhotoR+SensorOffset);
		printf ("Diff:%f\r\n",Diff);
    69b2:	0d e7       	ldi	r16, 0x7D	; 125
    69b4:	16 e2       	ldi	r17, 0x26	; 38
    69b6:	1b c0       	rjmp	.+54     	; 0x69ee <WorkerLineFollowerDirect+0x4a>
    69b8:	c3 01       	movw	r24, r6
    69ba:	b2 01       	movw	r22, r4
    69bc:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
    69c0:	7b 01       	movw	r14, r22
		OutL=Speed+(Diff*LineFollowKp);
		OutR=Speed-(Diff*LineFollowKp);
		
		if (OutL<0) OutL=0;
		if (OutR<0) OutR=0;
    69c2:	20 e0       	ldi	r18, 0x00	; 0
    69c4:	30 e0       	ldi	r19, 0x00	; 0
    69c6:	a9 01       	movw	r20, r18
    69c8:	c5 01       	movw	r24, r10
    69ca:	b4 01       	movw	r22, r8
    69cc:	0e 94 17 46 	call	0x8c2e	; 0x8c2e <__cmpsf2>
    69d0:	87 fd       	sbrc	r24, 7
    69d2:	5d c0       	rjmp	.+186    	; 0x6a8e <WorkerLineFollowerDirect+0xea>
    69d4:	c5 01       	movw	r24, r10
    69d6:	b4 01       	movw	r22, r8
    69d8:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
		DriverMotorSet((int16_t) OutL, (int16_t) OutR);
    69dc:	c7 01       	movw	r24, r14
    69de:	0e 94 e7 06 	call	0xdce	; 0xdce <DriverMotorSet>
			

		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    69e2:	6a e0       	ldi	r22, 0x0A	; 10
    69e4:	70 e0       	ldi	r23, 0x00	; 0
    69e6:	ce 01       	movw	r24, r28
    69e8:	09 96       	adiw	r24, 0x09	; 9
    69ea:	0e 94 0a 2b 	call	0x5614	; 0x5614 <vTaskDelayUntil>
	ADCStruct ADCData;

	
	while(1)
	{
		xLastWakeTime=xTaskGetTickCount();
    69ee:	0e 94 85 29 	call	0x530a	; 0x530a <xTaskGetTickCount>
    69f2:	89 87       	std	Y+9, r24	; 0x09
    69f4:	9a 87       	std	Y+10, r25	; 0x0a

		ADCData=GetADCData();
    69f6:	0e 94 b8 32 	call	0x6570	; 0x6570 <GetADCData>
    69fa:	29 83       	std	Y+1, r18	; 0x01
    69fc:	3a 83       	std	Y+2, r19	; 0x02
    69fe:	6d 83       	std	Y+5, r22	; 0x05
    6a00:	7e 83       	std	Y+6, r23	; 0x06
		Diff=(float) (ADCData.PhotoL-ADCData.PhotoR+SensorOffset);
    6a02:	69 81       	ldd	r22, Y+1	; 0x01
    6a04:	7a 81       	ldd	r23, Y+2	; 0x02
    6a06:	8d 81       	ldd	r24, Y+5	; 0x05
    6a08:	9e 81       	ldd	r25, Y+6	; 0x06
    6a0a:	68 1b       	sub	r22, r24
    6a0c:	79 0b       	sbc	r23, r25
    6a0e:	07 2e       	mov	r0, r23
    6a10:	00 0c       	add	r0, r0
    6a12:	88 0b       	sbc	r24, r24
    6a14:	99 0b       	sbc	r25, r25
    6a16:	0e 94 c6 46 	call	0x8d8c	; 0x8d8c <__floatsisf>
    6a1a:	6b 01       	movw	r12, r22
    6a1c:	7c 01       	movw	r14, r24
		printf ("Diff:%f\r\n",Diff);
    6a1e:	ff 92       	push	r15
    6a20:	8f 93       	push	r24
    6a22:	df 92       	push	r13
    6a24:	6f 93       	push	r22
    6a26:	1f 93       	push	r17
    6a28:	0f 93       	push	r16
    6a2a:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
		OutL=Speed+(Diff*LineFollowKp);
    6a2e:	2d ec       	ldi	r18, 0xCD	; 205
    6a30:	3c ec       	ldi	r19, 0xCC	; 204
    6a32:	4c e4       	ldi	r20, 0x4C	; 76
    6a34:	5e e3       	ldi	r21, 0x3E	; 62
    6a36:	6c 2d       	mov	r22, r12
    6a38:	7d 2d       	mov	r23, r13
    6a3a:	8e 2d       	mov	r24, r14
    6a3c:	9f 2d       	mov	r25, r15
    6a3e:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    6a42:	6b 01       	movw	r12, r22
    6a44:	7c 01       	movw	r14, r24
    6a46:	20 e0       	ldi	r18, 0x00	; 0
    6a48:	30 e0       	ldi	r19, 0x00	; 0
    6a4a:	48 e4       	ldi	r20, 0x48	; 72
    6a4c:	55 e4       	ldi	r21, 0x45	; 69
    6a4e:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <__addsf3>
    6a52:	2b 01       	movw	r4, r22
    6a54:	3c 01       	movw	r6, r24
		OutR=Speed-(Diff*LineFollowKp);
    6a56:	a7 01       	movw	r20, r14
    6a58:	96 01       	movw	r18, r12
    6a5a:	60 e0       	ldi	r22, 0x00	; 0
    6a5c:	70 e0       	ldi	r23, 0x00	; 0
    6a5e:	88 e4       	ldi	r24, 0x48	; 72
    6a60:	95 e4       	ldi	r25, 0x45	; 69
    6a62:	0e 94 aa 45 	call	0x8b54	; 0x8b54 <__subsf3>
    6a66:	4b 01       	movw	r8, r22
    6a68:	5c 01       	movw	r10, r24
		
		if (OutL<0) OutL=0;
    6a6a:	0f 90       	pop	r0
    6a6c:	0f 90       	pop	r0
    6a6e:	0f 90       	pop	r0
    6a70:	0f 90       	pop	r0
    6a72:	0f 90       	pop	r0
    6a74:	0f 90       	pop	r0
    6a76:	20 e0       	ldi	r18, 0x00	; 0
    6a78:	30 e0       	ldi	r19, 0x00	; 0
    6a7a:	a9 01       	movw	r20, r18
    6a7c:	c3 01       	movw	r24, r6
    6a7e:	b2 01       	movw	r22, r4
    6a80:	0e 94 17 46 	call	0x8c2e	; 0x8c2e <__cmpsf2>
    6a84:	87 ff       	sbrs	r24, 7
    6a86:	98 cf       	rjmp	.-208    	; 0x69b8 <WorkerLineFollowerDirect+0x14>
    6a88:	e1 2c       	mov	r14, r1
    6a8a:	f1 2c       	mov	r15, r1
    6a8c:	9a cf       	rjmp	.-204    	; 0x69c2 <WorkerLineFollowerDirect+0x1e>
    6a8e:	60 e0       	ldi	r22, 0x00	; 0
    6a90:	70 e0       	ldi	r23, 0x00	; 0
    6a92:	a4 cf       	rjmp	.-184    	; 0x69dc <WorkerLineFollowerDirect+0x38>

00006a94 <InitLineFollowerDirectTask>:
//Private function prototypes
static void WorkerLineFollowerDirect(void *pvParameters);

//Function definitions
void InitLineFollowerDirectTask()
{
    6a94:	ef 92       	push	r14
    6a96:	ff 92       	push	r15
    6a98:	0f 93       	push	r16
	xTaskCreate( WorkerLineFollowerDirect, "LFdirect", 256, NULL, tskIDLE_PRIORITY+3, &LineFollowerDirectTaskHandle );	
    6a9a:	8e e2       	ldi	r24, 0x2E	; 46
    6a9c:	e8 2e       	mov	r14, r24
    6a9e:	8e e2       	ldi	r24, 0x2E	; 46
    6aa0:	f8 2e       	mov	r15, r24
    6aa2:	03 e0       	ldi	r16, 0x03	; 3
    6aa4:	20 e0       	ldi	r18, 0x00	; 0
    6aa6:	30 e0       	ldi	r19, 0x00	; 0
    6aa8:	40 e0       	ldi	r20, 0x00	; 0
    6aaa:	51 e0       	ldi	r21, 0x01	; 1
    6aac:	67 e8       	ldi	r22, 0x87	; 135
    6aae:	76 e2       	ldi	r23, 0x26	; 38
    6ab0:	82 ed       	ldi	r24, 0xD2	; 210
    6ab2:	94 e3       	ldi	r25, 0x34	; 52
    6ab4:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <xTaskCreate>
	vTaskResume(LineFollowerDirectTaskHandle);
}

void DisableLineFollowerDirectTask()
{
	vTaskSuspend(LineFollowerDirectTaskHandle);
    6ab8:	80 91 2e 2e 	lds	r24, 0x2E2E	; 0x802e2e <LineFollowerDirectTaskHandle>
    6abc:	90 91 2f 2e 	lds	r25, 0x2E2F	; 0x802e2f <LineFollowerDirectTaskHandle+0x1>
//Function definitions
void InitLineFollowerDirectTask()
{
	xTaskCreate( WorkerLineFollowerDirect, "LFdirect", 256, NULL, tskIDLE_PRIORITY+3, &LineFollowerDirectTaskHandle );	
	DisableLineFollowerDirectTask();
}
    6ac0:	0f 91       	pop	r16
    6ac2:	ff 90       	pop	r15
    6ac4:	ef 90       	pop	r14
	vTaskResume(LineFollowerDirectTaskHandle);
}

void DisableLineFollowerDirectTask()
{
	vTaskSuspend(LineFollowerDirectTaskHandle);
    6ac6:	0c 94 7b 28 	jmp	0x50f6	; 0x50f6 <vTaskSuspend>

00006aca <EnableLineFollowerDirectTask>:
	DisableLineFollowerDirectTask();
}

void EnableLineFollowerDirectTask()
{
	vTaskResume(LineFollowerDirectTaskHandle);
    6aca:	80 91 2e 2e 	lds	r24, 0x2E2E	; 0x802e2e <LineFollowerDirectTaskHandle>
    6ace:	90 91 2f 2e 	lds	r25, 0x2E2F	; 0x802e2f <LineFollowerDirectTaskHandle+0x1>
    6ad2:	0c 94 f8 28 	jmp	0x51f0	; 0x51f0 <vTaskResume>

00006ad6 <DisableLineFollowerDirectTask>:
}

void DisableLineFollowerDirectTask()
{
	vTaskSuspend(LineFollowerDirectTaskHandle);
    6ad6:	80 91 2e 2e 	lds	r24, 0x2E2E	; 0x802e2e <LineFollowerDirectTaskHandle>
    6ada:	90 91 2f 2e 	lds	r25, 0x2E2F	; 0x802e2f <LineFollowerDirectTaskHandle+0x1>
    6ade:	0c 94 7b 28 	jmp	0x50f6	; 0x50f6 <vTaskSuspend>

00006ae2 <WorkerLineFollowerSpeed>:
	StopSema=xSemaphoreCreateBinary();
	xTaskCreate( WorkerLineFollowerSpeed, "LFSpeed", 512, NULL, tskIDLE_PRIORITY+2, NULL );
}

void WorkerLineFollowerSpeed(void *pvParameters)
{
    6ae2:	cf 93       	push	r28
    6ae4:	df 93       	push	r29
    6ae6:	cd b7       	in	r28, 0x3d	; 61
    6ae8:	de b7       	in	r29, 0x3e	; 62
    6aea:	2a 97       	sbiw	r28, 0x0a	; 10
    6aec:	cd bf       	out	0x3d, r28	; 61
    6aee:	de bf       	out	0x3e, r29	; 62
	float OutL,OutR;
	ADCStruct ADCData;
	
	while(1)
	{
		xSemaphoreTake(StartSema,portMAX_DELAY);
    6af0:	6f ef       	ldi	r22, 0xFF	; 255
    6af2:	7f ef       	ldi	r23, 0xFF	; 255
    6af4:	80 91 32 2e 	lds	r24, 0x2E32	; 0x802e32 <StartSema>
    6af8:	90 91 33 2e 	lds	r25, 0x2E33	; 0x802e33 <StartSema+0x1>
    6afc:	0e 94 43 23 	call	0x4686	; 0x4686 <xQueueSemaphoreTake>
		Speed=ReqSpeed;
    6b00:	80 91 38 2e 	lds	r24, 0x2E38	; 0x802e38 <ReqSpeed>
    6b04:	90 91 39 2e 	lds	r25, 0x2E39	; 0x802e39 <ReqSpeed+0x1>
    6b08:	a0 91 3a 2e 	lds	r26, 0x2E3A	; 0x802e3a <ReqSpeed+0x2>
    6b0c:	b0 91 3b 2e 	lds	r27, 0x2E3B	; 0x802e3b <ReqSpeed+0x3>
    6b10:	80 93 34 2e 	sts	0x2E34, r24	; 0x802e34 <Speed>
    6b14:	90 93 35 2e 	sts	0x2E35, r25	; 0x802e35 <Speed+0x1>
    6b18:	a0 93 36 2e 	sts	0x2E36, r26	; 0x802e36 <Speed+0x2>
    6b1c:	b0 93 37 2e 	sts	0x2E37, r27	; 0x802e37 <Speed+0x3>
		xLastWakeTime=xTaskGetTickCount();
    6b20:	0e 94 85 29 	call	0x530a	; 0x530a <xTaskGetTickCount>
    6b24:	89 87       	std	Y+9, r24	; 0x09
    6b26:	9a 87       	std	Y+10, r25	; 0x0a
    6b28:	18 c0       	rjmp	.+48     	; 0x6b5a <WorkerLineFollowerSpeed+0x78>
    6b2a:	c5 01       	movw	r24, r10
    6b2c:	b4 01       	movw	r22, r8
    6b2e:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
			//printf ("Diff:%f\r\n",Diff);
			OutL=Speed+(Diff*(float) (LINEFOLLOW_SPEED_KP));
			OutR=Speed-(Diff*(float) (LINEFOLLOW_SPEED_KP));
			if (OutL<0) OutL=0;
			if (OutR<0) OutR=0;
			MotorSpeedSet((int16_t) OutL, (int16_t) OutR);	
    6b32:	c7 01       	movw	r24, r14
    6b34:	0e 94 31 3b 	call	0x7662	; 0x7662 <MotorSpeedSet>
			
			if (xSemaphoreTake(StopSema,0)==pdPASS)
    6b38:	60 e0       	ldi	r22, 0x00	; 0
    6b3a:	70 e0       	ldi	r23, 0x00	; 0
    6b3c:	80 91 30 2e 	lds	r24, 0x2E30	; 0x802e30 <StopSema>
    6b40:	90 91 31 2e 	lds	r25, 0x2E31	; 0x802e31 <StopSema+0x1>
    6b44:	0e 94 43 23 	call	0x4686	; 0x4686 <xQueueSemaphoreTake>
    6b48:	81 30       	cpi	r24, 0x01	; 1
    6b4a:	09 f4       	brne	.+2      	; 0x6b4e <WorkerLineFollowerSpeed+0x6c>
    6b4c:	55 c0       	rjmp	.+170    	; 0x6bf8 <WorkerLineFollowerSpeed+0x116>
			{
				MotorSpeedSet(0,0);	
				break;
			}
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
    6b4e:	6a e0       	ldi	r22, 0x0A	; 10
    6b50:	70 e0       	ldi	r23, 0x00	; 0
    6b52:	ce 01       	movw	r24, r28
    6b54:	09 96       	adiw	r24, 0x09	; 9
    6b56:	0e 94 0a 2b 	call	0x5614	; 0x5614 <vTaskDelayUntil>
		Speed=ReqSpeed;
		xLastWakeTime=xTaskGetTickCount();
		while (1)
		{
			
			ADCData=GetADCData();
    6b5a:	0e 94 b8 32 	call	0x6570	; 0x6570 <GetADCData>
    6b5e:	29 83       	std	Y+1, r18	; 0x01
    6b60:	3a 83       	std	Y+2, r19	; 0x02
    6b62:	6d 83       	std	Y+5, r22	; 0x05
    6b64:	7e 83       	std	Y+6, r23	; 0x06
			Diff=(float) (ADCData.PhotoL-ADCData.PhotoR+SensorOffset);
			//printf ("Diff:%f\r\n",Diff);
			OutL=Speed+(Diff*(float) (LINEFOLLOW_SPEED_KP));
    6b66:	69 81       	ldd	r22, Y+1	; 0x01
    6b68:	7a 81       	ldd	r23, Y+2	; 0x02
    6b6a:	8d 81       	ldd	r24, Y+5	; 0x05
    6b6c:	9e 81       	ldd	r25, Y+6	; 0x06
    6b6e:	68 1b       	sub	r22, r24
    6b70:	79 0b       	sbc	r23, r25
    6b72:	64 56       	subi	r22, 0x64	; 100
    6b74:	71 09       	sbc	r23, r1
    6b76:	07 2e       	mov	r0, r23
    6b78:	00 0c       	add	r0, r0
    6b7a:	88 0b       	sbc	r24, r24
    6b7c:	99 0b       	sbc	r25, r25
    6b7e:	0e 94 c6 46 	call	0x8d8c	; 0x8d8c <__floatsisf>
    6b82:	2d ec       	ldi	r18, 0xCD	; 205
    6b84:	3c ec       	ldi	r19, 0xCC	; 204
    6b86:	4c ec       	ldi	r20, 0xCC	; 204
    6b88:	5d e3       	ldi	r21, 0x3D	; 61
    6b8a:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    6b8e:	4b 01       	movw	r8, r22
    6b90:	5c 01       	movw	r10, r24
    6b92:	c0 90 34 2e 	lds	r12, 0x2E34	; 0x802e34 <Speed>
    6b96:	d0 90 35 2e 	lds	r13, 0x2E35	; 0x802e35 <Speed+0x1>
    6b9a:	e0 90 36 2e 	lds	r14, 0x2E36	; 0x802e36 <Speed+0x2>
    6b9e:	f0 90 37 2e 	lds	r15, 0x2E37	; 0x802e37 <Speed+0x3>
    6ba2:	a7 01       	movw	r20, r14
    6ba4:	96 01       	movw	r18, r12
    6ba6:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <__addsf3>
    6baa:	2b 01       	movw	r4, r22
    6bac:	3c 01       	movw	r6, r24
			OutR=Speed-(Diff*(float) (LINEFOLLOW_SPEED_KP));
    6bae:	a5 01       	movw	r20, r10
    6bb0:	94 01       	movw	r18, r8
    6bb2:	c7 01       	movw	r24, r14
    6bb4:	b6 01       	movw	r22, r12
    6bb6:	0e 94 aa 45 	call	0x8b54	; 0x8b54 <__subsf3>
    6bba:	4b 01       	movw	r8, r22
    6bbc:	5c 01       	movw	r10, r24
			if (OutL<0) OutL=0;
    6bbe:	20 e0       	ldi	r18, 0x00	; 0
    6bc0:	30 e0       	ldi	r19, 0x00	; 0
    6bc2:	a9 01       	movw	r20, r18
    6bc4:	c3 01       	movw	r24, r6
    6bc6:	b2 01       	movw	r22, r4
    6bc8:	0e 94 17 46 	call	0x8c2e	; 0x8c2e <__cmpsf2>
    6bcc:	87 ff       	sbrs	r24, 7
    6bce:	0e c0       	rjmp	.+28     	; 0x6bec <WorkerLineFollowerSpeed+0x10a>
    6bd0:	e1 2c       	mov	r14, r1
    6bd2:	f1 2c       	mov	r15, r1
			if (OutR<0) OutR=0;
    6bd4:	20 e0       	ldi	r18, 0x00	; 0
    6bd6:	30 e0       	ldi	r19, 0x00	; 0
    6bd8:	a9 01       	movw	r20, r18
    6bda:	c5 01       	movw	r24, r10
    6bdc:	b4 01       	movw	r22, r8
    6bde:	0e 94 17 46 	call	0x8c2e	; 0x8c2e <__cmpsf2>
    6be2:	87 ff       	sbrs	r24, 7
    6be4:	a2 cf       	rjmp	.-188    	; 0x6b2a <WorkerLineFollowerSpeed+0x48>
    6be6:	60 e0       	ldi	r22, 0x00	; 0
    6be8:	70 e0       	ldi	r23, 0x00	; 0
    6bea:	a3 cf       	rjmp	.-186    	; 0x6b32 <WorkerLineFollowerSpeed+0x50>
    6bec:	c3 01       	movw	r24, r6
    6bee:	b2 01       	movw	r22, r4
    6bf0:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
    6bf4:	7b 01       	movw	r14, r22
    6bf6:	ee cf       	rjmp	.-36     	; 0x6bd4 <WorkerLineFollowerSpeed+0xf2>
			MotorSpeedSet((int16_t) OutL, (int16_t) OutR);	
			
			if (xSemaphoreTake(StopSema,0)==pdPASS)
			{
				MotorSpeedSet(0,0);	
    6bf8:	60 e0       	ldi	r22, 0x00	; 0
    6bfa:	70 e0       	ldi	r23, 0x00	; 0
    6bfc:	80 e0       	ldi	r24, 0x00	; 0
    6bfe:	90 e0       	ldi	r25, 0x00	; 0
    6c00:	0e 94 31 3b 	call	0x7662	; 0x7662 <MotorSpeedSet>
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
		}

		
		
	}
    6c04:	75 cf       	rjmp	.-278    	; 0x6af0 <WorkerLineFollowerSpeed+0xe>

00006c06 <InitLineFollowerSpeedTask>:
void WorkerLineFollowerSpeed(void *pvParameters);


//Function definitions
void InitLineFollowerSpeedTask()
{
    6c06:	ef 92       	push	r14
    6c08:	ff 92       	push	r15
    6c0a:	0f 93       	push	r16
	StartSema=xSemaphoreCreateBinary();
    6c0c:	43 e0       	ldi	r20, 0x03	; 3
    6c0e:	60 e0       	ldi	r22, 0x00	; 0
    6c10:	81 e0       	ldi	r24, 0x01	; 1
    6c12:	0e 94 ab 20 	call	0x4156	; 0x4156 <xQueueGenericCreate>
    6c16:	80 93 32 2e 	sts	0x2E32, r24	; 0x802e32 <StartSema>
    6c1a:	90 93 33 2e 	sts	0x2E33, r25	; 0x802e33 <StartSema+0x1>
	StopSema=xSemaphoreCreateBinary();
    6c1e:	43 e0       	ldi	r20, 0x03	; 3
    6c20:	60 e0       	ldi	r22, 0x00	; 0
    6c22:	81 e0       	ldi	r24, 0x01	; 1
    6c24:	0e 94 ab 20 	call	0x4156	; 0x4156 <xQueueGenericCreate>
    6c28:	80 93 30 2e 	sts	0x2E30, r24	; 0x802e30 <StopSema>
    6c2c:	90 93 31 2e 	sts	0x2E31, r25	; 0x802e31 <StopSema+0x1>
	xTaskCreate( WorkerLineFollowerSpeed, "LFSpeed", 512, NULL, tskIDLE_PRIORITY+2, NULL );
    6c30:	e1 2c       	mov	r14, r1
    6c32:	f1 2c       	mov	r15, r1
    6c34:	02 e0       	ldi	r16, 0x02	; 2
    6c36:	20 e0       	ldi	r18, 0x00	; 0
    6c38:	30 e0       	ldi	r19, 0x00	; 0
    6c3a:	40 e0       	ldi	r20, 0x00	; 0
    6c3c:	52 e0       	ldi	r21, 0x02	; 2
    6c3e:	60 e9       	ldi	r22, 0x90	; 144
    6c40:	76 e2       	ldi	r23, 0x26	; 38
    6c42:	81 e7       	ldi	r24, 0x71	; 113
    6c44:	95 e3       	ldi	r25, 0x35	; 53
    6c46:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <xTaskCreate>
}
    6c4a:	0f 91       	pop	r16
    6c4c:	ff 90       	pop	r15
    6c4e:	ef 90       	pop	r14
    6c50:	08 95       	ret

00006c52 <StartLineFollower>:
	}
}

void StartLineFollower(float Speed)
{
	ReqSpeed=Speed;
    6c52:	60 93 38 2e 	sts	0x2E38, r22	; 0x802e38 <ReqSpeed>
    6c56:	70 93 39 2e 	sts	0x2E39, r23	; 0x802e39 <ReqSpeed+0x1>
    6c5a:	80 93 3a 2e 	sts	0x2E3A, r24	; 0x802e3a <ReqSpeed+0x2>
    6c5e:	90 93 3b 2e 	sts	0x2E3B, r25	; 0x802e3b <ReqSpeed+0x3>
	xSemaphoreGive(StartSema);
    6c62:	20 e0       	ldi	r18, 0x00	; 0
    6c64:	40 e0       	ldi	r20, 0x00	; 0
    6c66:	50 e0       	ldi	r21, 0x00	; 0
    6c68:	60 e0       	ldi	r22, 0x00	; 0
    6c6a:	70 e0       	ldi	r23, 0x00	; 0
    6c6c:	80 91 32 2e 	lds	r24, 0x2E32	; 0x802e32 <StartSema>
    6c70:	90 91 33 2e 	lds	r25, 0x2E33	; 0x802e33 <StartSema+0x1>
    6c74:	0c 94 ef 20 	jmp	0x41de	; 0x41de <xQueueGenericSend>

00006c78 <StopLineFollower>:
	
}
void StopLineFollower()
{
	xSemaphoreGive(StopSema);
    6c78:	20 e0       	ldi	r18, 0x00	; 0
    6c7a:	40 e0       	ldi	r20, 0x00	; 0
    6c7c:	50 e0       	ldi	r21, 0x00	; 0
    6c7e:	60 e0       	ldi	r22, 0x00	; 0
    6c80:	70 e0       	ldi	r23, 0x00	; 0
    6c82:	80 91 30 2e 	lds	r24, 0x2E30	; 0x802e30 <StopSema>
    6c86:	90 91 31 2e 	lds	r25, 0x2E31	; 0x802e31 <StopSema+0x1>
    6c8a:	0c 94 ef 20 	jmp	0x41de	; 0x41de <xQueueGenericSend>

00006c8e <WorkerMotion>:
	DisableMotorSpeedTask();
	
}

static void WorkerMotion(void *pvParameters)
{
    6c8e:	cf 93       	push	r28
    6c90:	df 93       	push	r29
    6c92:	cd b7       	in	r28, 0x3d	; 61
    6c94:	de b7       	in	r29, 0x3e	; 62
    6c96:	67 97       	sbiw	r28, 0x17	; 23
    6c98:	cd bf       	out	0x3d, r28	; 61
    6c9a:	de bf       	out	0x3e, r29	; 62
    6c9c:	0f c0       	rjmp	.+30     	; 0x6cbc <WorkerMotion+0x2e>

		if (MotionCmd.Cmd==CMD_DRIVE_STRAIGHT)
		{
			CmdDriveStraight(MotionCmd.Params[0],MotionCmd.Params[1]);
		}	
		else if (MotionCmd.Cmd==CMD_DRIVE_SEGMENT)
    6c9e:	82 30       	cpi	r24, 0x02	; 2
    6ca0:	09 f4       	brne	.+2      	; 0x6ca4 <WorkerMotion+0x16>
    6ca2:	ae c0       	rjmp	.+348    	; 0x6e00 <WorkerMotion+0x172>
		{
			CmdDriveSegment(MotionCmd.Params[0]);
		}
		else if (MotionCmd.Cmd==CMD_ROTATE_CENTER)
    6ca4:	83 30       	cpi	r24, 0x03	; 3
    6ca6:	09 f4       	brne	.+2      	; 0x6caa <WorkerMotion+0x1c>
    6ca8:	fa c0       	rjmp	.+500    	; 0x6e9e <WorkerMotion+0x210>
		{
			CmdRotateCenter(MotionCmd.Params[0],MotionCmd.Params[1]);	
		}			
		if (uxQueueMessagesWaiting(CmdQueue)==0) xSemaphoreGive(CmdCompleteSema);
    6caa:	80 91 3e 2e 	lds	r24, 0x2E3E	; 0x802e3e <CmdQueue>
    6cae:	90 91 3f 2e 	lds	r25, 0x2E3F	; 0x802e3f <CmdQueue+0x1>
    6cb2:	0e 94 45 25 	call	0x4a8a	; 0x4a8a <uxQueueMessagesWaiting>
    6cb6:	88 23       	and	r24, r24
    6cb8:	09 f4       	brne	.+2      	; 0x6cbc <WorkerMotion+0x2e>
    6cba:	96 c0       	rjmp	.+300    	; 0x6de8 <WorkerMotion+0x15a>
	
	float fa;
	
	while (1)
	{
		xQueueReceive(CmdQueue,&MotionCmd,portMAX_DELAY);
    6cbc:	4f ef       	ldi	r20, 0xFF	; 255
    6cbe:	5f ef       	ldi	r21, 0xFF	; 255
    6cc0:	be 01       	movw	r22, r28
    6cc2:	6f 5f       	subi	r22, 0xFF	; 255
    6cc4:	7f 4f       	sbci	r23, 0xFF	; 255
    6cc6:	80 91 3e 2e 	lds	r24, 0x2E3E	; 0x802e3e <CmdQueue>
    6cca:	90 91 3f 2e 	lds	r25, 0x2E3F	; 0x802e3f <CmdQueue+0x1>
    6cce:	0e 94 86 22 	call	0x450c	; 0x450c <xQueueReceive>

		if (MotionCmd.Cmd==CMD_DRIVE_STRAIGHT)
    6cd2:	89 81       	ldd	r24, Y+1	; 0x01
    6cd4:	81 30       	cpi	r24, 0x01	; 1
    6cd6:	19 f7       	brne	.-58     	; 0x6c9e <WorkerMotion+0x10>
		{
			CmdDriveStraight(MotionCmd.Params[0],MotionCmd.Params[1]);
    6cd8:	4e 80       	ldd	r4, Y+6	; 0x06
    6cda:	5f 80       	ldd	r5, Y+7	; 0x07
    6cdc:	68 84       	ldd	r6, Y+8	; 0x08
    6cde:	79 84       	ldd	r7, Y+9	; 0x09
    6ce0:	8a 80       	ldd	r8, Y+2	; 0x02
    6ce2:	9b 80       	ldd	r9, Y+3	; 0x03
    6ce4:	ac 80       	ldd	r10, Y+4	; 0x04
    6ce6:	bd 80       	ldd	r11, Y+5	; 0x05
	ADCStruct ADCData;
	int Cnt;
		
	float fa;
		
	xLastWakeTime = xTaskGetTickCount();
    6ce8:	0e 94 85 29 	call	0x530a	; 0x530a <xTaskGetTickCount>
    6cec:	8a 87       	std	Y+10, r24	; 0x0a
    6cee:	9b 87       	std	Y+11, r25	; 0x0b
	EnableMotorPosTask();
    6cf0:	0e 94 52 3a 	call	0x74a4	; 0x74a4 <EnableMotorPosTask>
	EnableMotorSpeedTask();
    6cf4:	0e 94 1f 3b 	call	0x763e	; 0x763e <EnableMotorSpeedTask>
	Encoder=DriverMotorGetEncoder();
    6cf8:	0e 94 52 07 	call	0xea4	; 0xea4 <DriverMotorGetEncoder>
    6cfc:	6b 01       	movw	r12, r22
    6cfe:	7c 01       	movw	r14, r24
	if (Distance>0)
    6d00:	20 e0       	ldi	r18, 0x00	; 0
    6d02:	30 e0       	ldi	r19, 0x00	; 0
    6d04:	a9 01       	movw	r20, r18
    6d06:	c5 01       	movw	r24, r10
    6d08:	b4 01       	movw	r22, r8
    6d0a:	0e 94 76 47 	call	0x8eec	; 0x8eec <__gesf2>
	{
		//Fwd
		EncoderTarget.Cnt1=Encoder.Cnt1+MM_TO_CNT(Distance);
    6d0e:	2d ec       	ldi	r18, 0xCD	; 205
    6d10:	3c e4       	ldi	r19, 0x4C	; 76
    6d12:	4f e4       	ldi	r20, 0x4F	; 79
    6d14:	53 e4       	ldi	r21, 0x43	; 67
		
	xLastWakeTime = xTaskGetTickCount();
	EnableMotorPosTask();
	EnableMotorSpeedTask();
	Encoder=DriverMotorGetEncoder();
	if (Distance>0)
    6d16:	18 16       	cp	r1, r24
    6d18:	0c f0       	brlt	.+2      	; 0x6d1c <WorkerMotion+0x8e>
    6d1a:	50 c1       	rjmp	.+672    	; 0x6fbc <WorkerMotion+0x32e>
	{
		//Fwd
		EncoderTarget.Cnt1=Encoder.Cnt1+MM_TO_CNT(Distance);
    6d1c:	c5 01       	movw	r24, r10
    6d1e:	b4 01       	movw	r22, r8
    6d20:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    6d24:	20 e0       	ldi	r18, 0x00	; 0
    6d26:	30 e0       	ldi	r19, 0x00	; 0
    6d28:	44 eb       	ldi	r20, 0xB4	; 180
    6d2a:	53 e4       	ldi	r21, 0x43	; 67
    6d2c:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    6d30:	20 e0       	ldi	r18, 0x00	; 0
    6d32:	30 e0       	ldi	r19, 0x00	; 0
    6d34:	40 e4       	ldi	r20, 0x40	; 64
    6d36:	50 e4       	ldi	r21, 0x40	; 64
    6d38:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    6d3c:	6c 8b       	std	Y+20, r22	; 0x14
    6d3e:	7d 8b       	std	Y+21, r23	; 0x15
    6d40:	8e 8b       	std	Y+22, r24	; 0x16
    6d42:	9f 8b       	std	Y+23, r25	; 0x17
    6d44:	b6 01       	movw	r22, r12
    6d46:	dd 0c       	add	r13, r13
    6d48:	88 0b       	sbc	r24, r24
    6d4a:	99 0b       	sbc	r25, r25
    6d4c:	0e 94 c6 46 	call	0x8d8c	; 0x8d8c <__floatsisf>
    6d50:	9b 01       	movw	r18, r22
    6d52:	ac 01       	movw	r20, r24
    6d54:	6c 89       	ldd	r22, Y+20	; 0x14
    6d56:	7d 89       	ldd	r23, Y+21	; 0x15
    6d58:	8e 89       	ldd	r24, Y+22	; 0x16
    6d5a:	9f 89       	ldd	r25, Y+23	; 0x17
    6d5c:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <__addsf3>
    6d60:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
    6d64:	8b 01       	movw	r16, r22
				
		MotorSpeedSet(MM_TO_CNT(Speed),MM_TO_CNT(Speed));
    6d66:	2d ec       	ldi	r18, 0xCD	; 205
    6d68:	3c e4       	ldi	r19, 0x4C	; 76
    6d6a:	4f e4       	ldi	r20, 0x4F	; 79
    6d6c:	53 e4       	ldi	r21, 0x43	; 67
    6d6e:	c3 01       	movw	r24, r6
    6d70:	b2 01       	movw	r22, r4
    6d72:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    6d76:	20 e0       	ldi	r18, 0x00	; 0
    6d78:	30 e0       	ldi	r19, 0x00	; 0
    6d7a:	44 eb       	ldi	r20, 0xB4	; 180
    6d7c:	53 e4       	ldi	r21, 0x43	; 67
    6d7e:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    6d82:	20 e0       	ldi	r18, 0x00	; 0
    6d84:	30 e0       	ldi	r19, 0x00	; 0
    6d86:	40 e4       	ldi	r20, 0x40	; 64
    6d88:	50 e4       	ldi	r21, 0x40	; 64
    6d8a:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    6d8e:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
    6d92:	dc 01       	movw	r26, r24
    6d94:	cb 01       	movw	r24, r22
    6d96:	bc 01       	movw	r22, r24
    6d98:	0e 94 31 3b 	call	0x7662	; 0x7662 <MotorSpeedSet>
    6d9c:	09 c0       	rjmp	.+18     	; 0x6db0 <WorkerMotion+0x122>
		Encoder=DriverMotorGetEncoder();
				
		//Stop if target distance is reached
		if (Distance>0)
		{//Fwd
			if (Encoder.Cnt1>EncoderTarget.Cnt1) break;
    6d9e:	0c 15       	cp	r16, r12
    6da0:	1d 05       	cpc	r17, r13
    6da2:	b4 f0       	brlt	.+44     	; 0x6dd0 <WorkerMotion+0x142>
		else
		{//Reverse
			if (Encoder.Cnt1<EncoderTarget.Cnt1) break;
		}
				
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    6da4:	6a e0       	ldi	r22, 0x0A	; 10
    6da6:	70 e0       	ldi	r23, 0x00	; 0
    6da8:	ce 01       	movw	r24, r28
    6daa:	0a 96       	adiw	r24, 0x0a	; 10
    6dac:	0e 94 0a 2b 	call	0x5614	; 0x5614 <vTaskDelayUntil>
		EncoderTarget.Cnt1=Encoder.Cnt1+MM_TO_CNT(Distance);
		MotorSpeedSet(-MM_TO_CNT(Speed),-MM_TO_CNT(Speed));
	}
	while (1)
	{
		Encoder=DriverMotorGetEncoder();
    6db0:	0e 94 52 07 	call	0xea4	; 0xea4 <DriverMotorGetEncoder>
    6db4:	6b 01       	movw	r12, r22
    6db6:	7c 01       	movw	r14, r24
				
		//Stop if target distance is reached
		if (Distance>0)
    6db8:	20 e0       	ldi	r18, 0x00	; 0
    6dba:	30 e0       	ldi	r19, 0x00	; 0
    6dbc:	a9 01       	movw	r20, r18
    6dbe:	c5 01       	movw	r24, r10
    6dc0:	b4 01       	movw	r22, r8
    6dc2:	0e 94 76 47 	call	0x8eec	; 0x8eec <__gesf2>
    6dc6:	18 16       	cp	r1, r24
    6dc8:	54 f3       	brlt	.-44     	; 0x6d9e <WorkerMotion+0x110>
		{//Fwd
			if (Encoder.Cnt1>EncoderTarget.Cnt1) break;
		}
		else
		{//Reverse
			if (Encoder.Cnt1<EncoderTarget.Cnt1) break;
    6dca:	c0 16       	cp	r12, r16
    6dcc:	d1 06       	cpc	r13, r17
    6dce:	54 f7       	brge	.-44     	; 0x6da4 <WorkerMotion+0x116>
			if (Encoder.Cnt1>EncoderTarget.Cnt1) break;
		}
		
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
	}
	DisableMotorPosTask();
    6dd0:	0e 94 6b 3a 	call	0x74d6	; 0x74d6 <DisableMotorPosTask>
	DisableMotorSpeedTask();
    6dd4:	0e 94 2b 3b 	call	0x7656	; 0x7656 <DisableMotorSpeedTask>
		}
		else if (MotionCmd.Cmd==CMD_ROTATE_CENTER)
		{
			CmdRotateCenter(MotionCmd.Params[0],MotionCmd.Params[1]);	
		}			
		if (uxQueueMessagesWaiting(CmdQueue)==0) xSemaphoreGive(CmdCompleteSema);
    6dd8:	80 91 3e 2e 	lds	r24, 0x2E3E	; 0x802e3e <CmdQueue>
    6ddc:	90 91 3f 2e 	lds	r25, 0x2E3F	; 0x802e3f <CmdQueue+0x1>
    6de0:	0e 94 45 25 	call	0x4a8a	; 0x4a8a <uxQueueMessagesWaiting>
    6de4:	81 11       	cpse	r24, r1
    6de6:	6a cf       	rjmp	.-300    	; 0x6cbc <WorkerMotion+0x2e>
    6de8:	20 e0       	ldi	r18, 0x00	; 0
    6dea:	40 e0       	ldi	r20, 0x00	; 0
    6dec:	50 e0       	ldi	r21, 0x00	; 0
    6dee:	60 e0       	ldi	r22, 0x00	; 0
    6df0:	70 e0       	ldi	r23, 0x00	; 0
    6df2:	80 91 3c 2e 	lds	r24, 0x2E3C	; 0x802e3c <CmdCompleteSema>
    6df6:	90 91 3d 2e 	lds	r25, 0x2E3D	; 0x802e3d <CmdCompleteSema+0x1>
    6dfa:	0e 94 ef 20 	call	0x41de	; 0x41de <xQueueGenericSend>
    6dfe:	5e cf       	rjmp	.-324    	; 0x6cbc <WorkerMotion+0x2e>
		{
			CmdDriveStraight(MotionCmd.Params[0],MotionCmd.Params[1]);
		}	
		else if (MotionCmd.Cmd==CMD_DRIVE_SEGMENT)
		{
			CmdDriveSegment(MotionCmd.Params[0]);
    6e00:	ca 80       	ldd	r12, Y+2	; 0x02
    6e02:	db 80       	ldd	r13, Y+3	; 0x03
    6e04:	ec 80       	ldd	r14, Y+4	; 0x04
    6e06:	fd 80       	ldd	r15, Y+5	; 0x05
	ADCStruct ADCData;
	int Cnt;
			
	float fa;
			
	xLastWakeTime = xTaskGetTickCount();
    6e08:	0e 94 85 29 	call	0x530a	; 0x530a <xTaskGetTickCount>
    6e0c:	8a 8b       	std	Y+18, r24	; 0x12
    6e0e:	9b 8b       	std	Y+19, r25	; 0x13
	EnableMotorPosTask();
    6e10:	0e 94 52 3a 	call	0x74a4	; 0x74a4 <EnableMotorPosTask>
	EnableMotorSpeedTask();
    6e14:	0e 94 1f 3b 	call	0x763e	; 0x763e <EnableMotorSpeedTask>
	Encoder=DriverMotorGetEncoder();
    6e18:	0e 94 52 07 	call	0xea4	; 0xea4 <DriverMotorGetEncoder>
				
	StartLineFollower(MM_TO_CNT(Speed));
    6e1c:	2d ec       	ldi	r18, 0xCD	; 205
    6e1e:	3c e4       	ldi	r19, 0x4C	; 76
    6e20:	4f e4       	ldi	r20, 0x4F	; 79
    6e22:	53 e4       	ldi	r21, 0x43	; 67
    6e24:	c7 01       	movw	r24, r14
    6e26:	b6 01       	movw	r22, r12
    6e28:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    6e2c:	20 e0       	ldi	r18, 0x00	; 0
    6e2e:	30 e0       	ldi	r19, 0x00	; 0
    6e30:	44 eb       	ldi	r20, 0xB4	; 180
    6e32:	53 e4       	ldi	r21, 0x43	; 67
    6e34:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    6e38:	20 e0       	ldi	r18, 0x00	; 0
    6e3a:	30 e0       	ldi	r19, 0x00	; 0
    6e3c:	40 e4       	ldi	r20, 0x40	; 64
    6e3e:	50 e4       	ldi	r21, 0x40	; 64
    6e40:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    6e44:	0e 94 29 36 	call	0x6c52	; 0x6c52 <StartLineFollower>

	Cnt=0;
    6e48:	00 e0       	ldi	r16, 0x00	; 0
    6e4a:	10 e0       	ldi	r17, 0x00	; 0
    6e4c:	0b c0       	rjmp	.+22     	; 0x6e64 <WorkerMotion+0x1d6>
	while (1)
	{
		ADCData=GetADCData();
		if ((ADCData.PhotoL+ADCData.PhotoR)/2>LINEFOLLOW_THRESHOLD)
		{
			Cnt++;
    6e4e:	0f 5f       	subi	r16, 0xFF	; 255
    6e50:	1f 4f       	sbci	r17, 0xFF	; 255
			if (Cnt>LINEFOLLOW_THRESHOLD_CNT) break;
    6e52:	05 31       	cpi	r16, 0x15	; 21
    6e54:	11 05       	cpc	r17, r1
    6e56:	e4 f4       	brge	.+56     	; 0x6e90 <WorkerMotion+0x202>
		}
		else
		Cnt=0;
					
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    6e58:	6a e0       	ldi	r22, 0x0A	; 10
    6e5a:	70 e0       	ldi	r23, 0x00	; 0
    6e5c:	ce 01       	movw	r24, r28
    6e5e:	42 96       	adiw	r24, 0x12	; 18
    6e60:	0e 94 0a 2b 	call	0x5614	; 0x5614 <vTaskDelayUntil>
	StartLineFollower(MM_TO_CNT(Speed));

	Cnt=0;
	while (1)
	{
		ADCData=GetADCData();
    6e64:	0e 94 b8 32 	call	0x6570	; 0x6570 <GetADCData>
    6e68:	2a 87       	std	Y+10, r18	; 0x0a
    6e6a:	3b 87       	std	Y+11, r19	; 0x0b
    6e6c:	4c 87       	std	Y+12, r20	; 0x0c
    6e6e:	5d 87       	std	Y+13, r21	; 0x0d
    6e70:	6e 87       	std	Y+14, r22	; 0x0e
    6e72:	7f 87       	std	Y+15, r23	; 0x0f
    6e74:	88 8b       	std	Y+16, r24	; 0x10
    6e76:	99 8b       	std	Y+17, r25	; 0x11
		if ((ADCData.PhotoL+ADCData.PhotoR)/2>LINEFOLLOW_THRESHOLD)
    6e78:	2a 85       	ldd	r18, Y+10	; 0x0a
    6e7a:	3b 85       	ldd	r19, Y+11	; 0x0b
    6e7c:	8e 85       	ldd	r24, Y+14	; 0x0e
    6e7e:	9f 85       	ldd	r25, Y+15	; 0x0f
    6e80:	82 0f       	add	r24, r18
    6e82:	93 1f       	adc	r25, r19
    6e84:	8a 38       	cpi	r24, 0x8A	; 138
    6e86:	93 41       	sbci	r25, 0x13	; 19
    6e88:	14 f7       	brge	.-60     	; 0x6e4e <WorkerMotion+0x1c0>
		{
			Cnt++;
			if (Cnt>LINEFOLLOW_THRESHOLD_CNT) break;
		}
		else
		Cnt=0;
    6e8a:	00 e0       	ldi	r16, 0x00	; 0
    6e8c:	10 e0       	ldi	r17, 0x00	; 0
    6e8e:	e4 cf       	rjmp	.-56     	; 0x6e58 <WorkerMotion+0x1ca>
					
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
	}
	StopLineFollower();
    6e90:	0e 94 3c 36 	call	0x6c78	; 0x6c78 <StopLineFollower>
	DisableMotorPosTask();
    6e94:	0e 94 6b 3a 	call	0x74d6	; 0x74d6 <DisableMotorPosTask>
	DisableMotorSpeedTask();
    6e98:	0e 94 2b 3b 	call	0x7656	; 0x7656 <DisableMotorSpeedTask>
    6e9c:	06 cf       	rjmp	.-500    	; 0x6caa <WorkerMotion+0x1c>
		{
			CmdDriveSegment(MotionCmd.Params[0]);
		}
		else if (MotionCmd.Cmd==CMD_ROTATE_CENTER)
		{
			CmdRotateCenter(MotionCmd.Params[0],MotionCmd.Params[1]);	
    6e9e:	4e 80       	ldd	r4, Y+6	; 0x06
    6ea0:	5f 80       	ldd	r5, Y+7	; 0x07
    6ea2:	68 84       	ldd	r6, Y+8	; 0x08
    6ea4:	79 84       	ldd	r7, Y+9	; 0x09
    6ea6:	8a 80       	ldd	r8, Y+2	; 0x02
    6ea8:	9b 80       	ldd	r9, Y+3	; 0x03
    6eaa:	ac 80       	ldd	r10, Y+4	; 0x04
    6eac:	bd 80       	ldd	r11, Y+5	; 0x05
	ADCStruct ADCData;
	int Cnt;
		
	float fa;
	
	xLastWakeTime = xTaskGetTickCount();
    6eae:	0e 94 85 29 	call	0x530a	; 0x530a <xTaskGetTickCount>
    6eb2:	8a 87       	std	Y+10, r24	; 0x0a
    6eb4:	9b 87       	std	Y+11, r25	; 0x0b
	EnableMotorPosTask();
    6eb6:	0e 94 52 3a 	call	0x74a4	; 0x74a4 <EnableMotorPosTask>
	EnableMotorSpeedTask();
    6eba:	0e 94 1f 3b 	call	0x763e	; 0x763e <EnableMotorSpeedTask>
	Encoder=DriverMotorGetEncoder();
    6ebe:	0e 94 52 07 	call	0xea4	; 0xea4 <DriverMotorGetEncoder>
    6ec2:	6b 01       	movw	r12, r22
    6ec4:	7c 01       	movw	r14, r24
	fa=WHEEL_DISTANCE*3.14/360*Angle; //Calculate wheel distance to travel
    6ec6:	26 ec       	ldi	r18, 0xC6	; 198
    6ec8:	39 ed       	ldi	r19, 0xD9	; 217
    6eca:	47 e7       	ldi	r20, 0x77	; 119
    6ecc:	5f e3       	ldi	r21, 0x3F	; 63
    6ece:	c5 01       	movw	r24, r10
    6ed0:	b4 01       	movw	r22, r8
    6ed2:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    6ed6:	4b 01       	movw	r8, r22
    6ed8:	5c 01       	movw	r10, r24
	if (fa>0)
    6eda:	20 e0       	ldi	r18, 0x00	; 0
    6edc:	30 e0       	ldi	r19, 0x00	; 0
    6ede:	a9 01       	movw	r20, r18
    6ee0:	0e 94 76 47 	call	0x8eec	; 0x8eec <__gesf2>
    6ee4:	18 16       	cp	r1, r24
    6ee6:	0c f0       	brlt	.+2      	; 0x6eea <WorkerMotion+0x25c>
    6ee8:	ab c0       	rjmp	.+342    	; 0x7040 <WorkerMotion+0x3b2>
	{
		//Fwd
		EncoderTarget.Cnt1=(float) Encoder.Cnt1-MM_TO_CNT(fa);
    6eea:	b6 01       	movw	r22, r12
    6eec:	dd 0c       	add	r13, r13
    6eee:	88 0b       	sbc	r24, r24
    6ef0:	99 0b       	sbc	r25, r25
    6ef2:	0e 94 c6 46 	call	0x8d8c	; 0x8d8c <__floatsisf>
    6ef6:	6b 01       	movw	r12, r22
    6ef8:	7c 01       	movw	r14, r24
    6efa:	2d ec       	ldi	r18, 0xCD	; 205
    6efc:	3c e4       	ldi	r19, 0x4C	; 76
    6efe:	4f e4       	ldi	r20, 0x4F	; 79
    6f00:	53 e4       	ldi	r21, 0x43	; 67
    6f02:	c5 01       	movw	r24, r10
    6f04:	b4 01       	movw	r22, r8
    6f06:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    6f0a:	20 e0       	ldi	r18, 0x00	; 0
    6f0c:	30 e0       	ldi	r19, 0x00	; 0
    6f0e:	44 eb       	ldi	r20, 0xB4	; 180
    6f10:	53 e4       	ldi	r21, 0x43	; 67
    6f12:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    6f16:	20 e0       	ldi	r18, 0x00	; 0
    6f18:	30 e0       	ldi	r19, 0x00	; 0
    6f1a:	40 e4       	ldi	r20, 0x40	; 64
    6f1c:	50 e4       	ldi	r21, 0x40	; 64
    6f1e:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    6f22:	9b 01       	movw	r18, r22
    6f24:	ac 01       	movw	r20, r24
    6f26:	c7 01       	movw	r24, r14
    6f28:	b6 01       	movw	r22, r12
    6f2a:	0e 94 aa 45 	call	0x8b54	; 0x8b54 <__subsf3>
    6f2e:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
    6f32:	8b 01       	movw	r16, r22
		MotorSpeedSet(-MM_TO_CNT(Speed),MM_TO_CNT(Speed));
    6f34:	2d ec       	ldi	r18, 0xCD	; 205
    6f36:	3c e4       	ldi	r19, 0x4C	; 76
    6f38:	4f e4       	ldi	r20, 0x4F	; 79
    6f3a:	53 e4       	ldi	r21, 0x43	; 67
    6f3c:	c3 01       	movw	r24, r6
    6f3e:	b2 01       	movw	r22, r4
    6f40:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    6f44:	20 e0       	ldi	r18, 0x00	; 0
    6f46:	30 e0       	ldi	r19, 0x00	; 0
    6f48:	44 eb       	ldi	r20, 0xB4	; 180
    6f4a:	53 e4       	ldi	r21, 0x43	; 67
    6f4c:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    6f50:	20 e0       	ldi	r18, 0x00	; 0
    6f52:	30 e0       	ldi	r19, 0x00	; 0
    6f54:	40 e4       	ldi	r20, 0x40	; 64
    6f56:	50 e4       	ldi	r21, 0x40	; 64
    6f58:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    6f5c:	2b 01       	movw	r4, r22
    6f5e:	3c 01       	movw	r6, r24
    6f60:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
    6f64:	6b 01       	movw	r12, r22
    6f66:	7c 01       	movw	r14, r24
    6f68:	c3 01       	movw	r24, r6
    6f6a:	b2 01       	movw	r22, r4
    6f6c:	90 58       	subi	r25, 0x80	; 128
    6f6e:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
    6f72:	dc 01       	movw	r26, r24
    6f74:	cb 01       	movw	r24, r22
    6f76:	b6 01       	movw	r22, r12
    6f78:	0e 94 31 3b 	call	0x7662	; 0x7662 <MotorSpeedSet>
    6f7c:	0a c0       	rjmp	.+20     	; 0x6f92 <WorkerMotion+0x304>
		Encoder=DriverMotorGetEncoder();
		
		//Stop if target distance is reached
		if (fa>0)
		{//Fwd
			if (Encoder.Cnt1<EncoderTarget.Cnt1) break;
    6f7e:	c0 16       	cp	r12, r16
    6f80:	d1 06       	cpc	r13, r17
    6f82:	0c f4       	brge	.+2      	; 0x6f86 <WorkerMotion+0x2f8>
    6f84:	25 cf       	rjmp	.-438    	; 0x6dd0 <WorkerMotion+0x142>
		else
		{//Reverse
			if (Encoder.Cnt1>EncoderTarget.Cnt1) break;
		}
		
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    6f86:	6a e0       	ldi	r22, 0x0A	; 10
    6f88:	70 e0       	ldi	r23, 0x00	; 0
    6f8a:	ce 01       	movw	r24, r28
    6f8c:	0a 96       	adiw	r24, 0x0a	; 10
    6f8e:	0e 94 0a 2b 	call	0x5614	; 0x5614 <vTaskDelayUntil>
		EncoderTarget.Cnt1=(float) Encoder.Cnt1-MM_TO_CNT(fa);
		MotorSpeedSet(MM_TO_CNT(Speed),-MM_TO_CNT(Speed));
	}
	while (1)
	{
		Encoder=DriverMotorGetEncoder();
    6f92:	0e 94 52 07 	call	0xea4	; 0xea4 <DriverMotorGetEncoder>
    6f96:	6b 01       	movw	r12, r22
    6f98:	7c 01       	movw	r14, r24
		
		//Stop if target distance is reached
		if (fa>0)
    6f9a:	20 e0       	ldi	r18, 0x00	; 0
    6f9c:	30 e0       	ldi	r19, 0x00	; 0
    6f9e:	a9 01       	movw	r20, r18
    6fa0:	c5 01       	movw	r24, r10
    6fa2:	b4 01       	movw	r22, r8
    6fa4:	0e 94 76 47 	call	0x8eec	; 0x8eec <__gesf2>
    6fa8:	18 16       	cp	r1, r24
    6faa:	4c f3       	brlt	.-46     	; 0x6f7e <WorkerMotion+0x2f0>
		{//Fwd
			if (Encoder.Cnt1<EncoderTarget.Cnt1) break;
		}
		else
		{//Reverse
			if (Encoder.Cnt1>EncoderTarget.Cnt1) break;
    6fac:	0c 15       	cp	r16, r12
    6fae:	1d 05       	cpc	r17, r13
    6fb0:	54 f7       	brge	.-44     	; 0x6f86 <WorkerMotion+0x2f8>
		}
		
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
	}
	DisableMotorPosTask();
    6fb2:	0e 94 6b 3a 	call	0x74d6	; 0x74d6 <DisableMotorPosTask>
	DisableMotorSpeedTask();
    6fb6:	0e 94 2b 3b 	call	0x7656	; 0x7656 <DisableMotorSpeedTask>
    6fba:	0e cf       	rjmp	.-484    	; 0x6dd8 <WorkerMotion+0x14a>
		MotorSpeedSet(MM_TO_CNT(Speed),MM_TO_CNT(Speed));
	}
	else
	{
		//Reverse
		EncoderTarget.Cnt1=Encoder.Cnt1+MM_TO_CNT(Distance);
    6fbc:	c5 01       	movw	r24, r10
    6fbe:	b4 01       	movw	r22, r8
    6fc0:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    6fc4:	20 e0       	ldi	r18, 0x00	; 0
    6fc6:	30 e0       	ldi	r19, 0x00	; 0
    6fc8:	44 eb       	ldi	r20, 0xB4	; 180
    6fca:	53 e4       	ldi	r21, 0x43	; 67
    6fcc:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    6fd0:	20 e0       	ldi	r18, 0x00	; 0
    6fd2:	30 e0       	ldi	r19, 0x00	; 0
    6fd4:	40 e4       	ldi	r20, 0x40	; 64
    6fd6:	50 e4       	ldi	r21, 0x40	; 64
    6fd8:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    6fdc:	6c 8b       	std	Y+20, r22	; 0x14
    6fde:	7d 8b       	std	Y+21, r23	; 0x15
    6fe0:	8e 8b       	std	Y+22, r24	; 0x16
    6fe2:	9f 8b       	std	Y+23, r25	; 0x17
    6fe4:	b6 01       	movw	r22, r12
    6fe6:	dd 0c       	add	r13, r13
    6fe8:	88 0b       	sbc	r24, r24
    6fea:	99 0b       	sbc	r25, r25
    6fec:	0e 94 c6 46 	call	0x8d8c	; 0x8d8c <__floatsisf>
    6ff0:	9b 01       	movw	r18, r22
    6ff2:	ac 01       	movw	r20, r24
    6ff4:	6c 89       	ldd	r22, Y+20	; 0x14
    6ff6:	7d 89       	ldd	r23, Y+21	; 0x15
    6ff8:	8e 89       	ldd	r24, Y+22	; 0x16
    6ffa:	9f 89       	ldd	r25, Y+23	; 0x17
    6ffc:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <__addsf3>
    7000:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
    7004:	8b 01       	movw	r16, r22
		MotorSpeedSet(-MM_TO_CNT(Speed),-MM_TO_CNT(Speed));
    7006:	2d ec       	ldi	r18, 0xCD	; 205
    7008:	3c e4       	ldi	r19, 0x4C	; 76
    700a:	4f e4       	ldi	r20, 0x4F	; 79
    700c:	53 e4       	ldi	r21, 0x43	; 67
    700e:	c3 01       	movw	r24, r6
    7010:	b2 01       	movw	r22, r4
    7012:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    7016:	20 e0       	ldi	r18, 0x00	; 0
    7018:	30 e0       	ldi	r19, 0x00	; 0
    701a:	44 eb       	ldi	r20, 0xB4	; 180
    701c:	53 e4       	ldi	r21, 0x43	; 67
    701e:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    7022:	20 e0       	ldi	r18, 0x00	; 0
    7024:	30 e0       	ldi	r19, 0x00	; 0
    7026:	40 e4       	ldi	r20, 0x40	; 64
    7028:	50 e4       	ldi	r21, 0x40	; 64
    702a:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    702e:	90 58       	subi	r25, 0x80	; 128
    7030:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
    7034:	dc 01       	movw	r26, r24
    7036:	cb 01       	movw	r24, r22
    7038:	bc 01       	movw	r22, r24
    703a:	0e 94 31 3b 	call	0x7662	; 0x7662 <MotorSpeedSet>
    703e:	b8 ce       	rjmp	.-656    	; 0x6db0 <WorkerMotion+0x122>
		MotorSpeedSet(-MM_TO_CNT(Speed),MM_TO_CNT(Speed));
	}
	else
	{
		//Reverse
		EncoderTarget.Cnt1=(float) Encoder.Cnt1-MM_TO_CNT(fa);
    7040:	b6 01       	movw	r22, r12
    7042:	dd 0c       	add	r13, r13
    7044:	88 0b       	sbc	r24, r24
    7046:	99 0b       	sbc	r25, r25
    7048:	0e 94 c6 46 	call	0x8d8c	; 0x8d8c <__floatsisf>
    704c:	6b 01       	movw	r12, r22
    704e:	7c 01       	movw	r14, r24
    7050:	2d ec       	ldi	r18, 0xCD	; 205
    7052:	3c e4       	ldi	r19, 0x4C	; 76
    7054:	4f e4       	ldi	r20, 0x4F	; 79
    7056:	53 e4       	ldi	r21, 0x43	; 67
    7058:	c5 01       	movw	r24, r10
    705a:	b4 01       	movw	r22, r8
    705c:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    7060:	20 e0       	ldi	r18, 0x00	; 0
    7062:	30 e0       	ldi	r19, 0x00	; 0
    7064:	44 eb       	ldi	r20, 0xB4	; 180
    7066:	53 e4       	ldi	r21, 0x43	; 67
    7068:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    706c:	20 e0       	ldi	r18, 0x00	; 0
    706e:	30 e0       	ldi	r19, 0x00	; 0
    7070:	40 e4       	ldi	r20, 0x40	; 64
    7072:	50 e4       	ldi	r21, 0x40	; 64
    7074:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    7078:	9b 01       	movw	r18, r22
    707a:	ac 01       	movw	r20, r24
    707c:	c7 01       	movw	r24, r14
    707e:	b6 01       	movw	r22, r12
    7080:	0e 94 aa 45 	call	0x8b54	; 0x8b54 <__subsf3>
    7084:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
    7088:	8b 01       	movw	r16, r22
		MotorSpeedSet(MM_TO_CNT(Speed),-MM_TO_CNT(Speed));
    708a:	2d ec       	ldi	r18, 0xCD	; 205
    708c:	3c e4       	ldi	r19, 0x4C	; 76
    708e:	4f e4       	ldi	r20, 0x4F	; 79
    7090:	53 e4       	ldi	r21, 0x43	; 67
    7092:	c3 01       	movw	r24, r6
    7094:	b2 01       	movw	r22, r4
    7096:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    709a:	20 e0       	ldi	r18, 0x00	; 0
    709c:	30 e0       	ldi	r19, 0x00	; 0
    709e:	44 eb       	ldi	r20, 0xB4	; 180
    70a0:	53 e4       	ldi	r21, 0x43	; 67
    70a2:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    70a6:	20 e0       	ldi	r18, 0x00	; 0
    70a8:	30 e0       	ldi	r19, 0x00	; 0
    70aa:	40 e4       	ldi	r20, 0x40	; 64
    70ac:	50 e4       	ldi	r21, 0x40	; 64
    70ae:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    70b2:	2b 01       	movw	r4, r22
    70b4:	3c 01       	movw	r6, r24
    70b6:	90 58       	subi	r25, 0x80	; 128
    70b8:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
    70bc:	6b 01       	movw	r12, r22
    70be:	7c 01       	movw	r14, r24
    70c0:	c3 01       	movw	r24, r6
    70c2:	b2 01       	movw	r22, r4
    70c4:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
    70c8:	dc 01       	movw	r26, r24
    70ca:	cb 01       	movw	r24, r22
    70cc:	b6 01       	movw	r22, r12
    70ce:	0e 94 31 3b 	call	0x7662	; 0x7662 <MotorSpeedSet>
    70d2:	5f cf       	rjmp	.-322    	; 0x6f92 <WorkerMotion+0x304>

000070d4 <InitMotionTask>:
static void CmdDriveStraight(float Distance, float Speed);
static void CmdDriveSegment(float Speed);

//Function definitions
void InitMotionTask()
{
    70d4:	ef 92       	push	r14
    70d6:	ff 92       	push	r15
    70d8:	0f 93       	push	r16
	xTaskCreate( WorkerMotion, "motion", 256, NULL, tskIDLE_PRIORITY+3, NULL );	
    70da:	e1 2c       	mov	r14, r1
    70dc:	f1 2c       	mov	r15, r1
    70de:	03 e0       	ldi	r16, 0x03	; 3
    70e0:	20 e0       	ldi	r18, 0x00	; 0
    70e2:	30 e0       	ldi	r19, 0x00	; 0
    70e4:	40 e0       	ldi	r20, 0x00	; 0
    70e6:	51 e0       	ldi	r21, 0x01	; 1
    70e8:	68 e9       	ldi	r22, 0x98	; 152
    70ea:	76 e2       	ldi	r23, 0x26	; 38
    70ec:	87 e4       	ldi	r24, 0x47	; 71
    70ee:	96 e3       	ldi	r25, 0x36	; 54
    70f0:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <xTaskCreate>
	CmdQueue=xQueueCreate(1,sizeof(MotionCmdStruct));
    70f4:	40 e0       	ldi	r20, 0x00	; 0
    70f6:	69 e0       	ldi	r22, 0x09	; 9
    70f8:	81 e0       	ldi	r24, 0x01	; 1
    70fa:	0e 94 ab 20 	call	0x4156	; 0x4156 <xQueueGenericCreate>
    70fe:	80 93 3e 2e 	sts	0x2E3E, r24	; 0x802e3e <CmdQueue>
    7102:	90 93 3f 2e 	sts	0x2E3F, r25	; 0x802e3f <CmdQueue+0x1>
	CmdCompleteSema=xSemaphoreCreateBinary();
    7106:	43 e0       	ldi	r20, 0x03	; 3
    7108:	60 e0       	ldi	r22, 0x00	; 0
    710a:	81 e0       	ldi	r24, 0x01	; 1
    710c:	0e 94 ab 20 	call	0x4156	; 0x4156 <xQueueGenericCreate>
    7110:	80 93 3c 2e 	sts	0x2E3C, r24	; 0x802e3c <CmdCompleteSema>
    7114:	90 93 3d 2e 	sts	0x2E3D, r25	; 0x802e3d <CmdCompleteSema+0x1>
}
    7118:	0f 91       	pop	r16
    711a:	ff 90       	pop	r15
    711c:	ef 90       	pop	r14
    711e:	08 95       	ret

00007120 <DriveStraight>:
		
	}
}

void DriveStraight(float Distance, float Speed)
{
    7120:	cf 93       	push	r28
    7122:	df 93       	push	r29
    7124:	cd b7       	in	r28, 0x3d	; 61
    7126:	de b7       	in	r29, 0x3e	; 62
    7128:	29 97       	sbiw	r28, 0x09	; 9
    712a:	cd bf       	out	0x3d, r28	; 61
    712c:	de bf       	out	0x3e, r29	; 62
	MotionCmdStruct MotionCmd;
	MotionCmd.Cmd=CMD_DRIVE_STRAIGHT;
    712e:	e1 e0       	ldi	r30, 0x01	; 1
    7130:	e9 83       	std	Y+1, r30	; 0x01
	MotionCmd.Params[0]=Distance;
    7132:	6a 83       	std	Y+2, r22	; 0x02
    7134:	7b 83       	std	Y+3, r23	; 0x03
    7136:	8c 83       	std	Y+4, r24	; 0x04
    7138:	9d 83       	std	Y+5, r25	; 0x05
	MotionCmd.Params[1]=Speed;
    713a:	2e 83       	std	Y+6, r18	; 0x06
    713c:	3f 83       	std	Y+7, r19	; 0x07
    713e:	48 87       	std	Y+8, r20	; 0x08
    7140:	59 87       	std	Y+9, r21	; 0x09
	xQueueSendToBack(CmdQueue,&MotionCmd,portMAX_DELAY);	//Issue command
    7142:	20 e0       	ldi	r18, 0x00	; 0
    7144:	4f ef       	ldi	r20, 0xFF	; 255
    7146:	5f ef       	ldi	r21, 0xFF	; 255
    7148:	be 01       	movw	r22, r28
    714a:	6f 5f       	subi	r22, 0xFF	; 255
    714c:	7f 4f       	sbci	r23, 0xFF	; 255
    714e:	80 91 3e 2e 	lds	r24, 0x2E3E	; 0x802e3e <CmdQueue>
    7152:	90 91 3f 2e 	lds	r25, 0x2E3F	; 0x802e3f <CmdQueue+0x1>
    7156:	0e 94 ef 20 	call	0x41de	; 0x41de <xQueueGenericSend>
	xSemaphoreTake(CmdCompleteSema,portMAX_DELAY);			//Block until command has been executed
    715a:	6f ef       	ldi	r22, 0xFF	; 255
    715c:	7f ef       	ldi	r23, 0xFF	; 255
    715e:	80 91 3c 2e 	lds	r24, 0x2E3C	; 0x802e3c <CmdCompleteSema>
    7162:	90 91 3d 2e 	lds	r25, 0x2E3D	; 0x802e3d <CmdCompleteSema+0x1>
    7166:	0e 94 43 23 	call	0x4686	; 0x4686 <xQueueSemaphoreTake>
}
    716a:	29 96       	adiw	r28, 0x09	; 9
    716c:	cd bf       	out	0x3d, r28	; 61
    716e:	de bf       	out	0x3e, r29	; 62
    7170:	df 91       	pop	r29
    7172:	cf 91       	pop	r28
    7174:	08 95       	ret

00007176 <DriveSegment>:
void DriveSegment(float Speed)
{
    7176:	cf 93       	push	r28
    7178:	df 93       	push	r29
    717a:	cd b7       	in	r28, 0x3d	; 61
    717c:	de b7       	in	r29, 0x3e	; 62
    717e:	29 97       	sbiw	r28, 0x09	; 9
    7180:	cd bf       	out	0x3d, r28	; 61
    7182:	de bf       	out	0x3e, r29	; 62
	MotionCmdStruct MotionCmd;
	MotionCmd.Cmd=CMD_DRIVE_SEGMENT;
    7184:	22 e0       	ldi	r18, 0x02	; 2
    7186:	29 83       	std	Y+1, r18	; 0x01
	MotionCmd.Params[0]=Speed;
    7188:	6a 83       	std	Y+2, r22	; 0x02
    718a:	7b 83       	std	Y+3, r23	; 0x03
    718c:	8c 83       	std	Y+4, r24	; 0x04
    718e:	9d 83       	std	Y+5, r25	; 0x05
	xQueueSendToBack(CmdQueue,&MotionCmd,portMAX_DELAY);	//Issue command
    7190:	20 e0       	ldi	r18, 0x00	; 0
    7192:	4f ef       	ldi	r20, 0xFF	; 255
    7194:	5f ef       	ldi	r21, 0xFF	; 255
    7196:	be 01       	movw	r22, r28
    7198:	6f 5f       	subi	r22, 0xFF	; 255
    719a:	7f 4f       	sbci	r23, 0xFF	; 255
    719c:	80 91 3e 2e 	lds	r24, 0x2E3E	; 0x802e3e <CmdQueue>
    71a0:	90 91 3f 2e 	lds	r25, 0x2E3F	; 0x802e3f <CmdQueue+0x1>
    71a4:	0e 94 ef 20 	call	0x41de	; 0x41de <xQueueGenericSend>
	xSemaphoreTake(CmdCompleteSema,portMAX_DELAY);			//Block until command has been executed
    71a8:	6f ef       	ldi	r22, 0xFF	; 255
    71aa:	7f ef       	ldi	r23, 0xFF	; 255
    71ac:	80 91 3c 2e 	lds	r24, 0x2E3C	; 0x802e3c <CmdCompleteSema>
    71b0:	90 91 3d 2e 	lds	r25, 0x2E3D	; 0x802e3d <CmdCompleteSema+0x1>
    71b4:	0e 94 43 23 	call	0x4686	; 0x4686 <xQueueSemaphoreTake>
}
    71b8:	29 96       	adiw	r28, 0x09	; 9
    71ba:	cd bf       	out	0x3d, r28	; 61
    71bc:	de bf       	out	0x3e, r29	; 62
    71be:	df 91       	pop	r29
    71c0:	cf 91       	pop	r28
    71c2:	08 95       	ret

000071c4 <RotateCenter>:
void RotateCenter(float Angle, float Speed)
{
    71c4:	cf 93       	push	r28
    71c6:	df 93       	push	r29
    71c8:	cd b7       	in	r28, 0x3d	; 61
    71ca:	de b7       	in	r29, 0x3e	; 62
    71cc:	29 97       	sbiw	r28, 0x09	; 9
    71ce:	cd bf       	out	0x3d, r28	; 61
    71d0:	de bf       	out	0x3e, r29	; 62
	MotionCmdStruct MotionCmd;
	MotionCmd.Cmd=CMD_ROTATE_CENTER;
    71d2:	e3 e0       	ldi	r30, 0x03	; 3
    71d4:	e9 83       	std	Y+1, r30	; 0x01
	MotionCmd.Params[0]=Angle;
    71d6:	6a 83       	std	Y+2, r22	; 0x02
    71d8:	7b 83       	std	Y+3, r23	; 0x03
    71da:	8c 83       	std	Y+4, r24	; 0x04
    71dc:	9d 83       	std	Y+5, r25	; 0x05
	MotionCmd.Params[1]=Speed;
    71de:	2e 83       	std	Y+6, r18	; 0x06
    71e0:	3f 83       	std	Y+7, r19	; 0x07
    71e2:	48 87       	std	Y+8, r20	; 0x08
    71e4:	59 87       	std	Y+9, r21	; 0x09
	xQueueSendToBack(CmdQueue,&MotionCmd,portMAX_DELAY);	//Issue command
    71e6:	20 e0       	ldi	r18, 0x00	; 0
    71e8:	4f ef       	ldi	r20, 0xFF	; 255
    71ea:	5f ef       	ldi	r21, 0xFF	; 255
    71ec:	be 01       	movw	r22, r28
    71ee:	6f 5f       	subi	r22, 0xFF	; 255
    71f0:	7f 4f       	sbci	r23, 0xFF	; 255
    71f2:	80 91 3e 2e 	lds	r24, 0x2E3E	; 0x802e3e <CmdQueue>
    71f6:	90 91 3f 2e 	lds	r25, 0x2E3F	; 0x802e3f <CmdQueue+0x1>
    71fa:	0e 94 ef 20 	call	0x41de	; 0x41de <xQueueGenericSend>
	xSemaphoreTake(CmdCompleteSema,portMAX_DELAY);			//Block until command has been executed
    71fe:	6f ef       	ldi	r22, 0xFF	; 255
    7200:	7f ef       	ldi	r23, 0xFF	; 255
    7202:	80 91 3c 2e 	lds	r24, 0x2E3C	; 0x802e3c <CmdCompleteSema>
    7206:	90 91 3d 2e 	lds	r25, 0x2E3D	; 0x802e3d <CmdCompleteSema+0x1>
    720a:	0e 94 43 23 	call	0x4686	; 0x4686 <xQueueSemaphoreTake>
    720e:	29 96       	adiw	r28, 0x09	; 9
    7210:	cd bf       	out	0x3d, r28	; 61
    7212:	de bf       	out	0x3e, r29	; 62
    7214:	df 91       	pop	r29
    7216:	cf 91       	pop	r28
    7218:	08 95       	ret

0000721a <WorkerMotorPos>:
	IncSet.IncSet2=IncSet2;
	xQueueSend(IncSetQueue,&IncSet,portMAX_DELAY);
}

void WorkerMotorPos(void *pvParameters)
{
    721a:	cf 93       	push	r28
    721c:	df 93       	push	r29
    721e:	cd b7       	in	r28, 0x3d	; 61
    7220:	de b7       	in	r29, 0x3e	; 62
    7222:	2c 97       	sbiw	r28, 0x0c	; 12
    7224:	cd bf       	out	0x3d, r28	; 61
    7226:	de bf       	out	0x3e, r29	; 62
	float Err1=0,Err2=0;
	
	IncSetStruct IncSet;
	EncoderStruct EncoderInfo;
	
	xLastWakeTime = xTaskGetTickCount();
    7228:	0e 94 85 29 	call	0x530a	; 0x530a <xTaskGetTickCount>
    722c:	80 93 40 2e 	sts	0x2E40, r24	; 0x802e40 <xLastWakeTime>
    7230:	90 93 41 2e 	sts	0x2E41, r25	; 0x802e41 <xLastWakeTime+0x1>
void WorkerMotorPos(void *pvParameters)
{
	
	const TickType_t xPeriod = 10;
	
	float Set1=0,Set2=0;
    7234:	19 86       	std	Y+9, r1	; 0x09
    7236:	1a 86       	std	Y+10, r1	; 0x0a
    7238:	1b 86       	std	Y+11, r1	; 0x0b
    723a:	1c 86       	std	Y+12, r1	; 0x0c
    723c:	1d 82       	std	Y+5, r1	; 0x05
    723e:	1e 82       	std	Y+6, r1	; 0x06
    7240:	1f 82       	std	Y+7, r1	; 0x07
    7242:	18 86       	std	Y+8, r1	; 0x08
    7244:	77 c0       	rjmp	.+238    	; 0x7334 <WorkerMotorPos+0x11a>
			//PID 1
			Err1=Set1-EncoderInfo.Cnt1;
			Out1=Err1*MOTPOS_KP;
			if (Out1>0) Out1+=MOTPOS_FF_OFFSET;
			if (Out1>4095) Out1=4095;
			if (Out1<0) Out1-=MOTPOS_FF_OFFSET;			
    7246:	20 e0       	ldi	r18, 0x00	; 0
    7248:	30 e0       	ldi	r19, 0x00	; 0
    724a:	a9 01       	movw	r20, r18
    724c:	c7 01       	movw	r24, r14
    724e:	b6 01       	movw	r22, r12
    7250:	0e 94 17 46 	call	0x8c2e	; 0x8c2e <__cmpsf2>
    7254:	87 ff       	sbrs	r24, 7
    7256:	0a c0       	rjmp	.+20     	; 0x726c <WorkerMotorPos+0x52>
    7258:	20 e0       	ldi	r18, 0x00	; 0
    725a:	30 e8       	ldi	r19, 0x80	; 128
    725c:	4b eb       	ldi	r20, 0xBB	; 187
    725e:	54 e4       	ldi	r21, 0x44	; 68
    7260:	c7 01       	movw	r24, r14
    7262:	b6 01       	movw	r22, r12
    7264:	0e 94 aa 45 	call	0x8b54	; 0x8b54 <__subsf3>
    7268:	6b 01       	movw	r12, r22
    726a:	7c 01       	movw	r14, r24
			if (Out1<-4095) Out1=-4095;
    726c:	20 e0       	ldi	r18, 0x00	; 0
    726e:	30 ef       	ldi	r19, 0xF0	; 240
    7270:	4f e7       	ldi	r20, 0x7F	; 127
    7272:	55 ec       	ldi	r21, 0xC5	; 197
    7274:	c7 01       	movw	r24, r14
    7276:	b6 01       	movw	r22, r12
    7278:	0e 94 17 46 	call	0x8c2e	; 0x8c2e <__cmpsf2>
    727c:	87 ff       	sbrs	r24, 7
    727e:	b6 c0       	rjmp	.+364    	; 0x73ec <WorkerMotorPos+0x1d2>
    7280:	01 e0       	ldi	r16, 0x01	; 1
    7282:	10 ef       	ldi	r17, 0xF0	; 240

			//PID 2
			Err2=Set2-EncoderInfo.Cnt2;
			Out2=Err2*MOTPOS_KP;
    7284:	c5 01       	movw	r24, r10
    7286:	b4 01       	movw	r22, r8
    7288:	0e 94 c6 46 	call	0x8d8c	; 0x8d8c <__floatsisf>
    728c:	9b 01       	movw	r18, r22
    728e:	ac 01       	movw	r20, r24
    7290:	69 85       	ldd	r22, Y+9	; 0x09
    7292:	7a 85       	ldd	r23, Y+10	; 0x0a
    7294:	8b 85       	ldd	r24, Y+11	; 0x0b
    7296:	9c 85       	ldd	r25, Y+12	; 0x0c
    7298:	0e 94 aa 45 	call	0x8b54	; 0x8b54 <__subsf3>
    729c:	20 e0       	ldi	r18, 0x00	; 0
    729e:	30 e0       	ldi	r19, 0x00	; 0
    72a0:	46 e9       	ldi	r20, 0x96	; 150
    72a2:	53 e4       	ldi	r21, 0x43	; 67
    72a4:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    72a8:	6b 01       	movw	r12, r22
    72aa:	7c 01       	movw	r14, r24
			if (Out2>0) Out2+=MOTPOS_FF_OFFSET;
    72ac:	20 e0       	ldi	r18, 0x00	; 0
    72ae:	30 e0       	ldi	r19, 0x00	; 0
    72b0:	a9 01       	movw	r20, r18
    72b2:	0e 94 76 47 	call	0x8eec	; 0x8eec <__gesf2>
    72b6:	18 16       	cp	r1, r24
    72b8:	54 f4       	brge	.+20     	; 0x72ce <WorkerMotorPos+0xb4>
    72ba:	20 e0       	ldi	r18, 0x00	; 0
    72bc:	30 e8       	ldi	r19, 0x80	; 128
    72be:	4b eb       	ldi	r20, 0xBB	; 187
    72c0:	54 e4       	ldi	r21, 0x44	; 68
    72c2:	c7 01       	movw	r24, r14
    72c4:	b6 01       	movw	r22, r12
    72c6:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <__addsf3>
    72ca:	6b 01       	movw	r12, r22
    72cc:	7c 01       	movw	r14, r24
			if (Out2>4095) Out2=4095;
    72ce:	20 e0       	ldi	r18, 0x00	; 0
    72d0:	30 ef       	ldi	r19, 0xF0	; 240
    72d2:	4f e7       	ldi	r20, 0x7F	; 127
    72d4:	55 e4       	ldi	r21, 0x45	; 69
    72d6:	c7 01       	movw	r24, r14
    72d8:	b6 01       	movw	r22, r12
    72da:	0e 94 76 47 	call	0x8eec	; 0x8eec <__gesf2>
    72de:	18 16       	cp	r1, r24
    72e0:	0c f4       	brge	.+2      	; 0x72e4 <WorkerMotorPos+0xca>
    72e2:	8a c0       	rjmp	.+276    	; 0x73f8 <WorkerMotorPos+0x1de>
			if (Out2<0) Out2-=MOTPOS_FF_OFFSET;
    72e4:	20 e0       	ldi	r18, 0x00	; 0
    72e6:	30 e0       	ldi	r19, 0x00	; 0
    72e8:	a9 01       	movw	r20, r18
    72ea:	c7 01       	movw	r24, r14
    72ec:	b6 01       	movw	r22, r12
    72ee:	0e 94 17 46 	call	0x8c2e	; 0x8c2e <__cmpsf2>
    72f2:	87 ff       	sbrs	r24, 7
    72f4:	0a c0       	rjmp	.+20     	; 0x730a <WorkerMotorPos+0xf0>
    72f6:	20 e0       	ldi	r18, 0x00	; 0
    72f8:	30 e8       	ldi	r19, 0x80	; 128
    72fa:	4b eb       	ldi	r20, 0xBB	; 187
    72fc:	54 e4       	ldi	r21, 0x44	; 68
    72fe:	c7 01       	movw	r24, r14
    7300:	b6 01       	movw	r22, r12
    7302:	0e 94 aa 45 	call	0x8b54	; 0x8b54 <__subsf3>
    7306:	6b 01       	movw	r12, r22
    7308:	7c 01       	movw	r14, r24
			if (Out2<-4095) Out2=-4095;
    730a:	20 e0       	ldi	r18, 0x00	; 0
    730c:	30 ef       	ldi	r19, 0xF0	; 240
    730e:	4f e7       	ldi	r20, 0x7F	; 127
    7310:	55 ec       	ldi	r21, 0xC5	; 197
    7312:	c7 01       	movw	r24, r14
    7314:	b6 01       	movw	r22, r12
    7316:	0e 94 17 46 	call	0x8c2e	; 0x8c2e <__cmpsf2>
    731a:	87 ff       	sbrs	r24, 7
    731c:	74 c0       	rjmp	.+232    	; 0x7406 <WorkerMotorPos+0x1ec>
    731e:	61 e0       	ldi	r22, 0x01	; 1
    7320:	70 ef       	ldi	r23, 0xF0	; 240
			
			//printf ("Err:%f   Out:%f\r\n",Err2 ,Out2);			
			
			DriverMotorSet(Out1,Out2);
    7322:	c8 01       	movw	r24, r16
    7324:	0e 94 e7 06 	call	0xdce	; 0xdce <DriverMotorSet>
			
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
    7328:	6a e0       	ldi	r22, 0x0A	; 10
    732a:	70 e0       	ldi	r23, 0x00	; 0
    732c:	80 e4       	ldi	r24, 0x40	; 64
    732e:	9e e2       	ldi	r25, 0x2E	; 46
    7330:	0e 94 0a 2b 	call	0x5614	; 0x5614 <vTaskDelayUntil>
	
	xLastWakeTime = xTaskGetTickCount();
	
	while (1)
	{		
			EncoderInfo=DriverMotorGetEncoder();
    7334:	0e 94 52 07 	call	0xea4	; 0xea4 <DriverMotorGetEncoder>
    7338:	6b 01       	movw	r12, r22
    733a:	7c 01       	movw	r14, r24

			//Process reset setpoint command
			if (xSemaphoreTake(ResetSetpointSema,0)==pdPASS)
    733c:	60 e0       	ldi	r22, 0x00	; 0
    733e:	70 e0       	ldi	r23, 0x00	; 0
    7340:	80 91 46 2e 	lds	r24, 0x2E46	; 0x802e46 <ResetSetpointSema>
    7344:	90 91 47 2e 	lds	r25, 0x2E47	; 0x802e47 <ResetSetpointSema+0x1>
    7348:	0e 94 43 23 	call	0x4686	; 0x4686 <xQueueSemaphoreTake>
			{
				Set1=EncoderInfo.Cnt1;
    734c:	26 01       	movw	r4, r12
    734e:	dd 0c       	add	r13, r13
    7350:	66 08       	sbc	r6, r6
    7352:	77 08       	sbc	r7, r7
	while (1)
	{		
			EncoderInfo=DriverMotorGetEncoder();

			//Process reset setpoint command
			if (xSemaphoreTake(ResetSetpointSema,0)==pdPASS)
    7354:	81 30       	cpi	r24, 0x01	; 1
    7356:	09 f4       	brne	.+2      	; 0x735a <WorkerMotorPos+0x140>
    7358:	90 c0       	rjmp	.+288    	; 0x747a <WorkerMotorPos+0x260>
    735a:	47 01       	movw	r8, r14
    735c:	ff 0c       	add	r15, r15
    735e:	aa 08       	sbc	r10, r10
    7360:	bb 08       	sbc	r11, r11
				Set1=EncoderInfo.Cnt1;
				Set2=EncoderInfo.Cnt2;
			}
			
			//Process setpoint increment data
			if (xQueueReceive(IncSetQueue,&IncSet,0)==pdPASS)
    7362:	40 e0       	ldi	r20, 0x00	; 0
    7364:	50 e0       	ldi	r21, 0x00	; 0
    7366:	be 01       	movw	r22, r28
    7368:	6f 5f       	subi	r22, 0xFF	; 255
    736a:	7f 4f       	sbci	r23, 0xFF	; 255
    736c:	80 91 44 2e 	lds	r24, 0x2E44	; 0x802e44 <IncSetQueue>
    7370:	90 91 45 2e 	lds	r25, 0x2E45	; 0x802e45 <IncSetQueue+0x1>
    7374:	0e 94 86 22 	call	0x450c	; 0x450c <xQueueReceive>
    7378:	81 30       	cpi	r24, 0x01	; 1
    737a:	09 f4       	brne	.+2      	; 0x737e <WorkerMotorPos+0x164>
    737c:	49 c0       	rjmp	.+146    	; 0x7410 <WorkerMotorPos+0x1f6>
				Set2+=((float) IncSet.IncSet2)/100;
			}
			
			//PID 1
			Err1=Set1-EncoderInfo.Cnt1;
			Out1=Err1*MOTPOS_KP;
    737e:	c3 01       	movw	r24, r6
    7380:	b2 01       	movw	r22, r4
    7382:	0e 94 c6 46 	call	0x8d8c	; 0x8d8c <__floatsisf>
    7386:	9b 01       	movw	r18, r22
    7388:	ac 01       	movw	r20, r24
    738a:	6d 81       	ldd	r22, Y+5	; 0x05
    738c:	7e 81       	ldd	r23, Y+6	; 0x06
    738e:	8f 81       	ldd	r24, Y+7	; 0x07
    7390:	98 85       	ldd	r25, Y+8	; 0x08
    7392:	0e 94 aa 45 	call	0x8b54	; 0x8b54 <__subsf3>
    7396:	20 e0       	ldi	r18, 0x00	; 0
    7398:	30 e0       	ldi	r19, 0x00	; 0
    739a:	46 e9       	ldi	r20, 0x96	; 150
    739c:	53 e4       	ldi	r21, 0x43	; 67
    739e:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    73a2:	6b 01       	movw	r12, r22
    73a4:	7c 01       	movw	r14, r24
			if (Out1>0) Out1+=MOTPOS_FF_OFFSET;
    73a6:	20 e0       	ldi	r18, 0x00	; 0
    73a8:	30 e0       	ldi	r19, 0x00	; 0
    73aa:	a9 01       	movw	r20, r18
    73ac:	0e 94 76 47 	call	0x8eec	; 0x8eec <__gesf2>
    73b0:	18 16       	cp	r1, r24
    73b2:	54 f4       	brge	.+20     	; 0x73c8 <WorkerMotorPos+0x1ae>
    73b4:	20 e0       	ldi	r18, 0x00	; 0
    73b6:	30 e8       	ldi	r19, 0x80	; 128
    73b8:	4b eb       	ldi	r20, 0xBB	; 187
    73ba:	54 e4       	ldi	r21, 0x44	; 68
    73bc:	c7 01       	movw	r24, r14
    73be:	b6 01       	movw	r22, r12
    73c0:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <__addsf3>
    73c4:	6b 01       	movw	r12, r22
    73c6:	7c 01       	movw	r14, r24
			if (Out1>4095) Out1=4095;
    73c8:	20 e0       	ldi	r18, 0x00	; 0
    73ca:	30 ef       	ldi	r19, 0xF0	; 240
    73cc:	4f e7       	ldi	r20, 0x7F	; 127
    73ce:	55 e4       	ldi	r21, 0x45	; 69
    73d0:	c7 01       	movw	r24, r14
    73d2:	b6 01       	movw	r22, r12
    73d4:	0e 94 76 47 	call	0x8eec	; 0x8eec <__gesf2>
    73d8:	18 16       	cp	r1, r24
    73da:	0c f0       	brlt	.+2      	; 0x73de <WorkerMotorPos+0x1c4>
    73dc:	34 cf       	rjmp	.-408    	; 0x7246 <WorkerMotorPos+0x2c>
    73de:	c1 2c       	mov	r12, r1
    73e0:	90 ef       	ldi	r25, 0xF0	; 240
    73e2:	d9 2e       	mov	r13, r25
    73e4:	9f e7       	ldi	r25, 0x7F	; 127
    73e6:	e9 2e       	mov	r14, r25
    73e8:	95 e4       	ldi	r25, 0x45	; 69
    73ea:	f9 2e       	mov	r15, r25
    73ec:	c7 01       	movw	r24, r14
    73ee:	b6 01       	movw	r22, r12
    73f0:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
    73f4:	8b 01       	movw	r16, r22
    73f6:	46 cf       	rjmp	.-372    	; 0x7284 <WorkerMotorPos+0x6a>

			//PID 2
			Err2=Set2-EncoderInfo.Cnt2;
			Out2=Err2*MOTPOS_KP;
			if (Out2>0) Out2+=MOTPOS_FF_OFFSET;
			if (Out2>4095) Out2=4095;
    73f8:	c1 2c       	mov	r12, r1
    73fa:	80 ef       	ldi	r24, 0xF0	; 240
    73fc:	d8 2e       	mov	r13, r24
    73fe:	8f e7       	ldi	r24, 0x7F	; 127
    7400:	e8 2e       	mov	r14, r24
    7402:	85 e4       	ldi	r24, 0x45	; 69
    7404:	f8 2e       	mov	r15, r24
    7406:	c7 01       	movw	r24, r14
    7408:	b6 01       	movw	r22, r12
    740a:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
    740e:	89 cf       	rjmp	.-238    	; 0x7322 <WorkerMotorPos+0x108>
			}
			
			//Process setpoint increment data
			if (xQueueReceive(IncSetQueue,&IncSet,0)==pdPASS)
			{
				Set1+=((float) IncSet.IncSet1)/100;
    7410:	69 81       	ldd	r22, Y+1	; 0x01
    7412:	7a 81       	ldd	r23, Y+2	; 0x02
    7414:	07 2e       	mov	r0, r23
    7416:	00 0c       	add	r0, r0
    7418:	88 0b       	sbc	r24, r24
    741a:	99 0b       	sbc	r25, r25
    741c:	0e 94 c6 46 	call	0x8d8c	; 0x8d8c <__floatsisf>
    7420:	20 e0       	ldi	r18, 0x00	; 0
    7422:	30 e0       	ldi	r19, 0x00	; 0
    7424:	48 ec       	ldi	r20, 0xC8	; 200
    7426:	52 e4       	ldi	r21, 0x42	; 66
    7428:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    742c:	9b 01       	movw	r18, r22
    742e:	ac 01       	movw	r20, r24
    7430:	6d 81       	ldd	r22, Y+5	; 0x05
    7432:	7e 81       	ldd	r23, Y+6	; 0x06
    7434:	8f 81       	ldd	r24, Y+7	; 0x07
    7436:	98 85       	ldd	r25, Y+8	; 0x08
    7438:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <__addsf3>
    743c:	6d 83       	std	Y+5, r22	; 0x05
    743e:	7e 83       	std	Y+6, r23	; 0x06
    7440:	8f 83       	std	Y+7, r24	; 0x07
    7442:	98 87       	std	Y+8, r25	; 0x08
				Set2+=((float) IncSet.IncSet2)/100;
    7444:	6b 81       	ldd	r22, Y+3	; 0x03
    7446:	7c 81       	ldd	r23, Y+4	; 0x04
    7448:	07 2e       	mov	r0, r23
    744a:	00 0c       	add	r0, r0
    744c:	88 0b       	sbc	r24, r24
    744e:	99 0b       	sbc	r25, r25
    7450:	0e 94 c6 46 	call	0x8d8c	; 0x8d8c <__floatsisf>
    7454:	20 e0       	ldi	r18, 0x00	; 0
    7456:	30 e0       	ldi	r19, 0x00	; 0
    7458:	48 ec       	ldi	r20, 0xC8	; 200
    745a:	52 e4       	ldi	r21, 0x42	; 66
    745c:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    7460:	9b 01       	movw	r18, r22
    7462:	ac 01       	movw	r20, r24
    7464:	69 85       	ldd	r22, Y+9	; 0x09
    7466:	7a 85       	ldd	r23, Y+10	; 0x0a
    7468:	8b 85       	ldd	r24, Y+11	; 0x0b
    746a:	9c 85       	ldd	r25, Y+12	; 0x0c
    746c:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <__addsf3>
    7470:	69 87       	std	Y+9, r22	; 0x09
    7472:	7a 87       	std	Y+10, r23	; 0x0a
    7474:	8b 87       	std	Y+11, r24	; 0x0b
    7476:	9c 87       	std	Y+12, r25	; 0x0c
    7478:	82 cf       	rjmp	.-252    	; 0x737e <WorkerMotorPos+0x164>
			EncoderInfo=DriverMotorGetEncoder();

			//Process reset setpoint command
			if (xSemaphoreTake(ResetSetpointSema,0)==pdPASS)
			{
				Set1=EncoderInfo.Cnt1;
    747a:	c3 01       	movw	r24, r6
    747c:	b2 01       	movw	r22, r4
    747e:	0e 94 c6 46 	call	0x8d8c	; 0x8d8c <__floatsisf>
    7482:	6d 83       	std	Y+5, r22	; 0x05
    7484:	7e 83       	std	Y+6, r23	; 0x06
    7486:	8f 83       	std	Y+7, r24	; 0x07
    7488:	98 87       	std	Y+8, r25	; 0x08
				Set2=EncoderInfo.Cnt2;
    748a:	47 01       	movw	r8, r14
    748c:	ff 0c       	add	r15, r15
    748e:	aa 08       	sbc	r10, r10
    7490:	bb 08       	sbc	r11, r11
    7492:	c5 01       	movw	r24, r10
    7494:	b4 01       	movw	r22, r8
    7496:	0e 94 c6 46 	call	0x8d8c	; 0x8d8c <__floatsisf>
    749a:	69 87       	std	Y+9, r22	; 0x09
    749c:	7a 87       	std	Y+10, r23	; 0x0a
    749e:	8b 87       	std	Y+11, r24	; 0x0b
    74a0:	9c 87       	std	Y+12, r25	; 0x0c
    74a2:	5f cf       	rjmp	.-322    	; 0x7362 <WorkerMotorPos+0x148>

000074a4 <EnableMotorPosTask>:
	vSemaphoreCreateBinary(ResetSetpointSema);
}

void EnableMotorPosTask()
{
	DriverMotorResetEncoder();
    74a4:	0e 94 bd 09 	call	0x137a	; 0x137a <DriverMotorResetEncoder>
	xSemaphoreGive(ResetSetpointSema);
    74a8:	20 e0       	ldi	r18, 0x00	; 0
    74aa:	40 e0       	ldi	r20, 0x00	; 0
    74ac:	50 e0       	ldi	r21, 0x00	; 0
    74ae:	60 e0       	ldi	r22, 0x00	; 0
    74b0:	70 e0       	ldi	r23, 0x00	; 0
    74b2:	80 91 46 2e 	lds	r24, 0x2E46	; 0x802e46 <ResetSetpointSema>
    74b6:	90 91 47 2e 	lds	r25, 0x2E47	; 0x802e47 <ResetSetpointSema+0x1>
    74ba:	0e 94 ef 20 	call	0x41de	; 0x41de <xQueueGenericSend>
	xLastWakeTime = xTaskGetTickCount();
    74be:	0e 94 85 29 	call	0x530a	; 0x530a <xTaskGetTickCount>
    74c2:	80 93 40 2e 	sts	0x2E40, r24	; 0x802e40 <xLastWakeTime>
    74c6:	90 93 41 2e 	sts	0x2E41, r25	; 0x802e41 <xLastWakeTime+0x1>
	vTaskResume(MotorPosTaskHandle);
    74ca:	80 91 42 2e 	lds	r24, 0x2E42	; 0x802e42 <MotorPosTaskHandle>
    74ce:	90 91 43 2e 	lds	r25, 0x2E43	; 0x802e43 <MotorPosTaskHandle+0x1>
    74d2:	0c 94 f8 28 	jmp	0x51f0	; 0x51f0 <vTaskResume>

000074d6 <DisableMotorPosTask>:
}

void DisableMotorPosTask()
{
	vTaskSuspend(MotorPosTaskHandle);
    74d6:	80 91 42 2e 	lds	r24, 0x2E42	; 0x802e42 <MotorPosTaskHandle>
    74da:	90 91 43 2e 	lds	r25, 0x2E43	; 0x802e43 <MotorPosTaskHandle+0x1>
    74de:	0e 94 7b 28 	call	0x50f6	; 0x50f6 <vTaskSuspend>
	DriverMotorSet(0,0);
    74e2:	60 e0       	ldi	r22, 0x00	; 0
    74e4:	70 e0       	ldi	r23, 0x00	; 0
    74e6:	80 e0       	ldi	r24, 0x00	; 0
    74e8:	90 e0       	ldi	r25, 0x00	; 0
    74ea:	0c 94 e7 06 	jmp	0xdce	; 0xdce <DriverMotorSet>

000074ee <InitMotorPosTask>:
//Private function prototypes
void WorkerMotorPos(void *pvParameters);

//Function definitions
void InitMotorPosTask()
{
    74ee:	ef 92       	push	r14
    74f0:	ff 92       	push	r15
    74f2:	0f 93       	push	r16
	DriverMotorInit();
    74f4:	0e 94 b6 06 	call	0xd6c	; 0xd6c <DriverMotorInit>
	xTaskCreate( WorkerMotorPos, "motpos", 256, NULL, tskIDLE_PRIORITY+3, &MotorPosTaskHandle );
    74f8:	82 e4       	ldi	r24, 0x42	; 66
    74fa:	e8 2e       	mov	r14, r24
    74fc:	8e e2       	ldi	r24, 0x2E	; 46
    74fe:	f8 2e       	mov	r15, r24
    7500:	03 e0       	ldi	r16, 0x03	; 3
    7502:	20 e0       	ldi	r18, 0x00	; 0
    7504:	30 e0       	ldi	r19, 0x00	; 0
    7506:	40 e0       	ldi	r20, 0x00	; 0
    7508:	51 e0       	ldi	r21, 0x01	; 1
    750a:	6f e9       	ldi	r22, 0x9F	; 159
    750c:	76 e2       	ldi	r23, 0x26	; 38
    750e:	8d e0       	ldi	r24, 0x0D	; 13
    7510:	99 e3       	ldi	r25, 0x39	; 57
    7512:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <xTaskCreate>
	DisableMotorPosTask(); 	
    7516:	0e 94 6b 3a 	call	0x74d6	; 0x74d6 <DisableMotorPosTask>
	
	IncSetQueue=xQueueCreate(1,sizeof(IncSetStruct));
    751a:	40 e0       	ldi	r20, 0x00	; 0
    751c:	64 e0       	ldi	r22, 0x04	; 4
    751e:	81 e0       	ldi	r24, 0x01	; 1
    7520:	0e 94 ab 20 	call	0x4156	; 0x4156 <xQueueGenericCreate>
    7524:	80 93 44 2e 	sts	0x2E44, r24	; 0x802e44 <IncSetQueue>
    7528:	90 93 45 2e 	sts	0x2E45, r25	; 0x802e45 <IncSetQueue+0x1>
	vSemaphoreCreateBinary(ResetSetpointSema);
    752c:	43 e0       	ldi	r20, 0x03	; 3
    752e:	60 e0       	ldi	r22, 0x00	; 0
    7530:	81 e0       	ldi	r24, 0x01	; 1
    7532:	0e 94 ab 20 	call	0x4156	; 0x4156 <xQueueGenericCreate>
    7536:	80 93 46 2e 	sts	0x2E46, r24	; 0x802e46 <ResetSetpointSema>
    753a:	90 93 47 2e 	sts	0x2E47, r25	; 0x802e47 <ResetSetpointSema+0x1>
    753e:	00 97       	sbiw	r24, 0x00	; 0
    7540:	51 f0       	breq	.+20     	; 0x7556 <InitMotorPosTask+0x68>
    7542:	20 e0       	ldi	r18, 0x00	; 0
    7544:	40 e0       	ldi	r20, 0x00	; 0
    7546:	50 e0       	ldi	r21, 0x00	; 0
    7548:	60 e0       	ldi	r22, 0x00	; 0
    754a:	70 e0       	ldi	r23, 0x00	; 0
}
    754c:	0f 91       	pop	r16
    754e:	ff 90       	pop	r15
    7550:	ef 90       	pop	r14
	DriverMotorInit();
	xTaskCreate( WorkerMotorPos, "motpos", 256, NULL, tskIDLE_PRIORITY+3, &MotorPosTaskHandle );
	DisableMotorPosTask(); 	
	
	IncSetQueue=xQueueCreate(1,sizeof(IncSetStruct));
	vSemaphoreCreateBinary(ResetSetpointSema);
    7552:	0c 94 ef 20 	jmp	0x41de	; 0x41de <xQueueGenericSend>
}
    7556:	0f 91       	pop	r16
    7558:	ff 90       	pop	r15
    755a:	ef 90       	pop	r14
    755c:	08 95       	ret

0000755e <MotorPosIncSet>:
	DriverMotorSet(0,0);
}


void MotorPosIncSet(int16_t IncSet1,int16_t IncSet2)
{
    755e:	cf 93       	push	r28
    7560:	df 93       	push	r29
    7562:	00 d0       	rcall	.+0      	; 0x7564 <MotorPosIncSet+0x6>
    7564:	1f 92       	push	r1
    7566:	cd b7       	in	r28, 0x3d	; 61
    7568:	de b7       	in	r29, 0x3e	; 62
	IncSetStruct IncSet;
	IncSet.IncSet1=IncSet1;
    756a:	89 83       	std	Y+1, r24	; 0x01
    756c:	9a 83       	std	Y+2, r25	; 0x02
	IncSet.IncSet2=IncSet2;
    756e:	6b 83       	std	Y+3, r22	; 0x03
    7570:	7c 83       	std	Y+4, r23	; 0x04
	xQueueSend(IncSetQueue,&IncSet,portMAX_DELAY);
    7572:	20 e0       	ldi	r18, 0x00	; 0
    7574:	4f ef       	ldi	r20, 0xFF	; 255
    7576:	5f ef       	ldi	r21, 0xFF	; 255
    7578:	be 01       	movw	r22, r28
    757a:	6f 5f       	subi	r22, 0xFF	; 255
    757c:	7f 4f       	sbci	r23, 0xFF	; 255
    757e:	80 91 44 2e 	lds	r24, 0x2E44	; 0x802e44 <IncSetQueue>
    7582:	90 91 45 2e 	lds	r25, 0x2E45	; 0x802e45 <IncSetQueue+0x1>
    7586:	0e 94 ef 20 	call	0x41de	; 0x41de <xQueueGenericSend>
}
    758a:	24 96       	adiw	r28, 0x04	; 4
    758c:	cd bf       	out	0x3d, r28	; 61
    758e:	de bf       	out	0x3e, r29	; 62
    7590:	df 91       	pop	r29
    7592:	cf 91       	pop	r28
    7594:	08 95       	ret

00007596 <WorkerMotorSpeed>:
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
	
}

void WorkerMotorSpeed(void *pvParameters)
{
    7596:	cf 93       	push	r28
    7598:	df 93       	push	r29
    759a:	00 d0       	rcall	.+0      	; 0x759c <WorkerMotorSpeed+0x6>
    759c:	1f 92       	push	r1
    759e:	cd b7       	in	r28, 0x3d	; 61
    75a0:	de b7       	in	r29, 0x3e	; 62
	const TickType_t xPeriod = 10;
	MotorSpeedStruct MotorSpeed;

	xLastWakeTime = xTaskGetTickCount();
    75a2:	0e 94 85 29 	call	0x530a	; 0x530a <xTaskGetTickCount>
    75a6:	80 93 48 2e 	sts	0x2E48, r24	; 0x802e48 <xLastWakeTime>
    75aa:	90 93 49 2e 	sts	0x2E49, r25	; 0x802e49 <xLastWakeTime+0x1>
	
	while (1)
	{
			xQueuePeek(MotorSpeedQueue,&MotorSpeed,portMAX_DELAY);
    75ae:	4f ef       	ldi	r20, 0xFF	; 255
    75b0:	5f ef       	ldi	r21, 0xFF	; 255
    75b2:	be 01       	movw	r22, r28
    75b4:	6f 5f       	subi	r22, 0xFF	; 255
    75b6:	7f 4f       	sbci	r23, 0xFF	; 255
    75b8:	80 91 4c 2e 	lds	r24, 0x2E4C	; 0x802e4c <MotorSpeedQueue>
    75bc:	90 91 4d 2e 	lds	r25, 0x2E4D	; 0x802e4d <MotorSpeedQueue+0x1>
    75c0:	0e 94 3d 24 	call	0x487a	; 0x487a <xQueuePeek>
			MotorPosIncSet(MotorSpeed.Speed1,MotorSpeed.Speed2);
    75c4:	6b 81       	ldd	r22, Y+3	; 0x03
    75c6:	7c 81       	ldd	r23, Y+4	; 0x04
    75c8:	89 81       	ldd	r24, Y+1	; 0x01
    75ca:	9a 81       	ldd	r25, Y+2	; 0x02
    75cc:	0e 94 af 3a 	call	0x755e	; 0x755e <MotorPosIncSet>
			
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
    75d0:	6a e0       	ldi	r22, 0x0A	; 10
    75d2:	70 e0       	ldi	r23, 0x00	; 0
    75d4:	88 e4       	ldi	r24, 0x48	; 72
    75d6:	9e e2       	ldi	r25, 0x2E	; 46
    75d8:	0e 94 0a 2b 	call	0x5614	; 0x5614 <vTaskDelayUntil>
    75dc:	e8 cf       	rjmp	.-48     	; 0x75ae <WorkerMotorSpeed+0x18>

000075de <InitMotorSpeedTask>:
//Private function prototypes
void WorkerMotorSpeed(void *pvParameters);

//Function definitions
void InitMotorSpeedTask()
{
    75de:	ef 92       	push	r14
    75e0:	ff 92       	push	r15
    75e2:	0f 93       	push	r16
	xTaskCreate( WorkerMotorSpeed, "motspd", 256, NULL, tskIDLE_PRIORITY+3, &MotorSpeedTaskHandle );	
    75e4:	8a e4       	ldi	r24, 0x4A	; 74
    75e6:	e8 2e       	mov	r14, r24
    75e8:	8e e2       	ldi	r24, 0x2E	; 46
    75ea:	f8 2e       	mov	r15, r24
    75ec:	03 e0       	ldi	r16, 0x03	; 3
    75ee:	20 e0       	ldi	r18, 0x00	; 0
    75f0:	30 e0       	ldi	r19, 0x00	; 0
    75f2:	40 e0       	ldi	r20, 0x00	; 0
    75f4:	51 e0       	ldi	r21, 0x01	; 1
    75f6:	66 ea       	ldi	r22, 0xA6	; 166
    75f8:	76 e2       	ldi	r23, 0x26	; 38
    75fa:	8b ec       	ldi	r24, 0xCB	; 203
    75fc:	9a e3       	ldi	r25, 0x3A	; 58
    75fe:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <xTaskCreate>
	vTaskResume(MotorSpeedTaskHandle);
}

void DisableMotorSpeedTask()
{
	vTaskSuspend(MotorSpeedTaskHandle);
    7602:	80 91 4a 2e 	lds	r24, 0x2E4A	; 0x802e4a <MotorSpeedTaskHandle>
    7606:	90 91 4b 2e 	lds	r25, 0x2E4B	; 0x802e4b <MotorSpeedTaskHandle+0x1>
    760a:	0e 94 7b 28 	call	0x50f6	; 0x50f6 <vTaskSuspend>
void InitMotorSpeedTask()
{
	xTaskCreate( WorkerMotorSpeed, "motspd", 256, NULL, tskIDLE_PRIORITY+3, &MotorSpeedTaskHandle );	
	DisableMotorSpeedTask();
	
	MotorSpeedQueue=xQueueCreate(1,sizeof(MotorSpeedStruct));
    760e:	40 e0       	ldi	r20, 0x00	; 0
    7610:	64 e0       	ldi	r22, 0x04	; 4
    7612:	81 e0       	ldi	r24, 0x01	; 1
    7614:	0e 94 ab 20 	call	0x4156	; 0x4156 <xQueueGenericCreate>
    7618:	80 93 4c 2e 	sts	0x2E4C, r24	; 0x802e4c <MotorSpeedQueue>
    761c:	90 93 4d 2e 	sts	0x2E4D, r25	; 0x802e4d <MotorSpeedQueue+0x1>
}

void MotorSpeedSet(int16_t Speed1,int16_t Speed2)
{
	
	MotorSpeed.Speed1=Speed1;
    7620:	ee e4       	ldi	r30, 0x4E	; 78
    7622:	fe e2       	ldi	r31, 0x2E	; 46
    7624:	10 82       	st	Z, r1
    7626:	11 82       	std	Z+1, r1	; 0x01
	MotorSpeed.Speed2=Speed2;
    7628:	12 82       	std	Z+2, r1	; 0x02
    762a:	13 82       	std	Z+3, r1	; 0x03
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
    762c:	22 e0       	ldi	r18, 0x02	; 2
    762e:	40 e0       	ldi	r20, 0x00	; 0
    7630:	50 e0       	ldi	r21, 0x00	; 0
    7632:	bf 01       	movw	r22, r30
	xTaskCreate( WorkerMotorSpeed, "motspd", 256, NULL, tskIDLE_PRIORITY+3, &MotorSpeedTaskHandle );	
	DisableMotorSpeedTask();
	
	MotorSpeedQueue=xQueueCreate(1,sizeof(MotorSpeedStruct));
	MotorSpeedSet(0,0);
}
    7634:	0f 91       	pop	r16
    7636:	ff 90       	pop	r15
    7638:	ef 90       	pop	r14
void MotorSpeedSet(int16_t Speed1,int16_t Speed2)
{
	
	MotorSpeed.Speed1=Speed1;
	MotorSpeed.Speed2=Speed2;
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
    763a:	0c 94 ef 20 	jmp	0x41de	; 0x41de <xQueueGenericSend>

0000763e <EnableMotorSpeedTask>:
	MotorSpeedSet(0,0);
}

void EnableMotorSpeedTask()
{
	xLastWakeTime = xTaskGetTickCount();
    763e:	0e 94 85 29 	call	0x530a	; 0x530a <xTaskGetTickCount>
    7642:	80 93 48 2e 	sts	0x2E48, r24	; 0x802e48 <xLastWakeTime>
    7646:	90 93 49 2e 	sts	0x2E49, r25	; 0x802e49 <xLastWakeTime+0x1>
	vTaskResume(MotorSpeedTaskHandle);
    764a:	80 91 4a 2e 	lds	r24, 0x2E4A	; 0x802e4a <MotorSpeedTaskHandle>
    764e:	90 91 4b 2e 	lds	r25, 0x2E4B	; 0x802e4b <MotorSpeedTaskHandle+0x1>
    7652:	0c 94 f8 28 	jmp	0x51f0	; 0x51f0 <vTaskResume>

00007656 <DisableMotorSpeedTask>:
}

void DisableMotorSpeedTask()
{
	vTaskSuspend(MotorSpeedTaskHandle);
    7656:	80 91 4a 2e 	lds	r24, 0x2E4A	; 0x802e4a <MotorSpeedTaskHandle>
    765a:	90 91 4b 2e 	lds	r25, 0x2E4B	; 0x802e4b <MotorSpeedTaskHandle+0x1>
    765e:	0c 94 7b 28 	jmp	0x50f6	; 0x50f6 <vTaskSuspend>

00007662 <MotorSpeedSet>:
}

void MotorSpeedSet(int16_t Speed1,int16_t Speed2)
{
	
	MotorSpeed.Speed1=Speed1;
    7662:	ee e4       	ldi	r30, 0x4E	; 78
    7664:	fe e2       	ldi	r31, 0x2E	; 46
    7666:	80 83       	st	Z, r24
    7668:	91 83       	std	Z+1, r25	; 0x01
	MotorSpeed.Speed2=Speed2;
    766a:	62 83       	std	Z+2, r22	; 0x02
    766c:	73 83       	std	Z+3, r23	; 0x03
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
    766e:	22 e0       	ldi	r18, 0x02	; 2
    7670:	40 e0       	ldi	r20, 0x00	; 0
    7672:	50 e0       	ldi	r21, 0x00	; 0
    7674:	bf 01       	movw	r22, r30
    7676:	80 91 4c 2e 	lds	r24, 0x2E4C	; 0x802e4c <MotorSpeedQueue>
    767a:	90 91 4d 2e 	lds	r25, 0x2E4D	; 0x802e4d <MotorSpeedQueue+0x1>
    767e:	0c 94 ef 20 	jmp	0x41de	; 0x41de <xQueueGenericSend>

00007682 <InitOLEDMenuTask>:
}

void UpMenu()
{
	if (SelItem>0) SelItem--;
	if (SelItem<TopItem) TopItem=SelItem;
    7682:	ef 92       	push	r14
    7684:	ff 92       	push	r15
    7686:	0f 93       	push	r16
    7688:	e1 2c       	mov	r14, r1
    768a:	f1 2c       	mov	r15, r1
    768c:	02 e0       	ldi	r16, 0x02	; 2
    768e:	20 e0       	ldi	r18, 0x00	; 0
    7690:	30 e0       	ldi	r19, 0x00	; 0
    7692:	40 e0       	ldi	r20, 0x00	; 0
    7694:	54 e0       	ldi	r21, 0x04	; 4
    7696:	6d ea       	ldi	r22, 0xAD	; 173
    7698:	76 e2       	ldi	r23, 0x26	; 38
    769a:	80 eb       	ldi	r24, 0xB0	; 176
    769c:	91 e4       	ldi	r25, 0x41	; 65
    769e:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <xTaskCreate>
    76a2:	0f 91       	pop	r16
    76a4:	ff 90       	pop	r15
    76a6:	ef 90       	pop	r14
    76a8:	08 95       	ret

000076aa <DrawMenu>:
    76aa:	0f 93       	push	r16
    76ac:	1f 93       	push	r17
    76ae:	cf 93       	push	r28
    76b0:	df 93       	push	r29
    76b2:	d0 91 53 2e 	lds	r29, 0x2E53	; 0x802e53 <TopItem>
    76b6:	15 e0       	ldi	r17, 0x05	; 5
    76b8:	1d 0f       	add	r17, r29
    76ba:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <DriverOLEDClearScreen>
    76be:	1d 17       	cp	r17, r29
    76c0:	78 f0       	brcs	.+30     	; 0x76e0 <DrawMenu+0x36>
    76c2:	cd 2f       	mov	r28, r29
    76c4:	04 e1       	ldi	r16, 0x14	; 20
    76c6:	0c 9f       	mul	r16, r28
    76c8:	b0 01       	movw	r22, r0
    76ca:	11 24       	eor	r1, r1
    76cc:	6a 5e       	subi	r22, 0xEA	; 234
    76ce:	7f 4d       	sbci	r23, 0xDF	; 223
    76d0:	40 e0       	ldi	r20, 0x00	; 0
    76d2:	8c 2f       	mov	r24, r28
    76d4:	8d 1b       	sub	r24, r29
    76d6:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
    76da:	cf 5f       	subi	r28, 0xFF	; 255
    76dc:	1c 17       	cp	r17, r28
    76de:	98 f7       	brcc	.-26     	; 0x76c6 <DrawMenu+0x1c>
    76e0:	60 91 52 2e 	lds	r22, 0x2E52	; 0x802e52 <SelItem>
    76e4:	80 91 53 2e 	lds	r24, 0x2E53	; 0x802e53 <TopItem>
    76e8:	68 1b       	sub	r22, r24
    76ea:	20 e0       	ldi	r18, 0x00	; 0
    76ec:	4a e2       	ldi	r20, 0x2A	; 42
    76ee:	80 e0       	ldi	r24, 0x00	; 0
    76f0:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <DriverOLEDPrintSmChar>
    76f4:	df 91       	pop	r29
    76f6:	cf 91       	pop	r28
    76f8:	1f 91       	pop	r17
    76fa:	0f 91       	pop	r16
    76fc:	0c 94 d6 0c 	jmp	0x19ac	; 0x19ac <DriverOLEDUpdate>

00007700 <PageKarlsTask>:
}

void PageKarlsTask() {
    7700:	3f 92       	push	r3
    7702:	4f 92       	push	r4
    7704:	5f 92       	push	r5
    7706:	6f 92       	push	r6
    7708:	7f 92       	push	r7
    770a:	8f 92       	push	r8
    770c:	9f 92       	push	r9
    770e:	af 92       	push	r10
    7710:	bf 92       	push	r11
    7712:	cf 92       	push	r12
    7714:	df 92       	push	r13
    7716:	ef 92       	push	r14
    7718:	ff 92       	push	r15
    771a:	0f 93       	push	r16
    771c:	1f 93       	push	r17
    771e:	cf 93       	push	r28
    7720:	df 93       	push	r29
    7722:	cd b7       	in	r28, 0x3d	; 61
    7724:	de b7       	in	r29, 0x3e	; 62
    7726:	c4 54       	subi	r28, 0x44	; 68
    7728:	d1 09       	sbc	r29, r1
    772a:	cd bf       	out	0x3d, r28	; 61
    772c:	de bf       	out	0x3e, r29	; 62
    uint8_t Stick;
    char s[32];
    float DistX, DistY, DistZ, Ax, Ay, Az, Gx, Gy, Gz, VelX,VelY,VelZ;
    
    vTaskDelay(300);
    772e:	8c e2       	ldi	r24, 0x2C	; 44
    7730:	91 e0       	ldi	r25, 0x01	; 1
    7732:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
    7736:	8e 01       	movw	r16, r28
    7738:	0f 5f       	subi	r16, 0xFF	; 255
    773a:	1f 4f       	sbci	r17, 0xFF	; 255

		IPSGetPosition(&DistX, &DistY, &DistZ);
        IPSGetVelocity(&VelX, &VelY, &VelZ);
        IPSGetAcceleration(&Ax, &Ay, &Az);
        
        sprintf(s, "Dist X:%.2f", DistX);
    773c:	85 eb       	ldi	r24, 0xB5	; 181
    773e:	88 2e       	mov	r8, r24
    7740:	86 e2       	ldi	r24, 0x26	; 38
    7742:	98 2e       	mov	r9, r24
        DriverOLEDPrintSmText(0, s, 0);

        sprintf(s, "Dist Y:%.2f", DistY);
    7744:	91 ec       	ldi	r25, 0xC1	; 193
    7746:	a9 2e       	mov	r10, r25
    7748:	96 e2       	ldi	r25, 0x26	; 38
    774a:	b9 2e       	mov	r11, r25
        DriverOLEDPrintSmText(1, s, 0);

        sprintf(s, "Dist Z:%.2f", DistZ);
    774c:	2d ec       	ldi	r18, 0xCD	; 205
    774e:	c2 2e       	mov	r12, r18
    7750:	26 e2       	ldi	r18, 0x26	; 38
    7752:	d2 2e       	mov	r13, r18
        DriverOLEDPrintSmText(2, s, 0);
        
        sprintf(s, "X: G: %.2f A: %.2f", Gx, Ax);
    7754:	39 ed       	ldi	r19, 0xD9	; 217
    7756:	e3 2e       	mov	r14, r19
    7758:	36 e2       	ldi	r19, 0x26	; 38
    775a:	f3 2e       	mov	r15, r19
        DriverOLEDPrintSmText(3, s, 0);

        sprintf(s, "Y: G: %.2f A: %.2f", Gy, Ay);
    775c:	4c ee       	ldi	r20, 0xEC	; 236
    775e:	64 2e       	mov	r6, r20
    7760:	46 e2       	ldi	r20, 0x26	; 38
    7762:	74 2e       	mov	r7, r20
        DriverOLEDPrintSmText(4, s, 0);

        sprintf(s, "Z: G: %.2f A: %.2f", Gz, Az);
    7764:	5f ef       	ldi	r21, 0xFF	; 255
    7766:	45 2e       	mov	r4, r21
    7768:	56 e2       	ldi	r21, 0x26	; 38
    776a:	55 2e       	mov	r5, r21
    776c:	02 c0       	rjmp	.+4      	; 0x7772 <PageKarlsTask+0x72>
        {
            vTaskDelay(300);
            return;
        }
        
        DriverOLEDUpdate();
    776e:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <DriverOLEDUpdate>
    float DistX, DistY, DistZ, Ax, Ay, Az, Gx, Gy, Gz, VelX,VelY,VelZ;
    
    vTaskDelay(300);
    while (1)
    {
        Stick = DriverCursorStickGetFifo(300);
    7772:	8c e2       	ldi	r24, 0x2C	; 44
    7774:	91 e0       	ldi	r25, 0x01	; 1
    7776:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
    777a:	38 2e       	mov	r3, r24
        
        DriverOLEDClearScreen();
    777c:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <DriverOLEDClearScreen>

		IPSGetPosition(&DistX, &DistY, &DistZ);
    7780:	ae 01       	movw	r20, r28
    7782:	47 5c       	subi	r20, 0xC7	; 199
    7784:	5f 4f       	sbci	r21, 0xFF	; 255
    7786:	be 01       	movw	r22, r28
    7788:	63 5c       	subi	r22, 0xC3	; 195
    778a:	7f 4f       	sbci	r23, 0xFF	; 255
    778c:	ce 01       	movw	r24, r28
    778e:	8f 5b       	subi	r24, 0xBF	; 191
    7790:	9f 4f       	sbci	r25, 0xFF	; 255
    7792:	0e 94 fa 33 	call	0x67f4	; 0x67f4 <IPSGetPosition>
        IPSGetVelocity(&VelX, &VelY, &VelZ);
    7796:	ae 01       	movw	r20, r28
    7798:	4f 5d       	subi	r20, 0xDF	; 223
    779a:	5f 4f       	sbci	r21, 0xFF	; 255
    779c:	be 01       	movw	r22, r28
    779e:	6b 5d       	subi	r22, 0xDB	; 219
    77a0:	7f 4f       	sbci	r23, 0xFF	; 255
    77a2:	ce 01       	movw	r24, r28
    77a4:	89 96       	adiw	r24, 0x29	; 41
    77a6:	0e 94 4a 34 	call	0x6894	; 0x6894 <IPSGetVelocity>
        IPSGetAcceleration(&Ax, &Ay, &Az);
    77aa:	ae 01       	movw	r20, r28
    77ac:	43 5d       	subi	r20, 0xD3	; 211
    77ae:	5f 4f       	sbci	r21, 0xFF	; 255
    77b0:	be 01       	movw	r22, r28
    77b2:	6f 5c       	subi	r22, 0xCF	; 207
    77b4:	7f 4f       	sbci	r23, 0xFF	; 255
    77b6:	ce 01       	movw	r24, r28
    77b8:	c5 96       	adiw	r24, 0x35	; 53
    77ba:	0e 94 82 34 	call	0x6904	; 0x6904 <IPSGetAcceleration>
        
        sprintf(s, "Dist X:%.2f", DistX);
    77be:	25 96       	adiw	r28, 0x05	; 5
    77c0:	8f ad       	ldd	r24, Y+63	; 0x3f
    77c2:	25 97       	sbiw	r28, 0x05	; 5
    77c4:	8f 93       	push	r24
    77c6:	24 96       	adiw	r28, 0x04	; 4
    77c8:	8f ad       	ldd	r24, Y+63	; 0x3f
    77ca:	24 97       	sbiw	r28, 0x04	; 4
    77cc:	8f 93       	push	r24
    77ce:	23 96       	adiw	r28, 0x03	; 3
    77d0:	8f ad       	ldd	r24, Y+63	; 0x3f
    77d2:	23 97       	sbiw	r28, 0x03	; 3
    77d4:	8f 93       	push	r24
    77d6:	22 96       	adiw	r28, 0x02	; 2
    77d8:	8f ad       	ldd	r24, Y+63	; 0x3f
    77da:	22 97       	sbiw	r28, 0x02	; 2
    77dc:	8f 93       	push	r24
    77de:	9f 92       	push	r9
    77e0:	8f 92       	push	r8
    77e2:	1f 93       	push	r17
    77e4:	0f 93       	push	r16
    77e6:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
        DriverOLEDPrintSmText(0, s, 0);
    77ea:	40 e0       	ldi	r20, 0x00	; 0
    77ec:	b8 01       	movw	r22, r16
    77ee:	80 e0       	ldi	r24, 0x00	; 0
    77f0:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>

        sprintf(s, "Dist Y:%.2f", DistY);
    77f4:	21 96       	adiw	r28, 0x01	; 1
    77f6:	8f ad       	ldd	r24, Y+63	; 0x3f
    77f8:	21 97       	sbiw	r28, 0x01	; 1
    77fa:	8f 93       	push	r24
    77fc:	8f ad       	ldd	r24, Y+63	; 0x3f
    77fe:	8f 93       	push	r24
    7800:	8e ad       	ldd	r24, Y+62	; 0x3e
    7802:	8f 93       	push	r24
    7804:	8d ad       	ldd	r24, Y+61	; 0x3d
    7806:	8f 93       	push	r24
    7808:	bf 92       	push	r11
    780a:	af 92       	push	r10
    780c:	1f 93       	push	r17
    780e:	0f 93       	push	r16
    7810:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
        DriverOLEDPrintSmText(1, s, 0);
    7814:	40 e0       	ldi	r20, 0x00	; 0
    7816:	b8 01       	movw	r22, r16
    7818:	81 e0       	ldi	r24, 0x01	; 1
    781a:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>

        sprintf(s, "Dist Z:%.2f", DistZ);
    781e:	8c ad       	ldd	r24, Y+60	; 0x3c
    7820:	8f 93       	push	r24
    7822:	8b ad       	ldd	r24, Y+59	; 0x3b
    7824:	8f 93       	push	r24
    7826:	8a ad       	ldd	r24, Y+58	; 0x3a
    7828:	8f 93       	push	r24
    782a:	89 ad       	ldd	r24, Y+57	; 0x39
    782c:	8f 93       	push	r24
    782e:	df 92       	push	r13
    7830:	cf 92       	push	r12
    7832:	1f 93       	push	r17
    7834:	0f 93       	push	r16
    7836:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
        DriverOLEDPrintSmText(2, s, 0);
    783a:	40 e0       	ldi	r20, 0x00	; 0
    783c:	b8 01       	movw	r22, r16
    783e:	82 e0       	ldi	r24, 0x02	; 2
    7840:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
        
        sprintf(s, "X: G: %.2f A: %.2f", Gx, Ax);
    7844:	88 ad       	ldd	r24, Y+56	; 0x38
    7846:	8f 93       	push	r24
    7848:	8f a9       	ldd	r24, Y+55	; 0x37
    784a:	8f 93       	push	r24
    784c:	8e a9       	ldd	r24, Y+54	; 0x36
    784e:	8f 93       	push	r24
    7850:	8d a9       	ldd	r24, Y+53	; 0x35
    7852:	8f 93       	push	r24
    7854:	1f 92       	push	r1
    7856:	1f 92       	push	r1
    7858:	1f 92       	push	r1
    785a:	1f 92       	push	r1
    785c:	ff 92       	push	r15
    785e:	ef 92       	push	r14
    7860:	1f 93       	push	r17
    7862:	0f 93       	push	r16
    7864:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
        DriverOLEDPrintSmText(3, s, 0);
    7868:	cd bf       	out	0x3d, r28	; 61
    786a:	de bf       	out	0x3e, r29	; 62
    786c:	40 e0       	ldi	r20, 0x00	; 0
    786e:	b8 01       	movw	r22, r16
    7870:	83 e0       	ldi	r24, 0x03	; 3
    7872:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>

        sprintf(s, "Y: G: %.2f A: %.2f", Gy, Ay);
    7876:	8c a9       	ldd	r24, Y+52	; 0x34
    7878:	8f 93       	push	r24
    787a:	8b a9       	ldd	r24, Y+51	; 0x33
    787c:	8f 93       	push	r24
    787e:	8a a9       	ldd	r24, Y+50	; 0x32
    7880:	8f 93       	push	r24
    7882:	89 a9       	ldd	r24, Y+49	; 0x31
    7884:	8f 93       	push	r24
    7886:	1f 92       	push	r1
    7888:	1f 92       	push	r1
    788a:	1f 92       	push	r1
    788c:	1f 92       	push	r1
    788e:	7f 92       	push	r7
    7890:	6f 92       	push	r6
    7892:	1f 93       	push	r17
    7894:	0f 93       	push	r16
    7896:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
        DriverOLEDPrintSmText(4, s, 0);
    789a:	40 e0       	ldi	r20, 0x00	; 0
    789c:	b8 01       	movw	r22, r16
    789e:	84 e0       	ldi	r24, 0x04	; 4
    78a0:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>

        sprintf(s, "Z: G: %.2f A: %.2f", Gz, Az);
    78a4:	88 a9       	ldd	r24, Y+48	; 0x30
    78a6:	8f 93       	push	r24
    78a8:	8f a5       	ldd	r24, Y+47	; 0x2f
    78aa:	8f 93       	push	r24
    78ac:	8e a5       	ldd	r24, Y+46	; 0x2e
    78ae:	8f 93       	push	r24
    78b0:	8d a5       	ldd	r24, Y+45	; 0x2d
    78b2:	8f 93       	push	r24
    78b4:	1f 92       	push	r1
    78b6:	1f 92       	push	r1
    78b8:	1f 92       	push	r1
    78ba:	1f 92       	push	r1
    78bc:	5f 92       	push	r5
    78be:	4f 92       	push	r4
    78c0:	1f 93       	push	r17
    78c2:	0f 93       	push	r16
    78c4:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
        DriverOLEDPrintSmText(5, s, 0);
    78c8:	40 e0       	ldi	r20, 0x00	; 0
    78ca:	b8 01       	movw	r22, r16
    78cc:	85 e0       	ldi	r24, 0x05	; 5
    78ce:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
        
        if (Stick & CURSOR_UP);
        if (Stick & CURSOR_DOWN);
        if (Stick & CURSOR_RIGHT);
        if (Stick & CURSOR_LEFT);
        if (Stick & CURSOR_PRESS)
    78d2:	cd bf       	out	0x3d, r28	; 61
    78d4:	de bf       	out	0x3e, r29	; 62
    78d6:	30 fe       	sbrs	r3, 0
    78d8:	4a cf       	rjmp	.-364    	; 0x776e <PageKarlsTask+0x6e>
        {
            vTaskDelay(300);
    78da:	8c e2       	ldi	r24, 0x2C	; 44
    78dc:	91 e0       	ldi	r25, 0x01	; 1
    78de:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
            return;
        }
        
        DriverOLEDUpdate();
    }
}
    78e2:	cc 5b       	subi	r28, 0xBC	; 188
    78e4:	df 4f       	sbci	r29, 0xFF	; 255
    78e6:	cd bf       	out	0x3d, r28	; 61
    78e8:	de bf       	out	0x3e, r29	; 62
    78ea:	df 91       	pop	r29
    78ec:	cf 91       	pop	r28
    78ee:	1f 91       	pop	r17
    78f0:	0f 91       	pop	r16
    78f2:	ff 90       	pop	r15
    78f4:	ef 90       	pop	r14
    78f6:	df 90       	pop	r13
    78f8:	cf 90       	pop	r12
    78fa:	bf 90       	pop	r11
    78fc:	af 90       	pop	r10
    78fe:	9f 90       	pop	r9
    7900:	8f 90       	pop	r8
    7902:	7f 90       	pop	r7
    7904:	6f 90       	pop	r6
    7906:	5f 90       	pop	r5
    7908:	4f 90       	pop	r4
    790a:	3f 90       	pop	r3
    790c:	08 95       	ret

0000790e <PageCPUStatus>:



void PageCPUStatus()
{
    790e:	2f 92       	push	r2
    7910:	3f 92       	push	r3
    7912:	4f 92       	push	r4
    7914:	5f 92       	push	r5
    7916:	6f 92       	push	r6
    7918:	7f 92       	push	r7
    791a:	8f 92       	push	r8
    791c:	9f 92       	push	r9
    791e:	af 92       	push	r10
    7920:	bf 92       	push	r11
    7922:	cf 92       	push	r12
    7924:	df 92       	push	r13
    7926:	ef 92       	push	r14
    7928:	ff 92       	push	r15
    792a:	0f 93       	push	r16
    792c:	1f 93       	push	r17
    792e:	cf 93       	push	r28
    7930:	df 93       	push	r29
    7932:	cd b7       	in	r28, 0x3d	; 61
    7934:	de b7       	in	r29, 0x3e	; 62
    7936:	c4 57       	subi	r28, 0x74	; 116
    7938:	d1 40       	sbci	r29, 0x01	; 1
    793a:	cd bf       	out	0x3d, r28	; 61
    793c:	de bf       	out	0x3e, r29	; 62
	float Load;
	
	uint32_t IdleTime;
	uint32_t OldTotalRunTime=0,OldIdleTime=0;
	
	vTaskDelay(300);
    793e:	8c e2       	ldi	r24, 0x2C	; 44
    7940:	91 e0       	ldi	r25, 0x01	; 1
    7942:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
	uint32_t TotalRunTime;
	int NumTasks;
	float Load;
	
	uint32_t IdleTime;
	uint32_t OldTotalRunTime=0,OldIdleTime=0;
    7946:	41 2c       	mov	r4, r1
    7948:	51 2c       	mov	r5, r1
    794a:	32 01       	movw	r6, r4
    794c:	81 2c       	mov	r8, r1
    794e:	91 2c       	mov	r9, r1
    7950:	54 01       	movw	r10, r8
		
		
		DriverOLEDClearScreen();
		
		DriverOLEDPrintSmText(0,"Mem free:",0);
		sprintf (s,"%6u/%6u",xPortGetFreeHeapSize(),configTOTAL_HEAP_SIZE);
    7952:	8c e1       	ldi	r24, 0x1C	; 28
    7954:	28 2e       	mov	r2, r24
    7956:	87 e2       	ldi	r24, 0x27	; 39
    7958:	38 2e       	mov	r3, r24
    795a:	8e 01       	movw	r16, r28
    795c:	0f 5b       	subi	r16, 0xBF	; 191
    795e:	1e 4f       	sbci	r17, 0xFE	; 254
    7960:	8f c0       	rjmp	.+286    	; 0x7a80 <PageCPUStatus+0x172>
	{
		Stick=DriverCursorStickGetFifo(300);
		if (Stick & CURSOR_PRESS) break;
		
		
		DriverOLEDClearScreen();
    7962:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <DriverOLEDClearScreen>
		
		DriverOLEDPrintSmText(0,"Mem free:",0);
    7966:	40 e0       	ldi	r20, 0x00	; 0
    7968:	62 e1       	ldi	r22, 0x12	; 18
    796a:	77 e2       	ldi	r23, 0x27	; 39
    796c:	80 e0       	ldi	r24, 0x00	; 0
    796e:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		sprintf (s,"%6u/%6u",xPortGetFreeHeapSize(),configTOTAL_HEAP_SIZE);
    7972:	0e 94 0f 1d 	call	0x3a1e	; 0x3a1e <xPortGetFreeHeapSize>
    7976:	20 e4       	ldi	r18, 0x40	; 64
    7978:	2f 93       	push	r18
    797a:	1f 92       	push	r1
    797c:	9f 93       	push	r25
    797e:	8f 93       	push	r24
    7980:	3f 92       	push	r3
    7982:	2f 92       	push	r2
    7984:	1f 93       	push	r17
    7986:	0f 93       	push	r16
    7988:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    798c:	40 e0       	ldi	r20, 0x00	; 0
    798e:	b8 01       	movw	r22, r16
    7990:	81 e0       	ldi	r24, 0x01	; 1
    7992:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		
		
		NumTasks=uxTaskGetSystemState(TaskStatusArray,MAX_TASKS,&TotalRunTime);
    7996:	ae 01       	movw	r20, r28
    7998:	4f 58       	subi	r20, 0x8F	; 143
    799a:	5e 4f       	sbci	r21, 0xFE	; 254
    799c:	64 e1       	ldi	r22, 0x14	; 20
    799e:	ce 01       	movw	r24, r28
    79a0:	01 96       	adiw	r24, 0x01	; 1
    79a2:	0e 94 4c 2d 	call	0x5a98	; 0x5a98 <uxTaskGetSystemState>
		sprintf (s,"Number of tasks:%d",NumTasks);
    79a6:	1f 92       	push	r1
    79a8:	8f 93       	push	r24
    79aa:	84 e2       	ldi	r24, 0x24	; 36
    79ac:	97 e2       	ldi	r25, 0x27	; 39
    79ae:	9f 93       	push	r25
    79b0:	8f 93       	push	r24
    79b2:	1f 93       	push	r17
    79b4:	0f 93       	push	r16
    79b6:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(2,s,0);
    79ba:	40 e0       	ldi	r20, 0x00	; 0
    79bc:	b8 01       	movw	r22, r16
    79be:	82 e0       	ldi	r24, 0x02	; 2
    79c0:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		
		//Calculate system load
		vTaskGetTaskInfo(xTaskGetIdleTaskHandle(),&IdleTaskStatus,pdFALSE,eInvalid);
    79c4:	0e 94 8f 29 	call	0x531e	; 0x531e <xTaskGetIdleTaskHandle>
    79c8:	25 e0       	ldi	r18, 0x05	; 5
    79ca:	40 e0       	ldi	r20, 0x00	; 0
    79cc:	be 01       	movw	r22, r28
    79ce:	6f 59       	subi	r22, 0x9F	; 159
    79d0:	7e 4f       	sbci	r23, 0xFE	; 254
    79d2:	0e 94 6c 2c 	call	0x58d8	; 0x58d8 <vTaskGetInfo>
		IdleTime=IdleTaskStatus.ulRunTimeCounter;
    79d6:	c7 59       	subi	r28, 0x97	; 151
    79d8:	de 4f       	sbci	r29, 0xFE	; 254
    79da:	c8 80       	ld	r12, Y
    79dc:	d9 80       	ldd	r13, Y+1	; 0x01
    79de:	ea 80       	ldd	r14, Y+2	; 0x02
    79e0:	fb 80       	ldd	r15, Y+3	; 0x03
    79e2:	c9 56       	subi	r28, 0x69	; 105
    79e4:	d1 40       	sbci	r29, 0x01	; 1
		Load=(1-((float) (IdleTime-OldIdleTime)/ (float)(TotalRunTime-OldTotalRunTime)))*100;
		sprintf(s,"CPU Load:%2.2f",Load);
    79e6:	c7 01       	movw	r24, r14
    79e8:	b6 01       	movw	r22, r12
    79ea:	64 19       	sub	r22, r4
    79ec:	75 09       	sbc	r23, r5
    79ee:	86 09       	sbc	r24, r6
    79f0:	97 09       	sbc	r25, r7
    79f2:	0e 94 c4 46 	call	0x8d88	; 0x8d88 <__floatunsisf>
    79f6:	2b 01       	movw	r4, r22
    79f8:	3c 01       	movw	r6, r24
    79fa:	cf 58       	subi	r28, 0x8F	; 143
    79fc:	de 4f       	sbci	r29, 0xFE	; 254
    79fe:	88 81       	ld	r24, Y
    7a00:	99 81       	ldd	r25, Y+1	; 0x01
    7a02:	aa 81       	ldd	r26, Y+2	; 0x02
    7a04:	bb 81       	ldd	r27, Y+3	; 0x03
    7a06:	c1 57       	subi	r28, 0x71	; 113
    7a08:	d1 40       	sbci	r29, 0x01	; 1
    7a0a:	bc 01       	movw	r22, r24
    7a0c:	cd 01       	movw	r24, r26
    7a0e:	68 19       	sub	r22, r8
    7a10:	79 09       	sbc	r23, r9
    7a12:	8a 09       	sbc	r24, r10
    7a14:	9b 09       	sbc	r25, r11
    7a16:	0e 94 c4 46 	call	0x8d88	; 0x8d88 <__floatunsisf>
    7a1a:	9b 01       	movw	r18, r22
    7a1c:	ac 01       	movw	r20, r24
    7a1e:	c3 01       	movw	r24, r6
    7a20:	b2 01       	movw	r22, r4
    7a22:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    7a26:	9b 01       	movw	r18, r22
    7a28:	ac 01       	movw	r20, r24
    7a2a:	60 e0       	ldi	r22, 0x00	; 0
    7a2c:	70 e0       	ldi	r23, 0x00	; 0
    7a2e:	80 e8       	ldi	r24, 0x80	; 128
    7a30:	9f e3       	ldi	r25, 0x3F	; 63
    7a32:	0e 94 aa 45 	call	0x8b54	; 0x8b54 <__subsf3>
    7a36:	20 e0       	ldi	r18, 0x00	; 0
    7a38:	30 e0       	ldi	r19, 0x00	; 0
    7a3a:	48 ec       	ldi	r20, 0xC8	; 200
    7a3c:	52 e4       	ldi	r21, 0x42	; 66
    7a3e:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    7a42:	9f 93       	push	r25
    7a44:	8f 93       	push	r24
    7a46:	7f 93       	push	r23
    7a48:	6f 93       	push	r22
    7a4a:	87 e3       	ldi	r24, 0x37	; 55
    7a4c:	97 e2       	ldi	r25, 0x27	; 39
    7a4e:	9f 93       	push	r25
    7a50:	8f 93       	push	r24
    7a52:	1f 93       	push	r17
    7a54:	0f 93       	push	r16
    7a56:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(3,s,0);
    7a5a:	40 e0       	ldi	r20, 0x00	; 0
    7a5c:	b8 01       	movw	r22, r16
    7a5e:	83 e0       	ldi	r24, 0x03	; 3
    7a60:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		
		DriverOLEDUpdate();
    7a64:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <DriverOLEDUpdate>
		OldIdleTime=IdleTime;
		OldTotalRunTime=TotalRunTime;
    7a68:	cf 58       	subi	r28, 0x8F	; 143
    7a6a:	de 4f       	sbci	r29, 0xFE	; 254
    7a6c:	88 80       	ld	r8, Y
    7a6e:	99 80       	ldd	r9, Y+1	; 0x01
    7a70:	aa 80       	ldd	r10, Y+2	; 0x02
    7a72:	bb 80       	ldd	r11, Y+3	; 0x03
    7a74:	c1 57       	subi	r28, 0x71	; 113
    7a76:	d1 40       	sbci	r29, 0x01	; 1
		
	}
    7a78:	cd bf       	out	0x3d, r28	; 61
    7a7a:	de bf       	out	0x3e, r29	; 62
		Load=(1-((float) (IdleTime-OldIdleTime)/ (float)(TotalRunTime-OldTotalRunTime)))*100;
		sprintf(s,"CPU Load:%2.2f",Load);
		DriverOLEDPrintSmText(3,s,0);
		
		DriverOLEDUpdate();
		OldIdleTime=IdleTime;
    7a7c:	26 01       	movw	r4, r12
    7a7e:	37 01       	movw	r6, r14
	uint32_t OldTotalRunTime=0,OldIdleTime=0;
	
	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    7a80:	8c e2       	ldi	r24, 0x2C	; 44
    7a82:	91 e0       	ldi	r25, 0x01	; 1
    7a84:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
		if (Stick & CURSOR_PRESS) break;
    7a88:	80 ff       	sbrs	r24, 0
    7a8a:	6b cf       	rjmp	.-298    	; 0x7962 <PageCPUStatus+0x54>
		OldIdleTime=IdleTime;
		OldTotalRunTime=TotalRunTime;
		
	}
	
}
    7a8c:	cc 58       	subi	r28, 0x8C	; 140
    7a8e:	de 4f       	sbci	r29, 0xFE	; 254
    7a90:	cd bf       	out	0x3d, r28	; 61
    7a92:	de bf       	out	0x3e, r29	; 62
    7a94:	df 91       	pop	r29
    7a96:	cf 91       	pop	r28
    7a98:	1f 91       	pop	r17
    7a9a:	0f 91       	pop	r16
    7a9c:	ff 90       	pop	r15
    7a9e:	ef 90       	pop	r14
    7aa0:	df 90       	pop	r13
    7aa2:	cf 90       	pop	r12
    7aa4:	bf 90       	pop	r11
    7aa6:	af 90       	pop	r10
    7aa8:	9f 90       	pop	r9
    7aaa:	8f 90       	pop	r8
    7aac:	7f 90       	pop	r7
    7aae:	6f 90       	pop	r6
    7ab0:	5f 90       	pop	r5
    7ab2:	4f 90       	pop	r4
    7ab4:	3f 90       	pop	r3
    7ab6:	2f 90       	pop	r2
    7ab8:	08 95       	ret

00007aba <PageMotorSpeed>:

void PageMotorSpeed()
{
    7aba:	2f 92       	push	r2
    7abc:	3f 92       	push	r3
    7abe:	4f 92       	push	r4
    7ac0:	5f 92       	push	r5
    7ac2:	6f 92       	push	r6
    7ac4:	7f 92       	push	r7
    7ac6:	8f 92       	push	r8
    7ac8:	9f 92       	push	r9
    7aca:	af 92       	push	r10
    7acc:	bf 92       	push	r11
    7ace:	cf 92       	push	r12
    7ad0:	df 92       	push	r13
    7ad2:	ef 92       	push	r14
    7ad4:	ff 92       	push	r15
    7ad6:	0f 93       	push	r16
    7ad8:	1f 93       	push	r17
    7ada:	cf 93       	push	r28
    7adc:	df 93       	push	r29
    7ade:	cd b7       	in	r28, 0x3d	; 61
    7ae0:	de b7       	in	r29, 0x3e	; 62
    7ae2:	c7 54       	subi	r28, 0x47	; 71
    7ae4:	d1 09       	sbc	r29, r1
    7ae6:	cd bf       	out	0x3d, r28	; 61
    7ae8:	de bf       	out	0x3e, r29	; 62
	float Phase2;
	
	EncoderStruct EncoderInfo;
	EncoderEventStruct Event;
			
	EnableMotorPosTask();	
    7aea:	0e 94 52 3a 	call	0x74a4	; 0x74a4 <EnableMotorPosTask>
	EnableMotorSpeedTask();	
    7aee:	0e 94 1f 3b 	call	0x763e	; 0x763e <EnableMotorSpeedTask>
}

void PageMotorSpeed()
{
	uint8_t Stick;
	int16_t Speed1=50,Speed2=50;
    7af2:	82 e3       	ldi	r24, 0x32	; 50
    7af4:	a8 2e       	mov	r10, r24
    7af6:	b1 2c       	mov	r11, r1
    7af8:	92 e3       	ldi	r25, 0x32	; 50
    7afa:	c9 2e       	mov	r12, r25
    7afc:	d1 2c       	mov	r13, r1
    7afe:	9e 01       	movw	r18, r28
    7b00:	2f 5f       	subi	r18, 0xFF	; 255
    7b02:	3f 4f       	sbci	r19, 0xFF	; 255
    7b04:	79 01       	movw	r14, r18
		sprintf(s,"  A2:%d",EncoderInfo.Cnt2);
		DriverOLEDPrintSmText(3,s,0);
		
		sprintf(s,"  P1:%f",Phase1);
		DriverOLEDPrintSmText(4,s,0);
		sprintf(s,"  P2:%f",Phase2);
    7b06:	6a a6       	std	Y+42, r6	; 0x2a
    7b08:	32 01       	movw	r6, r4
    7b0a:	21 01       	movw	r4, r2
			
	EnableMotorPosTask();	
	EnableMotorSpeedTask();	
	while (1)
	{
		EncoderInfo=DriverMotorGetEncoder();
    7b0c:	0e 94 52 07 	call	0xea4	; 0xea4 <DriverMotorGetEncoder>
    7b10:	86 2e       	mov	r8, r22
    7b12:	37 2e       	mov	r3, r23
    7b14:	28 2e       	mov	r2, r24
    7b16:	99 2e       	mov	r9, r25

		EdgeIdx1=0; EdgeIdx2=0;
    7b18:	10 e0       	ldi	r17, 0x00	; 0
    7b1a:	00 e0       	ldi	r16, 0x00	; 0
		while(1) 
		{
			Event=DriverMotorGetEncoderEvent();
    7b1c:	0e 94 62 07 	call	0xec4	; 0xec4 <DriverMotorGetEncoderEvent>
    7b20:	29 a3       	std	Y+33, r18	; 0x21
    7b22:	3a a3       	std	Y+34, r19	; 0x22
    7b24:	4b a3       	std	Y+35, r20	; 0x23
    7b26:	5c a3       	std	Y+36, r21	; 0x24
    7b28:	89 a1       	ldd	r24, Y+33	; 0x21
    7b2a:	9a a1       	ldd	r25, Y+34	; 0x22
    7b2c:	ab a1       	ldd	r26, Y+35	; 0x23
    7b2e:	bc a1       	ldd	r27, Y+36	; 0x24
			if (Event.Time==0) break; //No more events
    7b30:	00 97       	sbiw	r24, 0x00	; 0
    7b32:	a1 05       	cpc	r26, r1
    7b34:	b1 05       	cpc	r27, r1
    7b36:	09 f4       	brne	.+2      	; 0x7b3a <PageMotorSpeed+0x80>
    7b38:	40 c0       	rjmp	.+128    	; 0x7bba <PageMotorSpeed+0x100>
			
			//Parse events for encoder 1
			if (EdgeIdx1==0)
    7b3a:	01 11       	cpse	r16, r1
    7b3c:	0c c0       	rjmp	.+24     	; 0x7b56 <PageMotorSpeed+0x9c>
			{
				if (Event.Event==RISING_1A)
    7b3e:	61 30       	cpi	r22, 0x01	; 1
    7b40:	c1 f1       	breq	.+112    	; 0x7bb2 <PageMotorSpeed+0xf8>
					EdgeIdx1++;
				}
			}

			//Parse events for encoder 2
			if (EdgeIdx2==0)
    7b42:	11 11       	cpse	r17, r1
    7b44:	17 c0       	rjmp	.+46     	; 0x7b74 <PageMotorSpeed+0xba>
			{
				if (Event.Event==RISING_2A)
    7b46:	63 30       	cpi	r22, 0x03	; 3
    7b48:	49 f7       	brne	.-46     	; 0x7b1c <PageMotorSpeed+0x62>
    7b4a:	8e a3       	std	Y+38, r24	; 0x26
    7b4c:	9f a3       	std	Y+39, r25	; 0x27
    7b4e:	a8 a7       	std	Y+40, r26	; 0x28
    7b50:	b9 a7       	std	Y+41, r27	; 0x29
				{
					EdgeList2[0]=Event.Time;
					EdgeIdx2++;
    7b52:	11 e0       	ldi	r17, 0x01	; 1
    7b54:	e3 cf       	rjmp	.-58     	; 0x7b1c <PageMotorSpeed+0x62>
				{
					EdgeList1[0]=Event.Time;
					EdgeIdx1++;
				}
			}
			else if (EdgeIdx1==1)
    7b56:	01 30       	cpi	r16, 0x01	; 1
    7b58:	d9 f0       	breq	.+54     	; 0x7b90 <PageMotorSpeed+0xd6>
				{
					EdgeList1[1]=Event.Time;
					EdgeIdx1++;
				}
			}
			else if (EdgeIdx1==2)
    7b5a:	02 30       	cpi	r16, 0x02	; 2
    7b5c:	91 f7       	brne	.-28     	; 0x7b42 <PageMotorSpeed+0x88>
			{
				if (Event.Event==RISING_1A)
    7b5e:	61 30       	cpi	r22, 0x01	; 1
    7b60:	81 f7       	brne	.-32     	; 0x7b42 <PageMotorSpeed+0x88>
    7b62:	24 96       	adiw	r28, 0x04	; 4
    7b64:	8c af       	std	Y+60, r24	; 0x3c
    7b66:	9d af       	std	Y+61, r25	; 0x3d
    7b68:	ae af       	std	Y+62, r26	; 0x3e
    7b6a:	bf af       	std	Y+63, r27	; 0x3f
    7b6c:	24 97       	sbiw	r28, 0x04	; 4
				{
					EdgeList1[2]=Event.Time;
					EdgeIdx1++;
    7b6e:	03 e0       	ldi	r16, 0x03	; 3
				}
			}

			//Parse events for encoder 2
			if (EdgeIdx2==0)
    7b70:	11 23       	and	r17, r17
    7b72:	a1 f2       	breq	.-88     	; 0x7b1c <PageMotorSpeed+0x62>
				{
					EdgeList2[0]=Event.Time;
					EdgeIdx2++;
				}
			}
			else if (EdgeIdx2==1)
    7b74:	11 30       	cpi	r17, 0x01	; 1
    7b76:	a1 f0       	breq	.+40     	; 0x7ba0 <PageMotorSpeed+0xe6>
				{
					EdgeList2[1]=Event.Time;
					EdgeIdx2++;
				}
			}
			else if (EdgeIdx2==2)
    7b78:	12 30       	cpi	r17, 0x02	; 2
    7b7a:	81 f6       	brne	.-96     	; 0x7b1c <PageMotorSpeed+0x62>
			{
				if (Event.Event==RISING_2A)
    7b7c:	63 30       	cpi	r22, 0x03	; 3
    7b7e:	71 f6       	brne	.-100    	; 0x7b1c <PageMotorSpeed+0x62>
    7b80:	28 96       	adiw	r28, 0x08	; 8
    7b82:	8c af       	std	Y+60, r24	; 0x3c
    7b84:	9d af       	std	Y+61, r25	; 0x3d
    7b86:	ae af       	std	Y+62, r26	; 0x3e
    7b88:	bf af       	std	Y+63, r27	; 0x3f
    7b8a:	28 97       	sbiw	r28, 0x08	; 8
				{
					EdgeList2[2]=Event.Time;
					EdgeIdx2++;
    7b8c:	13 e0       	ldi	r17, 0x03	; 3
    7b8e:	c6 cf       	rjmp	.-116    	; 0x7b1c <PageMotorSpeed+0x62>
					EdgeIdx1++;
				}
			}
			else if (EdgeIdx1==1)
			{
				if (Event.Event==RISING_1B)
    7b90:	62 30       	cpi	r22, 0x02	; 2
    7b92:	b9 f6       	brne	.-82     	; 0x7b42 <PageMotorSpeed+0x88>
    7b94:	8c af       	std	Y+60, r24	; 0x3c
    7b96:	9d af       	std	Y+61, r25	; 0x3d
    7b98:	ae af       	std	Y+62, r26	; 0x3e
    7b9a:	bf af       	std	Y+63, r27	; 0x3f
				{
					EdgeList1[1]=Event.Time;
					EdgeIdx1++;
    7b9c:	02 e0       	ldi	r16, 0x02	; 2
    7b9e:	e8 cf       	rjmp	.-48     	; 0x7b70 <PageMotorSpeed+0xb6>
					EdgeIdx2++;
				}
			}
			else if (EdgeIdx2==1)
			{
				if (Event.Event==RISING_2B)
    7ba0:	64 30       	cpi	r22, 0x04	; 4
    7ba2:	09 f0       	breq	.+2      	; 0x7ba6 <PageMotorSpeed+0xec>
    7ba4:	bb cf       	rjmp	.-138    	; 0x7b1c <PageMotorSpeed+0x62>
    7ba6:	88 af       	std	Y+56, r24	; 0x38
    7ba8:	99 af       	std	Y+57, r25	; 0x39
    7baa:	aa af       	std	Y+58, r26	; 0x3a
    7bac:	bb af       	std	Y+59, r27	; 0x3b
				{
					EdgeList2[1]=Event.Time;
					EdgeIdx2++;
    7bae:	12 e0       	ldi	r17, 0x02	; 2
    7bb0:	b5 cf       	rjmp	.-150    	; 0x7b1c <PageMotorSpeed+0x62>
    7bb2:	2c 01       	movw	r4, r24
    7bb4:	3d 01       	movw	r6, r26
			if (EdgeIdx1==0)
			{
				if (Event.Event==RISING_1A)
				{
					EdgeList1[0]=Event.Time;
					EdgeIdx1++;
    7bb6:	01 e0       	ldi	r16, 0x01	; 1
    7bb8:	db cf       	rjmp	.-74     	; 0x7b70 <PageMotorSpeed+0xb6>
					EdgeList2[2]=Event.Time;
					EdgeIdx2++;
				}
			}
		}
		if (EdgeIdx1==3) //All events needed are detected
    7bba:	03 30       	cpi	r16, 0x03	; 3
    7bbc:	09 f4       	brne	.+2      	; 0x7bc0 <PageMotorSpeed+0x106>
    7bbe:	c6 c0       	rjmp	.+396    	; 0x7d4c <PageMotorSpeed+0x292>
		{
			Phase1=(float) ((EdgeList1[1]-EdgeList1[0])/ (float) (EdgeList1[2]-EdgeList1[0]))*180;
		}
		if (EdgeIdx2==3) //All events needed are detected
    7bc0:	13 30       	cpi	r17, 0x03	; 3
    7bc2:	09 f4       	brne	.+2      	; 0x7bc6 <PageMotorSpeed+0x10c>
    7bc4:	8e c0       	rjmp	.+284    	; 0x7ce2 <PageMotorSpeed+0x228>
		{
			Phase2=(float) ((EdgeList2[1]-EdgeList2[0])/ (float) (EdgeList2[2]-EdgeList2[0]))*180;
		}
		
		
		Stick=DriverCursorStickGetFifo(300);
    7bc6:	8c e2       	ldi	r24, 0x2C	; 44
    7bc8:	91 e0       	ldi	r25, 0x01	; 1
    7bca:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
    7bce:	18 2f       	mov	r17, r24
		
		DriverOLEDClearScreen();
    7bd0:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <DriverOLEDClearScreen>
		
		sprintf(s,"  S1:%d",Speed1);
    7bd4:	df 92       	push	r13
    7bd6:	cf 92       	push	r12
    7bd8:	46 e4       	ldi	r20, 0x46	; 70
    7bda:	57 e2       	ldi	r21, 0x27	; 39
    7bdc:	5f 93       	push	r21
    7bde:	4f 93       	push	r20
    7be0:	ff 92       	push	r15
    7be2:	ef 92       	push	r14
    7be4:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    7be8:	40 e0       	ldi	r20, 0x00	; 0
    7bea:	b7 01       	movw	r22, r14
    7bec:	80 e0       	ldi	r24, 0x00	; 0
    7bee:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		sprintf(s,"  S2:%d",Speed2);
    7bf2:	bf 92       	push	r11
    7bf4:	af 92       	push	r10
    7bf6:	2e e4       	ldi	r18, 0x4E	; 78
    7bf8:	37 e2       	ldi	r19, 0x27	; 39
    7bfa:	3f 93       	push	r19
    7bfc:	2f 93       	push	r18
    7bfe:	ff 92       	push	r15
    7c00:	ef 92       	push	r14
    7c02:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    7c06:	40 e0       	ldi	r20, 0x00	; 0
    7c08:	b7 01       	movw	r22, r14
    7c0a:	81 e0       	ldi	r24, 0x01	; 1
    7c0c:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>

		sprintf(s,"  A1:%d",EncoderInfo.Cnt1);
    7c10:	3f 92       	push	r3
    7c12:	8f 92       	push	r8
    7c14:	86 e5       	ldi	r24, 0x56	; 86
    7c16:	97 e2       	ldi	r25, 0x27	; 39
    7c18:	9f 93       	push	r25
    7c1a:	8f 93       	push	r24
    7c1c:	ff 92       	push	r15
    7c1e:	ef 92       	push	r14
    7c20:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(2,s,0);
    7c24:	40 e0       	ldi	r20, 0x00	; 0
    7c26:	b7 01       	movw	r22, r14
    7c28:	82 e0       	ldi	r24, 0x02	; 2
    7c2a:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		sprintf(s,"  A2:%d",EncoderInfo.Cnt2);
    7c2e:	9f 92       	push	r9
    7c30:	2f 92       	push	r2
    7c32:	4e e5       	ldi	r20, 0x5E	; 94
    7c34:	57 e2       	ldi	r21, 0x27	; 39
    7c36:	5f 93       	push	r21
    7c38:	4f 93       	push	r20
    7c3a:	ff 92       	push	r15
    7c3c:	ef 92       	push	r14
    7c3e:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(3,s,0);
    7c42:	40 e0       	ldi	r20, 0x00	; 0
    7c44:	b7 01       	movw	r22, r14
    7c46:	83 e0       	ldi	r24, 0x03	; 3
    7c48:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		
		sprintf(s,"  P1:%f",Phase1);
    7c4c:	9c a9       	ldd	r25, Y+52	; 0x34
    7c4e:	9f 93       	push	r25
    7c50:	2b a9       	ldd	r18, Y+51	; 0x33
    7c52:	2f 93       	push	r18
    7c54:	3a a9       	ldd	r19, Y+50	; 0x32
    7c56:	3f 93       	push	r19
    7c58:	4e a5       	ldd	r20, Y+46	; 0x2e
    7c5a:	4f 93       	push	r20
    7c5c:	86 e6       	ldi	r24, 0x66	; 102
    7c5e:	97 e2       	ldi	r25, 0x27	; 39
    7c60:	9f 93       	push	r25
    7c62:	8f 93       	push	r24
    7c64:	ff 92       	push	r15
    7c66:	ef 92       	push	r14
    7c68:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(4,s,0);
    7c6c:	cd bf       	out	0x3d, r28	; 61
    7c6e:	de bf       	out	0x3e, r29	; 62
    7c70:	40 e0       	ldi	r20, 0x00	; 0
    7c72:	b7 01       	movw	r22, r14
    7c74:	84 e0       	ldi	r24, 0x04	; 4
    7c76:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		sprintf(s,"  P2:%f",Phase2);
    7c7a:	5a a5       	ldd	r21, Y+42	; 0x2a
    7c7c:	5f 93       	push	r21
    7c7e:	8f a9       	ldd	r24, Y+55	; 0x37
    7c80:	8f 93       	push	r24
    7c82:	9e a9       	ldd	r25, Y+54	; 0x36
    7c84:	9f 93       	push	r25
    7c86:	2d a9       	ldd	r18, Y+53	; 0x35
    7c88:	2f 93       	push	r18
    7c8a:	4e e6       	ldi	r20, 0x6E	; 110
    7c8c:	57 e2       	ldi	r21, 0x27	; 39
    7c8e:	5f 93       	push	r21
    7c90:	4f 93       	push	r20
    7c92:	ff 92       	push	r15
    7c94:	ef 92       	push	r14
    7c96:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(5,s,0);
    7c9a:	40 e0       	ldi	r20, 0x00	; 0
    7c9c:	b7 01       	movw	r22, r14
    7c9e:	85 e0       	ldi	r24, 0x05	; 5
    7ca0:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>

		
		if (Stick & CURSOR_UP) Speed1+=5;
    7ca4:	cd bf       	out	0x3d, r28	; 61
    7ca6:	de bf       	out	0x3e, r29	; 62
    7ca8:	14 ff       	sbrs	r17, 4
    7caa:	03 c0       	rjmp	.+6      	; 0x7cb2 <PageMotorSpeed+0x1f8>
    7cac:	35 e0       	ldi	r19, 0x05	; 5
    7cae:	c3 0e       	add	r12, r19
    7cb0:	d1 1c       	adc	r13, r1
		if (Stick & CURSOR_DOWN) Speed1-=5;
    7cb2:	12 ff       	sbrs	r17, 2
    7cb4:	03 c0       	rjmp	.+6      	; 0x7cbc <PageMotorSpeed+0x202>
    7cb6:	45 e0       	ldi	r20, 0x05	; 5
    7cb8:	c4 1a       	sub	r12, r20
    7cba:	d1 08       	sbc	r13, r1
		if (Stick & CURSOR_RIGHT) Speed2+=5;
    7cbc:	11 ff       	sbrs	r17, 1
    7cbe:	03 c0       	rjmp	.+6      	; 0x7cc6 <PageMotorSpeed+0x20c>
    7cc0:	55 e0       	ldi	r21, 0x05	; 5
    7cc2:	a5 0e       	add	r10, r21
    7cc4:	b1 1c       	adc	r11, r1
		if (Stick & CURSOR_LEFT) Speed2-=5;	
    7cc6:	13 ff       	sbrs	r17, 3
    7cc8:	03 c0       	rjmp	.+6      	; 0x7cd0 <PageMotorSpeed+0x216>
    7cca:	85 e0       	ldi	r24, 0x05	; 5
    7ccc:	a8 1a       	sub	r10, r24
    7cce:	b1 08       	sbc	r11, r1
		if (Stick & CURSOR_PRESS)
    7cd0:	10 fd       	sbrc	r17, 0
    7cd2:	69 c0       	rjmp	.+210    	; 0x7da6 <PageMotorSpeed+0x2ec>
			DisableMotorSpeedTask();
			DisableMotorPosTask();
			
			return;
		}	
		MotorSpeedSet(Speed1,Speed2);
    7cd4:	b5 01       	movw	r22, r10
    7cd6:	c6 01       	movw	r24, r12
    7cd8:	0e 94 31 3b 	call	0x7662	; 0x7662 <MotorSpeedSet>
		
		
		DriverOLEDUpdate();
    7cdc:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <DriverOLEDUpdate>
		
	}
    7ce0:	15 cf       	rjmp	.-470    	; 0x7b0c <PageMotorSpeed+0x52>
		{
			Phase1=(float) ((EdgeList1[1]-EdgeList1[0])/ (float) (EdgeList1[2]-EdgeList1[0]))*180;
		}
		if (EdgeIdx2==3) //All events needed are detected
		{
			Phase2=(float) ((EdgeList2[1]-EdgeList2[0])/ (float) (EdgeList2[2]-EdgeList2[0]))*180;
    7ce2:	68 ad       	ldd	r22, Y+56	; 0x38
    7ce4:	79 ad       	ldd	r23, Y+57	; 0x39
    7ce6:	8a ad       	ldd	r24, Y+58	; 0x3a
    7ce8:	9b ad       	ldd	r25, Y+59	; 0x3b
    7cea:	2e a1       	ldd	r18, Y+38	; 0x26
    7cec:	3f a1       	ldd	r19, Y+39	; 0x27
    7cee:	48 a5       	ldd	r20, Y+40	; 0x28
    7cf0:	59 a5       	ldd	r21, Y+41	; 0x29
    7cf2:	62 1b       	sub	r22, r18
    7cf4:	73 0b       	sbc	r23, r19
    7cf6:	84 0b       	sbc	r24, r20
    7cf8:	95 0b       	sbc	r25, r21
    7cfa:	0e 94 c4 46 	call	0x8d88	; 0x8d88 <__floatunsisf>
    7cfe:	6a a7       	std	Y+42, r22	; 0x2a
    7d00:	7b a7       	std	Y+43, r23	; 0x2b
    7d02:	8c a7       	std	Y+44, r24	; 0x2c
    7d04:	9d a7       	std	Y+45, r25	; 0x2d
    7d06:	28 96       	adiw	r28, 0x08	; 8
    7d08:	6c ad       	ldd	r22, Y+60	; 0x3c
    7d0a:	7d ad       	ldd	r23, Y+61	; 0x3d
    7d0c:	8e ad       	ldd	r24, Y+62	; 0x3e
    7d0e:	9f ad       	ldd	r25, Y+63	; 0x3f
    7d10:	28 97       	sbiw	r28, 0x08	; 8
    7d12:	2e a1       	ldd	r18, Y+38	; 0x26
    7d14:	3f a1       	ldd	r19, Y+39	; 0x27
    7d16:	48 a5       	ldd	r20, Y+40	; 0x28
    7d18:	59 a5       	ldd	r21, Y+41	; 0x29
    7d1a:	62 1b       	sub	r22, r18
    7d1c:	73 0b       	sbc	r23, r19
    7d1e:	84 0b       	sbc	r24, r20
    7d20:	95 0b       	sbc	r25, r21
    7d22:	0e 94 c4 46 	call	0x8d88	; 0x8d88 <__floatunsisf>
    7d26:	9b 01       	movw	r18, r22
    7d28:	ac 01       	movw	r20, r24
    7d2a:	6a a5       	ldd	r22, Y+42	; 0x2a
    7d2c:	7b a5       	ldd	r23, Y+43	; 0x2b
    7d2e:	8c a5       	ldd	r24, Y+44	; 0x2c
    7d30:	9d a5       	ldd	r25, Y+45	; 0x2d
    7d32:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    7d36:	20 e0       	ldi	r18, 0x00	; 0
    7d38:	30 e0       	ldi	r19, 0x00	; 0
    7d3a:	44 e3       	ldi	r20, 0x34	; 52
    7d3c:	53 e4       	ldi	r21, 0x43	; 67
    7d3e:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    7d42:	6d ab       	std	Y+53, r22	; 0x35
    7d44:	7e ab       	std	Y+54, r23	; 0x36
    7d46:	8f ab       	std	Y+55, r24	; 0x37
    7d48:	9a a7       	std	Y+42, r25	; 0x2a
    7d4a:	3d cf       	rjmp	.-390    	; 0x7bc6 <PageMotorSpeed+0x10c>
				}
			}
		}
		if (EdgeIdx1==3) //All events needed are detected
		{
			Phase1=(float) ((EdgeList1[1]-EdgeList1[0])/ (float) (EdgeList1[2]-EdgeList1[0]))*180;
    7d4c:	6c ad       	ldd	r22, Y+60	; 0x3c
    7d4e:	7d ad       	ldd	r23, Y+61	; 0x3d
    7d50:	8e ad       	ldd	r24, Y+62	; 0x3e
    7d52:	9f ad       	ldd	r25, Y+63	; 0x3f
    7d54:	64 19       	sub	r22, r4
    7d56:	75 09       	sbc	r23, r5
    7d58:	86 09       	sbc	r24, r6
    7d5a:	97 09       	sbc	r25, r7
    7d5c:	0e 94 c4 46 	call	0x8d88	; 0x8d88 <__floatunsisf>
    7d60:	6e a7       	std	Y+46, r22	; 0x2e
    7d62:	7f a7       	std	Y+47, r23	; 0x2f
    7d64:	88 ab       	std	Y+48, r24	; 0x30
    7d66:	99 ab       	std	Y+49, r25	; 0x31
    7d68:	24 96       	adiw	r28, 0x04	; 4
    7d6a:	6c ad       	ldd	r22, Y+60	; 0x3c
    7d6c:	7d ad       	ldd	r23, Y+61	; 0x3d
    7d6e:	8e ad       	ldd	r24, Y+62	; 0x3e
    7d70:	9f ad       	ldd	r25, Y+63	; 0x3f
    7d72:	24 97       	sbiw	r28, 0x04	; 4
    7d74:	64 19       	sub	r22, r4
    7d76:	75 09       	sbc	r23, r5
    7d78:	86 09       	sbc	r24, r6
    7d7a:	97 09       	sbc	r25, r7
    7d7c:	0e 94 c4 46 	call	0x8d88	; 0x8d88 <__floatunsisf>
    7d80:	9b 01       	movw	r18, r22
    7d82:	ac 01       	movw	r20, r24
    7d84:	6e a5       	ldd	r22, Y+46	; 0x2e
    7d86:	7f a5       	ldd	r23, Y+47	; 0x2f
    7d88:	88 a9       	ldd	r24, Y+48	; 0x30
    7d8a:	99 a9       	ldd	r25, Y+49	; 0x31
    7d8c:	0e 94 1c 46 	call	0x8c38	; 0x8c38 <__divsf3>
    7d90:	20 e0       	ldi	r18, 0x00	; 0
    7d92:	30 e0       	ldi	r19, 0x00	; 0
    7d94:	44 e3       	ldi	r20, 0x34	; 52
    7d96:	53 e4       	ldi	r21, 0x43	; 67
    7d98:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    7d9c:	6e a7       	std	Y+46, r22	; 0x2e
    7d9e:	7a ab       	std	Y+50, r23	; 0x32
    7da0:	8b ab       	std	Y+51, r24	; 0x33
    7da2:	9c ab       	std	Y+52, r25	; 0x34
    7da4:	0d cf       	rjmp	.-486    	; 0x7bc0 <PageMotorSpeed+0x106>
		if (Stick & CURSOR_DOWN) Speed1-=5;
		if (Stick & CURSOR_RIGHT) Speed2+=5;
		if (Stick & CURSOR_LEFT) Speed2-=5;	
		if (Stick & CURSOR_PRESS)
		{
			MotorSpeedSet(0,0);
    7da6:	60 e0       	ldi	r22, 0x00	; 0
    7da8:	70 e0       	ldi	r23, 0x00	; 0
    7daa:	80 e0       	ldi	r24, 0x00	; 0
    7dac:	90 e0       	ldi	r25, 0x00	; 0
    7dae:	0e 94 31 3b 	call	0x7662	; 0x7662 <MotorSpeedSet>
			vTaskDelay(300);
    7db2:	8c e2       	ldi	r24, 0x2C	; 44
    7db4:	91 e0       	ldi	r25, 0x01	; 1
    7db6:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
			DisableMotorSpeedTask();
    7dba:	0e 94 2b 3b 	call	0x7656	; 0x7656 <DisableMotorSpeedTask>
			DisableMotorPosTask();
    7dbe:	0e 94 6b 3a 	call	0x74d6	; 0x74d6 <DisableMotorPosTask>
		
		DriverOLEDUpdate();
		
	}
		
}
    7dc2:	c9 5b       	subi	r28, 0xB9	; 185
    7dc4:	df 4f       	sbci	r29, 0xFF	; 255
    7dc6:	cd bf       	out	0x3d, r28	; 61
    7dc8:	de bf       	out	0x3e, r29	; 62
    7dca:	df 91       	pop	r29
    7dcc:	cf 91       	pop	r28
    7dce:	1f 91       	pop	r17
    7dd0:	0f 91       	pop	r16
    7dd2:	ff 90       	pop	r15
    7dd4:	ef 90       	pop	r14
    7dd6:	df 90       	pop	r13
    7dd8:	cf 90       	pop	r12
    7dda:	bf 90       	pop	r11
    7ddc:	af 90       	pop	r10
    7dde:	9f 90       	pop	r9
    7de0:	8f 90       	pop	r8
    7de2:	7f 90       	pop	r7
    7de4:	6f 90       	pop	r6
    7de6:	5f 90       	pop	r5
    7de8:	4f 90       	pop	r4
    7dea:	3f 90       	pop	r3
    7dec:	2f 90       	pop	r2
    7dee:	08 95       	ret

00007df0 <PageADPS9960>:

void PageADPS9960()
{
    7df0:	7f 92       	push	r7
    7df2:	8f 92       	push	r8
    7df4:	9f 92       	push	r9
    7df6:	af 92       	push	r10
    7df8:	bf 92       	push	r11
    7dfa:	cf 92       	push	r12
    7dfc:	df 92       	push	r13
    7dfe:	ef 92       	push	r14
    7e00:	ff 92       	push	r15
    7e02:	0f 93       	push	r16
    7e04:	1f 93       	push	r17
    7e06:	cf 93       	push	r28
    7e08:	df 93       	push	r29
    7e0a:	cd b7       	in	r28, 0x3d	; 61
    7e0c:	de b7       	in	r29, 0x3e	; 62
    7e0e:	a8 97       	sbiw	r28, 0x28	; 40
    7e10:	cd bf       	out	0x3d, r28	; 61
    7e12:	de bf       	out	0x3e, r29	; 62
	uint8_t Stick;
	uint16_t C,R,G,B;
	char s[32];
	
	DriverLedSet(0b0010);
    7e14:	82 e0       	ldi	r24, 0x02	; 2
    7e16:	0e 94 94 06 	call	0xd28	; 0xd28 <DriverLedSet>
	vTaskDelay(300);
    7e1a:	8c e2       	ldi	r24, 0x2C	; 44
    7e1c:	91 e0       	ldi	r25, 0x01	; 1
    7e1e:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
    7e22:	8e 01       	movw	r16, r28
    7e24:	0f 5f       	subi	r16, 0xFF	; 255
    7e26:	1f 4f       	sbci	r17, 0xFF	; 255
		
		DriverOLEDClearScreen();
		
		DriverAdps9960Get(&C,&R,&G,&B);
		
		sprintf(s,"C:%u",C);
    7e28:	86 e7       	ldi	r24, 0x76	; 118
    7e2a:	88 2e       	mov	r8, r24
    7e2c:	87 e2       	ldi	r24, 0x27	; 39
    7e2e:	98 2e       	mov	r9, r24
		DriverOLEDPrintSmText(0,s,0);

		sprintf(s,"R:%u",R);
    7e30:	9b e7       	ldi	r25, 0x7B	; 123
    7e32:	a9 2e       	mov	r10, r25
    7e34:	97 e2       	ldi	r25, 0x27	; 39
    7e36:	b9 2e       	mov	r11, r25
		DriverOLEDPrintSmText(1,s,0);
		
		sprintf(s,"G:%u",G);
    7e38:	20 e8       	ldi	r18, 0x80	; 128
    7e3a:	c2 2e       	mov	r12, r18
    7e3c:	27 e2       	ldi	r18, 0x27	; 39
    7e3e:	d2 2e       	mov	r13, r18
		DriverOLEDPrintSmText(2,s,0);
		
		sprintf(s,"B:%u",B);
    7e40:	35 e8       	ldi	r19, 0x85	; 133
    7e42:	e3 2e       	mov	r14, r19
    7e44:	37 e2       	ldi	r19, 0x27	; 39
    7e46:	f3 2e       	mov	r15, r19
    7e48:	02 c0       	rjmp	.+4      	; 0x7e4e <PageADPS9960+0x5e>
			vTaskDelay(300);
			DriverLedClear(0b0010);
			return;
		}
	
		DriverOLEDUpdate();
    7e4a:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <DriverOLEDUpdate>
	
	DriverLedSet(0b0010);
	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    7e4e:	8c e2       	ldi	r24, 0x2C	; 44
    7e50:	91 e0       	ldi	r25, 0x01	; 1
    7e52:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
    7e56:	78 2e       	mov	r7, r24
		
		
		DriverOLEDClearScreen();
    7e58:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <DriverOLEDClearScreen>
		
		DriverAdps9960Get(&C,&R,&G,&B);
    7e5c:	9e 01       	movw	r18, r28
    7e5e:	2f 5d       	subi	r18, 0xDF	; 223
    7e60:	3f 4f       	sbci	r19, 0xFF	; 255
    7e62:	ae 01       	movw	r20, r28
    7e64:	4d 5d       	subi	r20, 0xDD	; 221
    7e66:	5f 4f       	sbci	r21, 0xFF	; 255
    7e68:	be 01       	movw	r22, r28
    7e6a:	6b 5d       	subi	r22, 0xDB	; 219
    7e6c:	7f 4f       	sbci	r23, 0xFF	; 255
    7e6e:	ce 01       	movw	r24, r28
    7e70:	87 96       	adiw	r24, 0x27	; 39
    7e72:	0e 94 88 04 	call	0x910	; 0x910 <DriverAdps9960Get>
		
		sprintf(s,"C:%u",C);
    7e76:	88 a5       	ldd	r24, Y+40	; 0x28
    7e78:	8f 93       	push	r24
    7e7a:	8f a1       	ldd	r24, Y+39	; 0x27
    7e7c:	8f 93       	push	r24
    7e7e:	9f 92       	push	r9
    7e80:	8f 92       	push	r8
    7e82:	1f 93       	push	r17
    7e84:	0f 93       	push	r16
    7e86:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    7e8a:	40 e0       	ldi	r20, 0x00	; 0
    7e8c:	b8 01       	movw	r22, r16
    7e8e:	80 e0       	ldi	r24, 0x00	; 0
    7e90:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>

		sprintf(s,"R:%u",R);
    7e94:	8e a1       	ldd	r24, Y+38	; 0x26
    7e96:	8f 93       	push	r24
    7e98:	8d a1       	ldd	r24, Y+37	; 0x25
    7e9a:	8f 93       	push	r24
    7e9c:	bf 92       	push	r11
    7e9e:	af 92       	push	r10
    7ea0:	1f 93       	push	r17
    7ea2:	0f 93       	push	r16
    7ea4:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    7ea8:	40 e0       	ldi	r20, 0x00	; 0
    7eaa:	b8 01       	movw	r22, r16
    7eac:	81 e0       	ldi	r24, 0x01	; 1
    7eae:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		
		sprintf(s,"G:%u",G);
    7eb2:	8c a1       	ldd	r24, Y+36	; 0x24
    7eb4:	8f 93       	push	r24
    7eb6:	8b a1       	ldd	r24, Y+35	; 0x23
    7eb8:	8f 93       	push	r24
    7eba:	df 92       	push	r13
    7ebc:	cf 92       	push	r12
    7ebe:	1f 93       	push	r17
    7ec0:	0f 93       	push	r16
    7ec2:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(2,s,0);
    7ec6:	40 e0       	ldi	r20, 0x00	; 0
    7ec8:	b8 01       	movw	r22, r16
    7eca:	82 e0       	ldi	r24, 0x02	; 2
    7ecc:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		
		sprintf(s,"B:%u",B);
    7ed0:	8a a1       	ldd	r24, Y+34	; 0x22
    7ed2:	8f 93       	push	r24
    7ed4:	89 a1       	ldd	r24, Y+33	; 0x21
    7ed6:	8f 93       	push	r24
    7ed8:	ff 92       	push	r15
    7eda:	ef 92       	push	r14
    7edc:	1f 93       	push	r17
    7ede:	0f 93       	push	r16
    7ee0:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(3,s,0);
    7ee4:	40 e0       	ldi	r20, 0x00	; 0
    7ee6:	b8 01       	movw	r22, r16
    7ee8:	83 e0       	ldi	r24, 0x03	; 3
    7eea:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		
		if (Stick & CURSOR_UP);
		if (Stick & CURSOR_DOWN);
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
    7eee:	cd bf       	out	0x3d, r28	; 61
    7ef0:	de bf       	out	0x3e, r29	; 62
    7ef2:	70 fe       	sbrs	r7, 0
    7ef4:	aa cf       	rjmp	.-172    	; 0x7e4a <PageADPS9960+0x5a>
		{
			vTaskDelay(300);
    7ef6:	8c e2       	ldi	r24, 0x2C	; 44
    7ef8:	91 e0       	ldi	r25, 0x01	; 1
    7efa:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
			DriverLedClear(0b0010);
    7efe:	82 e0       	ldi	r24, 0x02	; 2
    7f00:	0e 94 a4 06 	call	0xd48	; 0xd48 <DriverLedClear>
		}
	
		DriverOLEDUpdate();
		
	}	
}
    7f04:	a8 96       	adiw	r28, 0x28	; 40
    7f06:	cd bf       	out	0x3d, r28	; 61
    7f08:	de bf       	out	0x3e, r29	; 62
    7f0a:	df 91       	pop	r29
    7f0c:	cf 91       	pop	r28
    7f0e:	1f 91       	pop	r17
    7f10:	0f 91       	pop	r16
    7f12:	ff 90       	pop	r15
    7f14:	ef 90       	pop	r14
    7f16:	df 90       	pop	r13
    7f18:	cf 90       	pop	r12
    7f1a:	bf 90       	pop	r11
    7f1c:	af 90       	pop	r10
    7f1e:	9f 90       	pop	r9
    7f20:	8f 90       	pop	r8
    7f22:	7f 90       	pop	r7
    7f24:	08 95       	ret

00007f26 <PageADC>:

void PageADC()
{
    7f26:	2f 92       	push	r2
    7f28:	3f 92       	push	r3
    7f2a:	4f 92       	push	r4
    7f2c:	5f 92       	push	r5
    7f2e:	6f 92       	push	r6
    7f30:	7f 92       	push	r7
    7f32:	8f 92       	push	r8
    7f34:	9f 92       	push	r9
    7f36:	af 92       	push	r10
    7f38:	bf 92       	push	r11
    7f3a:	cf 92       	push	r12
    7f3c:	df 92       	push	r13
    7f3e:	ef 92       	push	r14
    7f40:	ff 92       	push	r15
    7f42:	0f 93       	push	r16
    7f44:	1f 93       	push	r17
    7f46:	cf 93       	push	r28
    7f48:	df 93       	push	r29
    7f4a:	cd b7       	in	r28, 0x3d	; 61
    7f4c:	de b7       	in	r29, 0x3e	; 62
    7f4e:	a9 97       	sbiw	r28, 0x29	; 41
    7f50:	cd bf       	out	0x3d, r28	; 61
    7f52:	de bf       	out	0x3e, r29	; 62
	uint8_t Stick;
	char s[32];
	ADCStruct ADCData;

	vTaskDelay(300);
    7f54:	8c e2       	ldi	r24, 0x2C	; 44
    7f56:	91 e0       	ldi	r25, 0x01	; 1
    7f58:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
    7f5c:	8e 01       	movw	r16, r28
    7f5e:	0f 5f       	subi	r16, 0xFF	; 255
    7f60:	1f 4f       	sbci	r17, 0xFF	; 255
		
		DriverOLEDClearScreen();
		ADCData=GetADCData();
		

		sprintf(s,"PHOTO1:%d",ADCData.PhotoL);
    7f62:	8a e8       	ldi	r24, 0x8A	; 138
    7f64:	88 2e       	mov	r8, r24
    7f66:	87 e2       	ldi	r24, 0x27	; 39
    7f68:	98 2e       	mov	r9, r24
		DriverOLEDPrintSmText(0,s,0);

		sprintf(s,"PHOTO2:%d",ADCData.PhotoM);
    7f6a:	94 e9       	ldi	r25, 0x94	; 148
    7f6c:	a9 2e       	mov	r10, r25
    7f6e:	97 e2       	ldi	r25, 0x27	; 39
    7f70:	b9 2e       	mov	r11, r25
		DriverOLEDPrintSmText(1,s,0);
		
		sprintf(s,"PHOTO3:%d",ADCData.PhotoR);
    7f72:	2e e9       	ldi	r18, 0x9E	; 158
    7f74:	62 2e       	mov	r6, r18
    7f76:	27 e2       	ldi	r18, 0x27	; 39
    7f78:	72 2e       	mov	r7, r18
		DriverOLEDPrintSmText(2,s,0);
		
		sprintf(s,"POT:%d",ADCData.Potmeter);
    7f7a:	38 ea       	ldi	r19, 0xA8	; 168
    7f7c:	43 2e       	mov	r4, r19
    7f7e:	37 e2       	ldi	r19, 0x27	; 39
    7f80:	53 2e       	mov	r5, r19
		DriverOLEDPrintSmText(3,s,0);
		
		sprintf(s,"DIFF:%d",ADCData.PhotoL-ADCData.PhotoR);	
    7f82:	4f ea       	ldi	r20, 0xAF	; 175
    7f84:	24 2e       	mov	r2, r20
    7f86:	47 e2       	ldi	r20, 0x27	; 39
    7f88:	34 2e       	mov	r3, r20
    7f8a:	02 c0       	rjmp	.+4      	; 0x7f90 <PageADC+0x6a>
		{
			vTaskDelay(300);
			return;
		}
		
		DriverOLEDUpdate();
    7f8c:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <DriverOLEDUpdate>
	ADCStruct ADCData;

	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    7f90:	8c e2       	ldi	r24, 0x2C	; 44
    7f92:	91 e0       	ldi	r25, 0x01	; 1
    7f94:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
    7f98:	89 a7       	std	Y+41, r24	; 0x29
		
		
		DriverOLEDClearScreen();
    7f9a:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <DriverOLEDClearScreen>
		ADCData=GetADCData();
    7f9e:	0e 94 b8 32 	call	0x6570	; 0x6570 <GetADCData>
    7fa2:	29 a3       	std	Y+33, r18	; 0x21
    7fa4:	3a a3       	std	Y+34, r19	; 0x22
    7fa6:	4b a3       	std	Y+35, r20	; 0x23
    7fa8:	5c a3       	std	Y+36, r21	; 0x24
    7faa:	6d a3       	std	Y+37, r22	; 0x25
    7fac:	7e a3       	std	Y+38, r23	; 0x26
    7fae:	8f a3       	std	Y+39, r24	; 0x27
    7fb0:	98 a7       	std	Y+40, r25	; 0x28
    7fb2:	e9 a0       	ldd	r14, Y+33	; 0x21
    7fb4:	fa a0       	ldd	r15, Y+34	; 0x22
    7fb6:	cd a0       	ldd	r12, Y+37	; 0x25
    7fb8:	de a0       	ldd	r13, Y+38	; 0x26
		

		sprintf(s,"PHOTO1:%d",ADCData.PhotoL);
    7fba:	ff 92       	push	r15
    7fbc:	ef 92       	push	r14
    7fbe:	9f 92       	push	r9
    7fc0:	8f 92       	push	r8
    7fc2:	1f 93       	push	r17
    7fc4:	0f 93       	push	r16
    7fc6:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    7fca:	40 e0       	ldi	r20, 0x00	; 0
    7fcc:	b8 01       	movw	r22, r16
    7fce:	80 e0       	ldi	r24, 0x00	; 0
    7fd0:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>

		sprintf(s,"PHOTO2:%d",ADCData.PhotoM);
    7fd4:	8c a1       	ldd	r24, Y+36	; 0x24
    7fd6:	8f 93       	push	r24
    7fd8:	8b a1       	ldd	r24, Y+35	; 0x23
    7fda:	8f 93       	push	r24
    7fdc:	bf 92       	push	r11
    7fde:	af 92       	push	r10
    7fe0:	1f 93       	push	r17
    7fe2:	0f 93       	push	r16
    7fe4:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    7fe8:	40 e0       	ldi	r20, 0x00	; 0
    7fea:	b8 01       	movw	r22, r16
    7fec:	81 e0       	ldi	r24, 0x01	; 1
    7fee:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		
		sprintf(s,"PHOTO3:%d",ADCData.PhotoR);
    7ff2:	df 92       	push	r13
    7ff4:	cf 92       	push	r12
    7ff6:	7f 92       	push	r7
    7ff8:	6f 92       	push	r6
    7ffa:	1f 93       	push	r17
    7ffc:	0f 93       	push	r16
    7ffe:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(2,s,0);
    8002:	40 e0       	ldi	r20, 0x00	; 0
    8004:	b8 01       	movw	r22, r16
    8006:	82 e0       	ldi	r24, 0x02	; 2
    8008:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		
		sprintf(s,"POT:%d",ADCData.Potmeter);
    800c:	88 a5       	ldd	r24, Y+40	; 0x28
    800e:	8f 93       	push	r24
    8010:	8f a1       	ldd	r24, Y+39	; 0x27
    8012:	8f 93       	push	r24
    8014:	5f 92       	push	r5
    8016:	4f 92       	push	r4
    8018:	1f 93       	push	r17
    801a:	0f 93       	push	r16
    801c:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(3,s,0);
    8020:	40 e0       	ldi	r20, 0x00	; 0
    8022:	b8 01       	movw	r22, r16
    8024:	83 e0       	ldi	r24, 0x03	; 3
    8026:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		
		sprintf(s,"DIFF:%d",ADCData.PhotoL-ADCData.PhotoR);	
    802a:	ec 18       	sub	r14, r12
    802c:	fd 08       	sbc	r15, r13
    802e:	ff 92       	push	r15
    8030:	ef 92       	push	r14
    8032:	3f 92       	push	r3
    8034:	2f 92       	push	r2
    8036:	1f 93       	push	r17
    8038:	0f 93       	push	r16
    803a:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(5,s,0);
    803e:	40 e0       	ldi	r20, 0x00	; 0
    8040:	b8 01       	movw	r22, r16
    8042:	85 e0       	ldi	r24, 0x05	; 5
    8044:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		
		if (Stick & CURSOR_UP);
		if (Stick & CURSOR_DOWN);
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
    8048:	cd bf       	out	0x3d, r28	; 61
    804a:	de bf       	out	0x3e, r29	; 62
    804c:	99 a5       	ldd	r25, Y+41	; 0x29
    804e:	90 ff       	sbrs	r25, 0
    8050:	9d cf       	rjmp	.-198    	; 0x7f8c <PageADC+0x66>
		{
			vTaskDelay(300);
    8052:	8c e2       	ldi	r24, 0x2C	; 44
    8054:	91 e0       	ldi	r25, 0x01	; 1
    8056:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
		}
		
		DriverOLEDUpdate();
		
	}
}
    805a:	a9 96       	adiw	r28, 0x29	; 41
    805c:	cd bf       	out	0x3d, r28	; 61
    805e:	de bf       	out	0x3e, r29	; 62
    8060:	df 91       	pop	r29
    8062:	cf 91       	pop	r28
    8064:	1f 91       	pop	r17
    8066:	0f 91       	pop	r16
    8068:	ff 90       	pop	r15
    806a:	ef 90       	pop	r14
    806c:	df 90       	pop	r13
    806e:	cf 90       	pop	r12
    8070:	bf 90       	pop	r11
    8072:	af 90       	pop	r10
    8074:	9f 90       	pop	r9
    8076:	8f 90       	pop	r8
    8078:	7f 90       	pop	r7
    807a:	6f 90       	pop	r6
    807c:	5f 90       	pop	r5
    807e:	4f 90       	pop	r4
    8080:	3f 90       	pop	r3
    8082:	2f 90       	pop	r2
    8084:	08 95       	ret

00008086 <PageLineFollowSpeed>:

void PageLineFollowSpeed()
{
    8086:	cf 93       	push	r28
		uint8_t Stick;
		char s[32];
		
		EnableMotorPosTask();
    8088:	0e 94 52 3a 	call	0x74a4	; 0x74a4 <EnableMotorPosTask>
		EnableMotorSpeedTask();
    808c:	0e 94 1f 3b 	call	0x763e	; 0x763e <EnableMotorSpeedTask>
		StartLineFollower(40.0);
    8090:	60 e0       	ldi	r22, 0x00	; 0
    8092:	70 e0       	ldi	r23, 0x00	; 0
    8094:	80 e2       	ldi	r24, 0x20	; 32
    8096:	92 e4       	ldi	r25, 0x42	; 66
    8098:	0e 94 29 36 	call	0x6c52	; 0x6c52 <StartLineFollower>
		vTaskDelay(300);
    809c:	8c e2       	ldi	r24, 0x2C	; 44
    809e:	91 e0       	ldi	r25, 0x01	; 1
    80a0:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
    80a4:	02 c0       	rjmp	.+4      	; 0x80aa <PageLineFollowSpeed+0x24>
						
				vTaskDelay(300);
				return;
			}
			
			DriverOLEDUpdate();
    80a6:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <DriverOLEDUpdate>
		EnableMotorSpeedTask();
		StartLineFollower(40.0);
		vTaskDelay(300);
		while (1)
		{
			Stick=DriverCursorStickGetFifo(300);
    80aa:	8c e2       	ldi	r24, 0x2C	; 44
    80ac:	91 e0       	ldi	r25, 0x01	; 1
    80ae:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
    80b2:	c8 2f       	mov	r28, r24
					
			DriverOLEDClearScreen();
    80b4:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <DriverOLEDClearScreen>
		
			DriverOLEDPrintSmText(0,"Line follower active",0);
    80b8:	40 e0       	ldi	r20, 0x00	; 0
    80ba:	67 eb       	ldi	r22, 0xB7	; 183
    80bc:	77 e2       	ldi	r23, 0x27	; 39
    80be:	80 e0       	ldi	r24, 0x00	; 0
    80c0:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
			
			if (Stick & CURSOR_UP);
			if (Stick & CURSOR_DOWN);
			if (Stick & CURSOR_RIGHT);
			if (Stick & CURSOR_LEFT);
			if (Stick & CURSOR_PRESS)
    80c4:	c0 ff       	sbrs	r28, 0
    80c6:	ef cf       	rjmp	.-34     	; 0x80a6 <PageLineFollowSpeed+0x20>
			{
				StopLineFollower();
    80c8:	0e 94 3c 36 	call	0x6c78	; 0x6c78 <StopLineFollower>
				DisableMotorSpeedTask();
    80cc:	0e 94 2b 3b 	call	0x7656	; 0x7656 <DisableMotorSpeedTask>
				DisableMotorPosTask();
    80d0:	0e 94 6b 3a 	call	0x74d6	; 0x74d6 <DisableMotorPosTask>
						
				vTaskDelay(300);
    80d4:	8c e2       	ldi	r24, 0x2C	; 44
    80d6:	91 e0       	ldi	r25, 0x01	; 1
				return;
			}
			
			DriverOLEDUpdate();
		}	
}
    80d8:	cf 91       	pop	r28
			{
				StopLineFollower();
				DisableMotorSpeedTask();
				DisableMotorPosTask();
						
				vTaskDelay(300);
    80da:	0c 94 60 2b 	jmp	0x56c0	; 0x56c0 <vTaskDelay>

000080de <PageLineFollowDirect>:
			DriverOLEDUpdate();
		}	
}

void PageLineFollowDirect()
{
    80de:	cf 93       	push	r28
	uint8_t Stick;
	char s[32];

	EnableLineFollowerDirectTask();
    80e0:	0e 94 65 35 	call	0x6aca	; 0x6aca <EnableLineFollowerDirectTask>
	vTaskDelay(300);
    80e4:	8c e2       	ldi	r24, 0x2C	; 44
    80e6:	91 e0       	ldi	r25, 0x01	; 1
    80e8:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
    80ec:	02 c0       	rjmp	.+4      	; 0x80f2 <PageLineFollowDirect+0x14>
			vTaskDelay(300);
			DisableLineFollowerDirectTask();
			return;
		}
		
		DriverOLEDUpdate();
    80ee:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <DriverOLEDUpdate>

	EnableLineFollowerDirectTask();
	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    80f2:	8c e2       	ldi	r24, 0x2C	; 44
    80f4:	91 e0       	ldi	r25, 0x01	; 1
    80f6:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
    80fa:	c8 2f       	mov	r28, r24
		
		DriverOLEDClearScreen();
    80fc:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <DriverOLEDClearScreen>
		
		DriverOLEDPrintSmText(0,"Line follower active",0);
    8100:	40 e0       	ldi	r20, 0x00	; 0
    8102:	67 eb       	ldi	r22, 0xB7	; 183
    8104:	77 e2       	ldi	r23, 0x27	; 39
    8106:	80 e0       	ldi	r24, 0x00	; 0
    8108:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		
		if (Stick & CURSOR_UP);
		if (Stick & CURSOR_DOWN);
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
    810c:	c0 ff       	sbrs	r28, 0
    810e:	ef cf       	rjmp	.-34     	; 0x80ee <PageLineFollowDirect+0x10>
		{
			vTaskDelay(300);
    8110:	8c e2       	ldi	r24, 0x2C	; 44
    8112:	91 e0       	ldi	r25, 0x01	; 1
    8114:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
			return;
		}
		
		DriverOLEDUpdate();
	}
}
    8118:	cf 91       	pop	r28
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
		{
			vTaskDelay(300);
			DisableLineFollowerDirectTask();
    811a:	0c 94 6b 35 	jmp	0x6ad6	; 0x6ad6 <DisableLineFollowerDirectTask>

0000811e <PageRGB>:
		DriverOLEDUpdate();
	}
}

void PageRGB()
{
    811e:	ef 92       	push	r14
    8120:	ff 92       	push	r15
    8122:	0f 93       	push	r16
    8124:	1f 93       	push	r17
    8126:	cf 93       	push	r28
    8128:	df 93       	push	r29
	uint8_t BlinkLeft=0;
	uint8_t BlinkRight=0;
	uint8_t Brake=0;
	uint8_t Effect=0;

	vTaskDelay(300);
    812a:	8c e2       	ldi	r24, 0x2C	; 44
    812c:	91 e0       	ldi	r25, 0x01	; 1
    812e:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
	uint8_t Stick;
	uint8_t Light=0;
	uint8_t BlinkLeft=0;
	uint8_t BlinkRight=0;
	uint8_t Brake=0;
	uint8_t Effect=0;
    8132:	d0 e0       	ldi	r29, 0x00	; 0
{
	uint8_t Stick;
	uint8_t Light=0;
	uint8_t BlinkLeft=0;
	uint8_t BlinkRight=0;
	uint8_t Brake=0;
    8134:	e1 2c       	mov	r14, r1
void PageRGB()
{
	uint8_t Stick;
	uint8_t Light=0;
	uint8_t BlinkLeft=0;
	uint8_t BlinkRight=0;
    8136:	f1 2c       	mov	r15, r1

void PageRGB()
{
	uint8_t Stick;
	uint8_t Light=0;
	uint8_t BlinkLeft=0;
    8138:	00 e0       	ldi	r16, 0x00	; 0
}

void PageRGB()
{
	uint8_t Stick;
	uint8_t Light=0;
    813a:	10 e0       	ldi	r17, 0x00	; 0
    813c:	11 c0       	rjmp	.+34     	; 0x8160 <PageRGB+0x42>
			vTaskDelay(300);
			return;
		}
		
		if (Light==0) Effect=RGB_NONE;
		if (Light==1) Effect=RGB_HEADLIGHT_LOW;
    813e:	11 30       	cpi	r17, 0x01	; 1
    8140:	09 f0       	breq	.+2      	; 0x8144 <PageRGB+0x26>
    8142:	4d c0       	rjmp	.+154    	; 0x81de <PageRGB+0xc0>
    8144:	d1 e0       	ldi	r29, 0x01	; 1
		if (Light==2) Effect=RGB_HEADLIGHT_HIGH;
		if (Brake==1) Effect|=RGB_BRAKE;
    8146:	81 e0       	ldi	r24, 0x01	; 1
    8148:	e8 16       	cp	r14, r24
    814a:	09 f4       	brne	.+2      	; 0x814e <PageRGB+0x30>
    814c:	44 c0       	rjmp	.+136    	; 0x81d6 <PageRGB+0xb8>
		if (BlinkLeft) Effect|=RGB_BLINK_LEFT;
    814e:	01 11       	cpse	r16, r1
    8150:	d4 60       	ori	r29, 0x04	; 4
		if (BlinkRight) Effect|=RGB_BLINK_RIGHT;
    8152:	f1 10       	cpse	r15, r1
    8154:	d8 60       	ori	r29, 0x08	; 8
		SetRGB(Effect);
    8156:	8d 2f       	mov	r24, r29
    8158:	0e 94 cc 42 	call	0x8598	; 0x8598 <SetRGB>
		
		DriverOLEDUpdate();
    815c:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <DriverOLEDUpdate>
	uint8_t Effect=0;

	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    8160:	8c e2       	ldi	r24, 0x2C	; 44
    8162:	91 e0       	ldi	r25, 0x01	; 1
    8164:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
    8168:	c8 2f       	mov	r28, r24
		
		DriverOLEDClearScreen();
    816a:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <DriverOLEDClearScreen>
		
		DriverOLEDPrintSmText(0,"Left:toggle blink",0);
    816e:	40 e0       	ldi	r20, 0x00	; 0
    8170:	6c ec       	ldi	r22, 0xCC	; 204
    8172:	77 e2       	ldi	r23, 0x27	; 39
    8174:	80 e0       	ldi	r24, 0x00	; 0
    8176:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		DriverOLEDPrintSmText(1,"Right:toggle blink",0);
    817a:	40 e0       	ldi	r20, 0x00	; 0
    817c:	6e ed       	ldi	r22, 0xDE	; 222
    817e:	77 e2       	ldi	r23, 0x27	; 39
    8180:	81 e0       	ldi	r24, 0x01	; 1
    8182:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		DriverOLEDPrintSmText(2,"Down:toggle brake",0);
    8186:	40 e0       	ldi	r20, 0x00	; 0
    8188:	61 ef       	ldi	r22, 0xF1	; 241
    818a:	77 e2       	ldi	r23, 0x27	; 39
    818c:	82 e0       	ldi	r24, 0x02	; 2
    818e:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		DriverOLEDPrintSmText(3,"Up:toggle light",0);		
    8192:	40 e0       	ldi	r20, 0x00	; 0
    8194:	63 e0       	ldi	r22, 0x03	; 3
    8196:	78 e2       	ldi	r23, 0x28	; 40
    8198:	83 e0       	ldi	r24, 0x03	; 3
    819a:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>


		
		if (Stick & CURSOR_UP)
    819e:	c4 ff       	sbrs	r28, 4
    81a0:	06 c0       	rjmp	.+12     	; 0x81ae <PageRGB+0x90>
		{
			if (Light==0) Light=1;
    81a2:	11 23       	and	r17, r17
    81a4:	d1 f0       	breq	.+52     	; 0x81da <PageRGB+0xbc>
			else if (Light==1) Light=2;
    81a6:	11 30       	cpi	r17, 0x01	; 1
    81a8:	49 f1       	breq	.+82     	; 0x81fc <PageRGB+0xde>
			else if (Light==2) Light=0;
    81aa:	12 30       	cpi	r17, 0x02	; 2
    81ac:	49 f1       	breq	.+82     	; 0x8200 <PageRGB+0xe2>
		}
		if (Stick & CURSOR_DOWN)
    81ae:	c2 ff       	sbrs	r28, 2
    81b0:	02 c0       	rjmp	.+4      	; 0x81b6 <PageRGB+0x98>
    81b2:	81 e0       	ldi	r24, 0x01	; 1
    81b4:	e8 26       	eor	r14, r24
		{
			if (Brake==0) Brake=1;
			else Brake=0;
		}
		if (Stick & CURSOR_RIGHT)
    81b6:	c1 ff       	sbrs	r28, 1
    81b8:	02 c0       	rjmp	.+4      	; 0x81be <PageRGB+0xa0>
    81ba:	81 e0       	ldi	r24, 0x01	; 1
    81bc:	f8 26       	eor	r15, r24
		{
			if (BlinkRight==0) BlinkRight=1;
			else BlinkRight=0;
		}
		if (Stick & CURSOR_LEFT)
    81be:	c3 ff       	sbrs	r28, 3
    81c0:	02 c0       	rjmp	.+4      	; 0x81c6 <PageRGB+0xa8>
    81c2:	81 e0       	ldi	r24, 0x01	; 1
    81c4:	08 27       	eor	r16, r24
		{
			if (BlinkLeft==0) BlinkLeft=1;
			else BlinkLeft=0;
		}
		if (Stick & CURSOR_PRESS)
    81c6:	c0 fd       	sbrc	r28, 0
    81c8:	0f c0       	rjmp	.+30     	; 0x81e8 <PageRGB+0xca>
		{
			vTaskDelay(300);
			return;
		}
		
		if (Light==0) Effect=RGB_NONE;
    81ca:	11 11       	cpse	r17, r1
    81cc:	b8 cf       	rjmp	.-144    	; 0x813e <PageRGB+0x20>
    81ce:	d0 e0       	ldi	r29, 0x00	; 0
		if (Light==1) Effect=RGB_HEADLIGHT_LOW;
		if (Light==2) Effect=RGB_HEADLIGHT_HIGH;
		if (Brake==1) Effect|=RGB_BRAKE;
    81d0:	81 e0       	ldi	r24, 0x01	; 1
    81d2:	e8 12       	cpse	r14, r24
    81d4:	bc cf       	rjmp	.-136    	; 0x814e <PageRGB+0x30>
    81d6:	d0 61       	ori	r29, 0x10	; 16
    81d8:	ba cf       	rjmp	.-140    	; 0x814e <PageRGB+0x30>


		
		if (Stick & CURSOR_UP)
		{
			if (Light==0) Light=1;
    81da:	11 e0       	ldi	r17, 0x01	; 1
    81dc:	e8 cf       	rjmp	.-48     	; 0x81ae <PageRGB+0x90>
			return;
		}
		
		if (Light==0) Effect=RGB_NONE;
		if (Light==1) Effect=RGB_HEADLIGHT_LOW;
		if (Light==2) Effect=RGB_HEADLIGHT_HIGH;
    81de:	12 30       	cpi	r17, 0x02	; 2
    81e0:	09 f0       	breq	.+2      	; 0x81e4 <PageRGB+0xc6>
    81e2:	b1 cf       	rjmp	.-158    	; 0x8146 <PageRGB+0x28>
    81e4:	d2 e0       	ldi	r29, 0x02	; 2
    81e6:	af cf       	rjmp	.-162    	; 0x8146 <PageRGB+0x28>
			if (BlinkLeft==0) BlinkLeft=1;
			else BlinkLeft=0;
		}
		if (Stick & CURSOR_PRESS)
		{
			vTaskDelay(300);
    81e8:	8c e2       	ldi	r24, 0x2C	; 44
    81ea:	91 e0       	ldi	r25, 0x01	; 1
		
		DriverOLEDUpdate();

		
	}	
}
    81ec:	df 91       	pop	r29
    81ee:	cf 91       	pop	r28
    81f0:	1f 91       	pop	r17
    81f2:	0f 91       	pop	r16
    81f4:	ff 90       	pop	r15
    81f6:	ef 90       	pop	r14
			if (BlinkLeft==0) BlinkLeft=1;
			else BlinkLeft=0;
		}
		if (Stick & CURSOR_PRESS)
		{
			vTaskDelay(300);
    81f8:	0c 94 60 2b 	jmp	0x56c0	; 0x56c0 <vTaskDelay>

		
		if (Stick & CURSOR_UP)
		{
			if (Light==0) Light=1;
			else if (Light==1) Light=2;
    81fc:	12 e0       	ldi	r17, 0x02	; 2
    81fe:	d7 cf       	rjmp	.-82     	; 0x81ae <PageRGB+0x90>
			else if (Light==2) Light=0;
    8200:	10 e0       	ldi	r17, 0x00	; 0
    8202:	d5 cf       	rjmp	.-86     	; 0x81ae <PageRGB+0x90>

00008204 <PageGyro>:
		
	}	
}

void PageGyro()
{
    8204:	bf 92       	push	r11
    8206:	cf 92       	push	r12
    8208:	df 92       	push	r13
    820a:	ef 92       	push	r14
    820c:	ff 92       	push	r15
    820e:	0f 93       	push	r16
    8210:	1f 93       	push	r17
    8212:	cf 93       	push	r28
    8214:	df 93       	push	r29
    8216:	cd b7       	in	r28, 0x3d	; 61
    8218:	de b7       	in	r29, 0x3e	; 62
    821a:	a8 97       	sbiw	r28, 0x28	; 40
    821c:	cd bf       	out	0x3d, r28	; 61
    821e:	de bf       	out	0x3e, r29	; 62
	uint8_t Stick;
	int16_t x,y,z;
	char s[32];
	float Yaw,YawRate;
	
	vTaskDelay(300);
    8220:	8c e2       	ldi	r24, 0x2C	; 44
    8222:	91 e0       	ldi	r25, 0x01	; 1
    8224:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
    8228:	8e 01       	movw	r16, r28
    822a:	0f 5f       	subi	r16, 0xFF	; 255
    822c:	1f 4f       	sbci	r17, 0xFF	; 255
		
		DriverOLEDClearScreen();
		
		GyroGet(&YawRate,&Yaw);
		
		sprintf(s,"Yaw:%f",Yaw);
    822e:	83 e1       	ldi	r24, 0x13	; 19
    8230:	c8 2e       	mov	r12, r24
    8232:	88 e2       	ldi	r24, 0x28	; 40
    8234:	d8 2e       	mov	r13, r24
		DriverOLEDPrintSmText(0,s,0);

		sprintf(s,"YawRate:%f",YawRate);
    8236:	9a e1       	ldi	r25, 0x1A	; 26
    8238:	e9 2e       	mov	r14, r25
    823a:	98 e2       	ldi	r25, 0x28	; 40
    823c:	f9 2e       	mov	r15, r25
    823e:	02 c0       	rjmp	.+4      	; 0x8244 <PageGyro+0x40>
		{
			vTaskDelay(300);
			return;
		}
		
		DriverOLEDUpdate();
    8240:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <DriverOLEDUpdate>
	float Yaw,YawRate;
	
	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    8244:	8c e2       	ldi	r24, 0x2C	; 44
    8246:	91 e0       	ldi	r25, 0x01	; 1
    8248:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
    824c:	b8 2e       	mov	r11, r24
		
		
		DriverOLEDClearScreen();
    824e:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <DriverOLEDClearScreen>
		
		GyroGet(&YawRate,&Yaw);
    8252:	be 01       	movw	r22, r28
    8254:	6b 5d       	subi	r22, 0xDB	; 219
    8256:	7f 4f       	sbci	r23, 0xFF	; 255
    8258:	ce 01       	movw	r24, r28
    825a:	81 96       	adiw	r24, 0x21	; 33
    825c:	0e 94 bf 33 	call	0x677e	; 0x677e <GyroGet>
		
		sprintf(s,"Yaw:%f",Yaw);
    8260:	88 a5       	ldd	r24, Y+40	; 0x28
    8262:	8f 93       	push	r24
    8264:	8f a1       	ldd	r24, Y+39	; 0x27
    8266:	8f 93       	push	r24
    8268:	8e a1       	ldd	r24, Y+38	; 0x26
    826a:	8f 93       	push	r24
    826c:	8d a1       	ldd	r24, Y+37	; 0x25
    826e:	8f 93       	push	r24
    8270:	df 92       	push	r13
    8272:	cf 92       	push	r12
    8274:	1f 93       	push	r17
    8276:	0f 93       	push	r16
    8278:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    827c:	40 e0       	ldi	r20, 0x00	; 0
    827e:	b8 01       	movw	r22, r16
    8280:	80 e0       	ldi	r24, 0x00	; 0
    8282:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>

		sprintf(s,"YawRate:%f",YawRate);
    8286:	8c a1       	ldd	r24, Y+36	; 0x24
    8288:	8f 93       	push	r24
    828a:	8b a1       	ldd	r24, Y+35	; 0x23
    828c:	8f 93       	push	r24
    828e:	8a a1       	ldd	r24, Y+34	; 0x22
    8290:	8f 93       	push	r24
    8292:	89 a1       	ldd	r24, Y+33	; 0x21
    8294:	8f 93       	push	r24
    8296:	ff 92       	push	r15
    8298:	ef 92       	push	r14
    829a:	1f 93       	push	r17
    829c:	0f 93       	push	r16
    829e:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    82a2:	40 e0       	ldi	r20, 0x00	; 0
    82a4:	b8 01       	movw	r22, r16
    82a6:	81 e0       	ldi	r24, 0x01	; 1
    82a8:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		
		if (Stick & CURSOR_UP);
		if (Stick & CURSOR_DOWN);
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
    82ac:	cd bf       	out	0x3d, r28	; 61
    82ae:	de bf       	out	0x3e, r29	; 62
    82b0:	b0 fe       	sbrs	r11, 0
    82b2:	c6 cf       	rjmp	.-116    	; 0x8240 <PageGyro+0x3c>
		{
			vTaskDelay(300);
    82b4:	8c e2       	ldi	r24, 0x2C	; 44
    82b6:	91 e0       	ldi	r25, 0x01	; 1
    82b8:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
		}
		
		DriverOLEDUpdate();
		
	}
}
    82bc:	a8 96       	adiw	r28, 0x28	; 40
    82be:	cd bf       	out	0x3d, r28	; 61
    82c0:	de bf       	out	0x3e, r29	; 62
    82c2:	df 91       	pop	r29
    82c4:	cf 91       	pop	r28
    82c6:	1f 91       	pop	r17
    82c8:	0f 91       	pop	r16
    82ca:	ff 90       	pop	r15
    82cc:	ef 90       	pop	r14
    82ce:	df 90       	pop	r13
    82d0:	cf 90       	pop	r12
    82d2:	bf 90       	pop	r11
    82d4:	08 95       	ret

000082d6 <PageRanger>:

void PageRanger()
{
    82d6:	df 92       	push	r13
    82d8:	ef 92       	push	r14
    82da:	ff 92       	push	r15
    82dc:	0f 93       	push	r16
    82de:	1f 93       	push	r17
    82e0:	cf 93       	push	r28
    82e2:	df 93       	push	r29
    82e4:	cd b7       	in	r28, 0x3d	; 61
    82e6:	de b7       	in	r29, 0x3e	; 62
    82e8:	a0 97       	sbiw	r28, 0x20	; 32
    82ea:	cd bf       	out	0x3d, r28	; 61
    82ec:	de bf       	out	0x3e, r29	; 62
	uint8_t Stick;
	uint16_t Distance;
	char s[32];
	
	vTaskDelay(300);
    82ee:	8c e2       	ldi	r24, 0x2C	; 44
    82f0:	91 e0       	ldi	r25, 0x01	; 1
    82f2:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
    82f6:	ce 01       	movw	r24, r28
    82f8:	01 96       	adiw	r24, 0x01	; 1
    82fa:	7c 01       	movw	r14, r24
		
		DriverOLEDClearScreen();
		
		Distance=DriverVL53L0XReadSingle();
		
		sprintf(s,"Range:%u",Distance);
    82fc:	05 e2       	ldi	r16, 0x25	; 37
    82fe:	18 e2       	ldi	r17, 0x28	; 40
    8300:	02 c0       	rjmp	.+4      	; 0x8306 <PageRanger+0x30>
		{
			vTaskDelay(300);
			return;
		}
		
		DriverOLEDUpdate();
    8302:	0e 94 d6 0c 	call	0x19ac	; 0x19ac <DriverOLEDUpdate>
	char s[32];
	
	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    8306:	8c e2       	ldi	r24, 0x2C	; 44
    8308:	91 e0       	ldi	r25, 0x01	; 1
    830a:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
    830e:	d8 2e       	mov	r13, r24
		
		
		DriverOLEDClearScreen();
    8310:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <DriverOLEDClearScreen>
		
		Distance=DriverVL53L0XReadSingle();
    8314:	0e 94 bd 1b 	call	0x377a	; 0x377a <DriverVL53L0XReadSingle>
		
		sprintf(s,"Range:%u",Distance);
    8318:	9f 93       	push	r25
    831a:	8f 93       	push	r24
    831c:	1f 93       	push	r17
    831e:	0f 93       	push	r16
    8320:	ff 92       	push	r15
    8322:	ef 92       	push	r14
    8324:	0e 94 4b 51 	call	0xa296	; 0xa296 <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    8328:	40 e0       	ldi	r20, 0x00	; 0
    832a:	b7 01       	movw	r22, r14
    832c:	80 e0       	ldi	r24, 0x00	; 0
    832e:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <DriverOLEDPrintSmText>
		
		if (Stick & CURSOR_UP);
		if (Stick & CURSOR_DOWN);
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
    8332:	0f 90       	pop	r0
    8334:	0f 90       	pop	r0
    8336:	0f 90       	pop	r0
    8338:	0f 90       	pop	r0
    833a:	0f 90       	pop	r0
    833c:	0f 90       	pop	r0
    833e:	d0 fe       	sbrs	r13, 0
    8340:	e0 cf       	rjmp	.-64     	; 0x8302 <PageRanger+0x2c>
		{
			vTaskDelay(300);
    8342:	8c e2       	ldi	r24, 0x2C	; 44
    8344:	91 e0       	ldi	r25, 0x01	; 1
    8346:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
		}
		
		DriverOLEDUpdate();
		
	}
    834a:	a0 96       	adiw	r28, 0x20	; 32
    834c:	cd bf       	out	0x3d, r28	; 61
    834e:	de bf       	out	0x3e, r29	; 62
    8350:	df 91       	pop	r29
    8352:	cf 91       	pop	r28
    8354:	1f 91       	pop	r17
    8356:	0f 91       	pop	r16
    8358:	ff 90       	pop	r15
    835a:	ef 90       	pop	r14
    835c:	df 90       	pop	r13
    835e:	08 95       	ret

00008360 <WorkerOLEDMenu>:
{
	uint8_t Stick;
	
	while(1)
	{
		Stick=DriverCursorStickGetFifo(300);
    8360:	8c e2       	ldi	r24, 0x2C	; 44
    8362:	91 e0       	ldi	r25, 0x01	; 1
    8364:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
}


void DownMenu()
{
	if (SelItem<NUM_LINES-1) SelItem++;
    8368:	60 91 52 2e 	lds	r22, 0x2E52	; 0x802e52 <SelItem>
	uint8_t Stick;
	
	while(1)
	{
		Stick=DriverCursorStickGetFifo(300);
		if (Stick & CURSOR_DOWN) DownMenu();
    836c:	82 ff       	sbrs	r24, 2
    836e:	18 c0       	rjmp	.+48     	; 0x83a0 <WorkerOLEDMenu+0x40>
}


void DownMenu()
{
	if (SelItem<NUM_LINES-1) SelItem++;
    8370:	6a 30       	cpi	r22, 0x0A	; 10
    8372:	08 f0       	brcs	.+2      	; 0x8376 <WorkerOLEDMenu+0x16>
    8374:	4a c0       	rjmp	.+148    	; 0x840a <WorkerOLEDMenu+0xaa>
    8376:	6f 5f       	subi	r22, 0xFF	; 255
    8378:	60 93 52 2e 	sts	0x2E52, r22	; 0x802e52 <SelItem>
	else {
		SelItem=0;
		TopItem=0;
	}
	if (SelItem>=TopItem+DISPLAYED_LINES) TopItem++;
    837c:	20 91 53 2e 	lds	r18, 0x2E53	; 0x802e53 <TopItem>
    8380:	82 2f       	mov	r24, r18
    8382:	90 e0       	ldi	r25, 0x00	; 0
    8384:	70 e0       	ldi	r23, 0x00	; 0
    8386:	ac 01       	movw	r20, r24
    8388:	4b 5f       	subi	r20, 0xFB	; 251
    838a:	5f 4f       	sbci	r21, 0xFF	; 255
    838c:	46 17       	cp	r20, r22
    838e:	57 07       	cpc	r21, r23
    8390:	0c f0       	brlt	.+2      	; 0x8394 <WorkerOLEDMenu+0x34>
    8392:	43 c0       	rjmp	.+134    	; 0x841a <WorkerOLEDMenu+0xba>
    8394:	81 e0       	ldi	r24, 0x01	; 1
    8396:	82 0f       	add	r24, r18
    8398:	80 93 53 2e 	sts	0x2E53, r24	; 0x802e53 <TopItem>
    839c:	90 e0       	ldi	r25, 0x00	; 0
    839e:	3d c0       	rjmp	.+122    	; 0x841a <WorkerOLEDMenu+0xba>
	
	while(1)
	{
		Stick=DriverCursorStickGetFifo(300);
		if (Stick & CURSOR_DOWN) DownMenu();
		else if (Stick & CURSOR_UP) UpMenu();
    83a0:	84 ff       	sbrs	r24, 4
    83a2:	0e c0       	rjmp	.+28     	; 0x83c0 <WorkerOLEDMenu+0x60>
	if (SelItem>=TopItem+DISPLAYED_LINES) TopItem++;
}

void UpMenu()
{
	if (SelItem>0) SelItem--;
    83a4:	66 23       	and	r22, r22
    83a6:	19 f0       	breq	.+6      	; 0x83ae <WorkerOLEDMenu+0x4e>
    83a8:	61 50       	subi	r22, 0x01	; 1
    83aa:	60 93 52 2e 	sts	0x2E52, r22	; 0x802e52 <SelItem>
	if (SelItem<TopItem) TopItem=SelItem;
    83ae:	80 91 53 2e 	lds	r24, 0x2E53	; 0x802e53 <TopItem>
    83b2:	68 17       	cp	r22, r24
    83b4:	a8 f5       	brcc	.+106    	; 0x8420 <WorkerOLEDMenu+0xc0>
    83b6:	60 93 53 2e 	sts	0x2E53, r22	; 0x802e53 <TopItem>
    83ba:	70 e0       	ldi	r23, 0x00	; 0
    83bc:	cb 01       	movw	r24, r22
    83be:	2d c0       	rjmp	.+90     	; 0x841a <WorkerOLEDMenu+0xba>
	while(1)
	{
		Stick=DriverCursorStickGetFifo(300);
		if (Stick & CURSOR_DOWN) DownMenu();
		else if (Stick & CURSOR_UP) UpMenu();
		else if (Stick & CURSOR_PRESS)
    83c0:	80 ff       	sbrs	r24, 0
    83c2:	1e c0       	rjmp	.+60     	; 0x8400 <WorkerOLEDMenu+0xa0>
		{
			if (SelItem==0) PageKarlsTask();
    83c4:	66 23       	and	r22, r22
    83c6:	91 f1       	breq	.+100    	; 0x842c <WorkerOLEDMenu+0xcc>
			else if (SelItem==1) PageCPUStatus();
    83c8:	61 30       	cpi	r22, 0x01	; 1
    83ca:	99 f1       	breq	.+102    	; 0x8432 <WorkerOLEDMenu+0xd2>
			else if (SelItem==2) PageMotorSpeed();
    83cc:	62 30       	cpi	r22, 0x02	; 2
    83ce:	a1 f1       	breq	.+104    	; 0x8438 <WorkerOLEDMenu+0xd8>
			else if (SelItem==3) PageADPS9960();
    83d0:	63 30       	cpi	r22, 0x03	; 3
    83d2:	a9 f1       	breq	.+106    	; 0x843e <WorkerOLEDMenu+0xde>
			else if (SelItem==4) PageADC();
    83d4:	64 30       	cpi	r22, 0x04	; 4
    83d6:	39 f1       	breq	.+78     	; 0x8426 <WorkerOLEDMenu+0xc6>
			else if (SelItem==5) PageLineFollowSpeed();
    83d8:	65 30       	cpi	r22, 0x05	; 5
    83da:	a1 f1       	breq	.+104    	; 0x8444 <WorkerOLEDMenu+0xe4>
			else if (SelItem==6) PageLineFollowDirect();
    83dc:	66 30       	cpi	r22, 0x06	; 6
    83de:	a9 f1       	breq	.+106    	; 0x844a <WorkerOLEDMenu+0xea>
			else if (SelItem==7) PageRGB();
    83e0:	67 30       	cpi	r22, 0x07	; 7
    83e2:	b1 f1       	breq	.+108    	; 0x8450 <WorkerOLEDMenu+0xf0>
			else if (SelItem==8) PageGyro();	
    83e4:	68 30       	cpi	r22, 0x08	; 8
    83e6:	b9 f1       	breq	.+110    	; 0x8456 <WorkerOLEDMenu+0xf6>
			else if (SelItem==9) PageRanger();
    83e8:	69 30       	cpi	r22, 0x09	; 9
    83ea:	c1 f1       	breq	.+112    	; 0x845c <WorkerOLEDMenu+0xfc>
			else if (SelItem==10) configASSERT(false); //Force halt
    83ec:	6a 30       	cpi	r22, 0x0A	; 10
    83ee:	41 f4       	brne	.+16     	; 0x8400 <WorkerOLEDMenu+0xa0>
    83f0:	6c e5       	ldi	r22, 0x5C	; 92
    83f2:	70 e0       	ldi	r23, 0x00	; 0
    83f4:	8e e2       	ldi	r24, 0x2E	; 46
    83f6:	98 e2       	ldi	r25, 0x28	; 40
    83f8:	0e 94 c5 30 	call	0x618a	; 0x618a <vAssertCalled>
    83fc:	60 91 52 2e 	lds	r22, 0x2E52	; 0x802e52 <SelItem>
    8400:	70 e0       	ldi	r23, 0x00	; 0
    8402:	80 91 53 2e 	lds	r24, 0x2E53	; 0x802e53 <TopItem>
    8406:	90 e0       	ldi	r25, 0x00	; 0
    8408:	08 c0       	rjmp	.+16     	; 0x841a <WorkerOLEDMenu+0xba>

void DownMenu()
{
	if (SelItem<NUM_LINES-1) SelItem++;
	else {
		SelItem=0;
    840a:	10 92 52 2e 	sts	0x2E52, r1	; 0x802e52 <SelItem>
		TopItem=0;
    840e:	10 92 53 2e 	sts	0x2E53, r1	; 0x802e53 <TopItem>
    8412:	80 e0       	ldi	r24, 0x00	; 0
    8414:	90 e0       	ldi	r25, 0x00	; 0
    8416:	60 e0       	ldi	r22, 0x00	; 0
    8418:	70 e0       	ldi	r23, 0x00	; 0
			else if (SelItem==8) PageGyro();	
			else if (SelItem==9) PageRanger();
			else if (SelItem==10) configASSERT(false); //Force halt
		}
		
		DrawMenu(TopItem,SelItem);
    841a:	0e 94 55 3b 	call	0x76aa	; 0x76aa <DrawMenu>
	}
    841e:	a0 cf       	rjmp	.-192    	; 0x8360 <WorkerOLEDMenu>
    8420:	70 e0       	ldi	r23, 0x00	; 0
    8422:	90 e0       	ldi	r25, 0x00	; 0
    8424:	fa cf       	rjmp	.-12     	; 0x841a <WorkerOLEDMenu+0xba>
		{
			if (SelItem==0) PageKarlsTask();
			else if (SelItem==1) PageCPUStatus();
			else if (SelItem==2) PageMotorSpeed();
			else if (SelItem==3) PageADPS9960();
			else if (SelItem==4) PageADC();
    8426:	0e 94 93 3f 	call	0x7f26	; 0x7f26 <PageADC>
    842a:	e8 cf       	rjmp	.-48     	; 0x83fc <WorkerOLEDMenu+0x9c>
		Stick=DriverCursorStickGetFifo(300);
		if (Stick & CURSOR_DOWN) DownMenu();
		else if (Stick & CURSOR_UP) UpMenu();
		else if (Stick & CURSOR_PRESS)
		{
			if (SelItem==0) PageKarlsTask();
    842c:	0e 94 80 3b 	call	0x7700	; 0x7700 <PageKarlsTask>
    8430:	e5 cf       	rjmp	.-54     	; 0x83fc <WorkerOLEDMenu+0x9c>
			else if (SelItem==1) PageCPUStatus();
    8432:	0e 94 87 3c 	call	0x790e	; 0x790e <PageCPUStatus>
    8436:	e2 cf       	rjmp	.-60     	; 0x83fc <WorkerOLEDMenu+0x9c>
			else if (SelItem==2) PageMotorSpeed();
    8438:	0e 94 5d 3d 	call	0x7aba	; 0x7aba <PageMotorSpeed>
    843c:	df cf       	rjmp	.-66     	; 0x83fc <WorkerOLEDMenu+0x9c>
			else if (SelItem==3) PageADPS9960();
    843e:	0e 94 f8 3e 	call	0x7df0	; 0x7df0 <PageADPS9960>
    8442:	dc cf       	rjmp	.-72     	; 0x83fc <WorkerOLEDMenu+0x9c>
			else if (SelItem==4) PageADC();
			else if (SelItem==5) PageLineFollowSpeed();
    8444:	0e 94 43 40 	call	0x8086	; 0x8086 <PageLineFollowSpeed>
    8448:	d9 cf       	rjmp	.-78     	; 0x83fc <WorkerOLEDMenu+0x9c>
			else if (SelItem==6) PageLineFollowDirect();
    844a:	0e 94 6f 40 	call	0x80de	; 0x80de <PageLineFollowDirect>
    844e:	d6 cf       	rjmp	.-84     	; 0x83fc <WorkerOLEDMenu+0x9c>
			else if (SelItem==7) PageRGB();
    8450:	0e 94 8f 40 	call	0x811e	; 0x811e <PageRGB>
    8454:	d3 cf       	rjmp	.-90     	; 0x83fc <WorkerOLEDMenu+0x9c>
			else if (SelItem==8) PageGyro();	
    8456:	0e 94 02 41 	call	0x8204	; 0x8204 <PageGyro>
    845a:	d0 cf       	rjmp	.-96     	; 0x83fc <WorkerOLEDMenu+0x9c>
			else if (SelItem==9) PageRanger();
    845c:	0e 94 6b 41 	call	0x82d6	; 0x82d6 <PageRanger>
    8460:	cd cf       	rjmp	.-102    	; 0x83fc <WorkerOLEDMenu+0x9c>

00008462 <WorkerRGB>:
	xQueueOverwrite(EffectQueue,&Effect);
	
}

void WorkerRGB(void *pvParameters)
{
    8462:	cf 93       	push	r28
    8464:	df 93       	push	r29
    8466:	1f 92       	push	r1
    8468:	cd b7       	in	r28, 0x3d	; 61
    846a:	de b7       	in	r29, 0x3e	; 62
    846c:	4a c0       	rjmp	.+148    	; 0x8502 <WorkerRGB+0xa0>
		
		//Time slot 1
		if (Effect & RGB_HEADLIGHT_HIGH)
		{
			FrontRight=PL9823_RGB(255,255,255);
			FrontLeft=PL9823_RGB(255,255,255);
    846e:	66 24       	eor	r6, r6
    8470:	6a 94       	dec	r6
    8472:	77 24       	eor	r7, r7
    8474:	7a 94       	dec	r7
    8476:	88 24       	eor	r8, r8
    8478:	8a 94       	dec	r8
    847a:	91 2c       	mov	r9, r1
		}
		if (Effect & RGB_HEADLIGHT_LOW)
    847c:	80 ff       	sbrs	r24, 0
    847e:	07 c0       	rjmp	.+14     	; 0x848e <WorkerRGB+0x2c>
		{
			FrontRight=PL9823_RGB(128,128,128);
			FrontLeft=PL9823_RGB(128,128,128);
    8480:	90 e8       	ldi	r25, 0x80	; 128
    8482:	69 2e       	mov	r6, r25
    8484:	20 e8       	ldi	r18, 0x80	; 128
    8486:	72 2e       	mov	r7, r18
    8488:	30 e8       	ldi	r19, 0x80	; 128
    848a:	83 2e       	mov	r8, r19
    848c:	91 2c       	mov	r9, r1
		}
		if (Effect & RGB_BRAKE)
    848e:	84 ff       	sbrs	r24, 4
    8490:	4b c0       	rjmp	.+150    	; 0x8528 <WorkerRGB+0xc6>
		{
			RearRight=PL9823_RED;
    8492:	22 24       	eor	r2, r2
    8494:	2a 94       	dec	r2
    8496:	31 2c       	mov	r3, r1
    8498:	41 2c       	mov	r4, r1
    849a:	51 2c       	mov	r5, r1
			RearLeft=PL9823_RED;
		}

		DriverPL9823Set(FrontLeft,FrontRight,RearRight,RearLeft);
    849c:	51 01       	movw	r10, r2
    849e:	62 01       	movw	r12, r4
    84a0:	71 01       	movw	r14, r2
    84a2:	82 01       	movw	r16, r4
    84a4:	93 01       	movw	r18, r6
    84a6:	a4 01       	movw	r20, r8
    84a8:	b3 01       	movw	r22, r6
    84aa:	c4 01       	movw	r24, r8
    84ac:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <DriverPL9823Set>
		vTaskDelay(250); 
    84b0:	8a ef       	ldi	r24, 0xFA	; 250
    84b2:	90 e0       	ldi	r25, 0x00	; 0
    84b4:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
		
		//Time slot 2
		if (Effect & RGB_BLINK_LEFT)
    84b8:	29 81       	ldd	r18, Y+1	; 0x01
    84ba:	22 ff       	sbrs	r18, 2
    84bc:	3a c0       	rjmp	.+116    	; 0x8532 <WorkerRGB+0xd0>
		{
			FrontLeft=PL9823_YELLOW;
			RearLeft=PL9823_YELLOW;
    84be:	aa 24       	eor	r10, r10
    84c0:	aa 94       	dec	r10
    84c2:	bb 24       	eor	r11, r11
    84c4:	ba 94       	dec	r11
    84c6:	c1 2c       	mov	r12, r1
    84c8:	d1 2c       	mov	r13, r1
		vTaskDelay(250); 
		
		//Time slot 2
		if (Effect & RGB_BLINK_LEFT)
		{
			FrontLeft=PL9823_YELLOW;
    84ca:	6f ef       	ldi	r22, 0xFF	; 255
    84cc:	7f ef       	ldi	r23, 0xFF	; 255
    84ce:	80 e0       	ldi	r24, 0x00	; 0
    84d0:	90 e0       	ldi	r25, 0x00	; 0
			RearLeft=PL9823_YELLOW;
		}
		if (Effect & RGB_BLINK_RIGHT)
    84d2:	23 ff       	sbrs	r18, 3
    84d4:	0c c0       	rjmp	.+24     	; 0x84ee <WorkerRGB+0x8c>
		{
			FrontRight=PL9823_YELLOW;
			RearRight=PL9823_YELLOW;
    84d6:	22 24       	eor	r2, r2
    84d8:	2a 94       	dec	r2
    84da:	33 24       	eor	r3, r3
    84dc:	3a 94       	dec	r3
    84de:	41 2c       	mov	r4, r1
    84e0:	51 2c       	mov	r5, r1
			FrontLeft=PL9823_YELLOW;
			RearLeft=PL9823_YELLOW;
		}
		if (Effect & RGB_BLINK_RIGHT)
		{
			FrontRight=PL9823_YELLOW;
    84e2:	66 24       	eor	r6, r6
    84e4:	6a 94       	dec	r6
    84e6:	77 24       	eor	r7, r7
    84e8:	7a 94       	dec	r7
    84ea:	81 2c       	mov	r8, r1
    84ec:	91 2c       	mov	r9, r1
			RearRight=PL9823_YELLOW;
		}
		DriverPL9823Set(FrontLeft,FrontRight,RearRight,RearLeft);
    84ee:	71 01       	movw	r14, r2
    84f0:	82 01       	movw	r16, r4
    84f2:	93 01       	movw	r18, r6
    84f4:	a4 01       	movw	r20, r8
    84f6:	0e 94 08 0f 	call	0x1e10	; 0x1e10 <DriverPL9823Set>
		vTaskDelay(250);
    84fa:	8a ef       	ldi	r24, 0xFA	; 250
    84fc:	90 e0       	ldi	r25, 0x00	; 0
    84fe:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
	{
		FrontLeft=PL9823_BLANK;
		FrontRight=PL9823_BLANK;
		RearLeft=PL9823_BLANK;
		RearRight=PL9823_BLANK;	
		xQueuePeek(EffectQueue,&Effect,0);
    8502:	40 e0       	ldi	r20, 0x00	; 0
    8504:	50 e0       	ldi	r21, 0x00	; 0
    8506:	be 01       	movw	r22, r28
    8508:	6f 5f       	subi	r22, 0xFF	; 255
    850a:	7f 4f       	sbci	r23, 0xFF	; 255
    850c:	80 91 76 2e 	lds	r24, 0x2E76	; 0x802e76 <EffectQueue>
    8510:	90 91 77 2e 	lds	r25, 0x2E77	; 0x802e77 <EffectQueue+0x1>
    8514:	0e 94 3d 24 	call	0x487a	; 0x487a <xQueuePeek>
		
		
		
		//Time slot 1
		if (Effect & RGB_HEADLIGHT_HIGH)
    8518:	89 81       	ldd	r24, Y+1	; 0x01
    851a:	81 fd       	sbrc	r24, 1
    851c:	a8 cf       	rjmp	.-176    	; 0x846e <WorkerRGB+0xc>
	uint8_t Effect;
	uint32_t FrontLeft,FrontRight,RearRight,RearLeft;
	
	while(1)
	{
		FrontLeft=PL9823_BLANK;
    851e:	61 2c       	mov	r6, r1
    8520:	71 2c       	mov	r7, r1
    8522:	81 2c       	mov	r8, r1
    8524:	91 2c       	mov	r9, r1
    8526:	aa cf       	rjmp	.-172    	; 0x847c <WorkerRGB+0x1a>
		FrontRight=PL9823_BLANK;
		RearLeft=PL9823_BLANK;
		RearRight=PL9823_BLANK;	
    8528:	21 2c       	mov	r2, r1
    852a:	31 2c       	mov	r3, r1
    852c:	41 2c       	mov	r4, r1
    852e:	51 2c       	mov	r5, r1
    8530:	b5 cf       	rjmp	.-150    	; 0x849c <WorkerRGB+0x3a>
    8532:	51 01       	movw	r10, r2
    8534:	62 01       	movw	r12, r4
    8536:	b3 01       	movw	r22, r6
    8538:	c4 01       	movw	r24, r8
    853a:	cb cf       	rjmp	.-106    	; 0x84d2 <WorkerRGB+0x70>

0000853c <InitRGBTask>:
void WorkerRGB(void *pvParameters);


//Function definitions
void InitRGBTask()
{
    853c:	ef 92       	push	r14
    853e:	ff 92       	push	r15
    8540:	0f 93       	push	r16
    8542:	cf 93       	push	r28
    8544:	df 93       	push	r29
    8546:	1f 92       	push	r1
    8548:	cd b7       	in	r28, 0x3d	; 61
    854a:	de b7       	in	r29, 0x3e	; 62
	EffectQueue=xQueueCreate(1,sizeof(uint8_t));
    854c:	40 e0       	ldi	r20, 0x00	; 0
    854e:	61 e0       	ldi	r22, 0x01	; 1
    8550:	81 e0       	ldi	r24, 0x01	; 1
    8552:	0e 94 ab 20 	call	0x4156	; 0x4156 <xQueueGenericCreate>
    8556:	80 93 76 2e 	sts	0x2E76, r24	; 0x802e76 <EffectQueue>
    855a:	90 93 77 2e 	sts	0x2E77, r25	; 0x802e77 <EffectQueue+0x1>
    855e:	19 82       	std	Y+1, r1	; 0x01
	xTaskCreate( WorkerRGB, "rgb", 512, NULL, tskIDLE_PRIORITY+4, NULL );	
}

void SetRGB(uint8_t Effect)
{
	xQueueOverwrite(EffectQueue,&Effect);
    8560:	22 e0       	ldi	r18, 0x02	; 2
    8562:	40 e0       	ldi	r20, 0x00	; 0
    8564:	50 e0       	ldi	r21, 0x00	; 0
    8566:	be 01       	movw	r22, r28
    8568:	6f 5f       	subi	r22, 0xFF	; 255
    856a:	7f 4f       	sbci	r23, 0xFF	; 255
    856c:	0e 94 ef 20 	call	0x41de	; 0x41de <xQueueGenericSend>
//Function definitions
void InitRGBTask()
{
	EffectQueue=xQueueCreate(1,sizeof(uint8_t));
	SetRGB(RGB_NONE);
	xTaskCreate( WorkerRGB, "rgb", 512, NULL, tskIDLE_PRIORITY+4, NULL );	
    8570:	e1 2c       	mov	r14, r1
    8572:	f1 2c       	mov	r15, r1
    8574:	04 e0       	ldi	r16, 0x04	; 4
    8576:	20 e0       	ldi	r18, 0x00	; 0
    8578:	30 e0       	ldi	r19, 0x00	; 0
    857a:	40 e0       	ldi	r20, 0x00	; 0
    857c:	52 e0       	ldi	r21, 0x02	; 2
    857e:	61 ea       	ldi	r22, 0xA1	; 161
    8580:	78 e2       	ldi	r23, 0x28	; 40
    8582:	81 e3       	ldi	r24, 0x31	; 49
    8584:	92 e4       	ldi	r25, 0x42	; 66
    8586:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <xTaskCreate>
}
    858a:	0f 90       	pop	r0
    858c:	df 91       	pop	r29
    858e:	cf 91       	pop	r28
    8590:	0f 91       	pop	r16
    8592:	ff 90       	pop	r15
    8594:	ef 90       	pop	r14
    8596:	08 95       	ret

00008598 <SetRGB>:

void SetRGB(uint8_t Effect)
{
    8598:	cf 93       	push	r28
    859a:	df 93       	push	r29
    859c:	1f 92       	push	r1
    859e:	cd b7       	in	r28, 0x3d	; 61
    85a0:	de b7       	in	r29, 0x3e	; 62
    85a2:	89 83       	std	Y+1, r24	; 0x01
	xQueueOverwrite(EffectQueue,&Effect);
    85a4:	22 e0       	ldi	r18, 0x02	; 2
    85a6:	40 e0       	ldi	r20, 0x00	; 0
    85a8:	50 e0       	ldi	r21, 0x00	; 0
    85aa:	be 01       	movw	r22, r28
    85ac:	6f 5f       	subi	r22, 0xFF	; 255
    85ae:	7f 4f       	sbci	r23, 0xFF	; 255
    85b0:	80 91 76 2e 	lds	r24, 0x2E76	; 0x802e76 <EffectQueue>
    85b4:	90 91 77 2e 	lds	r25, 0x2E77	; 0x802e77 <EffectQueue+0x1>
    85b8:	0e 94 ef 20 	call	0x41de	; 0x41de <xQueueGenericSend>
	
}
    85bc:	0f 90       	pop	r0
    85be:	df 91       	pop	r29
    85c0:	cf 91       	pop	r28
    85c2:	08 95       	ret

000085c4 <WorkerStartup>:
{
	xTaskCreate( WorkerStartup, "startup", 256, NULL, tskIDLE_PRIORITY+3, NULL );	
}

static void WorkerStartup(void *pvParameters)
{
    85c4:	81 e0       	ldi	r24, 0x01	; 1
    85c6:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <DriverPowerVccAuxSet>
	int res;
    85ca:	0e 94 06 05 	call	0xa0c	; 0xa0c <DriverCursorstickInit>
	
    85ce:	0e 94 86 06 	call	0xd0c	; 0xd0c <DriverLedInit>
	USART_RX_Queue_has_data = 0;
    85d2:	0e 94 96 11 	call	0x232c	; 0x232c <DriverUSARTInit>
	USART_RX_transmission_complete =1;
    85d6:	0e 94 9d 0f 	call	0x1f3a	; 0x1f3a <DriverPowerInit>
	
	DriverPowerVccAuxSet(1);//Enable Auxillary power line
    85da:	0e 94 c6 0f 	call	0x1f8c	; 0x1f8c <DriverTWIMInit>
	DriverCursorstickInit();//Initialize cursor stick
    85de:	0e 94 02 0f 	call	0x1e04	; 0x1e04 <DriverPL9823Init>
	// DriverLedInit();		//Initialize LED's
    85e2:	0e 94 86 03 	call	0x70c	; 0x70c <DriverAdcInit>
	DriverUSARTInit();		//USART init and link to stdio
	DriverPowerInit();		//Initialize aux power driver
    85e6:	82 e0       	ldi	r24, 0x02	; 2
    85e8:	0e 94 9c 0d 	call	0x1b38	; 0x1b38 <DriverOLEDInit>
	
    85ec:	0e 94 40 04 	call	0x880	; 0x880 <DriverAdps9960Init>
	DriverTWIMInit();		//Initialize TWI in master mode
    85f0:	0e 94 22 15 	call	0x2a44	; 0x2a44 <DriverVL53L0XInit>
	DriverPL9823Init();		//Initialize PL9823 LEDs
	//DriverAdcInit();		//Initialize ADC driver
	
    85f4:	82 e3       	ldi	r24, 0x32	; 50
    85f6:	90 e0       	ldi	r25, 0x00	; 0
    85f8:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskDelay>
	DriverOLEDInit(2);		//Initialize OLED display
	// DriverAdps9960Init();	//Initialize color sensor	
	//DriverVL53L0XInit();	//Initialize rangefinder
    85fc:	80 e2       	ldi	r24, 0x20	; 32
    85fe:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>

	
	vTaskDelay(50);
    8602:	0e 94 41 3b 	call	0x7682	; 0x7682 <InitOLEDMenuTask>
	
    8606:	0e 94 9b 32 	call	0x6536	; 0x6536 <InitADCTask>
	//Enable test output (T21)
    860a:	0e 94 77 3a 	call	0x74ee	; 0x74ee <InitMotorPosTask>
	PORTA.DIRSET=1<<5;	
    860e:	0e 94 ef 3a 	call	0x75de	; 0x75de <InitMotorSpeedTask>
	//Initialize application tasks			
    8612:	0e 94 03 36 	call	0x6c06	; 0x6c06 <InitLineFollowerSpeedTask>
	
    8616:	0e 94 4a 35 	call	0x6a94	; 0x6a94 <InitLineFollowerDirectTask>
	// InitOLEDMenuTask();
    861a:	0e 94 9e 42 	call	0x853c	; 0x853c <InitRGBTask>
	// InitADCTask();
    861e:	0e 94 a4 33 	call	0x6748	; 0x6748 <InitGyroTask>
	InitMotorPosTask();
    8622:	0e 94 96 45 	call	0x8b2c	; 0x8b2c <InitTerminalTask>
	InitMotorSpeedTask();
    8626:	0e 94 6a 38 	call	0x70d4	; 0x70d4 <InitMotionTask>
	// InitLineFollowerSpeedTask();
	// InitLineFollowerDirectTask();
    862a:	80 e0       	ldi	r24, 0x00	; 0
    862c:	90 e0       	ldi	r25, 0x00	; 0
    862e:	0c 94 7b 28 	jmp	0x50f6	; 0x50f6 <vTaskSuspend>

00008632 <InitStartupTask>:

#include "CustomProtocol.h"

//Private function prototypes
static void WorkerStartup(void *pvParameters);

    8632:	ef 92       	push	r14
    8634:	ff 92       	push	r15
    8636:	0f 93       	push	r16
//Function definitions
    8638:	e1 2c       	mov	r14, r1
    863a:	f1 2c       	mov	r15, r1
    863c:	03 e0       	ldi	r16, 0x03	; 3
    863e:	20 e0       	ldi	r18, 0x00	; 0
    8640:	30 e0       	ldi	r19, 0x00	; 0
    8642:	40 e0       	ldi	r20, 0x00	; 0
    8644:	51 e0       	ldi	r21, 0x01	; 1
    8646:	66 e4       	ldi	r22, 0x46	; 70
    8648:	78 e2       	ldi	r23, 0x28	; 40
    864a:	82 ee       	ldi	r24, 0xE2	; 226
    864c:	92 e4       	ldi	r25, 0x42	; 66
    864e:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <xTaskCreate>
void InitStartupTask()
    8652:	0f 91       	pop	r16
    8654:	ff 90       	pop	r15
    8656:	ef 90       	pop	r14
    8658:	08 95       	ret

0000865a <WorkerTerminal>:
	*/

}

static void WorkerTerminal(void *pvParameters)
{
    865a:	cf 93       	push	r28
    865c:	df 93       	push	r29
    865e:	cd b7       	in	r28, 0x3d	; 61
    8660:	de b7       	in	r29, 0x3e	; 62
    8662:	cc 51       	subi	r28, 0x1C	; 28
    8664:	d1 40       	sbci	r29, 0x01	; 1
    8666:	cd bf       	out	0x3d, r28	; 61
    8668:	de bf       	out	0x3e, r29	; 62
		SplitCmd(sbuf,Cmd,Pars);
		
		//Task list command
		if (strstr(Cmd,"help"))
		{
			printf_P (PSTR("Command list:\r\n"));
    866a:	86 eb       	ldi	r24, 0xB6	; 182
    866c:	e8 2e       	mov	r14, r24
    866e:	86 e0       	ldi	r24, 0x06	; 6
    8670:	f8 2e       	mov	r15, r24
			printf_P (PSTR("help :this help page\r\n"));
    8672:	0f e9       	ldi	r16, 0x9F	; 159
    8674:	16 e0       	ldi	r17, 0x06	; 6
			printf_P (PSTR("tsklst :list FreeRTOS tasks\r\n"));
    8676:	91 e8       	ldi	r25, 0x81	; 129
    8678:	c9 2e       	mov	r12, r25
    867a:	96 e0       	ldi	r25, 0x06	; 6
    867c:	d9 2e       	mov	r13, r25
			printf_P (PSTR("memmap :show memory map\r\n"));
    867e:	27 e6       	ldi	r18, 0x67	; 103
    8680:	22 2e       	mov	r2, r18
    8682:	26 e0       	ldi	r18, 0x06	; 6
    8684:	32 2e       	mov	r3, r18
	char Cmd[64];
	uint16_t c,r,g,b;
	
	while (1)
	{
		printf ("C>\r\n");
    8686:	8e e4       	ldi	r24, 0x4E	; 78
    8688:	98 e2       	ldi	r25, 0x28	; 40
    868a:	0e 94 1b 51 	call	0xa236	; 0xa236 <puts>
		fgets(sbuf,199,stdin);
    868e:	40 91 7c 2e 	lds	r20, 0x2E7C	; 0x802e7c <__iob>
    8692:	50 91 7d 2e 	lds	r21, 0x2E7D	; 0x802e7d <__iob+0x1>
    8696:	67 ec       	ldi	r22, 0xC7	; 199
    8698:	70 e0       	ldi	r23, 0x00	; 0
    869a:	ce 01       	movw	r24, r28
    869c:	01 96       	adiw	r24, 0x01	; 1
    869e:	0e 94 71 50 	call	0xa0e2	; 0xa0e2 <fgets>
static void SplitCmd(char *Data,char *Cmd,float *Pars)
{
	uint8_t a;
	char *ss;
	
	ss=strtok(Data," ");
    86a2:	69 e8       	ldi	r22, 0x89	; 137
    86a4:	74 e2       	ldi	r23, 0x24	; 36
    86a6:	ce 01       	movw	r24, r28
    86a8:	01 96       	adiw	r24, 0x01	; 1
    86aa:	0e 94 0a 50 	call	0xa014	; 0xa014 <strtok>
	if (ss!=NULL) strcpy(Cmd,ss);
    86ae:	00 97       	sbiw	r24, 0x00	; 0
    86b0:	31 f0       	breq	.+12     	; 0x86be <WorkerTerminal+0x64>
    86b2:	bc 01       	movw	r22, r24
    86b4:	ce 01       	movw	r24, r28
    86b6:	87 53       	subi	r24, 0x37	; 55
    86b8:	9f 4f       	sbci	r25, 0xFF	; 255
    86ba:	0e 94 1e 50 	call	0xa03c	; 0xa03c <strcpy>
	for (a=0;a<MAX_PARS;a++) 
	{
		ss=strtok(NULL," ");
    86be:	69 e8       	ldi	r22, 0x89	; 137
    86c0:	74 e2       	ldi	r23, 0x24	; 36
    86c2:	80 e0       	ldi	r24, 0x00	; 0
    86c4:	90 e0       	ldi	r25, 0x00	; 0
    86c6:	0e 94 0a 50 	call	0xa014	; 0xa014 <strtok>
		if (ss!=NULL)
    86ca:	00 97       	sbiw	r24, 0x00	; 0
    86cc:	09 f4       	brne	.+2      	; 0x86d0 <WorkerTerminal+0x76>
    86ce:	6a c0       	rjmp	.+212    	; 0x87a4 <WorkerTerminal+0x14a>
		{
			Pars[a]=atof(ss);
    86d0:	0e 94 23 4f 	call	0x9e46	; 0x9e46 <atof>
    86d4:	4b 01       	movw	r8, r22
    86d6:	5c 01       	movw	r10, r24
	
	ss=strtok(Data," ");
	if (ss!=NULL) strcpy(Cmd,ss);
	for (a=0;a<MAX_PARS;a++) 
	{
		ss=strtok(NULL," ");
    86d8:	69 e8       	ldi	r22, 0x89	; 137
    86da:	74 e2       	ldi	r23, 0x24	; 36
    86dc:	80 e0       	ldi	r24, 0x00	; 0
    86de:	90 e0       	ldi	r25, 0x00	; 0
    86e0:	0e 94 0a 50 	call	0xa014	; 0xa014 <strtok>
		if (ss!=NULL)
    86e4:	00 97       	sbiw	r24, 0x00	; 0
    86e6:	09 f4       	brne	.+2      	; 0x86ea <WorkerTerminal+0x90>
    86e8:	69 c0       	rjmp	.+210    	; 0x87bc <WorkerTerminal+0x162>
		{
			Pars[a]=atof(ss);
    86ea:	0e 94 23 4f 	call	0x9e46	; 0x9e46 <atof>
    86ee:	2b 01       	movw	r4, r22
    86f0:	3c 01       	movw	r6, r24
		printf ("C>\r\n");
		fgets(sbuf,199,stdin);
		SplitCmd(sbuf,Cmd,Pars);
		
		//Task list command
		if (strstr(Cmd,"help"))
    86f2:	62 e5       	ldi	r22, 0x52	; 82
    86f4:	78 e2       	ldi	r23, 0x28	; 40
    86f6:	ce 01       	movw	r24, r28
    86f8:	87 53       	subi	r24, 0x37	; 55
    86fa:	9f 4f       	sbci	r25, 0xFF	; 255
    86fc:	0e 94 30 50 	call	0xa060	; 0xa060 <strstr>
    8700:	89 2b       	or	r24, r25
    8702:	09 f4       	brne	.+2      	; 0x8706 <WorkerTerminal+0xac>
    8704:	5f c0       	rjmp	.+190    	; 0x87c4 <WorkerTerminal+0x16a>
		{
			printf_P (PSTR("Command list:\r\n"));
    8706:	ff 92       	push	r15
    8708:	ef 92       	push	r14
    870a:	0e 94 f3 50 	call	0xa1e6	; 0xa1e6 <printf_P>
			printf_P (PSTR("help :this help page\r\n"));
    870e:	1f 93       	push	r17
    8710:	0f 93       	push	r16
    8712:	0e 94 f3 50 	call	0xa1e6	; 0xa1e6 <printf_P>
			printf_P (PSTR("tsklst :list FreeRTOS tasks\r\n"));
    8716:	df 92       	push	r13
    8718:	cf 92       	push	r12
    871a:	0e 94 f3 50 	call	0xa1e6	; 0xa1e6 <printf_P>
			printf_P (PSTR("memmap :show memory map\r\n"));
    871e:	3f 92       	push	r3
    8720:	2f 92       	push	r2
    8722:	0e 94 f3 50 	call	0xa1e6	; 0xa1e6 <printf_P>
			printf_P (PSTR("drvstr distance speed :Drive straight over 'distance' mm at a speed of 'speed' mm/s\r\n"));
    8726:	81 e1       	ldi	r24, 0x11	; 17
    8728:	96 e0       	ldi	r25, 0x06	; 6
    872a:	9f 93       	push	r25
    872c:	8f 93       	push	r24
    872e:	0e 94 f3 50 	call	0xa1e6	; 0xa1e6 <printf_P>
			printf_P (PSTR("rotctr angle speed :rotate 'angle' degrees around center of robot at a speed of 'speed' mm/s\r\n"));
    8732:	82 eb       	ldi	r24, 0xB2	; 178
    8734:	95 e0       	ldi	r25, 0x05	; 5
    8736:	9f 93       	push	r25
    8738:	8f 93       	push	r24
    873a:	0e 94 f3 50 	call	0xa1e6	; 0xa1e6 <printf_P>
			printf_P (PSTR("drvseg speed :follow line segment until end at a speed of 'speed' mm/s\r\n"));
    873e:	89 e6       	ldi	r24, 0x69	; 105
    8740:	95 e0       	ldi	r25, 0x05	; 5
    8742:	9f 93       	push	r25
    8744:	8f 93       	push	r24
    8746:	0e 94 f3 50 	call	0xa1e6	; 0xa1e6 <printf_P>
			printf_P (PSTR("setled effect :set RGB led effect (see RGBTask.h)\r\n"));
    874a:	85 e3       	ldi	r24, 0x35	; 53
    874c:	95 e0       	ldi	r25, 0x05	; 5
    874e:	9f 93       	push	r25
    8750:	8f 93       	push	r24
    8752:	0e 94 f3 50 	call	0xa1e6	; 0xa1e6 <printf_P>
			printf_P (PSTR("setmot leftmotor_pwm rightmotor_pwm :directly control motor pwm signal. Pwm is in a range of -4095 to 4095\r\n"));
    8756:	88 ec       	ldi	r24, 0xC8	; 200
    8758:	94 e0       	ldi	r25, 0x04	; 4
    875a:	9f 93       	push	r25
    875c:	8f 93       	push	r24
    875e:	0e 94 f3 50 	call	0xa1e6	; 0xa1e6 <printf_P>
			printf_P (PSTR("getenc :get motor encoder values\r\n"));
    8762:	85 ea       	ldi	r24, 0xA5	; 165
    8764:	94 e0       	ldi	r25, 0x04	; 4
    8766:	9f 93       	push	r25
    8768:	8f 93       	push	r24
    876a:	0e 94 f3 50 	call	0xa1e6	; 0xa1e6 <printf_P>
			printf_P (PSTR("getrgb :returns RGB light sensor values\r\n"));
    876e:	8b e7       	ldi	r24, 0x7B	; 123
    8770:	94 e0       	ldi	r25, 0x04	; 4
    8772:	9f 93       	push	r25
    8774:	8f 93       	push	r24
    8776:	0e 94 f3 50 	call	0xa1e6	; 0xa1e6 <printf_P>
			printf_P (PSTR("getgyr :returns gyroscope info in format 'yawrate (deg/s) yaw(deg)\r\n"));
    877a:	86 e3       	ldi	r24, 0x36	; 54
    877c:	94 e0       	ldi	r25, 0x04	; 4
    877e:	9f 93       	push	r25
    8780:	8f 93       	push	r24
    8782:	0e 94 f3 50 	call	0xa1e6	; 0xa1e6 <printf_P>
			printf_P (PSTR("getadc :returns Analog channels in format 'left_line_sensor mid_line_sensor right_line_sensor potentiometer\r\n"));
    8786:	88 ec       	ldi	r24, 0xC8	; 200
    8788:	93 e0       	ldi	r25, 0x03	; 3
    878a:	9f 93       	push	r25
    878c:	8f 93       	push	r24
    878e:	0e 94 f3 50 	call	0xa1e6	; 0xa1e6 <printf_P>
			printf_P (PSTR("auxpwr state:'state'=1: turn on aux power net, 'state'=0: turn off aux power net\r\n"));
    8792:	85 e7       	ldi	r24, 0x75	; 117
    8794:	93 e0       	ldi	r25, 0x03	; 3
    8796:	9f 93       	push	r25
    8798:	8f 93       	push	r24
    879a:	0e 94 f3 50 	call	0xa1e6	; 0xa1e6 <printf_P>
    879e:	cd bf       	out	0x3d, r28	; 61
    87a0:	de bf       	out	0x3e, r29	; 62
    87a2:	71 cf       	rjmp	.-286    	; 0x8686 <WorkerTerminal+0x2c>
		if (ss!=NULL)
		{
			Pars[a]=atof(ss);
		}
		else
			Pars[a]=0.0;
    87a4:	81 2c       	mov	r8, r1
    87a6:	91 2c       	mov	r9, r1
    87a8:	54 01       	movw	r10, r8
	
	ss=strtok(Data," ");
	if (ss!=NULL) strcpy(Cmd,ss);
	for (a=0;a<MAX_PARS;a++) 
	{
		ss=strtok(NULL," ");
    87aa:	69 e8       	ldi	r22, 0x89	; 137
    87ac:	74 e2       	ldi	r23, 0x24	; 36
    87ae:	80 e0       	ldi	r24, 0x00	; 0
    87b0:	90 e0       	ldi	r25, 0x00	; 0
    87b2:	0e 94 0a 50 	call	0xa014	; 0xa014 <strtok>
		if (ss!=NULL)
    87b6:	00 97       	sbiw	r24, 0x00	; 0
    87b8:	09 f0       	breq	.+2      	; 0x87bc <WorkerTerminal+0x162>
    87ba:	97 cf       	rjmp	.-210    	; 0x86ea <WorkerTerminal+0x90>
		{
			Pars[a]=atof(ss);
		}
		else
			Pars[a]=0.0;
    87bc:	41 2c       	mov	r4, r1
    87be:	51 2c       	mov	r5, r1
    87c0:	32 01       	movw	r6, r4
    87c2:	97 cf       	rjmp	.-210    	; 0x86f2 <WorkerTerminal+0x98>
			printf_P (PSTR("getrgb :returns RGB light sensor values\r\n"));
			printf_P (PSTR("getgyr :returns gyroscope info in format 'yawrate (deg/s) yaw(deg)\r\n"));
			printf_P (PSTR("getadc :returns Analog channels in format 'left_line_sensor mid_line_sensor right_line_sensor potentiometer\r\n"));
			printf_P (PSTR("auxpwr state:'state'=1: turn on aux power net, 'state'=0: turn off aux power net\r\n"));
			printf_P (PSTR("sleep :enter sleep mode\r\n"));
		}
    87c4:	67 e5       	ldi	r22, 0x57	; 87
    87c6:	78 e2       	ldi	r23, 0x28	; 40
    87c8:	ce 01       	movw	r24, r28
    87ca:	87 53       	subi	r24, 0x37	; 55
    87cc:	9f 4f       	sbci	r25, 0xFF	; 255
    87ce:	0e 94 30 50 	call	0xa060	; 0xa060 <strstr>
    87d2:	89 2b       	or	r24, r25
    87d4:	49 f0       	breq	.+18     	; 0x87e8 <WorkerTerminal+0x18e>
		else if (strstr(Cmd,"tsklst"))
		{
    87d6:	ce 01       	movw	r24, r28
    87d8:	01 96       	adiw	r24, 0x01	; 1
    87da:	0e 94 3f 2f 	call	0x5e7e	; 0x5e7e <vTaskGetRunTimeStats>
			vTaskGetRunTimeStats(sbuf);
    87de:	ce 01       	movw	r24, r28
    87e0:	01 96       	adiw	r24, 0x01	; 1
    87e2:	0e 94 1b 51 	call	0xa236	; 0xa236 <puts>
    87e6:	4f cf       	rjmp	.-354    	; 0x8686 <WorkerTerminal+0x2c>
			puts(sbuf);
		}
    87e8:	6e e5       	ldi	r22, 0x5E	; 94
    87ea:	78 e2       	ldi	r23, 0x28	; 40
    87ec:	ce 01       	movw	r24, r28
    87ee:	87 53       	subi	r24, 0x37	; 55
    87f0:	9f 4f       	sbci	r25, 0xFF	; 255
    87f2:	0e 94 30 50 	call	0xa060	; 0xa060 <strstr>
    87f6:	89 2b       	or	r24, r25
    87f8:	19 f0       	breq	.+6      	; 0x8800 <WorkerTerminal+0x1a6>
		else if (strstr(Cmd,"memmap"))
		{
    87fa:	0e 94 23 31 	call	0x6246	; 0x6246 <MemMap>
    87fe:	43 cf       	rjmp	.-378    	; 0x8686 <WorkerTerminal+0x2c>
			MemMap();
		}
    8800:	65 e6       	ldi	r22, 0x65	; 101
    8802:	78 e2       	ldi	r23, 0x28	; 40
    8804:	ce 01       	movw	r24, r28
    8806:	87 53       	subi	r24, 0x37	; 55
    8808:	9f 4f       	sbci	r25, 0xFF	; 255
    880a:	0e 94 30 50 	call	0xa060	; 0xa060 <strstr>
    880e:	89 2b       	or	r24, r25
    8810:	59 f0       	breq	.+22     	; 0x8828 <WorkerTerminal+0x1ce>
		else if (strstr(Cmd,"drvstr"))
		{
    8812:	a3 01       	movw	r20, r6
    8814:	92 01       	movw	r18, r4
    8816:	c5 01       	movw	r24, r10
    8818:	b4 01       	movw	r22, r8
    881a:	0e 94 90 38 	call	0x7120	; 0x7120 <DriveStraight>
			DriveStraight(Pars[0],Pars[1]);
    881e:	8c e6       	ldi	r24, 0x6C	; 108
    8820:	98 e2       	ldi	r25, 0x28	; 40
    8822:	0e 94 1b 51 	call	0xa236	; 0xa236 <puts>
    8826:	2f cf       	rjmp	.-418    	; 0x8686 <WorkerTerminal+0x2c>
			printf ("OK\r\n");
		}
    8828:	60 e7       	ldi	r22, 0x70	; 112
    882a:	78 e2       	ldi	r23, 0x28	; 40
    882c:	ce 01       	movw	r24, r28
    882e:	87 53       	subi	r24, 0x37	; 55
    8830:	9f 4f       	sbci	r25, 0xFF	; 255
    8832:	0e 94 30 50 	call	0xa060	; 0xa060 <strstr>
    8836:	89 2b       	or	r24, r25
    8838:	49 f0       	breq	.+18     	; 0x884c <WorkerTerminal+0x1f2>
		else if (strstr(Cmd,"drvseg"))
		{
    883a:	c5 01       	movw	r24, r10
    883c:	b4 01       	movw	r22, r8
    883e:	0e 94 bb 38 	call	0x7176	; 0x7176 <DriveSegment>
			DriveSegment(Pars[0]);
    8842:	8c e6       	ldi	r24, 0x6C	; 108
    8844:	98 e2       	ldi	r25, 0x28	; 40
    8846:	0e 94 1b 51 	call	0xa236	; 0xa236 <puts>
    884a:	1d cf       	rjmp	.-454    	; 0x8686 <WorkerTerminal+0x2c>
			printf ("OK\r\n");
		}
    884c:	67 e7       	ldi	r22, 0x77	; 119
    884e:	78 e2       	ldi	r23, 0x28	; 40
    8850:	ce 01       	movw	r24, r28
    8852:	87 53       	subi	r24, 0x37	; 55
    8854:	9f 4f       	sbci	r25, 0xFF	; 255
    8856:	0e 94 30 50 	call	0xa060	; 0xa060 <strstr>
    885a:	89 2b       	or	r24, r25
    885c:	59 f0       	breq	.+22     	; 0x8874 <WorkerTerminal+0x21a>
		else if (strstr(Cmd,"rotctr"))
		{
    885e:	a3 01       	movw	r20, r6
    8860:	92 01       	movw	r18, r4
    8862:	c5 01       	movw	r24, r10
    8864:	b4 01       	movw	r22, r8
    8866:	0e 94 e2 38 	call	0x71c4	; 0x71c4 <RotateCenter>
			RotateCenter(Pars[0],Pars[1]);
    886a:	8c e6       	ldi	r24, 0x6C	; 108
    886c:	98 e2       	ldi	r25, 0x28	; 40
    886e:	0e 94 1b 51 	call	0xa236	; 0xa236 <puts>
    8872:	09 cf       	rjmp	.-494    	; 0x8686 <WorkerTerminal+0x2c>
			printf ("OK\r\n");
		}
    8874:	6e e7       	ldi	r22, 0x7E	; 126
    8876:	78 e2       	ldi	r23, 0x28	; 40
    8878:	ce 01       	movw	r24, r28
    887a:	87 53       	subi	r24, 0x37	; 55
    887c:	9f 4f       	sbci	r25, 0xFF	; 255
    887e:	0e 94 30 50 	call	0xa060	; 0xa060 <strstr>
    8882:	89 2b       	or	r24, r25
    8884:	61 f0       	breq	.+24     	; 0x889e <WorkerTerminal+0x244>
		else if (strstr(Cmd,"setled"))
		{
    8886:	c5 01       	movw	r24, r10
    8888:	b4 01       	movw	r22, r8
    888a:	0e 94 95 46 	call	0x8d2a	; 0x8d2a <__fixunssfsi>
    888e:	86 2f       	mov	r24, r22
    8890:	0e 94 cc 42 	call	0x8598	; 0x8598 <SetRGB>
			SetRGB(Pars[0]);
    8894:	8c e6       	ldi	r24, 0x6C	; 108
    8896:	98 e2       	ldi	r25, 0x28	; 40
    8898:	0e 94 1b 51 	call	0xa236	; 0xa236 <puts>
    889c:	f4 ce       	rjmp	.-536    	; 0x8686 <WorkerTerminal+0x2c>
			printf ("OK\r\n");
		}
    889e:	65 e8       	ldi	r22, 0x85	; 133
    88a0:	78 e2       	ldi	r23, 0x28	; 40
    88a2:	ce 01       	movw	r24, r28
    88a4:	87 53       	subi	r24, 0x37	; 55
    88a6:	9f 4f       	sbci	r25, 0xFF	; 255
    88a8:	0e 94 30 50 	call	0xa060	; 0xa060 <strstr>
    88ac:	89 2b       	or	r24, r25
    88ae:	a1 f0       	breq	.+40     	; 0x88d8 <WorkerTerminal+0x27e>
		else if (strstr(Cmd,"setmot"))
		{
    88b0:	c3 01       	movw	r24, r6
    88b2:	b2 01       	movw	r22, r4
    88b4:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
    88b8:	2b 01       	movw	r4, r22
    88ba:	3c 01       	movw	r6, r24
    88bc:	c5 01       	movw	r24, r10
    88be:	b4 01       	movw	r22, r8
    88c0:	0e 94 8e 46 	call	0x8d1c	; 0x8d1c <__fixsfsi>
    88c4:	dc 01       	movw	r26, r24
    88c6:	cb 01       	movw	r24, r22
    88c8:	b2 01       	movw	r22, r4
    88ca:	0e 94 e7 06 	call	0xdce	; 0xdce <DriverMotorSet>
			DriverMotorSet((int16_t) Pars[0],(int16_t) Pars[1]);
    88ce:	8c e6       	ldi	r24, 0x6C	; 108
    88d0:	98 e2       	ldi	r25, 0x28	; 40
    88d2:	0e 94 1b 51 	call	0xa236	; 0xa236 <puts>
    88d6:	d7 ce       	rjmp	.-594    	; 0x8686 <WorkerTerminal+0x2c>
			printf ("OK\r\n");
		}
    88d8:	6c e8       	ldi	r22, 0x8C	; 140
    88da:	78 e2       	ldi	r23, 0x28	; 40
    88dc:	ce 01       	movw	r24, r28
    88de:	87 53       	subi	r24, 0x37	; 55
    88e0:	9f 4f       	sbci	r25, 0xFF	; 255
    88e2:	0e 94 30 50 	call	0xa060	; 0xa060 <strstr>
    88e6:	89 2b       	or	r24, r25
    88e8:	99 f0       	breq	.+38     	; 0x8910 <WorkerTerminal+0x2b6>
		else if (strstr(Cmd,"getenc"))
		{	
			EncoderStruct Encoder;
    88ea:	0e 94 52 07 	call	0xea4	; 0xea4 <DriverMotorGetEncoder>
			Encoder=DriverMotorGetEncoder();
    88ee:	9f 93       	push	r25
    88f0:	8f 93       	push	r24
    88f2:	7f 93       	push	r23
    88f4:	6f 93       	push	r22
    88f6:	83 e9       	ldi	r24, 0x93	; 147
    88f8:	98 e2       	ldi	r25, 0x28	; 40
    88fa:	9f 93       	push	r25
    88fc:	8f 93       	push	r24
    88fe:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
    8902:	0f 90       	pop	r0
    8904:	0f 90       	pop	r0
    8906:	0f 90       	pop	r0
    8908:	0f 90       	pop	r0
    890a:	0f 90       	pop	r0
    890c:	0f 90       	pop	r0
    890e:	bb ce       	rjmp	.-650    	; 0x8686 <WorkerTerminal+0x2c>
			printf ("OK %d %d\r\n",Encoder.Cnt1,Encoder.Cnt2);
		}		
    8910:	6e e9       	ldi	r22, 0x9E	; 158
    8912:	78 e2       	ldi	r23, 0x28	; 40
    8914:	ce 01       	movw	r24, r28
    8916:	87 53       	subi	r24, 0x37	; 55
    8918:	9f 4f       	sbci	r25, 0xFF	; 255
    891a:	0e 94 30 50 	call	0xa060	; 0xa060 <strstr>
    891e:	89 2b       	or	r24, r25
    8920:	09 f4       	brne	.+2      	; 0x8924 <WorkerTerminal+0x2ca>
    8922:	47 c0       	rjmp	.+142    	; 0x89b2 <WorkerTerminal+0x358>
		else if (strstr(Cmd,"getrgb"))
		{
    8924:	9e 01       	movw	r18, r28
    8926:	2b 5e       	subi	r18, 0xEB	; 235
    8928:	3e 4f       	sbci	r19, 0xFE	; 254
    892a:	ae 01       	movw	r20, r28
    892c:	49 5e       	subi	r20, 0xE9	; 233
    892e:	5e 4f       	sbci	r21, 0xFE	; 254
    8930:	be 01       	movw	r22, r28
    8932:	67 5e       	subi	r22, 0xE7	; 231
    8934:	7e 4f       	sbci	r23, 0xFE	; 254
    8936:	ce 01       	movw	r24, r28
    8938:	85 5e       	subi	r24, 0xE5	; 229
    893a:	9e 4f       	sbci	r25, 0xFE	; 254
    893c:	0e 94 88 04 	call	0x910	; 0x910 <DriverAdps9960Get>
			DriverAdps9960Get(&c,&r,&g,&b);
    8940:	ca 5e       	subi	r28, 0xEA	; 234
    8942:	de 4f       	sbci	r29, 0xFE	; 254
    8944:	88 81       	ld	r24, Y
    8946:	c6 51       	subi	r28, 0x16	; 22
    8948:	d1 40       	sbci	r29, 0x01	; 1
    894a:	8f 93       	push	r24
    894c:	cb 5e       	subi	r28, 0xEB	; 235
    894e:	de 4f       	sbci	r29, 0xFE	; 254
    8950:	88 81       	ld	r24, Y
    8952:	c5 51       	subi	r28, 0x15	; 21
    8954:	d1 40       	sbci	r29, 0x01	; 1
    8956:	8f 93       	push	r24
    8958:	c8 5e       	subi	r28, 0xE8	; 232
    895a:	de 4f       	sbci	r29, 0xFE	; 254
    895c:	88 81       	ld	r24, Y
    895e:	c8 51       	subi	r28, 0x18	; 24
    8960:	d1 40       	sbci	r29, 0x01	; 1
    8962:	8f 93       	push	r24
    8964:	c9 5e       	subi	r28, 0xE9	; 233
    8966:	de 4f       	sbci	r29, 0xFE	; 254
    8968:	88 81       	ld	r24, Y
    896a:	c7 51       	subi	r28, 0x17	; 23
    896c:	d1 40       	sbci	r29, 0x01	; 1
    896e:	8f 93       	push	r24
    8970:	c6 5e       	subi	r28, 0xE6	; 230
    8972:	de 4f       	sbci	r29, 0xFE	; 254
    8974:	88 81       	ld	r24, Y
    8976:	ca 51       	subi	r28, 0x1A	; 26
    8978:	d1 40       	sbci	r29, 0x01	; 1
    897a:	8f 93       	push	r24
    897c:	c7 5e       	subi	r28, 0xE7	; 231
    897e:	de 4f       	sbci	r29, 0xFE	; 254
    8980:	88 81       	ld	r24, Y
    8982:	c9 51       	subi	r28, 0x19	; 25
    8984:	d1 40       	sbci	r29, 0x01	; 1
    8986:	8f 93       	push	r24
    8988:	c4 5e       	subi	r28, 0xE4	; 228
    898a:	de 4f       	sbci	r29, 0xFE	; 254
    898c:	88 81       	ld	r24, Y
    898e:	cc 51       	subi	r28, 0x1C	; 28
    8990:	d1 40       	sbci	r29, 0x01	; 1
    8992:	8f 93       	push	r24
    8994:	c5 5e       	subi	r28, 0xE5	; 229
    8996:	de 4f       	sbci	r29, 0xFE	; 254
    8998:	88 81       	ld	r24, Y
    899a:	cb 51       	subi	r28, 0x1B	; 27
    899c:	d1 40       	sbci	r29, 0x01	; 1
			printf ("OK %f %f\r\n",YawRate,Yaw);
		}
		else if (strstr(Cmd,"getadc"))
		{
			ADCStruct ADCData;
			ADCData=GetADCData();
    899e:	8f 93       	push	r24
    89a0:	85 ea       	ldi	r24, 0xA5	; 165
    89a2:	98 e2       	ldi	r25, 0x28	; 40
    89a4:	9f 93       	push	r25
    89a6:	8f 93       	push	r24
    89a8:	0e 94 df 50 	call	0xa1be	; 0xa1be <printf>
    89ac:	cd bf       	out	0x3d, r28	; 61
    89ae:	de bf       	out	0x3e, r29	; 62
    89b0:	6a ce       	rjmp	.-812    	; 0x8686 <WorkerTerminal+0x2c>
		}		
		else if (strstr(Cmd,"getrgb"))
		{
			DriverAdps9960Get(&c,&r,&g,&b);
			printf ("OK %d %d %d %d\r\n",c,r,g,b);
		}
    89b2:	66 eb       	ldi	r22, 0xB6	; 182
    89b4:	78 e2       	ldi	r23, 0x28	; 40
    89b6:	ce 01       	movw	r24, r28
    89b8:	87 53       	subi	r24, 0x37	; 55
    89ba:	9f 4f       	sbci	r25, 0xFF	; 255
    89bc:	0e 94 30 50 	call	0xa060	; 0xa060 <strstr>
    89c0:	89 2b       	or	r24, r25
    89c2:	d9 f1       	breq	.+118    	; 0x8a3a <WorkerTerminal+0x3e0>
		else if (strstr(Cmd,"getgyr"))
		{
			float YawRate,Yaw;
    89c4:	be 01       	movw	r22, r28
    89c6:	67 5f       	subi	r22, 0xF7	; 247
    89c8:	7e 4f       	sbci	r23, 0xFE	; 254
    89ca:	ce 01       	movw	r24, r28
    89cc:	8f 5e       	subi	r24, 0xEF	; 239
    89ce:	9e 4f       	sbci	r25, 0xFE	; 254
    89d0:	0e 94 bf 33 	call	0x677e	; 0x677e <GyroGet>
			GyroGet(&YawRate,&Yaw);
    89d4:	c4 5f       	subi	r28, 0xF4	; 244
    89d6:	de 4f       	sbci	r29, 0xFE	; 254
    89d8:	88 81       	ld	r24, Y
    89da:	cc 50       	subi	r28, 0x0C	; 12
    89dc:	d1 40       	sbci	r29, 0x01	; 1
    89de:	8f 93       	push	r24
    89e0:	c5 5f       	subi	r28, 0xF5	; 245
    89e2:	de 4f       	sbci	r29, 0xFE	; 254
    89e4:	88 81       	ld	r24, Y
    89e6:	cb 50       	subi	r28, 0x0B	; 11
    89e8:	d1 40       	sbci	r29, 0x01	; 1
    89ea:	8f 93       	push	r24
    89ec:	c6 5f       	subi	r28, 0xF6	; 246
    89ee:	de 4f       	sbci	r29, 0xFE	; 254
    89f0:	88 81       	ld	r24, Y
    89f2:	ca 50       	subi	r28, 0x0A	; 10
    89f4:	d1 40       	sbci	r29, 0x01	; 1
    89f6:	8f 93       	push	r24
    89f8:	c7 5f       	subi	r28, 0xF7	; 247
    89fa:	de 4f       	sbci	r29, 0xFE	; 254
    89fc:	88 81       	ld	r24, Y
    89fe:	c9 50       	subi	r28, 0x09	; 9
    8a00:	d1 40       	sbci	r29, 0x01	; 1
    8a02:	8f 93       	push	r24
    8a04:	cc 5e       	subi	r28, 0xEC	; 236
    8a06:	de 4f       	sbci	r29, 0xFE	; 254
    8a08:	88 81       	ld	r24, Y
    8a0a:	c4 51       	subi	r28, 0x14	; 20
    8a0c:	d1 40       	sbci	r29, 0x01	; 1
    8a0e:	8f 93       	push	r24
    8a10:	cd 5e       	subi	r28, 0xED	; 237
    8a12:	de 4f       	sbci	r29, 0xFE	; 254
    8a14:	88 81       	ld	r24, Y
    8a16:	c3 51       	subi	r28, 0x13	; 19
    8a18:	d1 40       	sbci	r29, 0x01	; 1
    8a1a:	8f 93       	push	r24
    8a1c:	ce 5e       	subi	r28, 0xEE	; 238
    8a1e:	de 4f       	sbci	r29, 0xFE	; 254
    8a20:	88 81       	ld	r24, Y
    8a22:	c2 51       	subi	r28, 0x12	; 18
    8a24:	d1 40       	sbci	r29, 0x01	; 1
    8a26:	8f 93       	push	r24
    8a28:	cf 5e       	subi	r28, 0xEF	; 239
    8a2a:	de 4f       	sbci	r29, 0xFE	; 254
    8a2c:	88 81       	ld	r24, Y
    8a2e:	c1 51       	subi	r28, 0x11	; 17
    8a30:	d1 40       	sbci	r29, 0x01	; 1
    8a32:	8f 93       	push	r24
    8a34:	8d eb       	ldi	r24, 0xBD	; 189
    8a36:	98 e2       	ldi	r25, 0x28	; 40
    8a38:	b5 cf       	rjmp	.-150    	; 0x89a4 <WorkerTerminal+0x34a>
			printf ("OK %f %f\r\n",YawRate,Yaw);
		}
    8a3a:	68 ec       	ldi	r22, 0xC8	; 200
    8a3c:	78 e2       	ldi	r23, 0x28	; 40
    8a3e:	ce 01       	movw	r24, r28
    8a40:	87 53       	subi	r24, 0x37	; 55
    8a42:	9f 4f       	sbci	r25, 0xFF	; 255
    8a44:	0e 94 30 50 	call	0xa060	; 0xa060 <strstr>
    8a48:	89 2b       	or	r24, r25
    8a4a:	09 f4       	brne	.+2      	; 0x8a4e <WorkerTerminal+0x3f4>
    8a4c:	55 c0       	rjmp	.+170    	; 0x8af8 <WorkerTerminal+0x49e>
		else if (strstr(Cmd,"getadc"))
		{
			ADCStruct ADCData;
    8a4e:	0e 94 b8 32 	call	0x6570	; 0x6570 <GetADCData>
    8a52:	c7 5f       	subi	r28, 0xF7	; 247
    8a54:	de 4f       	sbci	r29, 0xFE	; 254
    8a56:	28 83       	st	Y, r18
    8a58:	c9 50       	subi	r28, 0x09	; 9
    8a5a:	d1 40       	sbci	r29, 0x01	; 1
    8a5c:	c6 5f       	subi	r28, 0xF6	; 246
    8a5e:	de 4f       	sbci	r29, 0xFE	; 254
    8a60:	38 83       	st	Y, r19
    8a62:	ca 50       	subi	r28, 0x0A	; 10
    8a64:	d1 40       	sbci	r29, 0x01	; 1
    8a66:	c5 5f       	subi	r28, 0xF5	; 245
    8a68:	de 4f       	sbci	r29, 0xFE	; 254
    8a6a:	48 83       	st	Y, r20
    8a6c:	cb 50       	subi	r28, 0x0B	; 11
    8a6e:	d1 40       	sbci	r29, 0x01	; 1
    8a70:	c4 5f       	subi	r28, 0xF4	; 244
    8a72:	de 4f       	sbci	r29, 0xFE	; 254
    8a74:	58 83       	st	Y, r21
    8a76:	cc 50       	subi	r28, 0x0C	; 12
    8a78:	d1 40       	sbci	r29, 0x01	; 1
    8a7a:	c3 5f       	subi	r28, 0xF3	; 243
    8a7c:	de 4f       	sbci	r29, 0xFE	; 254
    8a7e:	68 83       	st	Y, r22
    8a80:	cd 50       	subi	r28, 0x0D	; 13
    8a82:	d1 40       	sbci	r29, 0x01	; 1
    8a84:	c2 5f       	subi	r28, 0xF2	; 242
    8a86:	de 4f       	sbci	r29, 0xFE	; 254
    8a88:	78 83       	st	Y, r23
    8a8a:	ce 50       	subi	r28, 0x0E	; 14
    8a8c:	d1 40       	sbci	r29, 0x01	; 1
    8a8e:	c1 5f       	subi	r28, 0xF1	; 241
    8a90:	de 4f       	sbci	r29, 0xFE	; 254
    8a92:	88 83       	st	Y, r24
    8a94:	cf 50       	subi	r28, 0x0F	; 15
    8a96:	d1 40       	sbci	r29, 0x01	; 1
    8a98:	c0 5f       	subi	r28, 0xF0	; 240
    8a9a:	de 4f       	sbci	r29, 0xFE	; 254
    8a9c:	98 83       	st	Y, r25
    8a9e:	c0 51       	subi	r28, 0x10	; 16
    8aa0:	d1 40       	sbci	r29, 0x01	; 1
			ADCData=GetADCData();
    8aa2:	9f 93       	push	r25
    8aa4:	c1 5f       	subi	r28, 0xF1	; 241
    8aa6:	de 4f       	sbci	r29, 0xFE	; 254
    8aa8:	88 81       	ld	r24, Y
    8aaa:	cf 50       	subi	r28, 0x0F	; 15
    8aac:	d1 40       	sbci	r29, 0x01	; 1
    8aae:	8f 93       	push	r24
    8ab0:	c2 5f       	subi	r28, 0xF2	; 242
    8ab2:	de 4f       	sbci	r29, 0xFE	; 254
    8ab4:	88 81       	ld	r24, Y
    8ab6:	ce 50       	subi	r28, 0x0E	; 14
    8ab8:	d1 40       	sbci	r29, 0x01	; 1
    8aba:	8f 93       	push	r24
    8abc:	c3 5f       	subi	r28, 0xF3	; 243
    8abe:	de 4f       	sbci	r29, 0xFE	; 254
    8ac0:	88 81       	ld	r24, Y
    8ac2:	cd 50       	subi	r28, 0x0D	; 13
    8ac4:	d1 40       	sbci	r29, 0x01	; 1
    8ac6:	8f 93       	push	r24
    8ac8:	c4 5f       	subi	r28, 0xF4	; 244
    8aca:	de 4f       	sbci	r29, 0xFE	; 254
    8acc:	88 81       	ld	r24, Y
    8ace:	cc 50       	subi	r28, 0x0C	; 12
    8ad0:	d1 40       	sbci	r29, 0x01	; 1
    8ad2:	8f 93       	push	r24
    8ad4:	c5 5f       	subi	r28, 0xF5	; 245
    8ad6:	de 4f       	sbci	r29, 0xFE	; 254
    8ad8:	88 81       	ld	r24, Y
    8ada:	cb 50       	subi	r28, 0x0B	; 11
    8adc:	d1 40       	sbci	r29, 0x01	; 1
    8ade:	8f 93       	push	r24
    8ae0:	c6 5f       	subi	r28, 0xF6	; 246
    8ae2:	de 4f       	sbci	r29, 0xFE	; 254
    8ae4:	88 81       	ld	r24, Y
    8ae6:	ca 50       	subi	r28, 0x0A	; 10
    8ae8:	d1 40       	sbci	r29, 0x01	; 1
    8aea:	8f 93       	push	r24
    8aec:	c7 5f       	subi	r28, 0xF7	; 247
    8aee:	de 4f       	sbci	r29, 0xFE	; 254
    8af0:	88 81       	ld	r24, Y
    8af2:	c9 50       	subi	r28, 0x09	; 9
    8af4:	d1 40       	sbci	r29, 0x01	; 1
    8af6:	53 cf       	rjmp	.-346    	; 0x899e <WorkerTerminal+0x344>
			printf ("OK %d %d %d %d\r\n",ADCData.PhotoL,ADCData.PhotoM,ADCData.PhotoR,ADCData.Potmeter);
		}
    8af8:	6f ec       	ldi	r22, 0xCF	; 207
    8afa:	78 e2       	ldi	r23, 0x28	; 40
    8afc:	ce 01       	movw	r24, r28
    8afe:	87 53       	subi	r24, 0x37	; 55
    8b00:	9f 4f       	sbci	r25, 0xFF	; 255
    8b02:	0e 94 30 50 	call	0xa060	; 0xa060 <strstr>
    8b06:	89 2b       	or	r24, r25
    8b08:	61 f0       	breq	.+24     	; 0x8b22 <WorkerTerminal+0x4c8>
		else if (strstr(Cmd,"auxpwr"))
		{
    8b0a:	c5 01       	movw	r24, r10
    8b0c:	b4 01       	movw	r22, r8
    8b0e:	0e 94 95 46 	call	0x8d2a	; 0x8d2a <__fixunssfsi>
    8b12:	86 2f       	mov	r24, r22
    8b14:	0e 94 a1 0f 	call	0x1f42	; 0x1f42 <DriverPowerVccAuxSet>
			DriverPowerVccAuxSet((uint8_t) Pars[0]);
    8b18:	8c e6       	ldi	r24, 0x6C	; 108
    8b1a:	98 e2       	ldi	r25, 0x28	; 40
    8b1c:	0e 94 1b 51 	call	0xa236	; 0xa236 <puts>
    8b20:	b2 cd       	rjmp	.-1180   	; 0x8686 <WorkerTerminal+0x2c>
			printf ("OK\r\n");
		}
		else if (strstr(Cmd, "sleep"))
    8b22:	86 ed       	ldi	r24, 0xD6	; 214
    8b24:	98 e2       	ldi	r25, 0x28	; 40
    8b26:	0e 94 1b 51 	call	0xa236	; 0xa236 <puts>
    8b2a:	ad cd       	rjmp	.-1190   	; 0x8686 <WorkerTerminal+0x2c>

00008b2c <InitTerminalTask>:
static void WorkerTerminal(void *pvParameters);
static void SplitCmd(char *Data,char *Cmd,float *Pars);

//Function definitions
void InitTerminalTask()
{
    8b2c:	ef 92       	push	r14
    8b2e:	ff 92       	push	r15
    8b30:	0f 93       	push	r16
	xTaskCreate( WorkerTerminal, "term", 1024, NULL, tskIDLE_PRIORITY+1, NULL );	
    8b32:	e1 2c       	mov	r14, r1
    8b34:	f1 2c       	mov	r15, r1
    8b36:	01 e0       	ldi	r16, 0x01	; 1
    8b38:	20 e0       	ldi	r18, 0x00	; 0
    8b3a:	30 e0       	ldi	r19, 0x00	; 0
    8b3c:	40 e0       	ldi	r20, 0x00	; 0
    8b3e:	54 e0       	ldi	r21, 0x04	; 4
    8b40:	67 ee       	ldi	r22, 0xE7	; 231
    8b42:	78 e2       	ldi	r23, 0x28	; 40
    8b44:	8d e2       	ldi	r24, 0x2D	; 45
    8b46:	93 e4       	ldi	r25, 0x43	; 67
    8b48:	0e 94 f9 26 	call	0x4df2	; 0x4df2 <xTaskCreate>
}
    8b4c:	0f 91       	pop	r16
    8b4e:	ff 90       	pop	r15
    8b50:	ef 90       	pop	r14
    8b52:	08 95       	ret

00008b54 <__subsf3>:
    8b54:	50 58       	subi	r21, 0x80	; 128

00008b56 <__addsf3>:
    8b56:	bb 27       	eor	r27, r27
    8b58:	aa 27       	eor	r26, r26
    8b5a:	0e 94 c2 45 	call	0x8b84	; 0x8b84 <__addsf3x>
    8b5e:	0c 94 3c 47 	jmp	0x8e78	; 0x8e78 <__fp_round>
    8b62:	0e 94 2e 47 	call	0x8e5c	; 0x8e5c <__fp_pscA>
    8b66:	38 f0       	brcs	.+14     	; 0x8b76 <__addsf3+0x20>
    8b68:	0e 94 35 47 	call	0x8e6a	; 0x8e6a <__fp_pscB>
    8b6c:	20 f0       	brcs	.+8      	; 0x8b76 <__addsf3+0x20>
    8b6e:	39 f4       	brne	.+14     	; 0x8b7e <__addsf3+0x28>
    8b70:	9f 3f       	cpi	r25, 0xFF	; 255
    8b72:	19 f4       	brne	.+6      	; 0x8b7a <__addsf3+0x24>
    8b74:	26 f4       	brtc	.+8      	; 0x8b7e <__addsf3+0x28>
    8b76:	0c 94 2b 47 	jmp	0x8e56	; 0x8e56 <__fp_nan>
    8b7a:	0e f4       	brtc	.+2      	; 0x8b7e <__addsf3+0x28>
    8b7c:	e0 95       	com	r30
    8b7e:	e7 fb       	bst	r30, 7
    8b80:	0c 94 25 47 	jmp	0x8e4a	; 0x8e4a <__fp_inf>

00008b84 <__addsf3x>:
    8b84:	e9 2f       	mov	r30, r25
    8b86:	0e 94 4d 47 	call	0x8e9a	; 0x8e9a <__fp_split3>
    8b8a:	58 f3       	brcs	.-42     	; 0x8b62 <__addsf3+0xc>
    8b8c:	ba 17       	cp	r27, r26
    8b8e:	62 07       	cpc	r22, r18
    8b90:	73 07       	cpc	r23, r19
    8b92:	84 07       	cpc	r24, r20
    8b94:	95 07       	cpc	r25, r21
    8b96:	20 f0       	brcs	.+8      	; 0x8ba0 <__addsf3x+0x1c>
    8b98:	79 f4       	brne	.+30     	; 0x8bb8 <__addsf3x+0x34>
    8b9a:	a6 f5       	brtc	.+104    	; 0x8c04 <__addsf3x+0x80>
    8b9c:	0c 94 6f 47 	jmp	0x8ede	; 0x8ede <__fp_zero>
    8ba0:	0e f4       	brtc	.+2      	; 0x8ba4 <__addsf3x+0x20>
    8ba2:	e0 95       	com	r30
    8ba4:	0b 2e       	mov	r0, r27
    8ba6:	ba 2f       	mov	r27, r26
    8ba8:	a0 2d       	mov	r26, r0
    8baa:	0b 01       	movw	r0, r22
    8bac:	b9 01       	movw	r22, r18
    8bae:	90 01       	movw	r18, r0
    8bb0:	0c 01       	movw	r0, r24
    8bb2:	ca 01       	movw	r24, r20
    8bb4:	a0 01       	movw	r20, r0
    8bb6:	11 24       	eor	r1, r1
    8bb8:	ff 27       	eor	r31, r31
    8bba:	59 1b       	sub	r21, r25
    8bbc:	99 f0       	breq	.+38     	; 0x8be4 <__addsf3x+0x60>
    8bbe:	59 3f       	cpi	r21, 0xF9	; 249
    8bc0:	50 f4       	brcc	.+20     	; 0x8bd6 <__addsf3x+0x52>
    8bc2:	50 3e       	cpi	r21, 0xE0	; 224
    8bc4:	68 f1       	brcs	.+90     	; 0x8c20 <__addsf3x+0x9c>
    8bc6:	1a 16       	cp	r1, r26
    8bc8:	f0 40       	sbci	r31, 0x00	; 0
    8bca:	a2 2f       	mov	r26, r18
    8bcc:	23 2f       	mov	r18, r19
    8bce:	34 2f       	mov	r19, r20
    8bd0:	44 27       	eor	r20, r20
    8bd2:	58 5f       	subi	r21, 0xF8	; 248
    8bd4:	f3 cf       	rjmp	.-26     	; 0x8bbc <__addsf3x+0x38>
    8bd6:	46 95       	lsr	r20
    8bd8:	37 95       	ror	r19
    8bda:	27 95       	ror	r18
    8bdc:	a7 95       	ror	r26
    8bde:	f0 40       	sbci	r31, 0x00	; 0
    8be0:	53 95       	inc	r21
    8be2:	c9 f7       	brne	.-14     	; 0x8bd6 <__addsf3x+0x52>
    8be4:	7e f4       	brtc	.+30     	; 0x8c04 <__addsf3x+0x80>
    8be6:	1f 16       	cp	r1, r31
    8be8:	ba 0b       	sbc	r27, r26
    8bea:	62 0b       	sbc	r22, r18
    8bec:	73 0b       	sbc	r23, r19
    8bee:	84 0b       	sbc	r24, r20
    8bf0:	ba f0       	brmi	.+46     	; 0x8c20 <__addsf3x+0x9c>
    8bf2:	91 50       	subi	r25, 0x01	; 1
    8bf4:	a1 f0       	breq	.+40     	; 0x8c1e <__addsf3x+0x9a>
    8bf6:	ff 0f       	add	r31, r31
    8bf8:	bb 1f       	adc	r27, r27
    8bfa:	66 1f       	adc	r22, r22
    8bfc:	77 1f       	adc	r23, r23
    8bfe:	88 1f       	adc	r24, r24
    8c00:	c2 f7       	brpl	.-16     	; 0x8bf2 <__addsf3x+0x6e>
    8c02:	0e c0       	rjmp	.+28     	; 0x8c20 <__addsf3x+0x9c>
    8c04:	ba 0f       	add	r27, r26
    8c06:	62 1f       	adc	r22, r18
    8c08:	73 1f       	adc	r23, r19
    8c0a:	84 1f       	adc	r24, r20
    8c0c:	48 f4       	brcc	.+18     	; 0x8c20 <__addsf3x+0x9c>
    8c0e:	87 95       	ror	r24
    8c10:	77 95       	ror	r23
    8c12:	67 95       	ror	r22
    8c14:	b7 95       	ror	r27
    8c16:	f7 95       	ror	r31
    8c18:	9e 3f       	cpi	r25, 0xFE	; 254
    8c1a:	08 f0       	brcs	.+2      	; 0x8c1e <__addsf3x+0x9a>
    8c1c:	b0 cf       	rjmp	.-160    	; 0x8b7e <__addsf3+0x28>
    8c1e:	93 95       	inc	r25
    8c20:	88 0f       	add	r24, r24
    8c22:	08 f0       	brcs	.+2      	; 0x8c26 <__addsf3x+0xa2>
    8c24:	99 27       	eor	r25, r25
    8c26:	ee 0f       	add	r30, r30
    8c28:	97 95       	ror	r25
    8c2a:	87 95       	ror	r24
    8c2c:	08 95       	ret

00008c2e <__cmpsf2>:
    8c2e:	0e 94 01 47 	call	0x8e02	; 0x8e02 <__fp_cmp>
    8c32:	08 f4       	brcc	.+2      	; 0x8c36 <__cmpsf2+0x8>
    8c34:	81 e0       	ldi	r24, 0x01	; 1
    8c36:	08 95       	ret

00008c38 <__divsf3>:
    8c38:	0e 94 30 46 	call	0x8c60	; 0x8c60 <__divsf3x>
    8c3c:	0c 94 3c 47 	jmp	0x8e78	; 0x8e78 <__fp_round>
    8c40:	0e 94 35 47 	call	0x8e6a	; 0x8e6a <__fp_pscB>
    8c44:	58 f0       	brcs	.+22     	; 0x8c5c <__divsf3+0x24>
    8c46:	0e 94 2e 47 	call	0x8e5c	; 0x8e5c <__fp_pscA>
    8c4a:	40 f0       	brcs	.+16     	; 0x8c5c <__divsf3+0x24>
    8c4c:	29 f4       	brne	.+10     	; 0x8c58 <__divsf3+0x20>
    8c4e:	5f 3f       	cpi	r21, 0xFF	; 255
    8c50:	29 f0       	breq	.+10     	; 0x8c5c <__divsf3+0x24>
    8c52:	0c 94 25 47 	jmp	0x8e4a	; 0x8e4a <__fp_inf>
    8c56:	51 11       	cpse	r21, r1
    8c58:	0c 94 70 47 	jmp	0x8ee0	; 0x8ee0 <__fp_szero>
    8c5c:	0c 94 2b 47 	jmp	0x8e56	; 0x8e56 <__fp_nan>

00008c60 <__divsf3x>:
    8c60:	0e 94 4d 47 	call	0x8e9a	; 0x8e9a <__fp_split3>
    8c64:	68 f3       	brcs	.-38     	; 0x8c40 <__divsf3+0x8>

00008c66 <__divsf3_pse>:
    8c66:	99 23       	and	r25, r25
    8c68:	b1 f3       	breq	.-20     	; 0x8c56 <__divsf3+0x1e>
    8c6a:	55 23       	and	r21, r21
    8c6c:	91 f3       	breq	.-28     	; 0x8c52 <__divsf3+0x1a>
    8c6e:	95 1b       	sub	r25, r21
    8c70:	55 0b       	sbc	r21, r21
    8c72:	bb 27       	eor	r27, r27
    8c74:	aa 27       	eor	r26, r26
    8c76:	62 17       	cp	r22, r18
    8c78:	73 07       	cpc	r23, r19
    8c7a:	84 07       	cpc	r24, r20
    8c7c:	38 f0       	brcs	.+14     	; 0x8c8c <__divsf3_pse+0x26>
    8c7e:	9f 5f       	subi	r25, 0xFF	; 255
    8c80:	5f 4f       	sbci	r21, 0xFF	; 255
    8c82:	22 0f       	add	r18, r18
    8c84:	33 1f       	adc	r19, r19
    8c86:	44 1f       	adc	r20, r20
    8c88:	aa 1f       	adc	r26, r26
    8c8a:	a9 f3       	breq	.-22     	; 0x8c76 <__divsf3_pse+0x10>
    8c8c:	35 d0       	rcall	.+106    	; 0x8cf8 <__divsf3_pse+0x92>
    8c8e:	0e 2e       	mov	r0, r30
    8c90:	3a f0       	brmi	.+14     	; 0x8ca0 <__divsf3_pse+0x3a>
    8c92:	e0 e8       	ldi	r30, 0x80	; 128
    8c94:	32 d0       	rcall	.+100    	; 0x8cfa <__divsf3_pse+0x94>
    8c96:	91 50       	subi	r25, 0x01	; 1
    8c98:	50 40       	sbci	r21, 0x00	; 0
    8c9a:	e6 95       	lsr	r30
    8c9c:	00 1c       	adc	r0, r0
    8c9e:	ca f7       	brpl	.-14     	; 0x8c92 <__divsf3_pse+0x2c>
    8ca0:	2b d0       	rcall	.+86     	; 0x8cf8 <__divsf3_pse+0x92>
    8ca2:	fe 2f       	mov	r31, r30
    8ca4:	29 d0       	rcall	.+82     	; 0x8cf8 <__divsf3_pse+0x92>
    8ca6:	66 0f       	add	r22, r22
    8ca8:	77 1f       	adc	r23, r23
    8caa:	88 1f       	adc	r24, r24
    8cac:	bb 1f       	adc	r27, r27
    8cae:	26 17       	cp	r18, r22
    8cb0:	37 07       	cpc	r19, r23
    8cb2:	48 07       	cpc	r20, r24
    8cb4:	ab 07       	cpc	r26, r27
    8cb6:	b0 e8       	ldi	r27, 0x80	; 128
    8cb8:	09 f0       	breq	.+2      	; 0x8cbc <__divsf3_pse+0x56>
    8cba:	bb 0b       	sbc	r27, r27
    8cbc:	80 2d       	mov	r24, r0
    8cbe:	bf 01       	movw	r22, r30
    8cc0:	ff 27       	eor	r31, r31
    8cc2:	93 58       	subi	r25, 0x83	; 131
    8cc4:	5f 4f       	sbci	r21, 0xFF	; 255
    8cc6:	3a f0       	brmi	.+14     	; 0x8cd6 <__divsf3_pse+0x70>
    8cc8:	9e 3f       	cpi	r25, 0xFE	; 254
    8cca:	51 05       	cpc	r21, r1
    8ccc:	78 f0       	brcs	.+30     	; 0x8cec <__divsf3_pse+0x86>
    8cce:	0c 94 25 47 	jmp	0x8e4a	; 0x8e4a <__fp_inf>
    8cd2:	0c 94 70 47 	jmp	0x8ee0	; 0x8ee0 <__fp_szero>
    8cd6:	5f 3f       	cpi	r21, 0xFF	; 255
    8cd8:	e4 f3       	brlt	.-8      	; 0x8cd2 <__divsf3_pse+0x6c>
    8cda:	98 3e       	cpi	r25, 0xE8	; 232
    8cdc:	d4 f3       	brlt	.-12     	; 0x8cd2 <__divsf3_pse+0x6c>
    8cde:	86 95       	lsr	r24
    8ce0:	77 95       	ror	r23
    8ce2:	67 95       	ror	r22
    8ce4:	b7 95       	ror	r27
    8ce6:	f7 95       	ror	r31
    8ce8:	9f 5f       	subi	r25, 0xFF	; 255
    8cea:	c9 f7       	brne	.-14     	; 0x8cde <__divsf3_pse+0x78>
    8cec:	88 0f       	add	r24, r24
    8cee:	91 1d       	adc	r25, r1
    8cf0:	96 95       	lsr	r25
    8cf2:	87 95       	ror	r24
    8cf4:	97 f9       	bld	r25, 7
    8cf6:	08 95       	ret
    8cf8:	e1 e0       	ldi	r30, 0x01	; 1
    8cfa:	66 0f       	add	r22, r22
    8cfc:	77 1f       	adc	r23, r23
    8cfe:	88 1f       	adc	r24, r24
    8d00:	bb 1f       	adc	r27, r27
    8d02:	62 17       	cp	r22, r18
    8d04:	73 07       	cpc	r23, r19
    8d06:	84 07       	cpc	r24, r20
    8d08:	ba 07       	cpc	r27, r26
    8d0a:	20 f0       	brcs	.+8      	; 0x8d14 <__divsf3_pse+0xae>
    8d0c:	62 1b       	sub	r22, r18
    8d0e:	73 0b       	sbc	r23, r19
    8d10:	84 0b       	sbc	r24, r20
    8d12:	ba 0b       	sbc	r27, r26
    8d14:	ee 1f       	adc	r30, r30
    8d16:	88 f7       	brcc	.-30     	; 0x8cfa <__divsf3_pse+0x94>
    8d18:	e0 95       	com	r30
    8d1a:	08 95       	ret

00008d1c <__fixsfsi>:
    8d1c:	0e 94 95 46 	call	0x8d2a	; 0x8d2a <__fixunssfsi>
    8d20:	68 94       	set
    8d22:	b1 11       	cpse	r27, r1
    8d24:	0c 94 70 47 	jmp	0x8ee0	; 0x8ee0 <__fp_szero>
    8d28:	08 95       	ret

00008d2a <__fixunssfsi>:
    8d2a:	0e 94 55 47 	call	0x8eaa	; 0x8eaa <__fp_splitA>
    8d2e:	88 f0       	brcs	.+34     	; 0x8d52 <__fixunssfsi+0x28>
    8d30:	9f 57       	subi	r25, 0x7F	; 127
    8d32:	98 f0       	brcs	.+38     	; 0x8d5a <__fixunssfsi+0x30>
    8d34:	b9 2f       	mov	r27, r25
    8d36:	99 27       	eor	r25, r25
    8d38:	b7 51       	subi	r27, 0x17	; 23
    8d3a:	b0 f0       	brcs	.+44     	; 0x8d68 <__fixunssfsi+0x3e>
    8d3c:	e1 f0       	breq	.+56     	; 0x8d76 <__fixunssfsi+0x4c>
    8d3e:	66 0f       	add	r22, r22
    8d40:	77 1f       	adc	r23, r23
    8d42:	88 1f       	adc	r24, r24
    8d44:	99 1f       	adc	r25, r25
    8d46:	1a f0       	brmi	.+6      	; 0x8d4e <__fixunssfsi+0x24>
    8d48:	ba 95       	dec	r27
    8d4a:	c9 f7       	brne	.-14     	; 0x8d3e <__fixunssfsi+0x14>
    8d4c:	14 c0       	rjmp	.+40     	; 0x8d76 <__fixunssfsi+0x4c>
    8d4e:	b1 30       	cpi	r27, 0x01	; 1
    8d50:	91 f0       	breq	.+36     	; 0x8d76 <__fixunssfsi+0x4c>
    8d52:	0e 94 6f 47 	call	0x8ede	; 0x8ede <__fp_zero>
    8d56:	b1 e0       	ldi	r27, 0x01	; 1
    8d58:	08 95       	ret
    8d5a:	0c 94 6f 47 	jmp	0x8ede	; 0x8ede <__fp_zero>
    8d5e:	67 2f       	mov	r22, r23
    8d60:	78 2f       	mov	r23, r24
    8d62:	88 27       	eor	r24, r24
    8d64:	b8 5f       	subi	r27, 0xF8	; 248
    8d66:	39 f0       	breq	.+14     	; 0x8d76 <__fixunssfsi+0x4c>
    8d68:	b9 3f       	cpi	r27, 0xF9	; 249
    8d6a:	cc f3       	brlt	.-14     	; 0x8d5e <__fixunssfsi+0x34>
    8d6c:	86 95       	lsr	r24
    8d6e:	77 95       	ror	r23
    8d70:	67 95       	ror	r22
    8d72:	b3 95       	inc	r27
    8d74:	d9 f7       	brne	.-10     	; 0x8d6c <__fixunssfsi+0x42>
    8d76:	3e f4       	brtc	.+14     	; 0x8d86 <__fixunssfsi+0x5c>
    8d78:	90 95       	com	r25
    8d7a:	80 95       	com	r24
    8d7c:	70 95       	com	r23
    8d7e:	61 95       	neg	r22
    8d80:	7f 4f       	sbci	r23, 0xFF	; 255
    8d82:	8f 4f       	sbci	r24, 0xFF	; 255
    8d84:	9f 4f       	sbci	r25, 0xFF	; 255
    8d86:	08 95       	ret

00008d88 <__floatunsisf>:
    8d88:	e8 94       	clt
    8d8a:	09 c0       	rjmp	.+18     	; 0x8d9e <__floatsisf+0x12>

00008d8c <__floatsisf>:
    8d8c:	97 fb       	bst	r25, 7
    8d8e:	3e f4       	brtc	.+14     	; 0x8d9e <__floatsisf+0x12>
    8d90:	90 95       	com	r25
    8d92:	80 95       	com	r24
    8d94:	70 95       	com	r23
    8d96:	61 95       	neg	r22
    8d98:	7f 4f       	sbci	r23, 0xFF	; 255
    8d9a:	8f 4f       	sbci	r24, 0xFF	; 255
    8d9c:	9f 4f       	sbci	r25, 0xFF	; 255
    8d9e:	99 23       	and	r25, r25
    8da0:	a9 f0       	breq	.+42     	; 0x8dcc <__floatsisf+0x40>
    8da2:	f9 2f       	mov	r31, r25
    8da4:	96 e9       	ldi	r25, 0x96	; 150
    8da6:	bb 27       	eor	r27, r27
    8da8:	93 95       	inc	r25
    8daa:	f6 95       	lsr	r31
    8dac:	87 95       	ror	r24
    8dae:	77 95       	ror	r23
    8db0:	67 95       	ror	r22
    8db2:	b7 95       	ror	r27
    8db4:	f1 11       	cpse	r31, r1
    8db6:	f8 cf       	rjmp	.-16     	; 0x8da8 <__floatsisf+0x1c>
    8db8:	fa f4       	brpl	.+62     	; 0x8df8 <__floatsisf+0x6c>
    8dba:	bb 0f       	add	r27, r27
    8dbc:	11 f4       	brne	.+4      	; 0x8dc2 <__floatsisf+0x36>
    8dbe:	60 ff       	sbrs	r22, 0
    8dc0:	1b c0       	rjmp	.+54     	; 0x8df8 <__floatsisf+0x6c>
    8dc2:	6f 5f       	subi	r22, 0xFF	; 255
    8dc4:	7f 4f       	sbci	r23, 0xFF	; 255
    8dc6:	8f 4f       	sbci	r24, 0xFF	; 255
    8dc8:	9f 4f       	sbci	r25, 0xFF	; 255
    8dca:	16 c0       	rjmp	.+44     	; 0x8df8 <__floatsisf+0x6c>
    8dcc:	88 23       	and	r24, r24
    8dce:	11 f0       	breq	.+4      	; 0x8dd4 <__floatsisf+0x48>
    8dd0:	96 e9       	ldi	r25, 0x96	; 150
    8dd2:	11 c0       	rjmp	.+34     	; 0x8df6 <__floatsisf+0x6a>
    8dd4:	77 23       	and	r23, r23
    8dd6:	21 f0       	breq	.+8      	; 0x8de0 <__floatsisf+0x54>
    8dd8:	9e e8       	ldi	r25, 0x8E	; 142
    8dda:	87 2f       	mov	r24, r23
    8ddc:	76 2f       	mov	r23, r22
    8dde:	05 c0       	rjmp	.+10     	; 0x8dea <__floatsisf+0x5e>
    8de0:	66 23       	and	r22, r22
    8de2:	71 f0       	breq	.+28     	; 0x8e00 <__floatsisf+0x74>
    8de4:	96 e8       	ldi	r25, 0x86	; 134
    8de6:	86 2f       	mov	r24, r22
    8de8:	70 e0       	ldi	r23, 0x00	; 0
    8dea:	60 e0       	ldi	r22, 0x00	; 0
    8dec:	2a f0       	brmi	.+10     	; 0x8df8 <__floatsisf+0x6c>
    8dee:	9a 95       	dec	r25
    8df0:	66 0f       	add	r22, r22
    8df2:	77 1f       	adc	r23, r23
    8df4:	88 1f       	adc	r24, r24
    8df6:	da f7       	brpl	.-10     	; 0x8dee <__floatsisf+0x62>
    8df8:	88 0f       	add	r24, r24
    8dfa:	96 95       	lsr	r25
    8dfc:	87 95       	ror	r24
    8dfe:	97 f9       	bld	r25, 7
    8e00:	08 95       	ret

00008e02 <__fp_cmp>:
    8e02:	99 0f       	add	r25, r25
    8e04:	00 08       	sbc	r0, r0
    8e06:	55 0f       	add	r21, r21
    8e08:	aa 0b       	sbc	r26, r26
    8e0a:	e0 e8       	ldi	r30, 0x80	; 128
    8e0c:	fe ef       	ldi	r31, 0xFE	; 254
    8e0e:	16 16       	cp	r1, r22
    8e10:	17 06       	cpc	r1, r23
    8e12:	e8 07       	cpc	r30, r24
    8e14:	f9 07       	cpc	r31, r25
    8e16:	c0 f0       	brcs	.+48     	; 0x8e48 <__fp_cmp+0x46>
    8e18:	12 16       	cp	r1, r18
    8e1a:	13 06       	cpc	r1, r19
    8e1c:	e4 07       	cpc	r30, r20
    8e1e:	f5 07       	cpc	r31, r21
    8e20:	98 f0       	brcs	.+38     	; 0x8e48 <__fp_cmp+0x46>
    8e22:	62 1b       	sub	r22, r18
    8e24:	73 0b       	sbc	r23, r19
    8e26:	84 0b       	sbc	r24, r20
    8e28:	95 0b       	sbc	r25, r21
    8e2a:	39 f4       	brne	.+14     	; 0x8e3a <__fp_cmp+0x38>
    8e2c:	0a 26       	eor	r0, r26
    8e2e:	61 f0       	breq	.+24     	; 0x8e48 <__fp_cmp+0x46>
    8e30:	23 2b       	or	r18, r19
    8e32:	24 2b       	or	r18, r20
    8e34:	25 2b       	or	r18, r21
    8e36:	21 f4       	brne	.+8      	; 0x8e40 <__fp_cmp+0x3e>
    8e38:	08 95       	ret
    8e3a:	0a 26       	eor	r0, r26
    8e3c:	09 f4       	brne	.+2      	; 0x8e40 <__fp_cmp+0x3e>
    8e3e:	a1 40       	sbci	r26, 0x01	; 1
    8e40:	a6 95       	lsr	r26
    8e42:	8f ef       	ldi	r24, 0xFF	; 255
    8e44:	81 1d       	adc	r24, r1
    8e46:	81 1d       	adc	r24, r1
    8e48:	08 95       	ret

00008e4a <__fp_inf>:
    8e4a:	97 f9       	bld	r25, 7
    8e4c:	9f 67       	ori	r25, 0x7F	; 127
    8e4e:	80 e8       	ldi	r24, 0x80	; 128
    8e50:	70 e0       	ldi	r23, 0x00	; 0
    8e52:	60 e0       	ldi	r22, 0x00	; 0
    8e54:	08 95       	ret

00008e56 <__fp_nan>:
    8e56:	9f ef       	ldi	r25, 0xFF	; 255
    8e58:	80 ec       	ldi	r24, 0xC0	; 192
    8e5a:	08 95       	ret

00008e5c <__fp_pscA>:
    8e5c:	00 24       	eor	r0, r0
    8e5e:	0a 94       	dec	r0
    8e60:	16 16       	cp	r1, r22
    8e62:	17 06       	cpc	r1, r23
    8e64:	18 06       	cpc	r1, r24
    8e66:	09 06       	cpc	r0, r25
    8e68:	08 95       	ret

00008e6a <__fp_pscB>:
    8e6a:	00 24       	eor	r0, r0
    8e6c:	0a 94       	dec	r0
    8e6e:	12 16       	cp	r1, r18
    8e70:	13 06       	cpc	r1, r19
    8e72:	14 06       	cpc	r1, r20
    8e74:	05 06       	cpc	r0, r21
    8e76:	08 95       	ret

00008e78 <__fp_round>:
    8e78:	09 2e       	mov	r0, r25
    8e7a:	03 94       	inc	r0
    8e7c:	00 0c       	add	r0, r0
    8e7e:	11 f4       	brne	.+4      	; 0x8e84 <__fp_round+0xc>
    8e80:	88 23       	and	r24, r24
    8e82:	52 f0       	brmi	.+20     	; 0x8e98 <__fp_round+0x20>
    8e84:	bb 0f       	add	r27, r27
    8e86:	40 f4       	brcc	.+16     	; 0x8e98 <__fp_round+0x20>
    8e88:	bf 2b       	or	r27, r31
    8e8a:	11 f4       	brne	.+4      	; 0x8e90 <__fp_round+0x18>
    8e8c:	60 ff       	sbrs	r22, 0
    8e8e:	04 c0       	rjmp	.+8      	; 0x8e98 <__fp_round+0x20>
    8e90:	6f 5f       	subi	r22, 0xFF	; 255
    8e92:	7f 4f       	sbci	r23, 0xFF	; 255
    8e94:	8f 4f       	sbci	r24, 0xFF	; 255
    8e96:	9f 4f       	sbci	r25, 0xFF	; 255
    8e98:	08 95       	ret

00008e9a <__fp_split3>:
    8e9a:	57 fd       	sbrc	r21, 7
    8e9c:	90 58       	subi	r25, 0x80	; 128
    8e9e:	44 0f       	add	r20, r20
    8ea0:	55 1f       	adc	r21, r21
    8ea2:	59 f0       	breq	.+22     	; 0x8eba <__fp_splitA+0x10>
    8ea4:	5f 3f       	cpi	r21, 0xFF	; 255
    8ea6:	71 f0       	breq	.+28     	; 0x8ec4 <__fp_splitA+0x1a>
    8ea8:	47 95       	ror	r20

00008eaa <__fp_splitA>:
    8eaa:	88 0f       	add	r24, r24
    8eac:	97 fb       	bst	r25, 7
    8eae:	99 1f       	adc	r25, r25
    8eb0:	61 f0       	breq	.+24     	; 0x8eca <__fp_splitA+0x20>
    8eb2:	9f 3f       	cpi	r25, 0xFF	; 255
    8eb4:	79 f0       	breq	.+30     	; 0x8ed4 <__fp_splitA+0x2a>
    8eb6:	87 95       	ror	r24
    8eb8:	08 95       	ret
    8eba:	12 16       	cp	r1, r18
    8ebc:	13 06       	cpc	r1, r19
    8ebe:	14 06       	cpc	r1, r20
    8ec0:	55 1f       	adc	r21, r21
    8ec2:	f2 cf       	rjmp	.-28     	; 0x8ea8 <__fp_split3+0xe>
    8ec4:	46 95       	lsr	r20
    8ec6:	f1 df       	rcall	.-30     	; 0x8eaa <__fp_splitA>
    8ec8:	08 c0       	rjmp	.+16     	; 0x8eda <__fp_splitA+0x30>
    8eca:	16 16       	cp	r1, r22
    8ecc:	17 06       	cpc	r1, r23
    8ece:	18 06       	cpc	r1, r24
    8ed0:	99 1f       	adc	r25, r25
    8ed2:	f1 cf       	rjmp	.-30     	; 0x8eb6 <__fp_splitA+0xc>
    8ed4:	86 95       	lsr	r24
    8ed6:	71 05       	cpc	r23, r1
    8ed8:	61 05       	cpc	r22, r1
    8eda:	08 94       	sec
    8edc:	08 95       	ret

00008ede <__fp_zero>:
    8ede:	e8 94       	clt

00008ee0 <__fp_szero>:
    8ee0:	bb 27       	eor	r27, r27
    8ee2:	66 27       	eor	r22, r22
    8ee4:	77 27       	eor	r23, r23
    8ee6:	cb 01       	movw	r24, r22
    8ee8:	97 f9       	bld	r25, 7
    8eea:	08 95       	ret

00008eec <__gesf2>:
    8eec:	0e 94 01 47 	call	0x8e02	; 0x8e02 <__fp_cmp>
    8ef0:	08 f4       	brcc	.+2      	; 0x8ef4 <__gesf2+0x8>
    8ef2:	8f ef       	ldi	r24, 0xFF	; 255
    8ef4:	08 95       	ret

00008ef6 <__mulsf3>:
    8ef6:	0e 94 8e 47 	call	0x8f1c	; 0x8f1c <__mulsf3x>
    8efa:	0c 94 3c 47 	jmp	0x8e78	; 0x8e78 <__fp_round>
    8efe:	0e 94 2e 47 	call	0x8e5c	; 0x8e5c <__fp_pscA>
    8f02:	38 f0       	brcs	.+14     	; 0x8f12 <__mulsf3+0x1c>
    8f04:	0e 94 35 47 	call	0x8e6a	; 0x8e6a <__fp_pscB>
    8f08:	20 f0       	brcs	.+8      	; 0x8f12 <__mulsf3+0x1c>
    8f0a:	95 23       	and	r25, r21
    8f0c:	11 f0       	breq	.+4      	; 0x8f12 <__mulsf3+0x1c>
    8f0e:	0c 94 25 47 	jmp	0x8e4a	; 0x8e4a <__fp_inf>
    8f12:	0c 94 2b 47 	jmp	0x8e56	; 0x8e56 <__fp_nan>
    8f16:	11 24       	eor	r1, r1
    8f18:	0c 94 70 47 	jmp	0x8ee0	; 0x8ee0 <__fp_szero>

00008f1c <__mulsf3x>:
    8f1c:	0e 94 4d 47 	call	0x8e9a	; 0x8e9a <__fp_split3>
    8f20:	70 f3       	brcs	.-36     	; 0x8efe <__mulsf3+0x8>

00008f22 <__mulsf3_pse>:
    8f22:	95 9f       	mul	r25, r21
    8f24:	c1 f3       	breq	.-16     	; 0x8f16 <__mulsf3+0x20>
    8f26:	95 0f       	add	r25, r21
    8f28:	50 e0       	ldi	r21, 0x00	; 0
    8f2a:	55 1f       	adc	r21, r21
    8f2c:	62 9f       	mul	r22, r18
    8f2e:	f0 01       	movw	r30, r0
    8f30:	72 9f       	mul	r23, r18
    8f32:	bb 27       	eor	r27, r27
    8f34:	f0 0d       	add	r31, r0
    8f36:	b1 1d       	adc	r27, r1
    8f38:	63 9f       	mul	r22, r19
    8f3a:	aa 27       	eor	r26, r26
    8f3c:	f0 0d       	add	r31, r0
    8f3e:	b1 1d       	adc	r27, r1
    8f40:	aa 1f       	adc	r26, r26
    8f42:	64 9f       	mul	r22, r20
    8f44:	66 27       	eor	r22, r22
    8f46:	b0 0d       	add	r27, r0
    8f48:	a1 1d       	adc	r26, r1
    8f4a:	66 1f       	adc	r22, r22
    8f4c:	82 9f       	mul	r24, r18
    8f4e:	22 27       	eor	r18, r18
    8f50:	b0 0d       	add	r27, r0
    8f52:	a1 1d       	adc	r26, r1
    8f54:	62 1f       	adc	r22, r18
    8f56:	73 9f       	mul	r23, r19
    8f58:	b0 0d       	add	r27, r0
    8f5a:	a1 1d       	adc	r26, r1
    8f5c:	62 1f       	adc	r22, r18
    8f5e:	83 9f       	mul	r24, r19
    8f60:	a0 0d       	add	r26, r0
    8f62:	61 1d       	adc	r22, r1
    8f64:	22 1f       	adc	r18, r18
    8f66:	74 9f       	mul	r23, r20
    8f68:	33 27       	eor	r19, r19
    8f6a:	a0 0d       	add	r26, r0
    8f6c:	61 1d       	adc	r22, r1
    8f6e:	23 1f       	adc	r18, r19
    8f70:	84 9f       	mul	r24, r20
    8f72:	60 0d       	add	r22, r0
    8f74:	21 1d       	adc	r18, r1
    8f76:	82 2f       	mov	r24, r18
    8f78:	76 2f       	mov	r23, r22
    8f7a:	6a 2f       	mov	r22, r26
    8f7c:	11 24       	eor	r1, r1
    8f7e:	9f 57       	subi	r25, 0x7F	; 127
    8f80:	50 40       	sbci	r21, 0x00	; 0
    8f82:	9a f0       	brmi	.+38     	; 0x8faa <__mulsf3_pse+0x88>
    8f84:	f1 f0       	breq	.+60     	; 0x8fc2 <__mulsf3_pse+0xa0>
    8f86:	88 23       	and	r24, r24
    8f88:	4a f0       	brmi	.+18     	; 0x8f9c <__mulsf3_pse+0x7a>
    8f8a:	ee 0f       	add	r30, r30
    8f8c:	ff 1f       	adc	r31, r31
    8f8e:	bb 1f       	adc	r27, r27
    8f90:	66 1f       	adc	r22, r22
    8f92:	77 1f       	adc	r23, r23
    8f94:	88 1f       	adc	r24, r24
    8f96:	91 50       	subi	r25, 0x01	; 1
    8f98:	50 40       	sbci	r21, 0x00	; 0
    8f9a:	a9 f7       	brne	.-22     	; 0x8f86 <__mulsf3_pse+0x64>
    8f9c:	9e 3f       	cpi	r25, 0xFE	; 254
    8f9e:	51 05       	cpc	r21, r1
    8fa0:	80 f0       	brcs	.+32     	; 0x8fc2 <__mulsf3_pse+0xa0>
    8fa2:	0c 94 25 47 	jmp	0x8e4a	; 0x8e4a <__fp_inf>
    8fa6:	0c 94 70 47 	jmp	0x8ee0	; 0x8ee0 <__fp_szero>
    8faa:	5f 3f       	cpi	r21, 0xFF	; 255
    8fac:	e4 f3       	brlt	.-8      	; 0x8fa6 <__mulsf3_pse+0x84>
    8fae:	98 3e       	cpi	r25, 0xE8	; 232
    8fb0:	d4 f3       	brlt	.-12     	; 0x8fa6 <__mulsf3_pse+0x84>
    8fb2:	86 95       	lsr	r24
    8fb4:	77 95       	ror	r23
    8fb6:	67 95       	ror	r22
    8fb8:	b7 95       	ror	r27
    8fba:	f7 95       	ror	r31
    8fbc:	e7 95       	ror	r30
    8fbe:	9f 5f       	subi	r25, 0xFF	; 255
    8fc0:	c1 f7       	brne	.-16     	; 0x8fb2 <__mulsf3_pse+0x90>
    8fc2:	fe 2b       	or	r31, r30
    8fc4:	88 0f       	add	r24, r24
    8fc6:	91 1d       	adc	r25, r1
    8fc8:	96 95       	lsr	r25
    8fca:	87 95       	ror	r24
    8fcc:	97 f9       	bld	r25, 7
    8fce:	08 95       	ret

00008fd0 <vfprintf>:
    8fd0:	2f 92       	push	r2
    8fd2:	3f 92       	push	r3
    8fd4:	4f 92       	push	r4
    8fd6:	5f 92       	push	r5
    8fd8:	6f 92       	push	r6
    8fda:	7f 92       	push	r7
    8fdc:	8f 92       	push	r8
    8fde:	9f 92       	push	r9
    8fe0:	af 92       	push	r10
    8fe2:	bf 92       	push	r11
    8fe4:	cf 92       	push	r12
    8fe6:	df 92       	push	r13
    8fe8:	ef 92       	push	r14
    8fea:	ff 92       	push	r15
    8fec:	0f 93       	push	r16
    8fee:	1f 93       	push	r17
    8ff0:	cf 93       	push	r28
    8ff2:	df 93       	push	r29
    8ff4:	cd b7       	in	r28, 0x3d	; 61
    8ff6:	de b7       	in	r29, 0x3e	; 62
    8ff8:	60 97       	sbiw	r28, 0x10	; 16
    8ffa:	cd bf       	out	0x3d, r28	; 61
    8ffc:	de bf       	out	0x3e, r29	; 62
    8ffe:	7c 01       	movw	r14, r24
    9000:	1b 01       	movw	r2, r22
    9002:	6a 01       	movw	r12, r20
    9004:	fc 01       	movw	r30, r24
    9006:	16 82       	std	Z+6, r1	; 0x06
    9008:	17 82       	std	Z+7, r1	; 0x07
    900a:	83 81       	ldd	r24, Z+3	; 0x03
    900c:	81 ff       	sbrs	r24, 1
    900e:	44 c3       	rjmp	.+1672   	; 0x9698 <vfprintf+0x6c8>
    9010:	9e 01       	movw	r18, r28
    9012:	2f 5f       	subi	r18, 0xFF	; 255
    9014:	3f 4f       	sbci	r19, 0xFF	; 255
    9016:	39 01       	movw	r6, r18
    9018:	f7 01       	movw	r30, r14
    901a:	93 81       	ldd	r25, Z+3	; 0x03
    901c:	f1 01       	movw	r30, r2
    901e:	93 fd       	sbrc	r25, 3
    9020:	85 91       	lpm	r24, Z+
    9022:	93 ff       	sbrs	r25, 3
    9024:	81 91       	ld	r24, Z+
    9026:	1f 01       	movw	r2, r30
    9028:	88 23       	and	r24, r24
    902a:	09 f4       	brne	.+2      	; 0x902e <vfprintf+0x5e>
    902c:	31 c3       	rjmp	.+1634   	; 0x9690 <vfprintf+0x6c0>
    902e:	85 32       	cpi	r24, 0x25	; 37
    9030:	39 f4       	brne	.+14     	; 0x9040 <vfprintf+0x70>
    9032:	93 fd       	sbrc	r25, 3
    9034:	85 91       	lpm	r24, Z+
    9036:	93 ff       	sbrs	r25, 3
    9038:	81 91       	ld	r24, Z+
    903a:	1f 01       	movw	r2, r30
    903c:	85 32       	cpi	r24, 0x25	; 37
    903e:	39 f4       	brne	.+14     	; 0x904e <vfprintf+0x7e>
    9040:	b7 01       	movw	r22, r14
    9042:	90 e0       	ldi	r25, 0x00	; 0
    9044:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    9048:	56 01       	movw	r10, r12
    904a:	65 01       	movw	r12, r10
    904c:	e5 cf       	rjmp	.-54     	; 0x9018 <vfprintf+0x48>
    904e:	10 e0       	ldi	r17, 0x00	; 0
    9050:	51 2c       	mov	r5, r1
    9052:	91 2c       	mov	r9, r1
    9054:	ff e1       	ldi	r31, 0x1F	; 31
    9056:	f9 15       	cp	r31, r9
    9058:	d8 f0       	brcs	.+54     	; 0x9090 <vfprintf+0xc0>
    905a:	8b 32       	cpi	r24, 0x2B	; 43
    905c:	79 f0       	breq	.+30     	; 0x907c <vfprintf+0xac>
    905e:	38 f4       	brcc	.+14     	; 0x906e <vfprintf+0x9e>
    9060:	80 32       	cpi	r24, 0x20	; 32
    9062:	79 f0       	breq	.+30     	; 0x9082 <vfprintf+0xb2>
    9064:	83 32       	cpi	r24, 0x23	; 35
    9066:	a1 f4       	brne	.+40     	; 0x9090 <vfprintf+0xc0>
    9068:	f9 2d       	mov	r31, r9
    906a:	f0 61       	ori	r31, 0x10	; 16
    906c:	2e c0       	rjmp	.+92     	; 0x90ca <vfprintf+0xfa>
    906e:	8d 32       	cpi	r24, 0x2D	; 45
    9070:	61 f0       	breq	.+24     	; 0x908a <vfprintf+0xba>
    9072:	80 33       	cpi	r24, 0x30	; 48
    9074:	69 f4       	brne	.+26     	; 0x9090 <vfprintf+0xc0>
    9076:	29 2d       	mov	r18, r9
    9078:	21 60       	ori	r18, 0x01	; 1
    907a:	2d c0       	rjmp	.+90     	; 0x90d6 <vfprintf+0x106>
    907c:	39 2d       	mov	r19, r9
    907e:	32 60       	ori	r19, 0x02	; 2
    9080:	93 2e       	mov	r9, r19
    9082:	89 2d       	mov	r24, r9
    9084:	84 60       	ori	r24, 0x04	; 4
    9086:	98 2e       	mov	r9, r24
    9088:	2a c0       	rjmp	.+84     	; 0x90de <vfprintf+0x10e>
    908a:	e9 2d       	mov	r30, r9
    908c:	e8 60       	ori	r30, 0x08	; 8
    908e:	15 c0       	rjmp	.+42     	; 0x90ba <vfprintf+0xea>
    9090:	97 fc       	sbrc	r9, 7
    9092:	2d c0       	rjmp	.+90     	; 0x90ee <vfprintf+0x11e>
    9094:	20 ed       	ldi	r18, 0xD0	; 208
    9096:	28 0f       	add	r18, r24
    9098:	2a 30       	cpi	r18, 0x0A	; 10
    909a:	88 f4       	brcc	.+34     	; 0x90be <vfprintf+0xee>
    909c:	96 fe       	sbrs	r9, 6
    909e:	06 c0       	rjmp	.+12     	; 0x90ac <vfprintf+0xdc>
    90a0:	3a e0       	ldi	r19, 0x0A	; 10
    90a2:	13 9f       	mul	r17, r19
    90a4:	20 0d       	add	r18, r0
    90a6:	11 24       	eor	r1, r1
    90a8:	12 2f       	mov	r17, r18
    90aa:	19 c0       	rjmp	.+50     	; 0x90de <vfprintf+0x10e>
    90ac:	8a e0       	ldi	r24, 0x0A	; 10
    90ae:	58 9e       	mul	r5, r24
    90b0:	20 0d       	add	r18, r0
    90b2:	11 24       	eor	r1, r1
    90b4:	52 2e       	mov	r5, r18
    90b6:	e9 2d       	mov	r30, r9
    90b8:	e0 62       	ori	r30, 0x20	; 32
    90ba:	9e 2e       	mov	r9, r30
    90bc:	10 c0       	rjmp	.+32     	; 0x90de <vfprintf+0x10e>
    90be:	8e 32       	cpi	r24, 0x2E	; 46
    90c0:	31 f4       	brne	.+12     	; 0x90ce <vfprintf+0xfe>
    90c2:	96 fc       	sbrc	r9, 6
    90c4:	e5 c2       	rjmp	.+1482   	; 0x9690 <vfprintf+0x6c0>
    90c6:	f9 2d       	mov	r31, r9
    90c8:	f0 64       	ori	r31, 0x40	; 64
    90ca:	9f 2e       	mov	r9, r31
    90cc:	08 c0       	rjmp	.+16     	; 0x90de <vfprintf+0x10e>
    90ce:	8c 36       	cpi	r24, 0x6C	; 108
    90d0:	21 f4       	brne	.+8      	; 0x90da <vfprintf+0x10a>
    90d2:	29 2d       	mov	r18, r9
    90d4:	20 68       	ori	r18, 0x80	; 128
    90d6:	92 2e       	mov	r9, r18
    90d8:	02 c0       	rjmp	.+4      	; 0x90de <vfprintf+0x10e>
    90da:	88 36       	cpi	r24, 0x68	; 104
    90dc:	41 f4       	brne	.+16     	; 0x90ee <vfprintf+0x11e>
    90de:	f1 01       	movw	r30, r2
    90e0:	93 fd       	sbrc	r25, 3
    90e2:	85 91       	lpm	r24, Z+
    90e4:	93 ff       	sbrs	r25, 3
    90e6:	81 91       	ld	r24, Z+
    90e8:	1f 01       	movw	r2, r30
    90ea:	81 11       	cpse	r24, r1
    90ec:	b3 cf       	rjmp	.-154    	; 0x9054 <vfprintf+0x84>
    90ee:	9b eb       	ldi	r25, 0xBB	; 187
    90f0:	98 0f       	add	r25, r24
    90f2:	93 30       	cpi	r25, 0x03	; 3
    90f4:	20 f4       	brcc	.+8      	; 0x90fe <vfprintf+0x12e>
    90f6:	99 2d       	mov	r25, r9
    90f8:	90 61       	ori	r25, 0x10	; 16
    90fa:	80 5e       	subi	r24, 0xE0	; 224
    90fc:	07 c0       	rjmp	.+14     	; 0x910c <vfprintf+0x13c>
    90fe:	9b e9       	ldi	r25, 0x9B	; 155
    9100:	98 0f       	add	r25, r24
    9102:	93 30       	cpi	r25, 0x03	; 3
    9104:	08 f0       	brcs	.+2      	; 0x9108 <vfprintf+0x138>
    9106:	66 c1       	rjmp	.+716    	; 0x93d4 <vfprintf+0x404>
    9108:	99 2d       	mov	r25, r9
    910a:	9f 7e       	andi	r25, 0xEF	; 239
    910c:	96 ff       	sbrs	r25, 6
    910e:	16 e0       	ldi	r17, 0x06	; 6
    9110:	9f 73       	andi	r25, 0x3F	; 63
    9112:	99 2e       	mov	r9, r25
    9114:	85 36       	cpi	r24, 0x65	; 101
    9116:	19 f4       	brne	.+6      	; 0x911e <vfprintf+0x14e>
    9118:	90 64       	ori	r25, 0x40	; 64
    911a:	99 2e       	mov	r9, r25
    911c:	08 c0       	rjmp	.+16     	; 0x912e <vfprintf+0x15e>
    911e:	86 36       	cpi	r24, 0x66	; 102
    9120:	21 f4       	brne	.+8      	; 0x912a <vfprintf+0x15a>
    9122:	39 2f       	mov	r19, r25
    9124:	30 68       	ori	r19, 0x80	; 128
    9126:	93 2e       	mov	r9, r19
    9128:	02 c0       	rjmp	.+4      	; 0x912e <vfprintf+0x15e>
    912a:	11 11       	cpse	r17, r1
    912c:	11 50       	subi	r17, 0x01	; 1
    912e:	97 fe       	sbrs	r9, 7
    9130:	07 c0       	rjmp	.+14     	; 0x9140 <vfprintf+0x170>
    9132:	1c 33       	cpi	r17, 0x3C	; 60
    9134:	50 f4       	brcc	.+20     	; 0x914a <vfprintf+0x17a>
    9136:	44 24       	eor	r4, r4
    9138:	43 94       	inc	r4
    913a:	41 0e       	add	r4, r17
    913c:	27 e0       	ldi	r18, 0x07	; 7
    913e:	0b c0       	rjmp	.+22     	; 0x9156 <vfprintf+0x186>
    9140:	18 30       	cpi	r17, 0x08	; 8
    9142:	38 f0       	brcs	.+14     	; 0x9152 <vfprintf+0x182>
    9144:	27 e0       	ldi	r18, 0x07	; 7
    9146:	17 e0       	ldi	r17, 0x07	; 7
    9148:	05 c0       	rjmp	.+10     	; 0x9154 <vfprintf+0x184>
    914a:	27 e0       	ldi	r18, 0x07	; 7
    914c:	9c e3       	ldi	r25, 0x3C	; 60
    914e:	49 2e       	mov	r4, r25
    9150:	02 c0       	rjmp	.+4      	; 0x9156 <vfprintf+0x186>
    9152:	21 2f       	mov	r18, r17
    9154:	41 2c       	mov	r4, r1
    9156:	56 01       	movw	r10, r12
    9158:	84 e0       	ldi	r24, 0x04	; 4
    915a:	a8 0e       	add	r10, r24
    915c:	b1 1c       	adc	r11, r1
    915e:	f6 01       	movw	r30, r12
    9160:	60 81       	ld	r22, Z
    9162:	71 81       	ldd	r23, Z+1	; 0x01
    9164:	82 81       	ldd	r24, Z+2	; 0x02
    9166:	93 81       	ldd	r25, Z+3	; 0x03
    9168:	04 2d       	mov	r16, r4
    916a:	a3 01       	movw	r20, r6
    916c:	0e 94 27 4f 	call	0x9e4e	; 0x9e4e <__ftoa_engine>
    9170:	6c 01       	movw	r12, r24
    9172:	f9 81       	ldd	r31, Y+1	; 0x01
    9174:	fc 87       	std	Y+12, r31	; 0x0c
    9176:	f0 ff       	sbrs	r31, 0
    9178:	02 c0       	rjmp	.+4      	; 0x917e <vfprintf+0x1ae>
    917a:	f3 ff       	sbrs	r31, 3
    917c:	06 c0       	rjmp	.+12     	; 0x918a <vfprintf+0x1ba>
    917e:	91 fc       	sbrc	r9, 1
    9180:	06 c0       	rjmp	.+12     	; 0x918e <vfprintf+0x1be>
    9182:	92 fe       	sbrs	r9, 2
    9184:	06 c0       	rjmp	.+12     	; 0x9192 <vfprintf+0x1c2>
    9186:	00 e2       	ldi	r16, 0x20	; 32
    9188:	05 c0       	rjmp	.+10     	; 0x9194 <vfprintf+0x1c4>
    918a:	0d e2       	ldi	r16, 0x2D	; 45
    918c:	03 c0       	rjmp	.+6      	; 0x9194 <vfprintf+0x1c4>
    918e:	0b e2       	ldi	r16, 0x2B	; 43
    9190:	01 c0       	rjmp	.+2      	; 0x9194 <vfprintf+0x1c4>
    9192:	00 e0       	ldi	r16, 0x00	; 0
    9194:	8c 85       	ldd	r24, Y+12	; 0x0c
    9196:	8c 70       	andi	r24, 0x0C	; 12
    9198:	19 f0       	breq	.+6      	; 0x91a0 <vfprintf+0x1d0>
    919a:	01 11       	cpse	r16, r1
    919c:	5a c2       	rjmp	.+1204   	; 0x9652 <vfprintf+0x682>
    919e:	9b c2       	rjmp	.+1334   	; 0x96d6 <vfprintf+0x706>
    91a0:	97 fe       	sbrs	r9, 7
    91a2:	10 c0       	rjmp	.+32     	; 0x91c4 <vfprintf+0x1f4>
    91a4:	4c 0c       	add	r4, r12
    91a6:	fc 85       	ldd	r31, Y+12	; 0x0c
    91a8:	f4 ff       	sbrs	r31, 4
    91aa:	04 c0       	rjmp	.+8      	; 0x91b4 <vfprintf+0x1e4>
    91ac:	8a 81       	ldd	r24, Y+2	; 0x02
    91ae:	81 33       	cpi	r24, 0x31	; 49
    91b0:	09 f4       	brne	.+2      	; 0x91b4 <vfprintf+0x1e4>
    91b2:	4a 94       	dec	r4
    91b4:	14 14       	cp	r1, r4
    91b6:	74 f5       	brge	.+92     	; 0x9214 <vfprintf+0x244>
    91b8:	28 e0       	ldi	r18, 0x08	; 8
    91ba:	24 15       	cp	r18, r4
    91bc:	78 f5       	brcc	.+94     	; 0x921c <vfprintf+0x24c>
    91be:	88 e0       	ldi	r24, 0x08	; 8
    91c0:	48 2e       	mov	r4, r24
    91c2:	2c c0       	rjmp	.+88     	; 0x921c <vfprintf+0x24c>
    91c4:	96 fc       	sbrc	r9, 6
    91c6:	2a c0       	rjmp	.+84     	; 0x921c <vfprintf+0x24c>
    91c8:	81 2f       	mov	r24, r17
    91ca:	90 e0       	ldi	r25, 0x00	; 0
    91cc:	8c 15       	cp	r24, r12
    91ce:	9d 05       	cpc	r25, r13
    91d0:	9c f0       	brlt	.+38     	; 0x91f8 <vfprintf+0x228>
    91d2:	3c ef       	ldi	r19, 0xFC	; 252
    91d4:	c3 16       	cp	r12, r19
    91d6:	3f ef       	ldi	r19, 0xFF	; 255
    91d8:	d3 06       	cpc	r13, r19
    91da:	74 f0       	brlt	.+28     	; 0x91f8 <vfprintf+0x228>
    91dc:	89 2d       	mov	r24, r9
    91de:	80 68       	ori	r24, 0x80	; 128
    91e0:	98 2e       	mov	r9, r24
    91e2:	0a c0       	rjmp	.+20     	; 0x91f8 <vfprintf+0x228>
    91e4:	e2 e0       	ldi	r30, 0x02	; 2
    91e6:	f0 e0       	ldi	r31, 0x00	; 0
    91e8:	ec 0f       	add	r30, r28
    91ea:	fd 1f       	adc	r31, r29
    91ec:	e1 0f       	add	r30, r17
    91ee:	f1 1d       	adc	r31, r1
    91f0:	80 81       	ld	r24, Z
    91f2:	80 33       	cpi	r24, 0x30	; 48
    91f4:	19 f4       	brne	.+6      	; 0x91fc <vfprintf+0x22c>
    91f6:	11 50       	subi	r17, 0x01	; 1
    91f8:	11 11       	cpse	r17, r1
    91fa:	f4 cf       	rjmp	.-24     	; 0x91e4 <vfprintf+0x214>
    91fc:	97 fe       	sbrs	r9, 7
    91fe:	0e c0       	rjmp	.+28     	; 0x921c <vfprintf+0x24c>
    9200:	44 24       	eor	r4, r4
    9202:	43 94       	inc	r4
    9204:	41 0e       	add	r4, r17
    9206:	81 2f       	mov	r24, r17
    9208:	90 e0       	ldi	r25, 0x00	; 0
    920a:	c8 16       	cp	r12, r24
    920c:	d9 06       	cpc	r13, r25
    920e:	2c f4       	brge	.+10     	; 0x921a <vfprintf+0x24a>
    9210:	1c 19       	sub	r17, r12
    9212:	04 c0       	rjmp	.+8      	; 0x921c <vfprintf+0x24c>
    9214:	44 24       	eor	r4, r4
    9216:	43 94       	inc	r4
    9218:	01 c0       	rjmp	.+2      	; 0x921c <vfprintf+0x24c>
    921a:	10 e0       	ldi	r17, 0x00	; 0
    921c:	97 fe       	sbrs	r9, 7
    921e:	06 c0       	rjmp	.+12     	; 0x922c <vfprintf+0x25c>
    9220:	1c 14       	cp	r1, r12
    9222:	1d 04       	cpc	r1, r13
    9224:	34 f4       	brge	.+12     	; 0x9232 <vfprintf+0x262>
    9226:	c6 01       	movw	r24, r12
    9228:	01 96       	adiw	r24, 0x01	; 1
    922a:	05 c0       	rjmp	.+10     	; 0x9236 <vfprintf+0x266>
    922c:	85 e0       	ldi	r24, 0x05	; 5
    922e:	90 e0       	ldi	r25, 0x00	; 0
    9230:	02 c0       	rjmp	.+4      	; 0x9236 <vfprintf+0x266>
    9232:	81 e0       	ldi	r24, 0x01	; 1
    9234:	90 e0       	ldi	r25, 0x00	; 0
    9236:	01 11       	cpse	r16, r1
    9238:	01 96       	adiw	r24, 0x01	; 1
    923a:	11 23       	and	r17, r17
    923c:	31 f0       	breq	.+12     	; 0x924a <vfprintf+0x27a>
    923e:	21 2f       	mov	r18, r17
    9240:	30 e0       	ldi	r19, 0x00	; 0
    9242:	2f 5f       	subi	r18, 0xFF	; 255
    9244:	3f 4f       	sbci	r19, 0xFF	; 255
    9246:	82 0f       	add	r24, r18
    9248:	93 1f       	adc	r25, r19
    924a:	25 2d       	mov	r18, r5
    924c:	30 e0       	ldi	r19, 0x00	; 0
    924e:	82 17       	cp	r24, r18
    9250:	93 07       	cpc	r25, r19
    9252:	14 f4       	brge	.+4      	; 0x9258 <vfprintf+0x288>
    9254:	58 1a       	sub	r5, r24
    9256:	01 c0       	rjmp	.+2      	; 0x925a <vfprintf+0x28a>
    9258:	51 2c       	mov	r5, r1
    925a:	89 2d       	mov	r24, r9
    925c:	89 70       	andi	r24, 0x09	; 9
    925e:	49 f4       	brne	.+18     	; 0x9272 <vfprintf+0x2a2>
    9260:	55 20       	and	r5, r5
    9262:	39 f0       	breq	.+14     	; 0x9272 <vfprintf+0x2a2>
    9264:	b7 01       	movw	r22, r14
    9266:	80 e2       	ldi	r24, 0x20	; 32
    9268:	90 e0       	ldi	r25, 0x00	; 0
    926a:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    926e:	5a 94       	dec	r5
    9270:	f7 cf       	rjmp	.-18     	; 0x9260 <vfprintf+0x290>
    9272:	00 23       	and	r16, r16
    9274:	29 f0       	breq	.+10     	; 0x9280 <vfprintf+0x2b0>
    9276:	b7 01       	movw	r22, r14
    9278:	80 2f       	mov	r24, r16
    927a:	90 e0       	ldi	r25, 0x00	; 0
    927c:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    9280:	93 fc       	sbrc	r9, 3
    9282:	09 c0       	rjmp	.+18     	; 0x9296 <vfprintf+0x2c6>
    9284:	55 20       	and	r5, r5
    9286:	39 f0       	breq	.+14     	; 0x9296 <vfprintf+0x2c6>
    9288:	b7 01       	movw	r22, r14
    928a:	80 e3       	ldi	r24, 0x30	; 48
    928c:	90 e0       	ldi	r25, 0x00	; 0
    928e:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    9292:	5a 94       	dec	r5
    9294:	f7 cf       	rjmp	.-18     	; 0x9284 <vfprintf+0x2b4>
    9296:	97 fe       	sbrs	r9, 7
    9298:	4c c0       	rjmp	.+152    	; 0x9332 <vfprintf+0x362>
    929a:	46 01       	movw	r8, r12
    929c:	d7 fe       	sbrs	r13, 7
    929e:	02 c0       	rjmp	.+4      	; 0x92a4 <vfprintf+0x2d4>
    92a0:	81 2c       	mov	r8, r1
    92a2:	91 2c       	mov	r9, r1
    92a4:	c6 01       	movw	r24, r12
    92a6:	88 19       	sub	r24, r8
    92a8:	99 09       	sbc	r25, r9
    92aa:	f3 01       	movw	r30, r6
    92ac:	e8 0f       	add	r30, r24
    92ae:	f9 1f       	adc	r31, r25
    92b0:	ed 87       	std	Y+13, r30	; 0x0d
    92b2:	fe 87       	std	Y+14, r31	; 0x0e
    92b4:	96 01       	movw	r18, r12
    92b6:	24 19       	sub	r18, r4
    92b8:	31 09       	sbc	r19, r1
    92ba:	2f 87       	std	Y+15, r18	; 0x0f
    92bc:	38 8b       	std	Y+16, r19	; 0x10
    92be:	01 2f       	mov	r16, r17
    92c0:	10 e0       	ldi	r17, 0x00	; 0
    92c2:	11 95       	neg	r17
    92c4:	01 95       	neg	r16
    92c6:	11 09       	sbc	r17, r1
    92c8:	3f ef       	ldi	r19, 0xFF	; 255
    92ca:	83 16       	cp	r8, r19
    92cc:	93 06       	cpc	r9, r19
    92ce:	29 f4       	brne	.+10     	; 0x92da <vfprintf+0x30a>
    92d0:	b7 01       	movw	r22, r14
    92d2:	8e e2       	ldi	r24, 0x2E	; 46
    92d4:	90 e0       	ldi	r25, 0x00	; 0
    92d6:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    92da:	c8 14       	cp	r12, r8
    92dc:	d9 04       	cpc	r13, r9
    92de:	4c f0       	brlt	.+18     	; 0x92f2 <vfprintf+0x322>
    92e0:	8f 85       	ldd	r24, Y+15	; 0x0f
    92e2:	98 89       	ldd	r25, Y+16	; 0x10
    92e4:	88 15       	cp	r24, r8
    92e6:	99 05       	cpc	r25, r9
    92e8:	24 f4       	brge	.+8      	; 0x92f2 <vfprintf+0x322>
    92ea:	ed 85       	ldd	r30, Y+13	; 0x0d
    92ec:	fe 85       	ldd	r31, Y+14	; 0x0e
    92ee:	81 81       	ldd	r24, Z+1	; 0x01
    92f0:	01 c0       	rjmp	.+2      	; 0x92f4 <vfprintf+0x324>
    92f2:	80 e3       	ldi	r24, 0x30	; 48
    92f4:	f1 e0       	ldi	r31, 0x01	; 1
    92f6:	8f 1a       	sub	r8, r31
    92f8:	91 08       	sbc	r9, r1
    92fa:	2d 85       	ldd	r18, Y+13	; 0x0d
    92fc:	3e 85       	ldd	r19, Y+14	; 0x0e
    92fe:	2f 5f       	subi	r18, 0xFF	; 255
    9300:	3f 4f       	sbci	r19, 0xFF	; 255
    9302:	2d 87       	std	Y+13, r18	; 0x0d
    9304:	3e 87       	std	Y+14, r19	; 0x0e
    9306:	80 16       	cp	r8, r16
    9308:	91 06       	cpc	r9, r17
    930a:	2c f0       	brlt	.+10     	; 0x9316 <vfprintf+0x346>
    930c:	b7 01       	movw	r22, r14
    930e:	90 e0       	ldi	r25, 0x00	; 0
    9310:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    9314:	d9 cf       	rjmp	.-78     	; 0x92c8 <vfprintf+0x2f8>
    9316:	c8 14       	cp	r12, r8
    9318:	d9 04       	cpc	r13, r9
    931a:	41 f4       	brne	.+16     	; 0x932c <vfprintf+0x35c>
    931c:	9a 81       	ldd	r25, Y+2	; 0x02
    931e:	96 33       	cpi	r25, 0x36	; 54
    9320:	20 f4       	brcc	.+8      	; 0x932a <vfprintf+0x35a>
    9322:	95 33       	cpi	r25, 0x35	; 53
    9324:	19 f4       	brne	.+6      	; 0x932c <vfprintf+0x35c>
    9326:	3c 85       	ldd	r19, Y+12	; 0x0c
    9328:	34 ff       	sbrs	r19, 4
    932a:	81 e3       	ldi	r24, 0x31	; 49
    932c:	b7 01       	movw	r22, r14
    932e:	90 e0       	ldi	r25, 0x00	; 0
    9330:	4e c0       	rjmp	.+156    	; 0x93ce <vfprintf+0x3fe>
    9332:	8a 81       	ldd	r24, Y+2	; 0x02
    9334:	81 33       	cpi	r24, 0x31	; 49
    9336:	19 f0       	breq	.+6      	; 0x933e <vfprintf+0x36e>
    9338:	9c 85       	ldd	r25, Y+12	; 0x0c
    933a:	9f 7e       	andi	r25, 0xEF	; 239
    933c:	9c 87       	std	Y+12, r25	; 0x0c
    933e:	b7 01       	movw	r22, r14
    9340:	90 e0       	ldi	r25, 0x00	; 0
    9342:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    9346:	11 11       	cpse	r17, r1
    9348:	05 c0       	rjmp	.+10     	; 0x9354 <vfprintf+0x384>
    934a:	94 fc       	sbrc	r9, 4
    934c:	18 c0       	rjmp	.+48     	; 0x937e <vfprintf+0x3ae>
    934e:	85 e6       	ldi	r24, 0x65	; 101
    9350:	90 e0       	ldi	r25, 0x00	; 0
    9352:	17 c0       	rjmp	.+46     	; 0x9382 <vfprintf+0x3b2>
    9354:	b7 01       	movw	r22, r14
    9356:	8e e2       	ldi	r24, 0x2E	; 46
    9358:	90 e0       	ldi	r25, 0x00	; 0
    935a:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    935e:	1e 5f       	subi	r17, 0xFE	; 254
    9360:	82 e0       	ldi	r24, 0x02	; 2
    9362:	01 e0       	ldi	r16, 0x01	; 1
    9364:	08 0f       	add	r16, r24
    9366:	f3 01       	movw	r30, r6
    9368:	e8 0f       	add	r30, r24
    936a:	f1 1d       	adc	r31, r1
    936c:	80 81       	ld	r24, Z
    936e:	b7 01       	movw	r22, r14
    9370:	90 e0       	ldi	r25, 0x00	; 0
    9372:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    9376:	80 2f       	mov	r24, r16
    9378:	01 13       	cpse	r16, r17
    937a:	f3 cf       	rjmp	.-26     	; 0x9362 <vfprintf+0x392>
    937c:	e6 cf       	rjmp	.-52     	; 0x934a <vfprintf+0x37a>
    937e:	85 e4       	ldi	r24, 0x45	; 69
    9380:	90 e0       	ldi	r25, 0x00	; 0
    9382:	b7 01       	movw	r22, r14
    9384:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    9388:	d7 fc       	sbrc	r13, 7
    938a:	06 c0       	rjmp	.+12     	; 0x9398 <vfprintf+0x3c8>
    938c:	c1 14       	cp	r12, r1
    938e:	d1 04       	cpc	r13, r1
    9390:	41 f4       	brne	.+16     	; 0x93a2 <vfprintf+0x3d2>
    9392:	ec 85       	ldd	r30, Y+12	; 0x0c
    9394:	e4 ff       	sbrs	r30, 4
    9396:	05 c0       	rjmp	.+10     	; 0x93a2 <vfprintf+0x3d2>
    9398:	d1 94       	neg	r13
    939a:	c1 94       	neg	r12
    939c:	d1 08       	sbc	r13, r1
    939e:	8d e2       	ldi	r24, 0x2D	; 45
    93a0:	01 c0       	rjmp	.+2      	; 0x93a4 <vfprintf+0x3d4>
    93a2:	8b e2       	ldi	r24, 0x2B	; 43
    93a4:	b7 01       	movw	r22, r14
    93a6:	90 e0       	ldi	r25, 0x00	; 0
    93a8:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    93ac:	80 e3       	ldi	r24, 0x30	; 48
    93ae:	2a e0       	ldi	r18, 0x0A	; 10
    93b0:	c2 16       	cp	r12, r18
    93b2:	d1 04       	cpc	r13, r1
    93b4:	2c f0       	brlt	.+10     	; 0x93c0 <vfprintf+0x3f0>
    93b6:	8f 5f       	subi	r24, 0xFF	; 255
    93b8:	fa e0       	ldi	r31, 0x0A	; 10
    93ba:	cf 1a       	sub	r12, r31
    93bc:	d1 08       	sbc	r13, r1
    93be:	f7 cf       	rjmp	.-18     	; 0x93ae <vfprintf+0x3de>
    93c0:	b7 01       	movw	r22, r14
    93c2:	90 e0       	ldi	r25, 0x00	; 0
    93c4:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    93c8:	b7 01       	movw	r22, r14
    93ca:	c6 01       	movw	r24, r12
    93cc:	c0 96       	adiw	r24, 0x30	; 48
    93ce:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    93d2:	54 c1       	rjmp	.+680    	; 0x967c <vfprintf+0x6ac>
    93d4:	83 36       	cpi	r24, 0x63	; 99
    93d6:	31 f0       	breq	.+12     	; 0x93e4 <vfprintf+0x414>
    93d8:	83 37       	cpi	r24, 0x73	; 115
    93da:	79 f0       	breq	.+30     	; 0x93fa <vfprintf+0x42a>
    93dc:	83 35       	cpi	r24, 0x53	; 83
    93de:	09 f0       	breq	.+2      	; 0x93e2 <vfprintf+0x412>
    93e0:	56 c0       	rjmp	.+172    	; 0x948e <vfprintf+0x4be>
    93e2:	20 c0       	rjmp	.+64     	; 0x9424 <vfprintf+0x454>
    93e4:	56 01       	movw	r10, r12
    93e6:	32 e0       	ldi	r19, 0x02	; 2
    93e8:	a3 0e       	add	r10, r19
    93ea:	b1 1c       	adc	r11, r1
    93ec:	f6 01       	movw	r30, r12
    93ee:	80 81       	ld	r24, Z
    93f0:	89 83       	std	Y+1, r24	; 0x01
    93f2:	01 e0       	ldi	r16, 0x01	; 1
    93f4:	10 e0       	ldi	r17, 0x00	; 0
    93f6:	63 01       	movw	r12, r6
    93f8:	12 c0       	rjmp	.+36     	; 0x941e <vfprintf+0x44e>
    93fa:	56 01       	movw	r10, r12
    93fc:	f2 e0       	ldi	r31, 0x02	; 2
    93fe:	af 0e       	add	r10, r31
    9400:	b1 1c       	adc	r11, r1
    9402:	f6 01       	movw	r30, r12
    9404:	c0 80       	ld	r12, Z
    9406:	d1 80       	ldd	r13, Z+1	; 0x01
    9408:	96 fe       	sbrs	r9, 6
    940a:	03 c0       	rjmp	.+6      	; 0x9412 <vfprintf+0x442>
    940c:	61 2f       	mov	r22, r17
    940e:	70 e0       	ldi	r23, 0x00	; 0
    9410:	02 c0       	rjmp	.+4      	; 0x9416 <vfprintf+0x446>
    9412:	6f ef       	ldi	r22, 0xFF	; 255
    9414:	7f ef       	ldi	r23, 0xFF	; 255
    9416:	c6 01       	movw	r24, r12
    9418:	0e 94 25 50 	call	0xa04a	; 0xa04a <strnlen>
    941c:	8c 01       	movw	r16, r24
    941e:	f9 2d       	mov	r31, r9
    9420:	ff 77       	andi	r31, 0x7F	; 127
    9422:	14 c0       	rjmp	.+40     	; 0x944c <vfprintf+0x47c>
    9424:	56 01       	movw	r10, r12
    9426:	22 e0       	ldi	r18, 0x02	; 2
    9428:	a2 0e       	add	r10, r18
    942a:	b1 1c       	adc	r11, r1
    942c:	f6 01       	movw	r30, r12
    942e:	c0 80       	ld	r12, Z
    9430:	d1 80       	ldd	r13, Z+1	; 0x01
    9432:	96 fe       	sbrs	r9, 6
    9434:	03 c0       	rjmp	.+6      	; 0x943c <vfprintf+0x46c>
    9436:	61 2f       	mov	r22, r17
    9438:	70 e0       	ldi	r23, 0x00	; 0
    943a:	02 c0       	rjmp	.+4      	; 0x9440 <vfprintf+0x470>
    943c:	6f ef       	ldi	r22, 0xFF	; 255
    943e:	7f ef       	ldi	r23, 0xFF	; 255
    9440:	c6 01       	movw	r24, r12
    9442:	0e 94 ff 4f 	call	0x9ffe	; 0x9ffe <strnlen_P>
    9446:	8c 01       	movw	r16, r24
    9448:	f9 2d       	mov	r31, r9
    944a:	f0 68       	ori	r31, 0x80	; 128
    944c:	9f 2e       	mov	r9, r31
    944e:	f3 fd       	sbrc	r31, 3
    9450:	1a c0       	rjmp	.+52     	; 0x9486 <vfprintf+0x4b6>
    9452:	85 2d       	mov	r24, r5
    9454:	90 e0       	ldi	r25, 0x00	; 0
    9456:	08 17       	cp	r16, r24
    9458:	19 07       	cpc	r17, r25
    945a:	a8 f4       	brcc	.+42     	; 0x9486 <vfprintf+0x4b6>
    945c:	b7 01       	movw	r22, r14
    945e:	80 e2       	ldi	r24, 0x20	; 32
    9460:	90 e0       	ldi	r25, 0x00	; 0
    9462:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    9466:	5a 94       	dec	r5
    9468:	f4 cf       	rjmp	.-24     	; 0x9452 <vfprintf+0x482>
    946a:	f6 01       	movw	r30, r12
    946c:	97 fc       	sbrc	r9, 7
    946e:	85 91       	lpm	r24, Z+
    9470:	97 fe       	sbrs	r9, 7
    9472:	81 91       	ld	r24, Z+
    9474:	6f 01       	movw	r12, r30
    9476:	b7 01       	movw	r22, r14
    9478:	90 e0       	ldi	r25, 0x00	; 0
    947a:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    947e:	51 10       	cpse	r5, r1
    9480:	5a 94       	dec	r5
    9482:	01 50       	subi	r16, 0x01	; 1
    9484:	11 09       	sbc	r17, r1
    9486:	01 15       	cp	r16, r1
    9488:	11 05       	cpc	r17, r1
    948a:	79 f7       	brne	.-34     	; 0x946a <vfprintf+0x49a>
    948c:	f7 c0       	rjmp	.+494    	; 0x967c <vfprintf+0x6ac>
    948e:	84 36       	cpi	r24, 0x64	; 100
    9490:	11 f0       	breq	.+4      	; 0x9496 <vfprintf+0x4c6>
    9492:	89 36       	cpi	r24, 0x69	; 105
    9494:	61 f5       	brne	.+88     	; 0x94ee <vfprintf+0x51e>
    9496:	56 01       	movw	r10, r12
    9498:	97 fe       	sbrs	r9, 7
    949a:	09 c0       	rjmp	.+18     	; 0x94ae <vfprintf+0x4de>
    949c:	24 e0       	ldi	r18, 0x04	; 4
    949e:	a2 0e       	add	r10, r18
    94a0:	b1 1c       	adc	r11, r1
    94a2:	f6 01       	movw	r30, r12
    94a4:	60 81       	ld	r22, Z
    94a6:	71 81       	ldd	r23, Z+1	; 0x01
    94a8:	82 81       	ldd	r24, Z+2	; 0x02
    94aa:	93 81       	ldd	r25, Z+3	; 0x03
    94ac:	0a c0       	rjmp	.+20     	; 0x94c2 <vfprintf+0x4f2>
    94ae:	f2 e0       	ldi	r31, 0x02	; 2
    94b0:	af 0e       	add	r10, r31
    94b2:	b1 1c       	adc	r11, r1
    94b4:	f6 01       	movw	r30, r12
    94b6:	60 81       	ld	r22, Z
    94b8:	71 81       	ldd	r23, Z+1	; 0x01
    94ba:	07 2e       	mov	r0, r23
    94bc:	00 0c       	add	r0, r0
    94be:	88 0b       	sbc	r24, r24
    94c0:	99 0b       	sbc	r25, r25
    94c2:	f9 2d       	mov	r31, r9
    94c4:	ff 76       	andi	r31, 0x6F	; 111
    94c6:	9f 2e       	mov	r9, r31
    94c8:	97 ff       	sbrs	r25, 7
    94ca:	09 c0       	rjmp	.+18     	; 0x94de <vfprintf+0x50e>
    94cc:	90 95       	com	r25
    94ce:	80 95       	com	r24
    94d0:	70 95       	com	r23
    94d2:	61 95       	neg	r22
    94d4:	7f 4f       	sbci	r23, 0xFF	; 255
    94d6:	8f 4f       	sbci	r24, 0xFF	; 255
    94d8:	9f 4f       	sbci	r25, 0xFF	; 255
    94da:	f0 68       	ori	r31, 0x80	; 128
    94dc:	9f 2e       	mov	r9, r31
    94de:	2a e0       	ldi	r18, 0x0A	; 10
    94e0:	30 e0       	ldi	r19, 0x00	; 0
    94e2:	a3 01       	movw	r20, r6
    94e4:	0e 94 74 51 	call	0xa2e8	; 0xa2e8 <__ultoa_invert>
    94e8:	c8 2e       	mov	r12, r24
    94ea:	c6 18       	sub	r12, r6
    94ec:	3f c0       	rjmp	.+126    	; 0x956c <vfprintf+0x59c>
    94ee:	09 2d       	mov	r16, r9
    94f0:	85 37       	cpi	r24, 0x75	; 117
    94f2:	21 f4       	brne	.+8      	; 0x94fc <vfprintf+0x52c>
    94f4:	0f 7e       	andi	r16, 0xEF	; 239
    94f6:	2a e0       	ldi	r18, 0x0A	; 10
    94f8:	30 e0       	ldi	r19, 0x00	; 0
    94fa:	1d c0       	rjmp	.+58     	; 0x9536 <vfprintf+0x566>
    94fc:	09 7f       	andi	r16, 0xF9	; 249
    94fe:	8f 36       	cpi	r24, 0x6F	; 111
    9500:	91 f0       	breq	.+36     	; 0x9526 <vfprintf+0x556>
    9502:	18 f4       	brcc	.+6      	; 0x950a <vfprintf+0x53a>
    9504:	88 35       	cpi	r24, 0x58	; 88
    9506:	59 f0       	breq	.+22     	; 0x951e <vfprintf+0x54e>
    9508:	c3 c0       	rjmp	.+390    	; 0x9690 <vfprintf+0x6c0>
    950a:	80 37       	cpi	r24, 0x70	; 112
    950c:	19 f0       	breq	.+6      	; 0x9514 <vfprintf+0x544>
    950e:	88 37       	cpi	r24, 0x78	; 120
    9510:	11 f0       	breq	.+4      	; 0x9516 <vfprintf+0x546>
    9512:	be c0       	rjmp	.+380    	; 0x9690 <vfprintf+0x6c0>
    9514:	00 61       	ori	r16, 0x10	; 16
    9516:	04 ff       	sbrs	r16, 4
    9518:	09 c0       	rjmp	.+18     	; 0x952c <vfprintf+0x55c>
    951a:	04 60       	ori	r16, 0x04	; 4
    951c:	07 c0       	rjmp	.+14     	; 0x952c <vfprintf+0x55c>
    951e:	94 fe       	sbrs	r9, 4
    9520:	08 c0       	rjmp	.+16     	; 0x9532 <vfprintf+0x562>
    9522:	06 60       	ori	r16, 0x06	; 6
    9524:	06 c0       	rjmp	.+12     	; 0x9532 <vfprintf+0x562>
    9526:	28 e0       	ldi	r18, 0x08	; 8
    9528:	30 e0       	ldi	r19, 0x00	; 0
    952a:	05 c0       	rjmp	.+10     	; 0x9536 <vfprintf+0x566>
    952c:	20 e1       	ldi	r18, 0x10	; 16
    952e:	30 e0       	ldi	r19, 0x00	; 0
    9530:	02 c0       	rjmp	.+4      	; 0x9536 <vfprintf+0x566>
    9532:	20 e1       	ldi	r18, 0x10	; 16
    9534:	32 e0       	ldi	r19, 0x02	; 2
    9536:	56 01       	movw	r10, r12
    9538:	07 ff       	sbrs	r16, 7
    953a:	09 c0       	rjmp	.+18     	; 0x954e <vfprintf+0x57e>
    953c:	84 e0       	ldi	r24, 0x04	; 4
    953e:	a8 0e       	add	r10, r24
    9540:	b1 1c       	adc	r11, r1
    9542:	f6 01       	movw	r30, r12
    9544:	60 81       	ld	r22, Z
    9546:	71 81       	ldd	r23, Z+1	; 0x01
    9548:	82 81       	ldd	r24, Z+2	; 0x02
    954a:	93 81       	ldd	r25, Z+3	; 0x03
    954c:	08 c0       	rjmp	.+16     	; 0x955e <vfprintf+0x58e>
    954e:	f2 e0       	ldi	r31, 0x02	; 2
    9550:	af 0e       	add	r10, r31
    9552:	b1 1c       	adc	r11, r1
    9554:	f6 01       	movw	r30, r12
    9556:	60 81       	ld	r22, Z
    9558:	71 81       	ldd	r23, Z+1	; 0x01
    955a:	80 e0       	ldi	r24, 0x00	; 0
    955c:	90 e0       	ldi	r25, 0x00	; 0
    955e:	a3 01       	movw	r20, r6
    9560:	0e 94 74 51 	call	0xa2e8	; 0xa2e8 <__ultoa_invert>
    9564:	c8 2e       	mov	r12, r24
    9566:	c6 18       	sub	r12, r6
    9568:	0f 77       	andi	r16, 0x7F	; 127
    956a:	90 2e       	mov	r9, r16
    956c:	96 fe       	sbrs	r9, 6
    956e:	0b c0       	rjmp	.+22     	; 0x9586 <vfprintf+0x5b6>
    9570:	09 2d       	mov	r16, r9
    9572:	0e 7f       	andi	r16, 0xFE	; 254
    9574:	c1 16       	cp	r12, r17
    9576:	50 f4       	brcc	.+20     	; 0x958c <vfprintf+0x5bc>
    9578:	94 fe       	sbrs	r9, 4
    957a:	0a c0       	rjmp	.+20     	; 0x9590 <vfprintf+0x5c0>
    957c:	92 fc       	sbrc	r9, 2
    957e:	08 c0       	rjmp	.+16     	; 0x9590 <vfprintf+0x5c0>
    9580:	09 2d       	mov	r16, r9
    9582:	0e 7e       	andi	r16, 0xEE	; 238
    9584:	05 c0       	rjmp	.+10     	; 0x9590 <vfprintf+0x5c0>
    9586:	dc 2c       	mov	r13, r12
    9588:	09 2d       	mov	r16, r9
    958a:	03 c0       	rjmp	.+6      	; 0x9592 <vfprintf+0x5c2>
    958c:	dc 2c       	mov	r13, r12
    958e:	01 c0       	rjmp	.+2      	; 0x9592 <vfprintf+0x5c2>
    9590:	d1 2e       	mov	r13, r17
    9592:	04 ff       	sbrs	r16, 4
    9594:	0d c0       	rjmp	.+26     	; 0x95b0 <vfprintf+0x5e0>
    9596:	fe 01       	movw	r30, r28
    9598:	ec 0d       	add	r30, r12
    959a:	f1 1d       	adc	r31, r1
    959c:	80 81       	ld	r24, Z
    959e:	80 33       	cpi	r24, 0x30	; 48
    95a0:	11 f4       	brne	.+4      	; 0x95a6 <vfprintf+0x5d6>
    95a2:	09 7e       	andi	r16, 0xE9	; 233
    95a4:	09 c0       	rjmp	.+18     	; 0x95b8 <vfprintf+0x5e8>
    95a6:	02 ff       	sbrs	r16, 2
    95a8:	06 c0       	rjmp	.+12     	; 0x95b6 <vfprintf+0x5e6>
    95aa:	d3 94       	inc	r13
    95ac:	d3 94       	inc	r13
    95ae:	04 c0       	rjmp	.+8      	; 0x95b8 <vfprintf+0x5e8>
    95b0:	80 2f       	mov	r24, r16
    95b2:	86 78       	andi	r24, 0x86	; 134
    95b4:	09 f0       	breq	.+2      	; 0x95b8 <vfprintf+0x5e8>
    95b6:	d3 94       	inc	r13
    95b8:	03 fd       	sbrc	r16, 3
    95ba:	11 c0       	rjmp	.+34     	; 0x95de <vfprintf+0x60e>
    95bc:	00 ff       	sbrs	r16, 0
    95be:	06 c0       	rjmp	.+12     	; 0x95cc <vfprintf+0x5fc>
    95c0:	1c 2d       	mov	r17, r12
    95c2:	d5 14       	cp	r13, r5
    95c4:	80 f4       	brcc	.+32     	; 0x95e6 <vfprintf+0x616>
    95c6:	15 0d       	add	r17, r5
    95c8:	1d 19       	sub	r17, r13
    95ca:	0d c0       	rjmp	.+26     	; 0x95e6 <vfprintf+0x616>
    95cc:	d5 14       	cp	r13, r5
    95ce:	58 f4       	brcc	.+22     	; 0x95e6 <vfprintf+0x616>
    95d0:	b7 01       	movw	r22, r14
    95d2:	80 e2       	ldi	r24, 0x20	; 32
    95d4:	90 e0       	ldi	r25, 0x00	; 0
    95d6:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    95da:	d3 94       	inc	r13
    95dc:	f7 cf       	rjmp	.-18     	; 0x95cc <vfprintf+0x5fc>
    95de:	d5 14       	cp	r13, r5
    95e0:	10 f4       	brcc	.+4      	; 0x95e6 <vfprintf+0x616>
    95e2:	5d 18       	sub	r5, r13
    95e4:	01 c0       	rjmp	.+2      	; 0x95e8 <vfprintf+0x618>
    95e6:	51 2c       	mov	r5, r1
    95e8:	04 ff       	sbrs	r16, 4
    95ea:	10 c0       	rjmp	.+32     	; 0x960c <vfprintf+0x63c>
    95ec:	b7 01       	movw	r22, r14
    95ee:	80 e3       	ldi	r24, 0x30	; 48
    95f0:	90 e0       	ldi	r25, 0x00	; 0
    95f2:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    95f6:	02 ff       	sbrs	r16, 2
    95f8:	17 c0       	rjmp	.+46     	; 0x9628 <vfprintf+0x658>
    95fa:	01 fd       	sbrc	r16, 1
    95fc:	03 c0       	rjmp	.+6      	; 0x9604 <vfprintf+0x634>
    95fe:	88 e7       	ldi	r24, 0x78	; 120
    9600:	90 e0       	ldi	r25, 0x00	; 0
    9602:	02 c0       	rjmp	.+4      	; 0x9608 <vfprintf+0x638>
    9604:	88 e5       	ldi	r24, 0x58	; 88
    9606:	90 e0       	ldi	r25, 0x00	; 0
    9608:	b7 01       	movw	r22, r14
    960a:	0c c0       	rjmp	.+24     	; 0x9624 <vfprintf+0x654>
    960c:	80 2f       	mov	r24, r16
    960e:	86 78       	andi	r24, 0x86	; 134
    9610:	59 f0       	breq	.+22     	; 0x9628 <vfprintf+0x658>
    9612:	01 ff       	sbrs	r16, 1
    9614:	02 c0       	rjmp	.+4      	; 0x961a <vfprintf+0x64a>
    9616:	8b e2       	ldi	r24, 0x2B	; 43
    9618:	01 c0       	rjmp	.+2      	; 0x961c <vfprintf+0x64c>
    961a:	80 e2       	ldi	r24, 0x20	; 32
    961c:	07 fd       	sbrc	r16, 7
    961e:	8d e2       	ldi	r24, 0x2D	; 45
    9620:	b7 01       	movw	r22, r14
    9622:	90 e0       	ldi	r25, 0x00	; 0
    9624:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    9628:	c1 16       	cp	r12, r17
    962a:	38 f4       	brcc	.+14     	; 0x963a <vfprintf+0x66a>
    962c:	b7 01       	movw	r22, r14
    962e:	80 e3       	ldi	r24, 0x30	; 48
    9630:	90 e0       	ldi	r25, 0x00	; 0
    9632:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    9636:	11 50       	subi	r17, 0x01	; 1
    9638:	f7 cf       	rjmp	.-18     	; 0x9628 <vfprintf+0x658>
    963a:	ca 94       	dec	r12
    963c:	f3 01       	movw	r30, r6
    963e:	ec 0d       	add	r30, r12
    9640:	f1 1d       	adc	r31, r1
    9642:	80 81       	ld	r24, Z
    9644:	b7 01       	movw	r22, r14
    9646:	90 e0       	ldi	r25, 0x00	; 0
    9648:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    964c:	c1 10       	cpse	r12, r1
    964e:	f5 cf       	rjmp	.-22     	; 0x963a <vfprintf+0x66a>
    9650:	15 c0       	rjmp	.+42     	; 0x967c <vfprintf+0x6ac>
    9652:	f4 e0       	ldi	r31, 0x04	; 4
    9654:	f5 15       	cp	r31, r5
    9656:	60 f5       	brcc	.+88     	; 0x96b0 <vfprintf+0x6e0>
    9658:	84 e0       	ldi	r24, 0x04	; 4
    965a:	58 1a       	sub	r5, r24
    965c:	93 fe       	sbrs	r9, 3
    965e:	1f c0       	rjmp	.+62     	; 0x969e <vfprintf+0x6ce>
    9660:	01 11       	cpse	r16, r1
    9662:	27 c0       	rjmp	.+78     	; 0x96b2 <vfprintf+0x6e2>
    9664:	2c 85       	ldd	r18, Y+12	; 0x0c
    9666:	23 ff       	sbrs	r18, 3
    9668:	2a c0       	rjmp	.+84     	; 0x96be <vfprintf+0x6ee>
    966a:	08 e3       	ldi	r16, 0x38	; 56
    966c:	12 e0       	ldi	r17, 0x02	; 2
    966e:	39 2d       	mov	r19, r9
    9670:	30 71       	andi	r19, 0x10	; 16
    9672:	93 2e       	mov	r9, r19
    9674:	f8 01       	movw	r30, r16
    9676:	84 91       	lpm	r24, Z
    9678:	81 11       	cpse	r24, r1
    967a:	24 c0       	rjmp	.+72     	; 0x96c4 <vfprintf+0x6f4>
    967c:	55 20       	and	r5, r5
    967e:	09 f4       	brne	.+2      	; 0x9682 <vfprintf+0x6b2>
    9680:	e4 cc       	rjmp	.-1592   	; 0x904a <vfprintf+0x7a>
    9682:	b7 01       	movw	r22, r14
    9684:	80 e2       	ldi	r24, 0x20	; 32
    9686:	90 e0       	ldi	r25, 0x00	; 0
    9688:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    968c:	5a 94       	dec	r5
    968e:	f6 cf       	rjmp	.-20     	; 0x967c <vfprintf+0x6ac>
    9690:	f7 01       	movw	r30, r14
    9692:	86 81       	ldd	r24, Z+6	; 0x06
    9694:	97 81       	ldd	r25, Z+7	; 0x07
    9696:	26 c0       	rjmp	.+76     	; 0x96e4 <vfprintf+0x714>
    9698:	8f ef       	ldi	r24, 0xFF	; 255
    969a:	9f ef       	ldi	r25, 0xFF	; 255
    969c:	23 c0       	rjmp	.+70     	; 0x96e4 <vfprintf+0x714>
    969e:	b7 01       	movw	r22, r14
    96a0:	80 e2       	ldi	r24, 0x20	; 32
    96a2:	90 e0       	ldi	r25, 0x00	; 0
    96a4:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    96a8:	5a 94       	dec	r5
    96aa:	51 10       	cpse	r5, r1
    96ac:	f8 cf       	rjmp	.-16     	; 0x969e <vfprintf+0x6ce>
    96ae:	d8 cf       	rjmp	.-80     	; 0x9660 <vfprintf+0x690>
    96b0:	51 2c       	mov	r5, r1
    96b2:	b7 01       	movw	r22, r14
    96b4:	80 2f       	mov	r24, r16
    96b6:	90 e0       	ldi	r25, 0x00	; 0
    96b8:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    96bc:	d3 cf       	rjmp	.-90     	; 0x9664 <vfprintf+0x694>
    96be:	0c e3       	ldi	r16, 0x3C	; 60
    96c0:	12 e0       	ldi	r17, 0x02	; 2
    96c2:	d5 cf       	rjmp	.-86     	; 0x966e <vfprintf+0x69e>
    96c4:	91 10       	cpse	r9, r1
    96c6:	80 52       	subi	r24, 0x20	; 32
    96c8:	b7 01       	movw	r22, r14
    96ca:	90 e0       	ldi	r25, 0x00	; 0
    96cc:	0e 94 a3 50 	call	0xa146	; 0xa146 <fputc>
    96d0:	0f 5f       	subi	r16, 0xFF	; 255
    96d2:	1f 4f       	sbci	r17, 0xFF	; 255
    96d4:	cf cf       	rjmp	.-98     	; 0x9674 <vfprintf+0x6a4>
    96d6:	23 e0       	ldi	r18, 0x03	; 3
    96d8:	25 15       	cp	r18, r5
    96da:	10 f4       	brcc	.+4      	; 0x96e0 <vfprintf+0x710>
    96dc:	83 e0       	ldi	r24, 0x03	; 3
    96de:	bd cf       	rjmp	.-134    	; 0x965a <vfprintf+0x68a>
    96e0:	51 2c       	mov	r5, r1
    96e2:	c0 cf       	rjmp	.-128    	; 0x9664 <vfprintf+0x694>
    96e4:	60 96       	adiw	r28, 0x10	; 16
    96e6:	cd bf       	out	0x3d, r28	; 61
    96e8:	de bf       	out	0x3e, r29	; 62
    96ea:	df 91       	pop	r29
    96ec:	cf 91       	pop	r28
    96ee:	1f 91       	pop	r17
    96f0:	0f 91       	pop	r16
    96f2:	ff 90       	pop	r15
    96f4:	ef 90       	pop	r14
    96f6:	df 90       	pop	r13
    96f8:	cf 90       	pop	r12
    96fa:	bf 90       	pop	r11
    96fc:	af 90       	pop	r10
    96fe:	9f 90       	pop	r9
    9700:	8f 90       	pop	r8
    9702:	7f 90       	pop	r7
    9704:	6f 90       	pop	r6
    9706:	5f 90       	pop	r5
    9708:	4f 90       	pop	r4
    970a:	3f 90       	pop	r3
    970c:	2f 90       	pop	r2
    970e:	08 95       	ret

00009710 <__udivmodhi4>:
    9710:	aa 1b       	sub	r26, r26
    9712:	bb 1b       	sub	r27, r27
    9714:	51 e1       	ldi	r21, 0x11	; 17
    9716:	07 c0       	rjmp	.+14     	; 0x9726 <__udivmodhi4_ep>

00009718 <__udivmodhi4_loop>:
    9718:	aa 1f       	adc	r26, r26
    971a:	bb 1f       	adc	r27, r27
    971c:	a6 17       	cp	r26, r22
    971e:	b7 07       	cpc	r27, r23
    9720:	10 f0       	brcs	.+4      	; 0x9726 <__udivmodhi4_ep>
    9722:	a6 1b       	sub	r26, r22
    9724:	b7 0b       	sbc	r27, r23

00009726 <__udivmodhi4_ep>:
    9726:	88 1f       	adc	r24, r24
    9728:	99 1f       	adc	r25, r25
    972a:	5a 95       	dec	r21
    972c:	a9 f7       	brne	.-22     	; 0x9718 <__udivmodhi4_loop>
    972e:	80 95       	com	r24
    9730:	90 95       	com	r25
    9732:	bc 01       	movw	r22, r24
    9734:	cd 01       	movw	r24, r26
    9736:	08 95       	ret

00009738 <__divmodhi4>:
    9738:	97 fb       	bst	r25, 7
    973a:	07 2e       	mov	r0, r23
    973c:	16 f4       	brtc	.+4      	; 0x9742 <__divmodhi4+0xa>
    973e:	00 94       	com	r0
    9740:	07 d0       	rcall	.+14     	; 0x9750 <__divmodhi4_neg1>
    9742:	77 fd       	sbrc	r23, 7
    9744:	09 d0       	rcall	.+18     	; 0x9758 <__divmodhi4_neg2>
    9746:	0e 94 88 4b 	call	0x9710	; 0x9710 <__udivmodhi4>
    974a:	07 fc       	sbrc	r0, 7
    974c:	05 d0       	rcall	.+10     	; 0x9758 <__divmodhi4_neg2>
    974e:	3e f4       	brtc	.+14     	; 0x975e <__divmodhi4_exit>

00009750 <__divmodhi4_neg1>:
    9750:	90 95       	com	r25
    9752:	81 95       	neg	r24
    9754:	9f 4f       	sbci	r25, 0xFF	; 255
    9756:	08 95       	ret

00009758 <__divmodhi4_neg2>:
    9758:	70 95       	com	r23
    975a:	61 95       	neg	r22
    975c:	7f 4f       	sbci	r23, 0xFF	; 255

0000975e <__divmodhi4_exit>:
    975e:	08 95       	ret

00009760 <__udivmodsi4>:
    9760:	a1 e2       	ldi	r26, 0x21	; 33
    9762:	1a 2e       	mov	r1, r26
    9764:	aa 1b       	sub	r26, r26
    9766:	bb 1b       	sub	r27, r27
    9768:	fd 01       	movw	r30, r26
    976a:	0d c0       	rjmp	.+26     	; 0x9786 <__udivmodsi4_ep>

0000976c <__udivmodsi4_loop>:
    976c:	aa 1f       	adc	r26, r26
    976e:	bb 1f       	adc	r27, r27
    9770:	ee 1f       	adc	r30, r30
    9772:	ff 1f       	adc	r31, r31
    9774:	a2 17       	cp	r26, r18
    9776:	b3 07       	cpc	r27, r19
    9778:	e4 07       	cpc	r30, r20
    977a:	f5 07       	cpc	r31, r21
    977c:	20 f0       	brcs	.+8      	; 0x9786 <__udivmodsi4_ep>
    977e:	a2 1b       	sub	r26, r18
    9780:	b3 0b       	sbc	r27, r19
    9782:	e4 0b       	sbc	r30, r20
    9784:	f5 0b       	sbc	r31, r21

00009786 <__udivmodsi4_ep>:
    9786:	66 1f       	adc	r22, r22
    9788:	77 1f       	adc	r23, r23
    978a:	88 1f       	adc	r24, r24
    978c:	99 1f       	adc	r25, r25
    978e:	1a 94       	dec	r1
    9790:	69 f7       	brne	.-38     	; 0x976c <__udivmodsi4_loop>
    9792:	60 95       	com	r22
    9794:	70 95       	com	r23
    9796:	80 95       	com	r24
    9798:	90 95       	com	r25
    979a:	9b 01       	movw	r18, r22
    979c:	ac 01       	movw	r20, r24
    979e:	bd 01       	movw	r22, r26
    97a0:	cf 01       	movw	r24, r30
    97a2:	08 95       	ret

000097a4 <__umulhisi3>:
    97a4:	a2 9f       	mul	r26, r18
    97a6:	b0 01       	movw	r22, r0
    97a8:	b3 9f       	mul	r27, r19
    97aa:	c0 01       	movw	r24, r0
    97ac:	a3 9f       	mul	r26, r19
    97ae:	70 0d       	add	r23, r0
    97b0:	81 1d       	adc	r24, r1
    97b2:	11 24       	eor	r1, r1
    97b4:	91 1d       	adc	r25, r1
    97b6:	b2 9f       	mul	r27, r18
    97b8:	70 0d       	add	r23, r0
    97ba:	81 1d       	adc	r24, r1
    97bc:	11 24       	eor	r1, r1
    97be:	91 1d       	adc	r25, r1
    97c0:	08 95       	ret

000097c2 <__muluhisi3>:
    97c2:	0e 94 d2 4b 	call	0x97a4	; 0x97a4 <__umulhisi3>
    97c6:	a5 9f       	mul	r26, r21
    97c8:	90 0d       	add	r25, r0
    97ca:	b4 9f       	mul	r27, r20
    97cc:	90 0d       	add	r25, r0
    97ce:	a4 9f       	mul	r26, r20
    97d0:	80 0d       	add	r24, r0
    97d2:	91 1d       	adc	r25, r1
    97d4:	11 24       	eor	r1, r1
    97d6:	08 95       	ret

000097d8 <__mulshisi3>:
    97d8:	b7 ff       	sbrs	r27, 7
    97da:	0c 94 e1 4b 	jmp	0x97c2	; 0x97c2 <__muluhisi3>

000097de <__mulohisi3>:
    97de:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <__muluhisi3>
    97e2:	82 1b       	sub	r24, r18
    97e4:	93 0b       	sbc	r25, r19
    97e6:	08 95       	ret

000097e8 <malloc>:
    97e8:	0f 93       	push	r16
    97ea:	1f 93       	push	r17
    97ec:	cf 93       	push	r28
    97ee:	df 93       	push	r29
    97f0:	82 30       	cpi	r24, 0x02	; 2
    97f2:	91 05       	cpc	r25, r1
    97f4:	10 f4       	brcc	.+4      	; 0x97fa <malloc+0x12>
    97f6:	82 e0       	ldi	r24, 0x02	; 2
    97f8:	90 e0       	ldi	r25, 0x00	; 0
    97fa:	e0 91 7a 2e 	lds	r30, 0x2E7A	; 0x802e7a <__flp>
    97fe:	f0 91 7b 2e 	lds	r31, 0x2E7B	; 0x802e7b <__flp+0x1>
    9802:	20 e0       	ldi	r18, 0x00	; 0
    9804:	30 e0       	ldi	r19, 0x00	; 0
    9806:	a0 e0       	ldi	r26, 0x00	; 0
    9808:	b0 e0       	ldi	r27, 0x00	; 0
    980a:	30 97       	sbiw	r30, 0x00	; 0
    980c:	19 f1       	breq	.+70     	; 0x9854 <malloc+0x6c>
    980e:	40 81       	ld	r20, Z
    9810:	51 81       	ldd	r21, Z+1	; 0x01
    9812:	02 81       	ldd	r16, Z+2	; 0x02
    9814:	13 81       	ldd	r17, Z+3	; 0x03
    9816:	48 17       	cp	r20, r24
    9818:	59 07       	cpc	r21, r25
    981a:	c8 f0       	brcs	.+50     	; 0x984e <malloc+0x66>
    981c:	84 17       	cp	r24, r20
    981e:	95 07       	cpc	r25, r21
    9820:	69 f4       	brne	.+26     	; 0x983c <malloc+0x54>
    9822:	10 97       	sbiw	r26, 0x00	; 0
    9824:	31 f0       	breq	.+12     	; 0x9832 <malloc+0x4a>
    9826:	12 96       	adiw	r26, 0x02	; 2
    9828:	0c 93       	st	X, r16
    982a:	12 97       	sbiw	r26, 0x02	; 2
    982c:	13 96       	adiw	r26, 0x03	; 3
    982e:	1c 93       	st	X, r17
    9830:	27 c0       	rjmp	.+78     	; 0x9880 <malloc+0x98>
    9832:	00 93 7a 2e 	sts	0x2E7A, r16	; 0x802e7a <__flp>
    9836:	10 93 7b 2e 	sts	0x2E7B, r17	; 0x802e7b <__flp+0x1>
    983a:	22 c0       	rjmp	.+68     	; 0x9880 <malloc+0x98>
    983c:	21 15       	cp	r18, r1
    983e:	31 05       	cpc	r19, r1
    9840:	19 f0       	breq	.+6      	; 0x9848 <malloc+0x60>
    9842:	42 17       	cp	r20, r18
    9844:	53 07       	cpc	r21, r19
    9846:	18 f4       	brcc	.+6      	; 0x984e <malloc+0x66>
    9848:	9a 01       	movw	r18, r20
    984a:	bd 01       	movw	r22, r26
    984c:	ef 01       	movw	r28, r30
    984e:	df 01       	movw	r26, r30
    9850:	f8 01       	movw	r30, r16
    9852:	db cf       	rjmp	.-74     	; 0x980a <malloc+0x22>
    9854:	21 15       	cp	r18, r1
    9856:	31 05       	cpc	r19, r1
    9858:	f9 f0       	breq	.+62     	; 0x9898 <malloc+0xb0>
    985a:	28 1b       	sub	r18, r24
    985c:	39 0b       	sbc	r19, r25
    985e:	24 30       	cpi	r18, 0x04	; 4
    9860:	31 05       	cpc	r19, r1
    9862:	80 f4       	brcc	.+32     	; 0x9884 <malloc+0x9c>
    9864:	8a 81       	ldd	r24, Y+2	; 0x02
    9866:	9b 81       	ldd	r25, Y+3	; 0x03
    9868:	61 15       	cp	r22, r1
    986a:	71 05       	cpc	r23, r1
    986c:	21 f0       	breq	.+8      	; 0x9876 <malloc+0x8e>
    986e:	fb 01       	movw	r30, r22
    9870:	82 83       	std	Z+2, r24	; 0x02
    9872:	93 83       	std	Z+3, r25	; 0x03
    9874:	04 c0       	rjmp	.+8      	; 0x987e <malloc+0x96>
    9876:	80 93 7a 2e 	sts	0x2E7A, r24	; 0x802e7a <__flp>
    987a:	90 93 7b 2e 	sts	0x2E7B, r25	; 0x802e7b <__flp+0x1>
    987e:	fe 01       	movw	r30, r28
    9880:	32 96       	adiw	r30, 0x02	; 2
    9882:	44 c0       	rjmp	.+136    	; 0x990c <malloc+0x124>
    9884:	fe 01       	movw	r30, r28
    9886:	e2 0f       	add	r30, r18
    9888:	f3 1f       	adc	r31, r19
    988a:	81 93       	st	Z+, r24
    988c:	91 93       	st	Z+, r25
    988e:	22 50       	subi	r18, 0x02	; 2
    9890:	31 09       	sbc	r19, r1
    9892:	28 83       	st	Y, r18
    9894:	39 83       	std	Y+1, r19	; 0x01
    9896:	3a c0       	rjmp	.+116    	; 0x990c <malloc+0x124>
    9898:	20 91 78 2e 	lds	r18, 0x2E78	; 0x802e78 <__brkval>
    989c:	30 91 79 2e 	lds	r19, 0x2E79	; 0x802e79 <__brkval+0x1>
    98a0:	23 2b       	or	r18, r19
    98a2:	41 f4       	brne	.+16     	; 0x98b4 <malloc+0xcc>
    98a4:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    98a8:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    98ac:	20 93 78 2e 	sts	0x2E78, r18	; 0x802e78 <__brkval>
    98b0:	30 93 79 2e 	sts	0x2E79, r19	; 0x802e79 <__brkval+0x1>
    98b4:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
    98b8:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
    98bc:	21 15       	cp	r18, r1
    98be:	31 05       	cpc	r19, r1
    98c0:	41 f4       	brne	.+16     	; 0x98d2 <malloc+0xea>
    98c2:	2d b7       	in	r18, 0x3d	; 61
    98c4:	3e b7       	in	r19, 0x3e	; 62
    98c6:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    98ca:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    98ce:	24 1b       	sub	r18, r20
    98d0:	35 0b       	sbc	r19, r21
    98d2:	e0 91 78 2e 	lds	r30, 0x2E78	; 0x802e78 <__brkval>
    98d6:	f0 91 79 2e 	lds	r31, 0x2E79	; 0x802e79 <__brkval+0x1>
    98da:	e2 17       	cp	r30, r18
    98dc:	f3 07       	cpc	r31, r19
    98de:	a0 f4       	brcc	.+40     	; 0x9908 <malloc+0x120>
    98e0:	2e 1b       	sub	r18, r30
    98e2:	3f 0b       	sbc	r19, r31
    98e4:	28 17       	cp	r18, r24
    98e6:	39 07       	cpc	r19, r25
    98e8:	78 f0       	brcs	.+30     	; 0x9908 <malloc+0x120>
    98ea:	ac 01       	movw	r20, r24
    98ec:	4e 5f       	subi	r20, 0xFE	; 254
    98ee:	5f 4f       	sbci	r21, 0xFF	; 255
    98f0:	24 17       	cp	r18, r20
    98f2:	35 07       	cpc	r19, r21
    98f4:	48 f0       	brcs	.+18     	; 0x9908 <malloc+0x120>
    98f6:	4e 0f       	add	r20, r30
    98f8:	5f 1f       	adc	r21, r31
    98fa:	40 93 78 2e 	sts	0x2E78, r20	; 0x802e78 <__brkval>
    98fe:	50 93 79 2e 	sts	0x2E79, r21	; 0x802e79 <__brkval+0x1>
    9902:	81 93       	st	Z+, r24
    9904:	91 93       	st	Z+, r25
    9906:	02 c0       	rjmp	.+4      	; 0x990c <malloc+0x124>
    9908:	e0 e0       	ldi	r30, 0x00	; 0
    990a:	f0 e0       	ldi	r31, 0x00	; 0
    990c:	cf 01       	movw	r24, r30
    990e:	df 91       	pop	r29
    9910:	cf 91       	pop	r28
    9912:	1f 91       	pop	r17
    9914:	0f 91       	pop	r16
    9916:	08 95       	ret

00009918 <free>:
    9918:	cf 93       	push	r28
    991a:	df 93       	push	r29
    991c:	00 97       	sbiw	r24, 0x00	; 0
    991e:	09 f4       	brne	.+2      	; 0x9922 <free+0xa>
    9920:	81 c0       	rjmp	.+258    	; 0x9a24 <free+0x10c>
    9922:	fc 01       	movw	r30, r24
    9924:	32 97       	sbiw	r30, 0x02	; 2
    9926:	12 82       	std	Z+2, r1	; 0x02
    9928:	13 82       	std	Z+3, r1	; 0x03
    992a:	a0 91 7a 2e 	lds	r26, 0x2E7A	; 0x802e7a <__flp>
    992e:	b0 91 7b 2e 	lds	r27, 0x2E7B	; 0x802e7b <__flp+0x1>
    9932:	10 97       	sbiw	r26, 0x00	; 0
    9934:	81 f4       	brne	.+32     	; 0x9956 <free+0x3e>
    9936:	20 81       	ld	r18, Z
    9938:	31 81       	ldd	r19, Z+1	; 0x01
    993a:	82 0f       	add	r24, r18
    993c:	93 1f       	adc	r25, r19
    993e:	20 91 78 2e 	lds	r18, 0x2E78	; 0x802e78 <__brkval>
    9942:	30 91 79 2e 	lds	r19, 0x2E79	; 0x802e79 <__brkval+0x1>
    9946:	28 17       	cp	r18, r24
    9948:	39 07       	cpc	r19, r25
    994a:	51 f5       	brne	.+84     	; 0x99a0 <free+0x88>
    994c:	e0 93 78 2e 	sts	0x2E78, r30	; 0x802e78 <__brkval>
    9950:	f0 93 79 2e 	sts	0x2E79, r31	; 0x802e79 <__brkval+0x1>
    9954:	67 c0       	rjmp	.+206    	; 0x9a24 <free+0x10c>
    9956:	ed 01       	movw	r28, r26
    9958:	20 e0       	ldi	r18, 0x00	; 0
    995a:	30 e0       	ldi	r19, 0x00	; 0
    995c:	ce 17       	cp	r28, r30
    995e:	df 07       	cpc	r29, r31
    9960:	40 f4       	brcc	.+16     	; 0x9972 <free+0x5a>
    9962:	4a 81       	ldd	r20, Y+2	; 0x02
    9964:	5b 81       	ldd	r21, Y+3	; 0x03
    9966:	9e 01       	movw	r18, r28
    9968:	41 15       	cp	r20, r1
    996a:	51 05       	cpc	r21, r1
    996c:	f1 f0       	breq	.+60     	; 0x99aa <free+0x92>
    996e:	ea 01       	movw	r28, r20
    9970:	f5 cf       	rjmp	.-22     	; 0x995c <free+0x44>
    9972:	c2 83       	std	Z+2, r28	; 0x02
    9974:	d3 83       	std	Z+3, r29	; 0x03
    9976:	40 81       	ld	r20, Z
    9978:	51 81       	ldd	r21, Z+1	; 0x01
    997a:	84 0f       	add	r24, r20
    997c:	95 1f       	adc	r25, r21
    997e:	c8 17       	cp	r28, r24
    9980:	d9 07       	cpc	r29, r25
    9982:	59 f4       	brne	.+22     	; 0x999a <free+0x82>
    9984:	88 81       	ld	r24, Y
    9986:	99 81       	ldd	r25, Y+1	; 0x01
    9988:	84 0f       	add	r24, r20
    998a:	95 1f       	adc	r25, r21
    998c:	02 96       	adiw	r24, 0x02	; 2
    998e:	80 83       	st	Z, r24
    9990:	91 83       	std	Z+1, r25	; 0x01
    9992:	8a 81       	ldd	r24, Y+2	; 0x02
    9994:	9b 81       	ldd	r25, Y+3	; 0x03
    9996:	82 83       	std	Z+2, r24	; 0x02
    9998:	93 83       	std	Z+3, r25	; 0x03
    999a:	21 15       	cp	r18, r1
    999c:	31 05       	cpc	r19, r1
    999e:	29 f4       	brne	.+10     	; 0x99aa <free+0x92>
    99a0:	e0 93 7a 2e 	sts	0x2E7A, r30	; 0x802e7a <__flp>
    99a4:	f0 93 7b 2e 	sts	0x2E7B, r31	; 0x802e7b <__flp+0x1>
    99a8:	3d c0       	rjmp	.+122    	; 0x9a24 <free+0x10c>
    99aa:	e9 01       	movw	r28, r18
    99ac:	ea 83       	std	Y+2, r30	; 0x02
    99ae:	fb 83       	std	Y+3, r31	; 0x03
    99b0:	49 91       	ld	r20, Y+
    99b2:	59 91       	ld	r21, Y+
    99b4:	c4 0f       	add	r28, r20
    99b6:	d5 1f       	adc	r29, r21
    99b8:	ec 17       	cp	r30, r28
    99ba:	fd 07       	cpc	r31, r29
    99bc:	61 f4       	brne	.+24     	; 0x99d6 <free+0xbe>
    99be:	80 81       	ld	r24, Z
    99c0:	91 81       	ldd	r25, Z+1	; 0x01
    99c2:	84 0f       	add	r24, r20
    99c4:	95 1f       	adc	r25, r21
    99c6:	02 96       	adiw	r24, 0x02	; 2
    99c8:	e9 01       	movw	r28, r18
    99ca:	88 83       	st	Y, r24
    99cc:	99 83       	std	Y+1, r25	; 0x01
    99ce:	82 81       	ldd	r24, Z+2	; 0x02
    99d0:	93 81       	ldd	r25, Z+3	; 0x03
    99d2:	8a 83       	std	Y+2, r24	; 0x02
    99d4:	9b 83       	std	Y+3, r25	; 0x03
    99d6:	e0 e0       	ldi	r30, 0x00	; 0
    99d8:	f0 e0       	ldi	r31, 0x00	; 0
    99da:	12 96       	adiw	r26, 0x02	; 2
    99dc:	8d 91       	ld	r24, X+
    99de:	9c 91       	ld	r25, X
    99e0:	13 97       	sbiw	r26, 0x03	; 3
    99e2:	00 97       	sbiw	r24, 0x00	; 0
    99e4:	19 f0       	breq	.+6      	; 0x99ec <free+0xd4>
    99e6:	fd 01       	movw	r30, r26
    99e8:	dc 01       	movw	r26, r24
    99ea:	f7 cf       	rjmp	.-18     	; 0x99da <free+0xc2>
    99ec:	8d 91       	ld	r24, X+
    99ee:	9c 91       	ld	r25, X
    99f0:	11 97       	sbiw	r26, 0x01	; 1
    99f2:	9d 01       	movw	r18, r26
    99f4:	2e 5f       	subi	r18, 0xFE	; 254
    99f6:	3f 4f       	sbci	r19, 0xFF	; 255
    99f8:	82 0f       	add	r24, r18
    99fa:	93 1f       	adc	r25, r19
    99fc:	20 91 78 2e 	lds	r18, 0x2E78	; 0x802e78 <__brkval>
    9a00:	30 91 79 2e 	lds	r19, 0x2E79	; 0x802e79 <__brkval+0x1>
    9a04:	28 17       	cp	r18, r24
    9a06:	39 07       	cpc	r19, r25
    9a08:	69 f4       	brne	.+26     	; 0x9a24 <free+0x10c>
    9a0a:	30 97       	sbiw	r30, 0x00	; 0
    9a0c:	29 f4       	brne	.+10     	; 0x9a18 <free+0x100>
    9a0e:	10 92 7a 2e 	sts	0x2E7A, r1	; 0x802e7a <__flp>
    9a12:	10 92 7b 2e 	sts	0x2E7B, r1	; 0x802e7b <__flp+0x1>
    9a16:	02 c0       	rjmp	.+4      	; 0x9a1c <free+0x104>
    9a18:	12 82       	std	Z+2, r1	; 0x02
    9a1a:	13 82       	std	Z+3, r1	; 0x03
    9a1c:	a0 93 78 2e 	sts	0x2E78, r26	; 0x802e78 <__brkval>
    9a20:	b0 93 79 2e 	sts	0x2E79, r27	; 0x802e79 <__brkval+0x1>
    9a24:	df 91       	pop	r29
    9a26:	cf 91       	pop	r28
    9a28:	08 95       	ret

00009a2a <swapfunc>:
    9a2a:	dc 01       	movw	r26, r24
    9a2c:	fb 01       	movw	r30, r22
    9a2e:	8c 91       	ld	r24, X
    9a30:	90 81       	ld	r25, Z
    9a32:	9d 93       	st	X+, r25
    9a34:	81 93       	st	Z+, r24
    9a36:	41 50       	subi	r20, 0x01	; 1
    9a38:	51 09       	sbc	r21, r1
    9a3a:	14 16       	cp	r1, r20
    9a3c:	15 06       	cpc	r1, r21
    9a3e:	bc f3       	brlt	.-18     	; 0x9a2e <swapfunc+0x4>
    9a40:	08 95       	ret

00009a42 <med3>:
    9a42:	cf 92       	push	r12
    9a44:	df 92       	push	r13
    9a46:	ef 92       	push	r14
    9a48:	ff 92       	push	r15
    9a4a:	0f 93       	push	r16
    9a4c:	1f 93       	push	r17
    9a4e:	cf 93       	push	r28
    9a50:	df 93       	push	r29
    9a52:	7c 01       	movw	r14, r24
    9a54:	6b 01       	movw	r12, r22
    9a56:	d4 2f       	mov	r29, r20
    9a58:	c5 2f       	mov	r28, r21
    9a5a:	89 01       	movw	r16, r18
    9a5c:	f9 01       	movw	r30, r18
    9a5e:	19 95       	eicall
    9a60:	6d 2f       	mov	r22, r29
    9a62:	7c 2f       	mov	r23, r28
    9a64:	97 ff       	sbrs	r25, 7
    9a66:	10 c0       	rjmp	.+32     	; 0x9a88 <med3+0x46>
    9a68:	c6 01       	movw	r24, r12
    9a6a:	f8 01       	movw	r30, r16
    9a6c:	19 95       	eicall
    9a6e:	97 ff       	sbrs	r25, 7
    9a70:	02 c0       	rjmp	.+4      	; 0x9a76 <med3+0x34>
    9a72:	c6 01       	movw	r24, r12
    9a74:	18 c0       	rjmp	.+48     	; 0x9aa6 <med3+0x64>
    9a76:	6d 2f       	mov	r22, r29
    9a78:	7c 2f       	mov	r23, r28
    9a7a:	c7 01       	movw	r24, r14
    9a7c:	f8 01       	movw	r30, r16
    9a7e:	19 95       	eicall
    9a80:	97 fd       	sbrc	r25, 7
    9a82:	0f c0       	rjmp	.+30     	; 0x9aa2 <med3+0x60>
    9a84:	c7 01       	movw	r24, r14
    9a86:	0f c0       	rjmp	.+30     	; 0x9aa6 <med3+0x64>
    9a88:	c6 01       	movw	r24, r12
    9a8a:	f8 01       	movw	r30, r16
    9a8c:	19 95       	eicall
    9a8e:	18 16       	cp	r1, r24
    9a90:	19 06       	cpc	r1, r25
    9a92:	7c f3       	brlt	.-34     	; 0x9a72 <med3+0x30>
    9a94:	6d 2f       	mov	r22, r29
    9a96:	7c 2f       	mov	r23, r28
    9a98:	c7 01       	movw	r24, r14
    9a9a:	f8 01       	movw	r30, r16
    9a9c:	19 95       	eicall
    9a9e:	97 fd       	sbrc	r25, 7
    9aa0:	f1 cf       	rjmp	.-30     	; 0x9a84 <med3+0x42>
    9aa2:	8d 2f       	mov	r24, r29
    9aa4:	9c 2f       	mov	r25, r28
    9aa6:	df 91       	pop	r29
    9aa8:	cf 91       	pop	r28
    9aaa:	1f 91       	pop	r17
    9aac:	0f 91       	pop	r16
    9aae:	ff 90       	pop	r15
    9ab0:	ef 90       	pop	r14
    9ab2:	df 90       	pop	r13
    9ab4:	cf 90       	pop	r12
    9ab6:	08 95       	ret

00009ab8 <qsort>:
    9ab8:	2f 92       	push	r2
    9aba:	3f 92       	push	r3
    9abc:	4f 92       	push	r4
    9abe:	5f 92       	push	r5
    9ac0:	6f 92       	push	r6
    9ac2:	7f 92       	push	r7
    9ac4:	8f 92       	push	r8
    9ac6:	9f 92       	push	r9
    9ac8:	af 92       	push	r10
    9aca:	bf 92       	push	r11
    9acc:	cf 92       	push	r12
    9ace:	df 92       	push	r13
    9ad0:	ef 92       	push	r14
    9ad2:	ff 92       	push	r15
    9ad4:	0f 93       	push	r16
    9ad6:	1f 93       	push	r17
    9ad8:	cf 93       	push	r28
    9ada:	df 93       	push	r29
    9adc:	cd b7       	in	r28, 0x3d	; 61
    9ade:	de b7       	in	r29, 0x3e	; 62
    9ae0:	2a 97       	sbiw	r28, 0x0a	; 10
    9ae2:	cd bf       	out	0x3d, r28	; 61
    9ae4:	de bf       	out	0x3e, r29	; 62
    9ae6:	8c 01       	movw	r16, r24
    9ae8:	7b 01       	movw	r14, r22
    9aea:	49 87       	std	Y+9, r20	; 0x09
    9aec:	5a 87       	std	Y+10, r21	; 0x0a
    9aee:	69 01       	movw	r12, r18
    9af0:	29 85       	ldd	r18, Y+9	; 0x09
    9af2:	3a 85       	ldd	r19, Y+10	; 0x0a
    9af4:	20 0f       	add	r18, r16
    9af6:	31 1f       	adc	r19, r17
    9af8:	29 83       	std	Y+1, r18	; 0x01
    9afa:	3a 83       	std	Y+2, r19	; 0x02
    9afc:	37 e0       	ldi	r19, 0x07	; 7
    9afe:	e3 16       	cp	r14, r19
    9b00:	f1 04       	cpc	r15, r1
    9b02:	70 f5       	brcc	.+92     	; 0x9b60 <qsort+0xa8>
    9b04:	69 80       	ldd	r6, Y+1	; 0x01
    9b06:	7a 80       	ldd	r7, Y+2	; 0x02
    9b08:	49 85       	ldd	r20, Y+9	; 0x09
    9b0a:	5a 85       	ldd	r21, Y+10	; 0x0a
    9b0c:	e4 9e       	mul	r14, r20
    9b0e:	50 01       	movw	r10, r0
    9b10:	e5 9e       	mul	r14, r21
    9b12:	b0 0c       	add	r11, r0
    9b14:	f4 9e       	mul	r15, r20
    9b16:	b0 0c       	add	r11, r0
    9b18:	11 24       	eor	r1, r1
    9b1a:	a0 0e       	add	r10, r16
    9b1c:	b1 1e       	adc	r11, r17
    9b1e:	6a 14       	cp	r6, r10
    9b20:	7b 04       	cpc	r7, r11
    9b22:	08 f0       	brcs	.+2      	; 0x9b26 <qsort+0x6e>
    9b24:	7a c1       	rjmp	.+756    	; 0x9e1a <qsort+0x362>
    9b26:	73 01       	movw	r14, r6
    9b28:	0e 15       	cp	r16, r14
    9b2a:	1f 05       	cpc	r17, r15
    9b2c:	28 f0       	brcs	.+10     	; 0x9b38 <qsort+0x80>
    9b2e:	89 85       	ldd	r24, Y+9	; 0x09
    9b30:	9a 85       	ldd	r25, Y+10	; 0x0a
    9b32:	68 0e       	add	r6, r24
    9b34:	79 1e       	adc	r7, r25
    9b36:	f3 cf       	rjmp	.-26     	; 0x9b1e <qsort+0x66>
    9b38:	47 01       	movw	r8, r14
    9b3a:	e9 85       	ldd	r30, Y+9	; 0x09
    9b3c:	fa 85       	ldd	r31, Y+10	; 0x0a
    9b3e:	8e 1a       	sub	r8, r30
    9b40:	9f 0a       	sbc	r9, r31
    9b42:	b7 01       	movw	r22, r14
    9b44:	c4 01       	movw	r24, r8
    9b46:	f6 01       	movw	r30, r12
    9b48:	19 95       	eicall
    9b4a:	18 16       	cp	r1, r24
    9b4c:	19 06       	cpc	r1, r25
    9b4e:	7c f7       	brge	.-34     	; 0x9b2e <qsort+0x76>
    9b50:	49 85       	ldd	r20, Y+9	; 0x09
    9b52:	5a 85       	ldd	r21, Y+10	; 0x0a
    9b54:	b4 01       	movw	r22, r8
    9b56:	c7 01       	movw	r24, r14
    9b58:	0e 94 15 4d 	call	0x9a2a	; 0x9a2a <swapfunc>
    9b5c:	74 01       	movw	r14, r8
    9b5e:	e4 cf       	rjmp	.-56     	; 0x9b28 <qsort+0x70>
    9b60:	c7 01       	movw	r24, r14
    9b62:	96 95       	lsr	r25
    9b64:	87 95       	ror	r24
    9b66:	29 85       	ldd	r18, Y+9	; 0x09
    9b68:	3a 85       	ldd	r19, Y+10	; 0x0a
    9b6a:	82 9f       	mul	r24, r18
    9b6c:	50 01       	movw	r10, r0
    9b6e:	83 9f       	mul	r24, r19
    9b70:	b0 0c       	add	r11, r0
    9b72:	92 9f       	mul	r25, r18
    9b74:	b0 0c       	add	r11, r0
    9b76:	11 24       	eor	r1, r1
    9b78:	a0 0e       	add	r10, r16
    9b7a:	b1 1e       	adc	r11, r17
    9b7c:	a7 01       	movw	r20, r14
    9b7e:	41 50       	subi	r20, 0x01	; 1
    9b80:	51 09       	sbc	r21, r1
    9b82:	4b 83       	std	Y+3, r20	; 0x03
    9b84:	5c 83       	std	Y+4, r21	; 0x04
    9b86:	57 e0       	ldi	r21, 0x07	; 7
    9b88:	e5 16       	cp	r14, r21
    9b8a:	f1 04       	cpc	r15, r1
    9b8c:	09 f4       	brne	.+2      	; 0x9b90 <qsort+0xd8>
    9b8e:	4c c0       	rjmp	.+152    	; 0x9c28 <qsort+0x170>
    9b90:	8b 81       	ldd	r24, Y+3	; 0x03
    9b92:	9c 81       	ldd	r25, Y+4	; 0x04
    9b94:	82 9f       	mul	r24, r18
    9b96:	30 01       	movw	r6, r0
    9b98:	83 9f       	mul	r24, r19
    9b9a:	70 0c       	add	r7, r0
    9b9c:	92 9f       	mul	r25, r18
    9b9e:	70 0c       	add	r7, r0
    9ba0:	11 24       	eor	r1, r1
    9ba2:	60 0e       	add	r6, r16
    9ba4:	71 1e       	adc	r7, r17
    9ba6:	99 e2       	ldi	r25, 0x29	; 41
    9ba8:	e9 16       	cp	r14, r25
    9baa:	f1 04       	cpc	r15, r1
    9bac:	a8 f1       	brcs	.+106    	; 0x9c18 <qsort+0x160>
    9bae:	c7 01       	movw	r24, r14
    9bb0:	43 e0       	ldi	r20, 0x03	; 3
    9bb2:	96 95       	lsr	r25
    9bb4:	87 95       	ror	r24
    9bb6:	4a 95       	dec	r20
    9bb8:	e1 f7       	brne	.-8      	; 0x9bb2 <qsort+0xfa>
    9bba:	82 9f       	mul	r24, r18
    9bbc:	40 01       	movw	r8, r0
    9bbe:	83 9f       	mul	r24, r19
    9bc0:	90 0c       	add	r9, r0
    9bc2:	92 9f       	mul	r25, r18
    9bc4:	90 0c       	add	r9, r0
    9bc6:	11 24       	eor	r1, r1
    9bc8:	14 01       	movw	r2, r8
    9bca:	22 0c       	add	r2, r2
    9bcc:	33 1c       	adc	r3, r3
    9bce:	a8 01       	movw	r20, r16
    9bd0:	42 0d       	add	r20, r2
    9bd2:	53 1d       	adc	r21, r3
    9bd4:	b8 01       	movw	r22, r16
    9bd6:	68 0d       	add	r22, r8
    9bd8:	79 1d       	adc	r23, r9
    9bda:	96 01       	movw	r18, r12
    9bdc:	c8 01       	movw	r24, r16
    9bde:	0e 94 21 4d 	call	0x9a42	; 0x9a42 <med3>
    9be2:	2c 01       	movw	r4, r24
    9be4:	a5 01       	movw	r20, r10
    9be6:	48 0d       	add	r20, r8
    9be8:	59 1d       	adc	r21, r9
    9bea:	91 94       	neg	r9
    9bec:	81 94       	neg	r8
    9bee:	91 08       	sbc	r9, r1
    9bf0:	96 01       	movw	r18, r12
    9bf2:	b5 01       	movw	r22, r10
    9bf4:	c5 01       	movw	r24, r10
    9bf6:	88 0d       	add	r24, r8
    9bf8:	99 1d       	adc	r25, r9
    9bfa:	0e 94 21 4d 	call	0x9a42	; 0x9a42 <med3>
    9bfe:	5c 01       	movw	r10, r24
    9c00:	b3 01       	movw	r22, r6
    9c02:	68 0d       	add	r22, r8
    9c04:	79 1d       	adc	r23, r9
    9c06:	96 01       	movw	r18, r12
    9c08:	a3 01       	movw	r20, r6
    9c0a:	c3 01       	movw	r24, r6
    9c0c:	82 19       	sub	r24, r2
    9c0e:	93 09       	sbc	r25, r3
    9c10:	0e 94 21 4d 	call	0x9a42	; 0x9a42 <med3>
    9c14:	3c 01       	movw	r6, r24
    9c16:	01 c0       	rjmp	.+2      	; 0x9c1a <qsort+0x162>
    9c18:	28 01       	movw	r4, r16
    9c1a:	96 01       	movw	r18, r12
    9c1c:	a3 01       	movw	r20, r6
    9c1e:	b5 01       	movw	r22, r10
    9c20:	c2 01       	movw	r24, r4
    9c22:	0e 94 21 4d 	call	0x9a42	; 0x9a42 <med3>
    9c26:	5c 01       	movw	r10, r24
    9c28:	49 85       	ldd	r20, Y+9	; 0x09
    9c2a:	5a 85       	ldd	r21, Y+10	; 0x0a
    9c2c:	b5 01       	movw	r22, r10
    9c2e:	c8 01       	movw	r24, r16
    9c30:	0e 94 15 4d 	call	0x9a2a	; 0x9a2a <swapfunc>
    9c34:	69 80       	ldd	r6, Y+1	; 0x01
    9c36:	7a 80       	ldd	r7, Y+2	; 0x02
    9c38:	2b 81       	ldd	r18, Y+3	; 0x03
    9c3a:	3c 81       	ldd	r19, Y+4	; 0x04
    9c3c:	49 85       	ldd	r20, Y+9	; 0x09
    9c3e:	5a 85       	ldd	r21, Y+10	; 0x0a
    9c40:	24 9f       	mul	r18, r20
    9c42:	f0 01       	movw	r30, r0
    9c44:	25 9f       	mul	r18, r21
    9c46:	f0 0d       	add	r31, r0
    9c48:	34 9f       	mul	r19, r20
    9c4a:	f0 0d       	add	r31, r0
    9c4c:	11 24       	eor	r1, r1
    9c4e:	ed 83       	std	Y+5, r30	; 0x05
    9c50:	fe 83       	std	Y+6, r31	; 0x06
    9c52:	5f 01       	movw	r10, r30
    9c54:	a0 0e       	add	r10, r16
    9c56:	b1 1e       	adc	r11, r17
    9c58:	46 0d       	add	r20, r6
    9c5a:	57 1d       	adc	r21, r7
    9c5c:	4b 83       	std	Y+3, r20	; 0x03
    9c5e:	5c 83       	std	Y+4, r21	; 0x04
    9c60:	25 01       	movw	r4, r10
    9c62:	13 01       	movw	r2, r6
    9c64:	19 82       	std	Y+1, r1	; 0x01
    9c66:	1a 82       	std	Y+2, r1	; 0x02
    9c68:	8b 80       	ldd	r8, Y+3	; 0x03
    9c6a:	9c 80       	ldd	r9, Y+4	; 0x04
    9c6c:	89 85       	ldd	r24, Y+9	; 0x09
    9c6e:	9a 85       	ldd	r25, Y+10	; 0x0a
    9c70:	88 1a       	sub	r8, r24
    9c72:	99 0a       	sbc	r9, r25
    9c74:	a8 14       	cp	r10, r8
    9c76:	b9 04       	cpc	r11, r9
    9c78:	08 f4       	brcc	.+2      	; 0x9c7c <qsort+0x1c4>
    9c7a:	50 c0       	rjmp	.+160    	; 0x9d1c <qsort+0x264>
    9c7c:	b8 01       	movw	r22, r16
    9c7e:	c4 01       	movw	r24, r8
    9c80:	f6 01       	movw	r30, r12
    9c82:	19 95       	eicall
    9c84:	18 16       	cp	r1, r24
    9c86:	19 06       	cpc	r1, r25
    9c88:	c4 f1       	brlt	.+112    	; 0x9cfa <qsort+0x242>
    9c8a:	89 2b       	or	r24, r25
    9c8c:	71 f4       	brne	.+28     	; 0x9caa <qsort+0x1f2>
    9c8e:	49 85       	ldd	r20, Y+9	; 0x09
    9c90:	5a 85       	ldd	r21, Y+10	; 0x0a
    9c92:	b4 01       	movw	r22, r8
    9c94:	c1 01       	movw	r24, r2
    9c96:	0e 94 15 4d 	call	0x9a2a	; 0x9a2a <swapfunc>
    9c9a:	89 85       	ldd	r24, Y+9	; 0x09
    9c9c:	9a 85       	ldd	r25, Y+10	; 0x0a
    9c9e:	28 0e       	add	r2, r24
    9ca0:	39 1e       	adc	r3, r25
    9ca2:	e1 e0       	ldi	r30, 0x01	; 1
    9ca4:	f0 e0       	ldi	r31, 0x00	; 0
    9ca6:	e9 83       	std	Y+1, r30	; 0x01
    9ca8:	fa 83       	std	Y+2, r31	; 0x02
    9caa:	2b 81       	ldd	r18, Y+3	; 0x03
    9cac:	3c 81       	ldd	r19, Y+4	; 0x04
    9cae:	49 85       	ldd	r20, Y+9	; 0x09
    9cb0:	5a 85       	ldd	r21, Y+10	; 0x0a
    9cb2:	24 0f       	add	r18, r20
    9cb4:	35 1f       	adc	r19, r21
    9cb6:	2b 83       	std	Y+3, r18	; 0x03
    9cb8:	3c 83       	std	Y+4, r19	; 0x04
    9cba:	d6 cf       	rjmp	.-84     	; 0x9c68 <qsort+0x1b0>
    9cbc:	b8 01       	movw	r22, r16
    9cbe:	c5 01       	movw	r24, r10
    9cc0:	f6 01       	movw	r30, r12
    9cc2:	19 95       	eicall
    9cc4:	95 01       	movw	r18, r10
    9cc6:	49 85       	ldd	r20, Y+9	; 0x09
    9cc8:	5a 85       	ldd	r21, Y+10	; 0x0a
    9cca:	24 1b       	sub	r18, r20
    9ccc:	35 0b       	sbc	r19, r21
    9cce:	2f 83       	std	Y+7, r18	; 0x07
    9cd0:	38 87       	std	Y+8, r19	; 0x08
    9cd2:	97 fd       	sbrc	r25, 7
    9cd4:	16 c0       	rjmp	.+44     	; 0x9d02 <qsort+0x24a>
    9cd6:	89 2b       	or	r24, r25
    9cd8:	71 f4       	brne	.+28     	; 0x9cf6 <qsort+0x23e>
    9cda:	49 85       	ldd	r20, Y+9	; 0x09
    9cdc:	5a 85       	ldd	r21, Y+10	; 0x0a
    9cde:	b2 01       	movw	r22, r4
    9ce0:	c5 01       	movw	r24, r10
    9ce2:	0e 94 15 4d 	call	0x9a2a	; 0x9a2a <swapfunc>
    9ce6:	29 85       	ldd	r18, Y+9	; 0x09
    9ce8:	3a 85       	ldd	r19, Y+10	; 0x0a
    9cea:	42 1a       	sub	r4, r18
    9cec:	53 0a       	sbc	r5, r19
    9cee:	41 e0       	ldi	r20, 0x01	; 1
    9cf0:	50 e0       	ldi	r21, 0x00	; 0
    9cf2:	49 83       	std	Y+1, r20	; 0x01
    9cf4:	5a 83       	std	Y+2, r21	; 0x02
    9cf6:	af 80       	ldd	r10, Y+7	; 0x07
    9cf8:	b8 84       	ldd	r11, Y+8	; 0x08
    9cfa:	a8 14       	cp	r10, r8
    9cfc:	b9 04       	cpc	r11, r9
    9cfe:	f0 f6       	brcc	.-68     	; 0x9cbc <qsort+0x204>
    9d00:	0d c0       	rjmp	.+26     	; 0x9d1c <qsort+0x264>
    9d02:	49 85       	ldd	r20, Y+9	; 0x09
    9d04:	5a 85       	ldd	r21, Y+10	; 0x0a
    9d06:	b5 01       	movw	r22, r10
    9d08:	c4 01       	movw	r24, r8
    9d0a:	0e 94 15 4d 	call	0x9a2a	; 0x9a2a <swapfunc>
    9d0e:	af 80       	ldd	r10, Y+7	; 0x07
    9d10:	b8 84       	ldd	r11, Y+8	; 0x08
    9d12:	41 e0       	ldi	r20, 0x01	; 1
    9d14:	50 e0       	ldi	r21, 0x00	; 0
    9d16:	49 83       	std	Y+1, r20	; 0x01
    9d18:	5a 83       	std	Y+2, r21	; 0x02
    9d1a:	c7 cf       	rjmp	.-114    	; 0x9caa <qsort+0x1f2>
    9d1c:	89 81       	ldd	r24, Y+1	; 0x01
    9d1e:	9a 81       	ldd	r25, Y+2	; 0x02
    9d20:	89 2b       	or	r24, r25
    9d22:	09 f4       	brne	.+2      	; 0x9d26 <qsort+0x26e>
    9d24:	4f c0       	rjmp	.+158    	; 0x9dc4 <qsort+0x30c>
    9d26:	6d 80       	ldd	r6, Y+5	; 0x05
    9d28:	7e 80       	ldd	r7, Y+6	; 0x06
    9d2a:	29 85       	ldd	r18, Y+9	; 0x09
    9d2c:	3a 85       	ldd	r19, Y+10	; 0x0a
    9d2e:	62 0e       	add	r6, r18
    9d30:	73 1e       	adc	r7, r19
    9d32:	60 0e       	add	r6, r16
    9d34:	71 1e       	adc	r7, r17
    9d36:	74 01       	movw	r14, r8
    9d38:	e2 18       	sub	r14, r2
    9d3a:	f3 08       	sbc	r15, r3
    9d3c:	a1 01       	movw	r20, r2
    9d3e:	40 1b       	sub	r20, r16
    9d40:	51 0b       	sbc	r21, r17
    9d42:	e4 16       	cp	r14, r20
    9d44:	f5 06       	cpc	r15, r21
    9d46:	0c f4       	brge	.+2      	; 0x9d4a <qsort+0x292>
    9d48:	a7 01       	movw	r20, r14
    9d4a:	14 16       	cp	r1, r20
    9d4c:	15 06       	cpc	r1, r21
    9d4e:	34 f4       	brge	.+12     	; 0x9d5c <qsort+0x2a4>
    9d50:	b4 01       	movw	r22, r8
    9d52:	64 1b       	sub	r22, r20
    9d54:	75 0b       	sbc	r23, r21
    9d56:	c8 01       	movw	r24, r16
    9d58:	0e 94 15 4d 	call	0x9a2a	; 0x9a2a <swapfunc>
    9d5c:	a2 01       	movw	r20, r4
    9d5e:	4a 19       	sub	r20, r10
    9d60:	5b 09       	sbc	r21, r11
    9d62:	5a 01       	movw	r10, r20
    9d64:	a3 01       	movw	r20, r6
    9d66:	44 19       	sub	r20, r4
    9d68:	55 09       	sbc	r21, r5
    9d6a:	89 85       	ldd	r24, Y+9	; 0x09
    9d6c:	9a 85       	ldd	r25, Y+10	; 0x0a
    9d6e:	48 1b       	sub	r20, r24
    9d70:	59 0b       	sbc	r21, r25
    9d72:	a4 16       	cp	r10, r20
    9d74:	b5 06       	cpc	r11, r21
    9d76:	08 f4       	brcc	.+2      	; 0x9d7a <qsort+0x2c2>
    9d78:	a5 01       	movw	r20, r10
    9d7a:	14 16       	cp	r1, r20
    9d7c:	15 06       	cpc	r1, r21
    9d7e:	34 f4       	brge	.+12     	; 0x9d8c <qsort+0x2d4>
    9d80:	b3 01       	movw	r22, r6
    9d82:	64 1b       	sub	r22, r20
    9d84:	75 0b       	sbc	r23, r21
    9d86:	c4 01       	movw	r24, r8
    9d88:	0e 94 15 4d 	call	0x9a2a	; 0x9a2a <swapfunc>
    9d8c:	e9 85       	ldd	r30, Y+9	; 0x09
    9d8e:	fa 85       	ldd	r31, Y+10	; 0x0a
    9d90:	ee 15       	cp	r30, r14
    9d92:	ff 05       	cpc	r31, r15
    9d94:	48 f4       	brcc	.+18     	; 0x9da8 <qsort+0x2f0>
    9d96:	c7 01       	movw	r24, r14
    9d98:	bf 01       	movw	r22, r30
    9d9a:	0e 94 88 4b 	call	0x9710	; 0x9710 <__udivmodhi4>
    9d9e:	96 01       	movw	r18, r12
    9da0:	af 01       	movw	r20, r30
    9da2:	c8 01       	movw	r24, r16
    9da4:	0e 94 5c 4d 	call	0x9ab8	; 0x9ab8 <qsort>
    9da8:	29 85       	ldd	r18, Y+9	; 0x09
    9daa:	3a 85       	ldd	r19, Y+10	; 0x0a
    9dac:	2a 15       	cp	r18, r10
    9dae:	3b 05       	cpc	r19, r11
    9db0:	a0 f5       	brcc	.+104    	; 0x9e1a <qsort+0x362>
    9db2:	83 01       	movw	r16, r6
    9db4:	0a 19       	sub	r16, r10
    9db6:	1b 09       	sbc	r17, r11
    9db8:	c5 01       	movw	r24, r10
    9dba:	b9 01       	movw	r22, r18
    9dbc:	0e 94 88 4b 	call	0x9710	; 0x9710 <__udivmodhi4>
    9dc0:	7b 01       	movw	r14, r22
    9dc2:	96 ce       	rjmp	.-724    	; 0x9af0 <qsort+0x38>
    9dc4:	e9 85       	ldd	r30, Y+9	; 0x09
    9dc6:	fa 85       	ldd	r31, Y+10	; 0x0a
    9dc8:	ee 9e       	mul	r14, r30
    9dca:	50 01       	movw	r10, r0
    9dcc:	ef 9e       	mul	r14, r31
    9dce:	b0 0c       	add	r11, r0
    9dd0:	fe 9e       	mul	r15, r30
    9dd2:	b0 0c       	add	r11, r0
    9dd4:	11 24       	eor	r1, r1
    9dd6:	a0 0e       	add	r10, r16
    9dd8:	b1 1e       	adc	r11, r17
    9dda:	6a 14       	cp	r6, r10
    9ddc:	7b 04       	cpc	r7, r11
    9dde:	e8 f4       	brcc	.+58     	; 0x9e1a <qsort+0x362>
    9de0:	73 01       	movw	r14, r6
    9de2:	0e 15       	cp	r16, r14
    9de4:	1f 05       	cpc	r17, r15
    9de6:	28 f0       	brcs	.+10     	; 0x9df2 <qsort+0x33a>
    9de8:	89 85       	ldd	r24, Y+9	; 0x09
    9dea:	9a 85       	ldd	r25, Y+10	; 0x0a
    9dec:	68 0e       	add	r6, r24
    9dee:	79 1e       	adc	r7, r25
    9df0:	f4 cf       	rjmp	.-24     	; 0x9dda <qsort+0x322>
    9df2:	47 01       	movw	r8, r14
    9df4:	e9 85       	ldd	r30, Y+9	; 0x09
    9df6:	fa 85       	ldd	r31, Y+10	; 0x0a
    9df8:	8e 1a       	sub	r8, r30
    9dfa:	9f 0a       	sbc	r9, r31
    9dfc:	b7 01       	movw	r22, r14
    9dfe:	c4 01       	movw	r24, r8
    9e00:	f6 01       	movw	r30, r12
    9e02:	19 95       	eicall
    9e04:	18 16       	cp	r1, r24
    9e06:	19 06       	cpc	r1, r25
    9e08:	7c f7       	brge	.-34     	; 0x9de8 <qsort+0x330>
    9e0a:	49 85       	ldd	r20, Y+9	; 0x09
    9e0c:	5a 85       	ldd	r21, Y+10	; 0x0a
    9e0e:	b4 01       	movw	r22, r8
    9e10:	c7 01       	movw	r24, r14
    9e12:	0e 94 15 4d 	call	0x9a2a	; 0x9a2a <swapfunc>
    9e16:	74 01       	movw	r14, r8
    9e18:	e4 cf       	rjmp	.-56     	; 0x9de2 <qsort+0x32a>
    9e1a:	2a 96       	adiw	r28, 0x0a	; 10
    9e1c:	cd bf       	out	0x3d, r28	; 61
    9e1e:	de bf       	out	0x3e, r29	; 62
    9e20:	df 91       	pop	r29
    9e22:	cf 91       	pop	r28
    9e24:	1f 91       	pop	r17
    9e26:	0f 91       	pop	r16
    9e28:	ff 90       	pop	r15
    9e2a:	ef 90       	pop	r14
    9e2c:	df 90       	pop	r13
    9e2e:	cf 90       	pop	r12
    9e30:	bf 90       	pop	r11
    9e32:	af 90       	pop	r10
    9e34:	9f 90       	pop	r9
    9e36:	8f 90       	pop	r8
    9e38:	7f 90       	pop	r7
    9e3a:	6f 90       	pop	r6
    9e3c:	5f 90       	pop	r5
    9e3e:	4f 90       	pop	r4
    9e40:	3f 90       	pop	r3
    9e42:	2f 90       	pop	r2
    9e44:	08 95       	ret

00009e46 <atof>:
    9e46:	66 27       	eor	r22, r22
    9e48:	77 27       	eor	r23, r23
    9e4a:	0c 94 d2 51 	jmp	0xa3a4	; 0xa3a4 <strtod>

00009e4e <__ftoa_engine>:
    9e4e:	28 30       	cpi	r18, 0x08	; 8
    9e50:	08 f0       	brcs	.+2      	; 0x9e54 <__ftoa_engine+0x6>
    9e52:	27 e0       	ldi	r18, 0x07	; 7
    9e54:	33 27       	eor	r19, r19
    9e56:	da 01       	movw	r26, r20
    9e58:	99 0f       	add	r25, r25
    9e5a:	31 1d       	adc	r19, r1
    9e5c:	87 fd       	sbrc	r24, 7
    9e5e:	91 60       	ori	r25, 0x01	; 1
    9e60:	00 96       	adiw	r24, 0x00	; 0
    9e62:	61 05       	cpc	r22, r1
    9e64:	71 05       	cpc	r23, r1
    9e66:	39 f4       	brne	.+14     	; 0x9e76 <__ftoa_engine+0x28>
    9e68:	32 60       	ori	r19, 0x02	; 2
    9e6a:	2e 5f       	subi	r18, 0xFE	; 254
    9e6c:	3d 93       	st	X+, r19
    9e6e:	30 e3       	ldi	r19, 0x30	; 48
    9e70:	2a 95       	dec	r18
    9e72:	e1 f7       	brne	.-8      	; 0x9e6c <__ftoa_engine+0x1e>
    9e74:	08 95       	ret
    9e76:	9f 3f       	cpi	r25, 0xFF	; 255
    9e78:	30 f0       	brcs	.+12     	; 0x9e86 <__ftoa_engine+0x38>
    9e7a:	80 38       	cpi	r24, 0x80	; 128
    9e7c:	71 05       	cpc	r23, r1
    9e7e:	61 05       	cpc	r22, r1
    9e80:	09 f0       	breq	.+2      	; 0x9e84 <__ftoa_engine+0x36>
    9e82:	3c 5f       	subi	r19, 0xFC	; 252
    9e84:	3c 5f       	subi	r19, 0xFC	; 252
    9e86:	3d 93       	st	X+, r19
    9e88:	91 30       	cpi	r25, 0x01	; 1
    9e8a:	08 f0       	brcs	.+2      	; 0x9e8e <__ftoa_engine+0x40>
    9e8c:	80 68       	ori	r24, 0x80	; 128
    9e8e:	91 1d       	adc	r25, r1
    9e90:	df 93       	push	r29
    9e92:	cf 93       	push	r28
    9e94:	1f 93       	push	r17
    9e96:	0f 93       	push	r16
    9e98:	ff 92       	push	r15
    9e9a:	ef 92       	push	r14
    9e9c:	19 2f       	mov	r17, r25
    9e9e:	98 7f       	andi	r25, 0xF8	; 248
    9ea0:	96 95       	lsr	r25
    9ea2:	e9 2f       	mov	r30, r25
    9ea4:	96 95       	lsr	r25
    9ea6:	96 95       	lsr	r25
    9ea8:	e9 0f       	add	r30, r25
    9eaa:	ff 27       	eor	r31, r31
    9eac:	e6 56       	subi	r30, 0x66	; 102
    9eae:	fd 4f       	sbci	r31, 0xFD	; 253
    9eb0:	99 27       	eor	r25, r25
    9eb2:	33 27       	eor	r19, r19
    9eb4:	ee 24       	eor	r14, r14
    9eb6:	ff 24       	eor	r15, r15
    9eb8:	a7 01       	movw	r20, r14
    9eba:	e7 01       	movw	r28, r14
    9ebc:	05 90       	lpm	r0, Z+
    9ebe:	08 94       	sec
    9ec0:	07 94       	ror	r0
    9ec2:	28 f4       	brcc	.+10     	; 0x9ece <__ftoa_engine+0x80>
    9ec4:	36 0f       	add	r19, r22
    9ec6:	e7 1e       	adc	r14, r23
    9ec8:	f8 1e       	adc	r15, r24
    9eca:	49 1f       	adc	r20, r25
    9ecc:	51 1d       	adc	r21, r1
    9ece:	66 0f       	add	r22, r22
    9ed0:	77 1f       	adc	r23, r23
    9ed2:	88 1f       	adc	r24, r24
    9ed4:	99 1f       	adc	r25, r25
    9ed6:	06 94       	lsr	r0
    9ed8:	a1 f7       	brne	.-24     	; 0x9ec2 <__ftoa_engine+0x74>
    9eda:	05 90       	lpm	r0, Z+
    9edc:	07 94       	ror	r0
    9ede:	28 f4       	brcc	.+10     	; 0x9eea <__ftoa_engine+0x9c>
    9ee0:	e7 0e       	add	r14, r23
    9ee2:	f8 1e       	adc	r15, r24
    9ee4:	49 1f       	adc	r20, r25
    9ee6:	56 1f       	adc	r21, r22
    9ee8:	c1 1d       	adc	r28, r1
    9eea:	77 0f       	add	r23, r23
    9eec:	88 1f       	adc	r24, r24
    9eee:	99 1f       	adc	r25, r25
    9ef0:	66 1f       	adc	r22, r22
    9ef2:	06 94       	lsr	r0
    9ef4:	a1 f7       	brne	.-24     	; 0x9ede <__ftoa_engine+0x90>
    9ef6:	05 90       	lpm	r0, Z+
    9ef8:	07 94       	ror	r0
    9efa:	28 f4       	brcc	.+10     	; 0x9f06 <__ftoa_engine+0xb8>
    9efc:	f8 0e       	add	r15, r24
    9efe:	49 1f       	adc	r20, r25
    9f00:	56 1f       	adc	r21, r22
    9f02:	c7 1f       	adc	r28, r23
    9f04:	d1 1d       	adc	r29, r1
    9f06:	88 0f       	add	r24, r24
    9f08:	99 1f       	adc	r25, r25
    9f0a:	66 1f       	adc	r22, r22
    9f0c:	77 1f       	adc	r23, r23
    9f0e:	06 94       	lsr	r0
    9f10:	a1 f7       	brne	.-24     	; 0x9efa <__ftoa_engine+0xac>
    9f12:	05 90       	lpm	r0, Z+
    9f14:	07 94       	ror	r0
    9f16:	20 f4       	brcc	.+8      	; 0x9f20 <__ftoa_engine+0xd2>
    9f18:	49 0f       	add	r20, r25
    9f1a:	56 1f       	adc	r21, r22
    9f1c:	c7 1f       	adc	r28, r23
    9f1e:	d8 1f       	adc	r29, r24
    9f20:	99 0f       	add	r25, r25
    9f22:	66 1f       	adc	r22, r22
    9f24:	77 1f       	adc	r23, r23
    9f26:	88 1f       	adc	r24, r24
    9f28:	06 94       	lsr	r0
    9f2a:	a9 f7       	brne	.-22     	; 0x9f16 <__ftoa_engine+0xc8>
    9f2c:	84 91       	lpm	r24, Z
    9f2e:	10 95       	com	r17
    9f30:	17 70       	andi	r17, 0x07	; 7
    9f32:	41 f0       	breq	.+16     	; 0x9f44 <__ftoa_engine+0xf6>
    9f34:	d6 95       	lsr	r29
    9f36:	c7 95       	ror	r28
    9f38:	57 95       	ror	r21
    9f3a:	47 95       	ror	r20
    9f3c:	f7 94       	ror	r15
    9f3e:	e7 94       	ror	r14
    9f40:	1a 95       	dec	r17
    9f42:	c1 f7       	brne	.-16     	; 0x9f34 <__ftoa_engine+0xe6>
    9f44:	e0 e4       	ldi	r30, 0x40	; 64
    9f46:	f2 e0       	ldi	r31, 0x02	; 2
    9f48:	68 94       	set
    9f4a:	15 90       	lpm	r1, Z+
    9f4c:	15 91       	lpm	r17, Z+
    9f4e:	35 91       	lpm	r19, Z+
    9f50:	65 91       	lpm	r22, Z+
    9f52:	95 91       	lpm	r25, Z+
    9f54:	05 90       	lpm	r0, Z+
    9f56:	7f e2       	ldi	r23, 0x2F	; 47
    9f58:	73 95       	inc	r23
    9f5a:	e1 18       	sub	r14, r1
    9f5c:	f1 0a       	sbc	r15, r17
    9f5e:	43 0b       	sbc	r20, r19
    9f60:	56 0b       	sbc	r21, r22
    9f62:	c9 0b       	sbc	r28, r25
    9f64:	d0 09       	sbc	r29, r0
    9f66:	c0 f7       	brcc	.-16     	; 0x9f58 <__ftoa_engine+0x10a>
    9f68:	e1 0c       	add	r14, r1
    9f6a:	f1 1e       	adc	r15, r17
    9f6c:	43 1f       	adc	r20, r19
    9f6e:	56 1f       	adc	r21, r22
    9f70:	c9 1f       	adc	r28, r25
    9f72:	d0 1d       	adc	r29, r0
    9f74:	7e f4       	brtc	.+30     	; 0x9f94 <__ftoa_engine+0x146>
    9f76:	70 33       	cpi	r23, 0x30	; 48
    9f78:	11 f4       	brne	.+4      	; 0x9f7e <__ftoa_engine+0x130>
    9f7a:	8a 95       	dec	r24
    9f7c:	e6 cf       	rjmp	.-52     	; 0x9f4a <__ftoa_engine+0xfc>
    9f7e:	e8 94       	clt
    9f80:	01 50       	subi	r16, 0x01	; 1
    9f82:	30 f0       	brcs	.+12     	; 0x9f90 <__ftoa_engine+0x142>
    9f84:	08 0f       	add	r16, r24
    9f86:	0a f4       	brpl	.+2      	; 0x9f8a <__ftoa_engine+0x13c>
    9f88:	00 27       	eor	r16, r16
    9f8a:	02 17       	cp	r16, r18
    9f8c:	08 f4       	brcc	.+2      	; 0x9f90 <__ftoa_engine+0x142>
    9f8e:	20 2f       	mov	r18, r16
    9f90:	23 95       	inc	r18
    9f92:	02 2f       	mov	r16, r18
    9f94:	7a 33       	cpi	r23, 0x3A	; 58
    9f96:	28 f0       	brcs	.+10     	; 0x9fa2 <__ftoa_engine+0x154>
    9f98:	79 e3       	ldi	r23, 0x39	; 57
    9f9a:	7d 93       	st	X+, r23
    9f9c:	2a 95       	dec	r18
    9f9e:	e9 f7       	brne	.-6      	; 0x9f9a <__ftoa_engine+0x14c>
    9fa0:	10 c0       	rjmp	.+32     	; 0x9fc2 <__ftoa_engine+0x174>
    9fa2:	7d 93       	st	X+, r23
    9fa4:	2a 95       	dec	r18
    9fa6:	89 f6       	brne	.-94     	; 0x9f4a <__ftoa_engine+0xfc>
    9fa8:	06 94       	lsr	r0
    9faa:	97 95       	ror	r25
    9fac:	67 95       	ror	r22
    9fae:	37 95       	ror	r19
    9fb0:	17 95       	ror	r17
    9fb2:	17 94       	ror	r1
    9fb4:	e1 18       	sub	r14, r1
    9fb6:	f1 0a       	sbc	r15, r17
    9fb8:	43 0b       	sbc	r20, r19
    9fba:	56 0b       	sbc	r21, r22
    9fbc:	c9 0b       	sbc	r28, r25
    9fbe:	d0 09       	sbc	r29, r0
    9fc0:	98 f0       	brcs	.+38     	; 0x9fe8 <__ftoa_engine+0x19a>
    9fc2:	23 95       	inc	r18
    9fc4:	7e 91       	ld	r23, -X
    9fc6:	73 95       	inc	r23
    9fc8:	7a 33       	cpi	r23, 0x3A	; 58
    9fca:	08 f0       	brcs	.+2      	; 0x9fce <__ftoa_engine+0x180>
    9fcc:	70 e3       	ldi	r23, 0x30	; 48
    9fce:	7c 93       	st	X, r23
    9fd0:	20 13       	cpse	r18, r16
    9fd2:	b8 f7       	brcc	.-18     	; 0x9fc2 <__ftoa_engine+0x174>
    9fd4:	7e 91       	ld	r23, -X
    9fd6:	70 61       	ori	r23, 0x10	; 16
    9fd8:	7d 93       	st	X+, r23
    9fda:	30 f0       	brcs	.+12     	; 0x9fe8 <__ftoa_engine+0x19a>
    9fdc:	83 95       	inc	r24
    9fde:	71 e3       	ldi	r23, 0x31	; 49
    9fe0:	7d 93       	st	X+, r23
    9fe2:	70 e3       	ldi	r23, 0x30	; 48
    9fe4:	2a 95       	dec	r18
    9fe6:	e1 f7       	brne	.-8      	; 0x9fe0 <__ftoa_engine+0x192>
    9fe8:	11 24       	eor	r1, r1
    9fea:	ef 90       	pop	r14
    9fec:	ff 90       	pop	r15
    9fee:	0f 91       	pop	r16
    9ff0:	1f 91       	pop	r17
    9ff2:	cf 91       	pop	r28
    9ff4:	df 91       	pop	r29
    9ff6:	99 27       	eor	r25, r25
    9ff8:	87 fd       	sbrc	r24, 7
    9ffa:	90 95       	com	r25
    9ffc:	08 95       	ret

00009ffe <strnlen_P>:
    9ffe:	fc 01       	movw	r30, r24
    a000:	05 90       	lpm	r0, Z+
    a002:	61 50       	subi	r22, 0x01	; 1
    a004:	70 40       	sbci	r23, 0x00	; 0
    a006:	01 10       	cpse	r0, r1
    a008:	d8 f7       	brcc	.-10     	; 0xa000 <__stack+0x1>
    a00a:	80 95       	com	r24
    a00c:	90 95       	com	r25
    a00e:	8e 0f       	add	r24, r30
    a010:	9f 1f       	adc	r25, r31
    a012:	08 95       	ret

0000a014 <strtok>:
    a014:	4c ee       	ldi	r20, 0xEC	; 236
    a016:	58 e2       	ldi	r21, 0x28	; 40
    a018:	0c 94 4a 50 	jmp	0xa094	; 0xa094 <strtok_r>

0000a01c <memcpy>:
    a01c:	fb 01       	movw	r30, r22
    a01e:	dc 01       	movw	r26, r24
    a020:	02 c0       	rjmp	.+4      	; 0xa026 <memcpy+0xa>
    a022:	01 90       	ld	r0, Z+
    a024:	0d 92       	st	X+, r0
    a026:	41 50       	subi	r20, 0x01	; 1
    a028:	50 40       	sbci	r21, 0x00	; 0
    a02a:	d8 f7       	brcc	.-10     	; 0xa022 <memcpy+0x6>
    a02c:	08 95       	ret

0000a02e <memset>:
    a02e:	dc 01       	movw	r26, r24
    a030:	01 c0       	rjmp	.+2      	; 0xa034 <memset+0x6>
    a032:	6d 93       	st	X+, r22
    a034:	41 50       	subi	r20, 0x01	; 1
    a036:	50 40       	sbci	r21, 0x00	; 0
    a038:	e0 f7       	brcc	.-8      	; 0xa032 <memset+0x4>
    a03a:	08 95       	ret

0000a03c <strcpy>:
    a03c:	fb 01       	movw	r30, r22
    a03e:	dc 01       	movw	r26, r24
    a040:	01 90       	ld	r0, Z+
    a042:	0d 92       	st	X+, r0
    a044:	00 20       	and	r0, r0
    a046:	e1 f7       	brne	.-8      	; 0xa040 <strcpy+0x4>
    a048:	08 95       	ret

0000a04a <strnlen>:
    a04a:	fc 01       	movw	r30, r24
    a04c:	61 50       	subi	r22, 0x01	; 1
    a04e:	70 40       	sbci	r23, 0x00	; 0
    a050:	01 90       	ld	r0, Z+
    a052:	01 10       	cpse	r0, r1
    a054:	d8 f7       	brcc	.-10     	; 0xa04c <strnlen+0x2>
    a056:	80 95       	com	r24
    a058:	90 95       	com	r25
    a05a:	8e 0f       	add	r24, r30
    a05c:	9f 1f       	adc	r25, r31
    a05e:	08 95       	ret

0000a060 <strstr>:
    a060:	fb 01       	movw	r30, r22
    a062:	51 91       	ld	r21, Z+
    a064:	55 23       	and	r21, r21
    a066:	a9 f0       	breq	.+42     	; 0xa092 <strstr+0x32>
    a068:	bf 01       	movw	r22, r30
    a06a:	dc 01       	movw	r26, r24
    a06c:	4d 91       	ld	r20, X+
    a06e:	45 17       	cp	r20, r21
    a070:	41 11       	cpse	r20, r1
    a072:	e1 f7       	brne	.-8      	; 0xa06c <strstr+0xc>
    a074:	59 f4       	brne	.+22     	; 0xa08c <strstr+0x2c>
    a076:	cd 01       	movw	r24, r26
    a078:	01 90       	ld	r0, Z+
    a07a:	00 20       	and	r0, r0
    a07c:	49 f0       	breq	.+18     	; 0xa090 <strstr+0x30>
    a07e:	4d 91       	ld	r20, X+
    a080:	40 15       	cp	r20, r0
    a082:	41 11       	cpse	r20, r1
    a084:	c9 f3       	breq	.-14     	; 0xa078 <strstr+0x18>
    a086:	fb 01       	movw	r30, r22
    a088:	41 11       	cpse	r20, r1
    a08a:	ef cf       	rjmp	.-34     	; 0xa06a <strstr+0xa>
    a08c:	81 e0       	ldi	r24, 0x01	; 1
    a08e:	90 e0       	ldi	r25, 0x00	; 0
    a090:	01 97       	sbiw	r24, 0x01	; 1
    a092:	08 95       	ret

0000a094 <strtok_r>:
    a094:	fa 01       	movw	r30, r20
    a096:	a1 91       	ld	r26, Z+
    a098:	b0 81       	ld	r27, Z
    a09a:	00 97       	sbiw	r24, 0x00	; 0
    a09c:	19 f4       	brne	.+6      	; 0xa0a4 <strtok_r+0x10>
    a09e:	10 97       	sbiw	r26, 0x00	; 0
    a0a0:	e1 f0       	breq	.+56     	; 0xa0da <strtok_r+0x46>
    a0a2:	cd 01       	movw	r24, r26
    a0a4:	dc 01       	movw	r26, r24
    a0a6:	cd 01       	movw	r24, r26
    a0a8:	0d 90       	ld	r0, X+
    a0aa:	00 20       	and	r0, r0
    a0ac:	11 f4       	brne	.+4      	; 0xa0b2 <strtok_r+0x1e>
    a0ae:	c0 01       	movw	r24, r0
    a0b0:	13 c0       	rjmp	.+38     	; 0xa0d8 <strtok_r+0x44>
    a0b2:	fb 01       	movw	r30, r22
    a0b4:	21 91       	ld	r18, Z+
    a0b6:	22 23       	and	r18, r18
    a0b8:	19 f0       	breq	.+6      	; 0xa0c0 <strtok_r+0x2c>
    a0ba:	20 15       	cp	r18, r0
    a0bc:	d9 f7       	brne	.-10     	; 0xa0b4 <strtok_r+0x20>
    a0be:	f3 cf       	rjmp	.-26     	; 0xa0a6 <strtok_r+0x12>
    a0c0:	fb 01       	movw	r30, r22
    a0c2:	21 91       	ld	r18, Z+
    a0c4:	20 15       	cp	r18, r0
    a0c6:	19 f4       	brne	.+6      	; 0xa0ce <strtok_r+0x3a>
    a0c8:	1e 92       	st	-X, r1
    a0ca:	11 96       	adiw	r26, 0x01	; 1
    a0cc:	06 c0       	rjmp	.+12     	; 0xa0da <strtok_r+0x46>
    a0ce:	22 23       	and	r18, r18
    a0d0:	c1 f7       	brne	.-16     	; 0xa0c2 <strtok_r+0x2e>
    a0d2:	0d 90       	ld	r0, X+
    a0d4:	00 20       	and	r0, r0
    a0d6:	a1 f7       	brne	.-24     	; 0xa0c0 <strtok_r+0x2c>
    a0d8:	d0 01       	movw	r26, r0
    a0da:	fa 01       	movw	r30, r20
    a0dc:	a1 93       	st	Z+, r26
    a0de:	b0 83       	st	Z, r27
    a0e0:	08 95       	ret

0000a0e2 <fgets>:
    a0e2:	cf 92       	push	r12
    a0e4:	df 92       	push	r13
    a0e6:	ef 92       	push	r14
    a0e8:	ff 92       	push	r15
    a0ea:	0f 93       	push	r16
    a0ec:	1f 93       	push	r17
    a0ee:	cf 93       	push	r28
    a0f0:	df 93       	push	r29
    a0f2:	fa 01       	movw	r30, r20
    a0f4:	23 81       	ldd	r18, Z+3	; 0x03
    a0f6:	20 fd       	sbrc	r18, 0
    a0f8:	03 c0       	rjmp	.+6      	; 0xa100 <fgets+0x1e>
    a0fa:	80 e0       	ldi	r24, 0x00	; 0
    a0fc:	90 e0       	ldi	r25, 0x00	; 0
    a0fe:	1a c0       	rjmp	.+52     	; 0xa134 <fgets+0x52>
    a100:	16 16       	cp	r1, r22
    a102:	17 06       	cpc	r1, r23
    a104:	d4 f7       	brge	.-12     	; 0xa0fa <fgets+0x18>
    a106:	7a 01       	movw	r14, r20
    a108:	8c 01       	movw	r16, r24
    a10a:	eb 01       	movw	r28, r22
    a10c:	6c 01       	movw	r12, r24
    a10e:	c1 30       	cpi	r28, 0x01	; 1
    a110:	d1 05       	cpc	r29, r1
    a112:	69 f0       	breq	.+26     	; 0xa12e <fgets+0x4c>
    a114:	c7 01       	movw	r24, r14
    a116:	0e 94 4f 53 	call	0xa69e	; 0xa69e <fgetc>
    a11a:	8f 3f       	cpi	r24, 0xFF	; 255
    a11c:	ff ef       	ldi	r31, 0xFF	; 255
    a11e:	9f 07       	cpc	r25, r31
    a120:	61 f3       	breq	.-40     	; 0xa0fa <fgets+0x18>
    a122:	f6 01       	movw	r30, r12
    a124:	81 93       	st	Z+, r24
    a126:	6f 01       	movw	r12, r30
    a128:	21 97       	sbiw	r28, 0x01	; 1
    a12a:	0a 97       	sbiw	r24, 0x0a	; 10
    a12c:	81 f7       	brne	.-32     	; 0xa10e <fgets+0x2c>
    a12e:	f6 01       	movw	r30, r12
    a130:	10 82       	st	Z, r1
    a132:	c8 01       	movw	r24, r16
    a134:	df 91       	pop	r29
    a136:	cf 91       	pop	r28
    a138:	1f 91       	pop	r17
    a13a:	0f 91       	pop	r16
    a13c:	ff 90       	pop	r15
    a13e:	ef 90       	pop	r14
    a140:	df 90       	pop	r13
    a142:	cf 90       	pop	r12
    a144:	08 95       	ret

0000a146 <fputc>:
    a146:	0f 93       	push	r16
    a148:	1f 93       	push	r17
    a14a:	cf 93       	push	r28
    a14c:	df 93       	push	r29
    a14e:	fb 01       	movw	r30, r22
    a150:	23 81       	ldd	r18, Z+3	; 0x03
    a152:	21 fd       	sbrc	r18, 1
    a154:	03 c0       	rjmp	.+6      	; 0xa15c <fputc+0x16>
    a156:	8f ef       	ldi	r24, 0xFF	; 255
    a158:	9f ef       	ldi	r25, 0xFF	; 255
    a15a:	2c c0       	rjmp	.+88     	; 0xa1b4 <fputc+0x6e>
    a15c:	22 ff       	sbrs	r18, 2
    a15e:	16 c0       	rjmp	.+44     	; 0xa18c <fputc+0x46>
    a160:	46 81       	ldd	r20, Z+6	; 0x06
    a162:	57 81       	ldd	r21, Z+7	; 0x07
    a164:	24 81       	ldd	r18, Z+4	; 0x04
    a166:	35 81       	ldd	r19, Z+5	; 0x05
    a168:	42 17       	cp	r20, r18
    a16a:	53 07       	cpc	r21, r19
    a16c:	44 f4       	brge	.+16     	; 0xa17e <fputc+0x38>
    a16e:	a0 81       	ld	r26, Z
    a170:	b1 81       	ldd	r27, Z+1	; 0x01
    a172:	9d 01       	movw	r18, r26
    a174:	2f 5f       	subi	r18, 0xFF	; 255
    a176:	3f 4f       	sbci	r19, 0xFF	; 255
    a178:	20 83       	st	Z, r18
    a17a:	31 83       	std	Z+1, r19	; 0x01
    a17c:	8c 93       	st	X, r24
    a17e:	26 81       	ldd	r18, Z+6	; 0x06
    a180:	37 81       	ldd	r19, Z+7	; 0x07
    a182:	2f 5f       	subi	r18, 0xFF	; 255
    a184:	3f 4f       	sbci	r19, 0xFF	; 255
    a186:	26 83       	std	Z+6, r18	; 0x06
    a188:	37 83       	std	Z+7, r19	; 0x07
    a18a:	14 c0       	rjmp	.+40     	; 0xa1b4 <fputc+0x6e>
    a18c:	8b 01       	movw	r16, r22
    a18e:	ec 01       	movw	r28, r24
    a190:	fb 01       	movw	r30, r22
    a192:	00 84       	ldd	r0, Z+8	; 0x08
    a194:	f1 85       	ldd	r31, Z+9	; 0x09
    a196:	e0 2d       	mov	r30, r0
    a198:	19 95       	eicall
    a19a:	89 2b       	or	r24, r25
    a19c:	e1 f6       	brne	.-72     	; 0xa156 <fputc+0x10>
    a19e:	d8 01       	movw	r26, r16
    a1a0:	16 96       	adiw	r26, 0x06	; 6
    a1a2:	8d 91       	ld	r24, X+
    a1a4:	9c 91       	ld	r25, X
    a1a6:	17 97       	sbiw	r26, 0x07	; 7
    a1a8:	01 96       	adiw	r24, 0x01	; 1
    a1aa:	16 96       	adiw	r26, 0x06	; 6
    a1ac:	8d 93       	st	X+, r24
    a1ae:	9c 93       	st	X, r25
    a1b0:	17 97       	sbiw	r26, 0x07	; 7
    a1b2:	ce 01       	movw	r24, r28
    a1b4:	df 91       	pop	r29
    a1b6:	cf 91       	pop	r28
    a1b8:	1f 91       	pop	r17
    a1ba:	0f 91       	pop	r16
    a1bc:	08 95       	ret

0000a1be <printf>:
    a1be:	cf 93       	push	r28
    a1c0:	df 93       	push	r29
    a1c2:	cd b7       	in	r28, 0x3d	; 61
    a1c4:	de b7       	in	r29, 0x3e	; 62
    a1c6:	ae 01       	movw	r20, r28
    a1c8:	4a 5f       	subi	r20, 0xFA	; 250
    a1ca:	5f 4f       	sbci	r21, 0xFF	; 255
    a1cc:	fa 01       	movw	r30, r20
    a1ce:	61 91       	ld	r22, Z+
    a1d0:	71 91       	ld	r23, Z+
    a1d2:	af 01       	movw	r20, r30
    a1d4:	80 91 7e 2e 	lds	r24, 0x2E7E	; 0x802e7e <__iob+0x2>
    a1d8:	90 91 7f 2e 	lds	r25, 0x2E7F	; 0x802e7f <__iob+0x3>
    a1dc:	0e 94 e8 47 	call	0x8fd0	; 0x8fd0 <vfprintf>
    a1e0:	df 91       	pop	r29
    a1e2:	cf 91       	pop	r28
    a1e4:	08 95       	ret

0000a1e6 <printf_P>:
    a1e6:	0f 93       	push	r16
    a1e8:	1f 93       	push	r17
    a1ea:	cf 93       	push	r28
    a1ec:	df 93       	push	r29
    a1ee:	cd b7       	in	r28, 0x3d	; 61
    a1f0:	de b7       	in	r29, 0x3e	; 62
    a1f2:	ae 01       	movw	r20, r28
    a1f4:	48 5f       	subi	r20, 0xF8	; 248
    a1f6:	5f 4f       	sbci	r21, 0xFF	; 255
    a1f8:	da 01       	movw	r26, r20
    a1fa:	6d 91       	ld	r22, X+
    a1fc:	7d 91       	ld	r23, X+
    a1fe:	ad 01       	movw	r20, r26
    a200:	0c e7       	ldi	r16, 0x7C	; 124
    a202:	1e e2       	ldi	r17, 0x2E	; 46
    a204:	f8 01       	movw	r30, r16
    a206:	82 81       	ldd	r24, Z+2	; 0x02
    a208:	93 81       	ldd	r25, Z+3	; 0x03
    a20a:	dc 01       	movw	r26, r24
    a20c:	13 96       	adiw	r26, 0x03	; 3
    a20e:	2c 91       	ld	r18, X
    a210:	13 97       	sbiw	r26, 0x03	; 3
    a212:	28 60       	ori	r18, 0x08	; 8
    a214:	13 96       	adiw	r26, 0x03	; 3
    a216:	2c 93       	st	X, r18
    a218:	0e 94 e8 47 	call	0x8fd0	; 0x8fd0 <vfprintf>
    a21c:	d8 01       	movw	r26, r16
    a21e:	12 96       	adiw	r26, 0x02	; 2
    a220:	ed 91       	ld	r30, X+
    a222:	fc 91       	ld	r31, X
    a224:	13 97       	sbiw	r26, 0x03	; 3
    a226:	23 81       	ldd	r18, Z+3	; 0x03
    a228:	27 7f       	andi	r18, 0xF7	; 247
    a22a:	23 83       	std	Z+3, r18	; 0x03
    a22c:	df 91       	pop	r29
    a22e:	cf 91       	pop	r28
    a230:	1f 91       	pop	r17
    a232:	0f 91       	pop	r16
    a234:	08 95       	ret

0000a236 <puts>:
    a236:	0f 93       	push	r16
    a238:	1f 93       	push	r17
    a23a:	cf 93       	push	r28
    a23c:	df 93       	push	r29
    a23e:	e0 91 7e 2e 	lds	r30, 0x2E7E	; 0x802e7e <__iob+0x2>
    a242:	f0 91 7f 2e 	lds	r31, 0x2E7F	; 0x802e7f <__iob+0x3>
    a246:	23 81       	ldd	r18, Z+3	; 0x03
    a248:	21 ff       	sbrs	r18, 1
    a24a:	1b c0       	rjmp	.+54     	; 0xa282 <puts+0x4c>
    a24c:	8c 01       	movw	r16, r24
    a24e:	d0 e0       	ldi	r29, 0x00	; 0
    a250:	c0 e0       	ldi	r28, 0x00	; 0
    a252:	f8 01       	movw	r30, r16
    a254:	81 91       	ld	r24, Z+
    a256:	8f 01       	movw	r16, r30
    a258:	60 91 7e 2e 	lds	r22, 0x2E7E	; 0x802e7e <__iob+0x2>
    a25c:	70 91 7f 2e 	lds	r23, 0x2E7F	; 0x802e7f <__iob+0x3>
    a260:	db 01       	movw	r26, r22
    a262:	18 96       	adiw	r26, 0x08	; 8
    a264:	ed 91       	ld	r30, X+
    a266:	fc 91       	ld	r31, X
    a268:	19 97       	sbiw	r26, 0x09	; 9
    a26a:	88 23       	and	r24, r24
    a26c:	31 f0       	breq	.+12     	; 0xa27a <puts+0x44>
    a26e:	19 95       	eicall
    a270:	89 2b       	or	r24, r25
    a272:	79 f3       	breq	.-34     	; 0xa252 <puts+0x1c>
    a274:	df ef       	ldi	r29, 0xFF	; 255
    a276:	cf ef       	ldi	r28, 0xFF	; 255
    a278:	ec cf       	rjmp	.-40     	; 0xa252 <puts+0x1c>
    a27a:	8a e0       	ldi	r24, 0x0A	; 10
    a27c:	19 95       	eicall
    a27e:	89 2b       	or	r24, r25
    a280:	19 f0       	breq	.+6      	; 0xa288 <puts+0x52>
    a282:	8f ef       	ldi	r24, 0xFF	; 255
    a284:	9f ef       	ldi	r25, 0xFF	; 255
    a286:	02 c0       	rjmp	.+4      	; 0xa28c <puts+0x56>
    a288:	8d 2f       	mov	r24, r29
    a28a:	9c 2f       	mov	r25, r28
    a28c:	df 91       	pop	r29
    a28e:	cf 91       	pop	r28
    a290:	1f 91       	pop	r17
    a292:	0f 91       	pop	r16
    a294:	08 95       	ret

0000a296 <sprintf>:
    a296:	0f 93       	push	r16
    a298:	1f 93       	push	r17
    a29a:	cf 93       	push	r28
    a29c:	df 93       	push	r29
    a29e:	cd b7       	in	r28, 0x3d	; 61
    a2a0:	de b7       	in	r29, 0x3e	; 62
    a2a2:	2e 97       	sbiw	r28, 0x0e	; 14
    a2a4:	cd bf       	out	0x3d, r28	; 61
    a2a6:	de bf       	out	0x3e, r29	; 62
    a2a8:	0e 89       	ldd	r16, Y+22	; 0x16
    a2aa:	1f 89       	ldd	r17, Y+23	; 0x17
    a2ac:	86 e0       	ldi	r24, 0x06	; 6
    a2ae:	8c 83       	std	Y+4, r24	; 0x04
    a2b0:	09 83       	std	Y+1, r16	; 0x01
    a2b2:	1a 83       	std	Y+2, r17	; 0x02
    a2b4:	8f ef       	ldi	r24, 0xFF	; 255
    a2b6:	9f e7       	ldi	r25, 0x7F	; 127
    a2b8:	8d 83       	std	Y+5, r24	; 0x05
    a2ba:	9e 83       	std	Y+6, r25	; 0x06
    a2bc:	ae 01       	movw	r20, r28
    a2be:	46 5e       	subi	r20, 0xE6	; 230
    a2c0:	5f 4f       	sbci	r21, 0xFF	; 255
    a2c2:	68 8d       	ldd	r22, Y+24	; 0x18
    a2c4:	79 8d       	ldd	r23, Y+25	; 0x19
    a2c6:	ce 01       	movw	r24, r28
    a2c8:	01 96       	adiw	r24, 0x01	; 1
    a2ca:	0e 94 e8 47 	call	0x8fd0	; 0x8fd0 <vfprintf>
    a2ce:	ef 81       	ldd	r30, Y+7	; 0x07
    a2d0:	f8 85       	ldd	r31, Y+8	; 0x08
    a2d2:	e0 0f       	add	r30, r16
    a2d4:	f1 1f       	adc	r31, r17
    a2d6:	10 82       	st	Z, r1
    a2d8:	2e 96       	adiw	r28, 0x0e	; 14
    a2da:	cd bf       	out	0x3d, r28	; 61
    a2dc:	de bf       	out	0x3e, r29	; 62
    a2de:	df 91       	pop	r29
    a2e0:	cf 91       	pop	r28
    a2e2:	1f 91       	pop	r17
    a2e4:	0f 91       	pop	r16
    a2e6:	08 95       	ret

0000a2e8 <__ultoa_invert>:
    a2e8:	fa 01       	movw	r30, r20
    a2ea:	aa 27       	eor	r26, r26
    a2ec:	28 30       	cpi	r18, 0x08	; 8
    a2ee:	51 f1       	breq	.+84     	; 0xa344 <__ultoa_invert+0x5c>
    a2f0:	20 31       	cpi	r18, 0x10	; 16
    a2f2:	81 f1       	breq	.+96     	; 0xa354 <__ultoa_invert+0x6c>
    a2f4:	e8 94       	clt
    a2f6:	6f 93       	push	r22
    a2f8:	6e 7f       	andi	r22, 0xFE	; 254
    a2fa:	6e 5f       	subi	r22, 0xFE	; 254
    a2fc:	7f 4f       	sbci	r23, 0xFF	; 255
    a2fe:	8f 4f       	sbci	r24, 0xFF	; 255
    a300:	9f 4f       	sbci	r25, 0xFF	; 255
    a302:	af 4f       	sbci	r26, 0xFF	; 255
    a304:	b1 e0       	ldi	r27, 0x01	; 1
    a306:	3e d0       	rcall	.+124    	; 0xa384 <__ultoa_invert+0x9c>
    a308:	b4 e0       	ldi	r27, 0x04	; 4
    a30a:	3c d0       	rcall	.+120    	; 0xa384 <__ultoa_invert+0x9c>
    a30c:	67 0f       	add	r22, r23
    a30e:	78 1f       	adc	r23, r24
    a310:	89 1f       	adc	r24, r25
    a312:	9a 1f       	adc	r25, r26
    a314:	a1 1d       	adc	r26, r1
    a316:	68 0f       	add	r22, r24
    a318:	79 1f       	adc	r23, r25
    a31a:	8a 1f       	adc	r24, r26
    a31c:	91 1d       	adc	r25, r1
    a31e:	a1 1d       	adc	r26, r1
    a320:	6a 0f       	add	r22, r26
    a322:	71 1d       	adc	r23, r1
    a324:	81 1d       	adc	r24, r1
    a326:	91 1d       	adc	r25, r1
    a328:	a1 1d       	adc	r26, r1
    a32a:	20 d0       	rcall	.+64     	; 0xa36c <__ultoa_invert+0x84>
    a32c:	09 f4       	brne	.+2      	; 0xa330 <__ultoa_invert+0x48>
    a32e:	68 94       	set
    a330:	3f 91       	pop	r19
    a332:	2a e0       	ldi	r18, 0x0A	; 10
    a334:	26 9f       	mul	r18, r22
    a336:	11 24       	eor	r1, r1
    a338:	30 19       	sub	r19, r0
    a33a:	30 5d       	subi	r19, 0xD0	; 208
    a33c:	31 93       	st	Z+, r19
    a33e:	de f6       	brtc	.-74     	; 0xa2f6 <__ultoa_invert+0xe>
    a340:	cf 01       	movw	r24, r30
    a342:	08 95       	ret
    a344:	46 2f       	mov	r20, r22
    a346:	47 70       	andi	r20, 0x07	; 7
    a348:	40 5d       	subi	r20, 0xD0	; 208
    a34a:	41 93       	st	Z+, r20
    a34c:	b3 e0       	ldi	r27, 0x03	; 3
    a34e:	0f d0       	rcall	.+30     	; 0xa36e <__ultoa_invert+0x86>
    a350:	c9 f7       	brne	.-14     	; 0xa344 <__ultoa_invert+0x5c>
    a352:	f6 cf       	rjmp	.-20     	; 0xa340 <__ultoa_invert+0x58>
    a354:	46 2f       	mov	r20, r22
    a356:	4f 70       	andi	r20, 0x0F	; 15
    a358:	40 5d       	subi	r20, 0xD0	; 208
    a35a:	4a 33       	cpi	r20, 0x3A	; 58
    a35c:	18 f0       	brcs	.+6      	; 0xa364 <__ultoa_invert+0x7c>
    a35e:	49 5d       	subi	r20, 0xD9	; 217
    a360:	31 fd       	sbrc	r19, 1
    a362:	40 52       	subi	r20, 0x20	; 32
    a364:	41 93       	st	Z+, r20
    a366:	02 d0       	rcall	.+4      	; 0xa36c <__ultoa_invert+0x84>
    a368:	a9 f7       	brne	.-22     	; 0xa354 <__ultoa_invert+0x6c>
    a36a:	ea cf       	rjmp	.-44     	; 0xa340 <__ultoa_invert+0x58>
    a36c:	b4 e0       	ldi	r27, 0x04	; 4
    a36e:	a6 95       	lsr	r26
    a370:	97 95       	ror	r25
    a372:	87 95       	ror	r24
    a374:	77 95       	ror	r23
    a376:	67 95       	ror	r22
    a378:	ba 95       	dec	r27
    a37a:	c9 f7       	brne	.-14     	; 0xa36e <__ultoa_invert+0x86>
    a37c:	00 97       	sbiw	r24, 0x00	; 0
    a37e:	61 05       	cpc	r22, r1
    a380:	71 05       	cpc	r23, r1
    a382:	08 95       	ret
    a384:	9b 01       	movw	r18, r22
    a386:	ac 01       	movw	r20, r24
    a388:	0a 2e       	mov	r0, r26
    a38a:	06 94       	lsr	r0
    a38c:	57 95       	ror	r21
    a38e:	47 95       	ror	r20
    a390:	37 95       	ror	r19
    a392:	27 95       	ror	r18
    a394:	ba 95       	dec	r27
    a396:	c9 f7       	brne	.-14     	; 0xa38a <__ultoa_invert+0xa2>
    a398:	62 0f       	add	r22, r18
    a39a:	73 1f       	adc	r23, r19
    a39c:	84 1f       	adc	r24, r20
    a39e:	95 1f       	adc	r25, r21
    a3a0:	a0 1d       	adc	r26, r0
    a3a2:	08 95       	ret

0000a3a4 <strtod>:
    a3a4:	8f 92       	push	r8
    a3a6:	9f 92       	push	r9
    a3a8:	af 92       	push	r10
    a3aa:	bf 92       	push	r11
    a3ac:	cf 92       	push	r12
    a3ae:	df 92       	push	r13
    a3b0:	ef 92       	push	r14
    a3b2:	ff 92       	push	r15
    a3b4:	0f 93       	push	r16
    a3b6:	1f 93       	push	r17
    a3b8:	cf 93       	push	r28
    a3ba:	df 93       	push	r29
    a3bc:	ec 01       	movw	r28, r24
    a3be:	6b 01       	movw	r12, r22
    a3c0:	61 15       	cp	r22, r1
    a3c2:	71 05       	cpc	r23, r1
    a3c4:	19 f0       	breq	.+6      	; 0xa3cc <strtod+0x28>
    a3c6:	fb 01       	movw	r30, r22
    a3c8:	80 83       	st	Z, r24
    a3ca:	91 83       	std	Z+1, r25	; 0x01
    a3cc:	7e 01       	movw	r14, r28
    a3ce:	ff ef       	ldi	r31, 0xFF	; 255
    a3d0:	ef 1a       	sub	r14, r31
    a3d2:	ff 0a       	sbc	r15, r31
    a3d4:	08 81       	ld	r16, Y
    a3d6:	80 2f       	mov	r24, r16
    a3d8:	90 e0       	ldi	r25, 0x00	; 0
    a3da:	0e 94 2e 53 	call	0xa65c	; 0xa65c <isspace>
    a3de:	89 2b       	or	r24, r25
    a3e0:	11 f0       	breq	.+4      	; 0xa3e6 <strtod+0x42>
    a3e2:	e7 01       	movw	r28, r14
    a3e4:	f3 cf       	rjmp	.-26     	; 0xa3cc <strtod+0x28>
    a3e6:	0d 32       	cpi	r16, 0x2D	; 45
    a3e8:	39 f4       	brne	.+14     	; 0xa3f8 <strtod+0x54>
    a3ea:	7e 01       	movw	r14, r28
    a3ec:	82 e0       	ldi	r24, 0x02	; 2
    a3ee:	e8 0e       	add	r14, r24
    a3f0:	f1 1c       	adc	r15, r1
    a3f2:	09 81       	ldd	r16, Y+1	; 0x01
    a3f4:	11 e0       	ldi	r17, 0x01	; 1
    a3f6:	08 c0       	rjmp	.+16     	; 0xa408 <strtod+0x64>
    a3f8:	0b 32       	cpi	r16, 0x2B	; 43
    a3fa:	29 f4       	brne	.+10     	; 0xa406 <strtod+0x62>
    a3fc:	7e 01       	movw	r14, r28
    a3fe:	92 e0       	ldi	r25, 0x02	; 2
    a400:	e9 0e       	add	r14, r25
    a402:	f1 1c       	adc	r15, r1
    a404:	09 81       	ldd	r16, Y+1	; 0x01
    a406:	10 e0       	ldi	r17, 0x00	; 0
    a408:	e7 01       	movw	r28, r14
    a40a:	21 97       	sbiw	r28, 0x01	; 1
    a40c:	43 e0       	ldi	r20, 0x03	; 3
    a40e:	50 e0       	ldi	r21, 0x00	; 0
    a410:	62 e4       	ldi	r22, 0x42	; 66
    a412:	73 e0       	ldi	r23, 0x03	; 3
    a414:	ce 01       	movw	r24, r28
    a416:	0e 94 37 53 	call	0xa66e	; 0xa66e <strncasecmp_P>
    a41a:	89 2b       	or	r24, r25
    a41c:	c1 f4       	brne	.+48     	; 0xa44e <strtod+0xaa>
    a41e:	23 96       	adiw	r28, 0x03	; 3
    a420:	45 e0       	ldi	r20, 0x05	; 5
    a422:	50 e0       	ldi	r21, 0x00	; 0
    a424:	6d e3       	ldi	r22, 0x3D	; 61
    a426:	73 e0       	ldi	r23, 0x03	; 3
    a428:	ce 01       	movw	r24, r28
    a42a:	0e 94 37 53 	call	0xa66e	; 0xa66e <strncasecmp_P>
    a42e:	89 2b       	or	r24, r25
    a430:	09 f4       	brne	.+2      	; 0xa434 <strtod+0x90>
    a432:	25 96       	adiw	r28, 0x05	; 5
    a434:	c1 14       	cp	r12, r1
    a436:	d1 04       	cpc	r13, r1
    a438:	19 f0       	breq	.+6      	; 0xa440 <strtod+0x9c>
    a43a:	f6 01       	movw	r30, r12
    a43c:	c0 83       	st	Z, r28
    a43e:	d1 83       	std	Z+1, r29	; 0x01
    a440:	11 11       	cpse	r17, r1
    a442:	f6 c0       	rjmp	.+492    	; 0xa630 <strtod+0x28c>
    a444:	60 e0       	ldi	r22, 0x00	; 0
    a446:	70 e0       	ldi	r23, 0x00	; 0
    a448:	80 e8       	ldi	r24, 0x80	; 128
    a44a:	9f e7       	ldi	r25, 0x7F	; 127
    a44c:	fa c0       	rjmp	.+500    	; 0xa642 <strtod+0x29e>
    a44e:	43 e0       	ldi	r20, 0x03	; 3
    a450:	50 e0       	ldi	r21, 0x00	; 0
    a452:	6a e3       	ldi	r22, 0x3A	; 58
    a454:	73 e0       	ldi	r23, 0x03	; 3
    a456:	ce 01       	movw	r24, r28
    a458:	0e 94 37 53 	call	0xa66e	; 0xa66e <strncasecmp_P>
    a45c:	89 2b       	or	r24, r25
    a45e:	59 f4       	brne	.+22     	; 0xa476 <strtod+0xd2>
    a460:	c1 14       	cp	r12, r1
    a462:	d1 04       	cpc	r13, r1
    a464:	09 f4       	brne	.+2      	; 0xa468 <strtod+0xc4>
    a466:	e9 c0       	rjmp	.+466    	; 0xa63a <strtod+0x296>
    a468:	f2 e0       	ldi	r31, 0x02	; 2
    a46a:	ef 0e       	add	r14, r31
    a46c:	f1 1c       	adc	r15, r1
    a46e:	f6 01       	movw	r30, r12
    a470:	e0 82       	st	Z, r14
    a472:	f1 82       	std	Z+1, r15	; 0x01
    a474:	e2 c0       	rjmp	.+452    	; 0xa63a <strtod+0x296>
    a476:	20 e0       	ldi	r18, 0x00	; 0
    a478:	30 e0       	ldi	r19, 0x00	; 0
    a47a:	a9 01       	movw	r20, r18
    a47c:	c0 e0       	ldi	r28, 0x00	; 0
    a47e:	d0 e0       	ldi	r29, 0x00	; 0
    a480:	f7 01       	movw	r30, r14
    a482:	60 ed       	ldi	r22, 0xD0	; 208
    a484:	a6 2e       	mov	r10, r22
    a486:	a0 0e       	add	r10, r16
    a488:	89 e0       	ldi	r24, 0x09	; 9
    a48a:	8a 15       	cp	r24, r10
    a48c:	30 f1       	brcs	.+76     	; 0xa4da <strtod+0x136>
    a48e:	91 2f       	mov	r25, r17
    a490:	92 60       	ori	r25, 0x02	; 2
    a492:	b9 2e       	mov	r11, r25
    a494:	81 2f       	mov	r24, r17
    a496:	88 70       	andi	r24, 0x08	; 8
    a498:	12 ff       	sbrs	r17, 2
    a49a:	04 c0       	rjmp	.+8      	; 0xa4a4 <strtod+0x100>
    a49c:	81 11       	cpse	r24, r1
    a49e:	24 c0       	rjmp	.+72     	; 0xa4e8 <strtod+0x144>
    a4a0:	21 96       	adiw	r28, 0x01	; 1
    a4a2:	22 c0       	rjmp	.+68     	; 0xa4e8 <strtod+0x144>
    a4a4:	81 11       	cpse	r24, r1
    a4a6:	21 97       	sbiw	r28, 0x01	; 1
    a4a8:	a5 e0       	ldi	r26, 0x05	; 5
    a4aa:	b0 e0       	ldi	r27, 0x00	; 0
    a4ac:	0e 94 e1 4b 	call	0x97c2	; 0x97c2 <__muluhisi3>
    a4b0:	dc 01       	movw	r26, r24
    a4b2:	cb 01       	movw	r24, r22
    a4b4:	88 0f       	add	r24, r24
    a4b6:	99 1f       	adc	r25, r25
    a4b8:	aa 1f       	adc	r26, r26
    a4ba:	bb 1f       	adc	r27, r27
    a4bc:	9c 01       	movw	r18, r24
    a4be:	ad 01       	movw	r20, r26
    a4c0:	2a 0d       	add	r18, r10
    a4c2:	31 1d       	adc	r19, r1
    a4c4:	41 1d       	adc	r20, r1
    a4c6:	51 1d       	adc	r21, r1
    a4c8:	28 39       	cpi	r18, 0x98	; 152
    a4ca:	89 e9       	ldi	r24, 0x99	; 153
    a4cc:	38 07       	cpc	r19, r24
    a4ce:	48 07       	cpc	r20, r24
    a4d0:	89 e1       	ldi	r24, 0x19	; 25
    a4d2:	58 07       	cpc	r21, r24
    a4d4:	48 f0       	brcs	.+18     	; 0xa4e8 <strtod+0x144>
    a4d6:	16 60       	ori	r17, 0x06	; 6
    a4d8:	06 c0       	rjmp	.+12     	; 0xa4e6 <strtod+0x142>
    a4da:	9e ef       	ldi	r25, 0xFE	; 254
    a4dc:	a9 12       	cpse	r10, r25
    a4de:	0a c0       	rjmp	.+20     	; 0xa4f4 <strtod+0x150>
    a4e0:	13 fd       	sbrc	r17, 3
    a4e2:	40 c0       	rjmp	.+128    	; 0xa564 <strtod+0x1c0>
    a4e4:	18 60       	ori	r17, 0x08	; 8
    a4e6:	b1 2e       	mov	r11, r17
    a4e8:	8f ef       	ldi	r24, 0xFF	; 255
    a4ea:	e8 1a       	sub	r14, r24
    a4ec:	f8 0a       	sbc	r15, r24
    a4ee:	00 81       	ld	r16, Z
    a4f0:	1b 2d       	mov	r17, r11
    a4f2:	c6 cf       	rjmp	.-116    	; 0xa480 <strtod+0xdc>
    a4f4:	80 2f       	mov	r24, r16
    a4f6:	8f 7d       	andi	r24, 0xDF	; 223
    a4f8:	85 34       	cpi	r24, 0x45	; 69
    a4fa:	a1 f5       	brne	.+104    	; 0xa564 <strtod+0x1c0>
    a4fc:	80 81       	ld	r24, Z
    a4fe:	8d 32       	cpi	r24, 0x2D	; 45
    a500:	11 f4       	brne	.+4      	; 0xa506 <strtod+0x162>
    a502:	10 61       	ori	r17, 0x10	; 16
    a504:	06 c0       	rjmp	.+12     	; 0xa512 <strtod+0x16e>
    a506:	8b 32       	cpi	r24, 0x2B	; 43
    a508:	21 f0       	breq	.+8      	; 0xa512 <strtod+0x16e>
    a50a:	31 96       	adiw	r30, 0x01	; 1
    a50c:	61 e0       	ldi	r22, 0x01	; 1
    a50e:	70 e0       	ldi	r23, 0x00	; 0
    a510:	04 c0       	rjmp	.+8      	; 0xa51a <strtod+0x176>
    a512:	81 81       	ldd	r24, Z+1	; 0x01
    a514:	32 96       	adiw	r30, 0x02	; 2
    a516:	62 e0       	ldi	r22, 0x02	; 2
    a518:	70 e0       	ldi	r23, 0x00	; 0
    a51a:	80 53       	subi	r24, 0x30	; 48
    a51c:	8a 30       	cpi	r24, 0x0A	; 10
    a51e:	18 f0       	brcs	.+6      	; 0xa526 <strtod+0x182>
    a520:	e6 1b       	sub	r30, r22
    a522:	f7 0b       	sbc	r31, r23
    a524:	1f c0       	rjmp	.+62     	; 0xa564 <strtod+0x1c0>
    a526:	60 e0       	ldi	r22, 0x00	; 0
    a528:	70 e0       	ldi	r23, 0x00	; 0
    a52a:	60 38       	cpi	r22, 0x80	; 128
    a52c:	9c e0       	ldi	r25, 0x0C	; 12
    a52e:	79 07       	cpc	r23, r25
    a530:	5c f4       	brge	.+22     	; 0xa548 <strtod+0x1a4>
    a532:	db 01       	movw	r26, r22
    a534:	aa 0f       	add	r26, r26
    a536:	bb 1f       	adc	r27, r27
    a538:	aa 0f       	add	r26, r26
    a53a:	bb 1f       	adc	r27, r27
    a53c:	6a 0f       	add	r22, r26
    a53e:	7b 1f       	adc	r23, r27
    a540:	66 0f       	add	r22, r22
    a542:	77 1f       	adc	r23, r23
    a544:	68 0f       	add	r22, r24
    a546:	71 1d       	adc	r23, r1
    a548:	31 96       	adiw	r30, 0x01	; 1
    a54a:	df 01       	movw	r26, r30
    a54c:	11 97       	sbiw	r26, 0x01	; 1
    a54e:	8c 91       	ld	r24, X
    a550:	80 53       	subi	r24, 0x30	; 48
    a552:	8a 30       	cpi	r24, 0x0A	; 10
    a554:	50 f3       	brcs	.-44     	; 0xa52a <strtod+0x186>
    a556:	14 ff       	sbrs	r17, 4
    a558:	03 c0       	rjmp	.+6      	; 0xa560 <strtod+0x1bc>
    a55a:	71 95       	neg	r23
    a55c:	61 95       	neg	r22
    a55e:	71 09       	sbc	r23, r1
    a560:	c6 0f       	add	r28, r22
    a562:	d7 1f       	adc	r29, r23
    a564:	11 ff       	sbrs	r17, 1
    a566:	08 c0       	rjmp	.+16     	; 0xa578 <strtod+0x1d4>
    a568:	c1 14       	cp	r12, r1
    a56a:	d1 04       	cpc	r13, r1
    a56c:	29 f0       	breq	.+10     	; 0xa578 <strtod+0x1d4>
    a56e:	cf 01       	movw	r24, r30
    a570:	01 97       	sbiw	r24, 0x01	; 1
    a572:	f6 01       	movw	r30, r12
    a574:	80 83       	st	Z, r24
    a576:	91 83       	std	Z+1, r25	; 0x01
    a578:	ca 01       	movw	r24, r20
    a57a:	b9 01       	movw	r22, r18
    a57c:	0e 94 c4 46 	call	0x8d88	; 0x8d88 <__floatunsisf>
    a580:	21 2f       	mov	r18, r17
    a582:	23 70       	andi	r18, 0x03	; 3
    a584:	23 30       	cpi	r18, 0x03	; 3
    a586:	19 f0       	breq	.+6      	; 0xa58e <strtod+0x1ea>
    a588:	4b 01       	movw	r8, r22
    a58a:	5c 01       	movw	r10, r24
    a58c:	06 c0       	rjmp	.+12     	; 0xa59a <strtod+0x1f6>
    a58e:	4b 01       	movw	r8, r22
    a590:	5c 01       	movw	r10, r24
    a592:	b7 fa       	bst	r11, 7
    a594:	b0 94       	com	r11
    a596:	b7 f8       	bld	r11, 7
    a598:	b0 94       	com	r11
    a59a:	20 e0       	ldi	r18, 0x00	; 0
    a59c:	30 e0       	ldi	r19, 0x00	; 0
    a59e:	a9 01       	movw	r20, r18
    a5a0:	c5 01       	movw	r24, r10
    a5a2:	b4 01       	movw	r22, r8
    a5a4:	0e 94 17 46 	call	0x8c2e	; 0x8c2e <__cmpsf2>
    a5a8:	88 23       	and	r24, r24
    a5aa:	09 f4       	brne	.+2      	; 0xa5ae <strtod+0x20a>
    a5ac:	3e c0       	rjmp	.+124    	; 0xa62a <strtod+0x286>
    a5ae:	d7 ff       	sbrs	r29, 7
    a5b0:	06 c0       	rjmp	.+12     	; 0xa5be <strtod+0x21a>
    a5b2:	d1 95       	neg	r29
    a5b4:	c1 95       	neg	r28
    a5b6:	d1 09       	sbc	r29, r1
    a5b8:	09 e5       	ldi	r16, 0x59	; 89
    a5ba:	13 e0       	ldi	r17, 0x03	; 3
    a5bc:	02 c0       	rjmp	.+4      	; 0xa5c2 <strtod+0x21e>
    a5be:	01 e7       	ldi	r16, 0x71	; 113
    a5c0:	13 e0       	ldi	r17, 0x03	; 3
    a5c2:	68 01       	movw	r12, r16
    a5c4:	f8 e1       	ldi	r31, 0x18	; 24
    a5c6:	cf 1a       	sub	r12, r31
    a5c8:	d1 08       	sbc	r13, r1
    a5ca:	90 e2       	ldi	r25, 0x20	; 32
    a5cc:	e9 2e       	mov	r14, r25
    a5ce:	f1 2c       	mov	r15, r1
    a5d0:	ce 15       	cp	r28, r14
    a5d2:	df 05       	cpc	r29, r15
    a5d4:	74 f0       	brlt	.+28     	; 0xa5f2 <strtod+0x24e>
    a5d6:	f8 01       	movw	r30, r16
    a5d8:	25 91       	lpm	r18, Z+
    a5da:	35 91       	lpm	r19, Z+
    a5dc:	45 91       	lpm	r20, Z+
    a5de:	54 91       	lpm	r21, Z
    a5e0:	c5 01       	movw	r24, r10
    a5e2:	b4 01       	movw	r22, r8
    a5e4:	0e 94 7b 47 	call	0x8ef6	; 0x8ef6 <__mulsf3>
    a5e8:	4b 01       	movw	r8, r22
    a5ea:	5c 01       	movw	r10, r24
    a5ec:	ce 19       	sub	r28, r14
    a5ee:	df 09       	sbc	r29, r15
    a5f0:	ef cf       	rjmp	.-34     	; 0xa5d0 <strtod+0x22c>
    a5f2:	04 50       	subi	r16, 0x04	; 4
    a5f4:	11 09       	sbc	r17, r1
    a5f6:	f5 94       	asr	r15
    a5f8:	e7 94       	ror	r14
    a5fa:	0c 15       	cp	r16, r12
    a5fc:	1d 05       	cpc	r17, r13
    a5fe:	41 f7       	brne	.-48     	; 0xa5d0 <strtod+0x22c>
    a600:	8a 2d       	mov	r24, r10
    a602:	88 0f       	add	r24, r24
    a604:	8b 2d       	mov	r24, r11
    a606:	88 1f       	adc	r24, r24
    a608:	8f 3f       	cpi	r24, 0xFF	; 255
    a60a:	49 f0       	breq	.+18     	; 0xa61e <strtod+0x27a>
    a60c:	20 e0       	ldi	r18, 0x00	; 0
    a60e:	30 e0       	ldi	r19, 0x00	; 0
    a610:	a9 01       	movw	r20, r18
    a612:	c5 01       	movw	r24, r10
    a614:	b4 01       	movw	r22, r8
    a616:	0e 94 17 46 	call	0x8c2e	; 0x8c2e <__cmpsf2>
    a61a:	81 11       	cpse	r24, r1
    a61c:	06 c0       	rjmp	.+12     	; 0xa62a <strtod+0x286>
    a61e:	82 e2       	ldi	r24, 0x22	; 34
    a620:	90 e0       	ldi	r25, 0x00	; 0
    a622:	80 93 82 2e 	sts	0x2E82, r24	; 0x802e82 <errno>
    a626:	90 93 83 2e 	sts	0x2E83, r25	; 0x802e83 <errno+0x1>
    a62a:	c5 01       	movw	r24, r10
    a62c:	b4 01       	movw	r22, r8
    a62e:	09 c0       	rjmp	.+18     	; 0xa642 <strtod+0x29e>
    a630:	60 e0       	ldi	r22, 0x00	; 0
    a632:	70 e0       	ldi	r23, 0x00	; 0
    a634:	80 e8       	ldi	r24, 0x80	; 128
    a636:	9f ef       	ldi	r25, 0xFF	; 255
    a638:	04 c0       	rjmp	.+8      	; 0xa642 <strtod+0x29e>
    a63a:	60 e0       	ldi	r22, 0x00	; 0
    a63c:	70 e0       	ldi	r23, 0x00	; 0
    a63e:	80 ec       	ldi	r24, 0xC0	; 192
    a640:	9f e7       	ldi	r25, 0x7F	; 127
    a642:	df 91       	pop	r29
    a644:	cf 91       	pop	r28
    a646:	1f 91       	pop	r17
    a648:	0f 91       	pop	r16
    a64a:	ff 90       	pop	r15
    a64c:	ef 90       	pop	r14
    a64e:	df 90       	pop	r13
    a650:	cf 90       	pop	r12
    a652:	bf 90       	pop	r11
    a654:	af 90       	pop	r10
    a656:	9f 90       	pop	r9
    a658:	8f 90       	pop	r8
    a65a:	08 95       	ret

0000a65c <isspace>:
    a65c:	91 11       	cpse	r25, r1
    a65e:	0c 94 8d 53 	jmp	0xa71a	; 0xa71a <__ctype_isfalse>
    a662:	80 32       	cpi	r24, 0x20	; 32
    a664:	19 f0       	breq	.+6      	; 0xa66c <isspace+0x10>
    a666:	89 50       	subi	r24, 0x09	; 9
    a668:	85 50       	subi	r24, 0x05	; 5
    a66a:	c8 f7       	brcc	.-14     	; 0xa65e <isspace+0x2>
    a66c:	08 95       	ret

0000a66e <strncasecmp_P>:
    a66e:	fb 01       	movw	r30, r22
    a670:	dc 01       	movw	r26, r24
    a672:	41 50       	subi	r20, 0x01	; 1
    a674:	50 40       	sbci	r21, 0x00	; 0
    a676:	88 f0       	brcs	.+34     	; 0xa69a <strncasecmp_P+0x2c>
    a678:	8d 91       	ld	r24, X+
    a67a:	81 34       	cpi	r24, 0x41	; 65
    a67c:	1c f0       	brlt	.+6      	; 0xa684 <strncasecmp_P+0x16>
    a67e:	8b 35       	cpi	r24, 0x5B	; 91
    a680:	0c f4       	brge	.+2      	; 0xa684 <strncasecmp_P+0x16>
    a682:	80 5e       	subi	r24, 0xE0	; 224
    a684:	65 91       	lpm	r22, Z+
    a686:	61 34       	cpi	r22, 0x41	; 65
    a688:	1c f0       	brlt	.+6      	; 0xa690 <strncasecmp_P+0x22>
    a68a:	6b 35       	cpi	r22, 0x5B	; 91
    a68c:	0c f4       	brge	.+2      	; 0xa690 <strncasecmp_P+0x22>
    a68e:	60 5e       	subi	r22, 0xE0	; 224
    a690:	86 1b       	sub	r24, r22
    a692:	61 11       	cpse	r22, r1
    a694:	71 f3       	breq	.-36     	; 0xa672 <strncasecmp_P+0x4>
    a696:	99 0b       	sbc	r25, r25
    a698:	08 95       	ret
    a69a:	88 1b       	sub	r24, r24
    a69c:	fc cf       	rjmp	.-8      	; 0xa696 <strncasecmp_P+0x28>

0000a69e <fgetc>:
    a69e:	cf 93       	push	r28
    a6a0:	df 93       	push	r29
    a6a2:	ec 01       	movw	r28, r24
    a6a4:	2b 81       	ldd	r18, Y+3	; 0x03
    a6a6:	20 ff       	sbrs	r18, 0
    a6a8:	33 c0       	rjmp	.+102    	; 0xa710 <fgetc+0x72>
    a6aa:	26 ff       	sbrs	r18, 6
    a6ac:	0a c0       	rjmp	.+20     	; 0xa6c2 <fgetc+0x24>
    a6ae:	2f 7b       	andi	r18, 0xBF	; 191
    a6b0:	2b 83       	std	Y+3, r18	; 0x03
    a6b2:	8e 81       	ldd	r24, Y+6	; 0x06
    a6b4:	9f 81       	ldd	r25, Y+7	; 0x07
    a6b6:	01 96       	adiw	r24, 0x01	; 1
    a6b8:	8e 83       	std	Y+6, r24	; 0x06
    a6ba:	9f 83       	std	Y+7, r25	; 0x07
    a6bc:	8a 81       	ldd	r24, Y+2	; 0x02
    a6be:	90 e0       	ldi	r25, 0x00	; 0
    a6c0:	29 c0       	rjmp	.+82     	; 0xa714 <fgetc+0x76>
    a6c2:	22 ff       	sbrs	r18, 2
    a6c4:	0f c0       	rjmp	.+30     	; 0xa6e4 <fgetc+0x46>
    a6c6:	e8 81       	ld	r30, Y
    a6c8:	f9 81       	ldd	r31, Y+1	; 0x01
    a6ca:	80 81       	ld	r24, Z
    a6cc:	08 2e       	mov	r0, r24
    a6ce:	00 0c       	add	r0, r0
    a6d0:	99 0b       	sbc	r25, r25
    a6d2:	00 97       	sbiw	r24, 0x00	; 0
    a6d4:	19 f4       	brne	.+6      	; 0xa6dc <fgetc+0x3e>
    a6d6:	20 62       	ori	r18, 0x20	; 32
    a6d8:	2b 83       	std	Y+3, r18	; 0x03
    a6da:	1a c0       	rjmp	.+52     	; 0xa710 <fgetc+0x72>
    a6dc:	31 96       	adiw	r30, 0x01	; 1
    a6de:	e8 83       	st	Y, r30
    a6e0:	f9 83       	std	Y+1, r31	; 0x01
    a6e2:	0e c0       	rjmp	.+28     	; 0xa700 <fgetc+0x62>
    a6e4:	ea 85       	ldd	r30, Y+10	; 0x0a
    a6e6:	fb 85       	ldd	r31, Y+11	; 0x0b
    a6e8:	19 95       	eicall
    a6ea:	97 ff       	sbrs	r25, 7
    a6ec:	09 c0       	rjmp	.+18     	; 0xa700 <fgetc+0x62>
    a6ee:	2b 81       	ldd	r18, Y+3	; 0x03
    a6f0:	01 96       	adiw	r24, 0x01	; 1
    a6f2:	11 f0       	breq	.+4      	; 0xa6f8 <fgetc+0x5a>
    a6f4:	80 e2       	ldi	r24, 0x20	; 32
    a6f6:	01 c0       	rjmp	.+2      	; 0xa6fa <fgetc+0x5c>
    a6f8:	80 e1       	ldi	r24, 0x10	; 16
    a6fa:	82 2b       	or	r24, r18
    a6fc:	8b 83       	std	Y+3, r24	; 0x03
    a6fe:	08 c0       	rjmp	.+16     	; 0xa710 <fgetc+0x72>
    a700:	2e 81       	ldd	r18, Y+6	; 0x06
    a702:	3f 81       	ldd	r19, Y+7	; 0x07
    a704:	2f 5f       	subi	r18, 0xFF	; 255
    a706:	3f 4f       	sbci	r19, 0xFF	; 255
    a708:	2e 83       	std	Y+6, r18	; 0x06
    a70a:	3f 83       	std	Y+7, r19	; 0x07
    a70c:	99 27       	eor	r25, r25
    a70e:	02 c0       	rjmp	.+4      	; 0xa714 <fgetc+0x76>
    a710:	8f ef       	ldi	r24, 0xFF	; 255
    a712:	9f ef       	ldi	r25, 0xFF	; 255
    a714:	df 91       	pop	r29
    a716:	cf 91       	pop	r28
    a718:	08 95       	ret

0000a71a <__ctype_isfalse>:
    a71a:	99 27       	eor	r25, r25
    a71c:	88 27       	eor	r24, r24

0000a71e <__ctype_istrue>:
    a71e:	08 95       	ret

0000a720 <_exit>:
    a720:	f8 94       	cli

0000a722 <__stop_program>:
    a722:	ff cf       	rjmp	.-2      	; 0xa722 <__stop_program>
