
LinebotFinal.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000a22a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000870  00802000  0000a22a  0000a2be  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000575  00802870  00802870  0000ab2e  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  0000ab2e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000ab8c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000b28  00000000  00000000  0000abcc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001a0f0  00000000  00000000  0000b6f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006571  00000000  00000000  000257e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000992c  00000000  00000000  0002bd55  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00002880  00000000  00000000  00035684  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005992  00000000  00000000  00037f04  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00010f74  00000000  00000000  0003d896  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000f00  00000000  00000000  0004e80a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 63 03 	jmp	0x6c6	; 0x6c6 <__ctors_end>
       4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
       8:	0c 94 7f 07 	jmp	0xefe	; 0xefe <__vector_2>
       c:	0c 94 06 08 	jmp	0x100c	; 0x100c <__vector_3>
      10:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      14:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      18:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      1c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      20:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      24:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      28:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      2c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      30:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      34:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      38:	0c 94 95 1e 	jmp	0x3d2a	; 0x3d2a <__vector_14>
      3c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      40:	0c 94 09 1f 	jmp	0x3e12	; 0x3e12 <__vector_16>
      44:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      48:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      4c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      50:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      54:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      58:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      5c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      60:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      64:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      68:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      6c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      70:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      74:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      78:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      7c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      80:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      84:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      88:	0c 94 52 05 	jmp	0xaa4	; 0xaa4 <__vector_34>
      8c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      90:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      94:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      98:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      9c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      a0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      a4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      a8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      ac:	0c 94 8d 08 	jmp	0x111a	; 0x111a <__vector_43>
      b0:	0c 94 14 09 	jmp	0x1228	; 0x1228 <__vector_44>
      b4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      b8:	0c 94 d9 10 	jmp	0x21b2	; 0x21b2 <__vector_46>
      bc:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      c0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      c4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      c8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      cc:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      d0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      d4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      d8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      dc:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      e0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      e4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      e8:	0c 94 f9 11 	jmp	0x23f2	; 0x23f2 <__vector_58>
      ec:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      f0:	0c 94 b2 11 	jmp	0x2364	; 0x2364 <__vector_60>
      f4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      f8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
      fc:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     100:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     104:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     108:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     10c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     110:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     114:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     118:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     11c:	0c 94 04 04 	jmp	0x808	; 0x808 <__vector_71>
     120:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     124:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     128:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     12c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     130:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     134:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     138:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     13c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     140:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     144:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     148:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     14c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     150:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     154:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     158:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     15c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     160:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     164:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     168:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     16c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     170:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     174:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     178:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     17c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     180:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     184:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     188:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     18c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     190:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     194:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     198:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     19c:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1a0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1a4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1a8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1ac:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1b0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1b4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1b8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1bc:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1c0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1c4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1c8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1cc:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1d0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1d4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1d8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1dc:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1e0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1e4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1e8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1ec:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1f0:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1f4:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>
     1f8:	0c 94 84 03 	jmp	0x708	; 0x708 <__bad_interrupt>

000001fc <__trampolines_start>:
     1fc:	0c 94 59 11 	jmp	0x22b2	; 0x22b2 <stdio_putchar>
     200:	0c 94 43 11 	jmp	0x2286	; 0x2286 <stdio_getchar>
     204:	0c 94 fe 33 	jmp	0x67fc	; 0x67fc <WorkerLineFollowerSpeed>
     208:	0c 94 74 30 	jmp	0x60e8	; 0x60e8 <cmpfunc>
     20c:	0c 94 58 39 	jmp	0x72b0	; 0x72b0 <WorkerMotorSpeed>
     210:	0c 94 65 40 	jmp	0x80ca	; 0x80ca <WorkerStartup>
     214:	0c 94 5f 33 	jmp	0x66be	; 0x66be <WorkerLineFollowerDirect>
     218:	0c 94 b0 40 	jmp	0x8160	; 0x8160 <WorkerTerminal>
     21c:	0c 94 c7 31 	jmp	0x638e	; 0x638e <WorkerADC>
     220:	0c 94 36 3f 	jmp	0x7e6c	; 0x7e6c <WorkerOLEDMenu>
     224:	0c 94 46 32 	jmp	0x648c	; 0x648c <WorkerGyro>
     228:	0c 94 d4 34 	jmp	0x69a8	; 0x69a8 <WorkerMotion>
     22c:	0c 94 29 25 	jmp	0x4a52	; 0x4a52 <prvIdleTask>
     230:	0c 94 b4 3f 	jmp	0x7f68	; 0x7f68 <WorkerRGB>
     234:	0c 94 9a 37 	jmp	0x6f34	; 0x6f34 <WorkerMotorPos>

00000238 <__trampolines_end>:
     238:	6e 61       	ori	r22, 0x1E	; 30
     23a:	6e 00       	.word	0x006e	; ????

0000023c <__c.2332>:
     23c:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     24c:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     25c:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     26c:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     27c:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     28c:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     29c:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     2ac:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     2bc:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     2cc:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     2dc:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     2ec:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     2fc:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     30c:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     31c:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     32c:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

0000033a <pstr_nan>:
     33a:	4e 41 4e                                            NAN

0000033d <pstr_inity>:
     33d:	49 4e 49 54 59                                      INITY

00000342 <pstr_inf>:
     342:	49 4e 46                                            INF

00000345 <pwr_m10>:
     345:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     355:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

0000035d <pwr_p10>:
     35d:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     36d:	ca 1b 0e 5a ae c5 9d 74                             ...Z...t

00000375 <__c.4867>:
     375:	61 75 78 70 77 72 20 73 74 61 74 65 3a 27 73 74     auxpwr state:'st
     385:	61 74 65 27 3d 31 3a 20 74 75 72 6e 20 6f 6e 20     ate'=1: turn on 
     395:	61 75 78 20 70 6f 77 65 72 20 6e 65 74 2c 20 27     aux power net, '
     3a5:	73 74 61 74 65 27 3d 30 3a 20 74 75 72 6e 20 6f     state'=0: turn o
     3b5:	66 66 20 61 75 78 20 70 6f 77 65 72 20 6e 65 74     ff aux power net
     3c5:	0d 0a 00                                            ...

000003c8 <__c.4865>:
     3c8:	67 65 74 61 64 63 20 3a 72 65 74 75 72 6e 73 20     getadc :returns 
     3d8:	41 6e 61 6c 6f 67 20 63 68 61 6e 6e 65 6c 73 20     Analog channels 
     3e8:	69 6e 20 66 6f 72 6d 61 74 20 27 6c 65 66 74 5f     in format 'left_
     3f8:	6c 69 6e 65 5f 73 65 6e 73 6f 72 20 6d 69 64 5f     line_sensor mid_
     408:	6c 69 6e 65 5f 73 65 6e 73 6f 72 20 72 69 67 68     line_sensor righ
     418:	74 5f 6c 69 6e 65 5f 73 65 6e 73 6f 72 20 70 6f     t_line_sensor po
     428:	74 65 6e 74 69 6f 6d 65 74 65 72 0d 0a 00           tentiometer...

00000436 <__c.4863>:
     436:	67 65 74 67 79 72 20 3a 72 65 74 75 72 6e 73 20     getgyr :returns 
     446:	67 79 72 6f 73 63 6f 70 65 20 69 6e 66 6f 20 69     gyroscope info i
     456:	6e 20 66 6f 72 6d 61 74 20 27 79 61 77 72 61 74     n format 'yawrat
     466:	65 20 28 64 65 67 2f 73 29 20 79 61 77 28 64 65     e (deg/s) yaw(de
     476:	67 29 0d 0a 00                                      g)...

0000047b <__c.4861>:
     47b:	67 65 74 72 67 62 20 3a 72 65 74 75 72 6e 73 20     getrgb :returns 
     48b:	52 47 42 20 6c 69 67 68 74 20 73 65 6e 73 6f 72     RGB light sensor
     49b:	20 76 61 6c 75 65 73 0d 0a 00                        values...

000004a5 <__c.4859>:
     4a5:	67 65 74 65 6e 63 20 3a 67 65 74 20 6d 6f 74 6f     getenc :get moto
     4b5:	72 20 65 6e 63 6f 64 65 72 20 76 61 6c 75 65 73     r encoder values
     4c5:	0d 0a 00                                            ...

000004c8 <__c.4857>:
     4c8:	73 65 74 6d 6f 74 20 6c 65 66 74 6d 6f 74 6f 72     setmot leftmotor
     4d8:	5f 70 77 6d 20 72 69 67 68 74 6d 6f 74 6f 72 5f     _pwm rightmotor_
     4e8:	70 77 6d 20 3a 64 69 72 65 63 74 6c 79 20 63 6f     pwm :directly co
     4f8:	6e 74 72 6f 6c 20 6d 6f 74 6f 72 20 70 77 6d 20     ntrol motor pwm 
     508:	73 69 67 6e 61 6c 2e 20 50 77 6d 20 69 73 20 69     signal. Pwm is i
     518:	6e 20 61 20 72 61 6e 67 65 20 6f 66 20 2d 34 30     n a range of -40
     528:	39 35 20 74 6f 20 34 30 39 35 0d 0a 00              95 to 4095...

00000535 <__c.4855>:
     535:	73 65 74 6c 65 64 20 65 66 66 65 63 74 20 3a 73     setled effect :s
     545:	65 74 20 52 47 42 20 6c 65 64 20 65 66 66 65 63     et RGB led effec
     555:	74 20 28 73 65 65 20 52 47 42 54 61 73 6b 2e 68     t (see RGBTask.h
     565:	29 0d 0a 00                                         )...

00000569 <__c.4853>:
     569:	64 72 76 73 65 67 20 73 70 65 65 64 20 3a 66 6f     drvseg speed :fo
     579:	6c 6c 6f 77 20 6c 69 6e 65 20 73 65 67 6d 65 6e     llow line segmen
     589:	74 20 75 6e 74 69 6c 20 65 6e 64 20 61 74 20 61     t until end at a
     599:	20 73 70 65 65 64 20 6f 66 20 27 73 70 65 65 64      speed of 'speed
     5a9:	27 20 6d 6d 2f 73 0d 0a 00                          ' mm/s...

000005b2 <__c.4851>:
     5b2:	72 6f 74 63 74 72 20 61 6e 67 6c 65 20 73 70 65     rotctr angle spe
     5c2:	65 64 20 3a 72 6f 74 61 74 65 20 27 61 6e 67 6c     ed :rotate 'angl
     5d2:	65 27 20 64 65 67 72 65 65 73 20 61 72 6f 75 6e     e' degrees aroun
     5e2:	64 20 63 65 6e 74 65 72 20 6f 66 20 72 6f 62 6f     d center of robo
     5f2:	74 20 61 74 20 61 20 73 70 65 65 64 20 6f 66 20     t at a speed of 
     602:	27 73 70 65 65 64 27 20 6d 6d 2f 73 0d 0a 00        'speed' mm/s...

00000611 <__c.4849>:
     611:	64 72 76 73 74 72 20 64 69 73 74 61 6e 63 65 20     drvstr distance 
     621:	73 70 65 65 64 20 3a 44 72 69 76 65 20 73 74 72     speed :Drive str
     631:	61 69 67 68 74 20 6f 76 65 72 20 27 64 69 73 74     aight over 'dist
     641:	61 6e 63 65 27 20 6d 6d 20 61 74 20 61 20 73 70     ance' mm at a sp
     651:	65 65 64 20 6f 66 20 27 73 70 65 65 64 27 20 6d     eed of 'speed' m
     661:	6d 2f 73 0d 0a 00                                   m/s...

00000667 <__c.4847>:
     667:	6d 65 6d 6d 61 70 20 3a 73 68 6f 77 20 6d 65 6d     memmap :show mem
     677:	6f 72 79 20 6d 61 70 0d 0a 00                       ory map...

00000681 <__c.4845>:
     681:	74 73 6b 6c 73 74 20 3a 6c 69 73 74 20 46 72 65     tsklst :list Fre
     691:	65 52 54 4f 53 20 74 61 73 6b 73 0d 0a 00           eRTOS tasks...

0000069f <__c.4843>:
     69f:	68 65 6c 70 20 3a 74 68 69 73 20 68 65 6c 70 20     help :this help 
     6af:	70 61 67 65 0d 0a 00                                page...

000006b6 <__c.4841>:
     6b6:	43 6f 6d 6d 61 6e 64 20 6c 69 73 74 3a 0d 0a 00     Command list:...

000006c6 <__ctors_end>:
     6c6:	11 24       	eor	r1, r1
     6c8:	1f be       	out	0x3f, r1	; 63
     6ca:	cf ef       	ldi	r28, 0xFF	; 255
     6cc:	cd bf       	out	0x3d, r28	; 61
     6ce:	df e9       	ldi	r29, 0x9F	; 159
     6d0:	de bf       	out	0x3e, r29	; 62
     6d2:	00 e0       	ldi	r16, 0x00	; 0
     6d4:	0c bf       	out	0x3c, r16	; 60

000006d6 <__do_copy_data>:
     6d6:	18 e2       	ldi	r17, 0x28	; 40
     6d8:	a0 e0       	ldi	r26, 0x00	; 0
     6da:	b0 e2       	ldi	r27, 0x20	; 32
     6dc:	ea e2       	ldi	r30, 0x2A	; 42
     6de:	f2 ea       	ldi	r31, 0xA2	; 162
     6e0:	00 e0       	ldi	r16, 0x00	; 0
     6e2:	0b bf       	out	0x3b, r16	; 59
     6e4:	02 c0       	rjmp	.+4      	; 0x6ea <__do_copy_data+0x14>
     6e6:	07 90       	elpm	r0, Z+
     6e8:	0d 92       	st	X+, r0
     6ea:	a0 37       	cpi	r26, 0x70	; 112
     6ec:	b1 07       	cpc	r27, r17
     6ee:	d9 f7       	brne	.-10     	; 0x6e6 <__do_copy_data+0x10>

000006f0 <__do_clear_bss>:
     6f0:	2d e2       	ldi	r18, 0x2D	; 45
     6f2:	a0 e7       	ldi	r26, 0x70	; 112
     6f4:	b8 e2       	ldi	r27, 0x28	; 40
     6f6:	01 c0       	rjmp	.+2      	; 0x6fa <.do_clear_bss_start>

000006f8 <.do_clear_bss_loop>:
     6f8:	1d 92       	st	X+, r1

000006fa <.do_clear_bss_start>:
     6fa:	a5 3e       	cpi	r26, 0xE5	; 229
     6fc:	b2 07       	cpc	r27, r18
     6fe:	e1 f7       	brne	.-8      	; 0x6f8 <.do_clear_bss_loop>
     700:	0e 94 52 30 	call	0x60a4	; 0x60a4 <main>
     704:	0c 94 13 51 	jmp	0xa226	; 0xa226 <_exit>

00000708 <__bad_interrupt>:
     708:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000070c <DriverAdcInit>:
SemaphoreHandle_t AdcBusySema;					//Semaphore is taken when an ADC acquisition is performed
SemaphoreHandle_t ConversionCompleteSema;	//Semaphore used to signal completion of an ADC conversion

void DriverAdcInit(void)
{
	ADCA.CTRLA=0b00000001; //Enable ADC
     70c:	e0 e0       	ldi	r30, 0x00	; 0
     70e:	f2 e0       	ldi	r31, 0x02	; 2
     710:	81 e0       	ldi	r24, 0x01	; 1
     712:	80 83       	st	Z, r24
	ADCA.CTRLB=0b00000110; //Manual mode, 12 bit right justified
     714:	96 e0       	ldi	r25, 0x06	; 6
     716:	91 83       	std	Z+1, r25	; 0x01
	ADCA.REFCTRL=0b00000010; //1.00V internal reference, enable bandgap
     718:	92 e0       	ldi	r25, 0x02	; 2
     71a:	92 83       	std	Z+2, r25	; 0x02
	ADCA.PRESCALER=0b00000011; //DIV32; 1MHz ADCClk. Should be lower than 1,8MHz per spec
     71c:	93 e0       	ldi	r25, 0x03	; 3
     71e:	94 83       	std	Z+4, r25	; 0x04
	ADCA.CH0.INTCTRL=0b01; //Lo pri int
     720:	82 a3       	std	Z+34, r24	; 0x22
	
	AdcBusySema=xSemaphoreCreateBinary();
     722:	43 e0       	ldi	r20, 0x03	; 3
     724:	60 e0       	ldi	r22, 0x00	; 0
     726:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueGenericCreate>
     72a:	80 93 bf 2d 	sts	0x2DBF, r24	; 0x802dbf <AdcBusySema>
     72e:	90 93 c0 2d 	sts	0x2DC0, r25	; 0x802dc0 <AdcBusySema+0x1>
	ConversionCompleteSema=xSemaphoreCreateBinary();
     732:	43 e0       	ldi	r20, 0x03	; 3
     734:	60 e0       	ldi	r22, 0x00	; 0
     736:	81 e0       	ldi	r24, 0x01	; 1
     738:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueGenericCreate>
     73c:	80 93 bd 2d 	sts	0x2DBD, r24	; 0x802dbd <ConversionCompleteSema>
     740:	90 93 be 2d 	sts	0x2DBE, r25	; 0x802dbe <ConversionCompleteSema+0x1>
	xSemaphoreGive(AdcBusySema);		
     744:	20 e0       	ldi	r18, 0x00	; 0
     746:	40 e0       	ldi	r20, 0x00	; 0
     748:	50 e0       	ldi	r21, 0x00	; 0
     74a:	60 e0       	ldi	r22, 0x00	; 0
     74c:	70 e0       	ldi	r23, 0x00	; 0
     74e:	80 91 bf 2d 	lds	r24, 0x2DBF	; 0x802dbf <AdcBusySema>
     752:	90 91 c0 2d 	lds	r25, 0x2DC0	; 0x802dc0 <AdcBusySema+0x1>
     756:	0c 94 be 20 	jmp	0x417c	; 0x417c <xQueueGenericSend>

0000075a <DriverAdcGetCh>:
}

int16_t DriverAdcGetCh(int8_t PinPos,int8_t PinNeg)
{
     75a:	cf 93       	push	r28
     75c:	df 93       	push	r29
     75e:	c8 2f       	mov	r28, r24
     760:	d6 2f       	mov	r29, r22
	int16_t Res;
	
	xSemaphoreTake(AdcBusySema,portMAX_DELAY);
     762:	6f ef       	ldi	r22, 0xFF	; 255
     764:	7f ef       	ldi	r23, 0xFF	; 255
     766:	80 91 bf 2d 	lds	r24, 0x2DBF	; 0x802dbf <AdcBusySema>
     76a:	90 91 c0 2d 	lds	r25, 0x2DC0	; 0x802dc0 <AdcBusySema+0x1>
     76e:	0e 94 12 23 	call	0x4624	; 0x4624 <xQueueSemaphoreTake>
	
	//Configure channels
	if (PinPos<16 && PinPos>=0)
     772:	c0 31       	cpi	r28, 0x10	; 16
     774:	28 f0       	brcs	.+10     	; 0x780 <DriverAdcGetCh+0x26>
		ADCA.CH0.MUXCTRL=PinPos<<3;
	else
		return 10000; //Invalid settings
     776:	80 e1       	ldi	r24, 0x10	; 16
     778:	97 e2       	ldi	r25, 0x27	; 39
	
	xSemaphoreTake(ConversionCompleteSema,portMAX_DELAY);
	Res=ADCA.CH0.RES;
	xSemaphoreGive(AdcBusySema);
	return Res;
}
     77a:	df 91       	pop	r29
     77c:	cf 91       	pop	r28
     77e:	08 95       	ret
	
	xSemaphoreTake(AdcBusySema,portMAX_DELAY);
	
	//Configure channels
	if (PinPos<16 && PinPos>=0)
		ADCA.CH0.MUXCTRL=PinPos<<3;
     780:	cc 0f       	add	r28, r28
     782:	cc 0f       	add	r28, r28
     784:	cc 0f       	add	r28, r28
     786:	c0 93 21 02 	sts	0x0221, r28	; 0x800221 <__TEXT_REGION_LENGTH__+0x700221>
	else
		return 10000; //Invalid settings

	if (PinNeg==-1) 
     78a:	df 3f       	cpi	r29, 0xFF	; 255
     78c:	a1 f1       	breq	.+104    	; 0x7f6 <DriverAdcGetCh+0x9c>
		{			
		ADCA.CH0.CTRL=0b00000001; //Single ended mode, no gain
		ADCA.CTRLB&=~0b00010000;  //Unsigned mode		
		}		
	else if (PinNeg>=0 && PinNeg<4)
     78e:	d4 30       	cpi	r29, 0x04	; 4
     790:	68 f5       	brcc	.+90     	; 0x7ec <DriverAdcGetCh+0x92>
		{			
		ADCA.CH0.CTRL=0b00000010; //Differential mode, no gain
     792:	82 e0       	ldi	r24, 0x02	; 2
		ADCA.CTRLB|=0b00010000;   //Signed mode
		ADCA.CH0.MUXCTRL|=PinNeg;
		}						
	else if (PinNeg>=4 && PinNeg<8)
		{
		ADCA.CH0.CTRL=0b00011111; //Differential mode, div 2
     794:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
		ADCA.CTRLB|=0b00010000;
     798:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
     79c:	80 61       	ori	r24, 0x10	; 16
     79e:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
		ADCA.CH0.MUXCTRL|=(PinNeg-4);	
     7a2:	80 91 21 02 	lds	r24, 0x0221	; 0x800221 <__TEXT_REGION_LENGTH__+0x700221>
     7a6:	d8 2b       	or	r29, r24
     7a8:	d0 93 21 02 	sts	0x0221, r29	; 0x800221 <__TEXT_REGION_LENGTH__+0x700221>
		}
	else return 10000; //Invalid settings
	
	//Start measurement
	ADCA.CH0.CTRL|=0b10000000; //Start conversion
     7ac:	80 91 20 02 	lds	r24, 0x0220	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
     7b0:	80 68       	ori	r24, 0x80	; 128
     7b2:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
	
	xSemaphoreTake(ConversionCompleteSema,portMAX_DELAY);
     7b6:	6f ef       	ldi	r22, 0xFF	; 255
     7b8:	7f ef       	ldi	r23, 0xFF	; 255
     7ba:	80 91 bd 2d 	lds	r24, 0x2DBD	; 0x802dbd <ConversionCompleteSema>
     7be:	90 91 be 2d 	lds	r25, 0x2DBE	; 0x802dbe <ConversionCompleteSema+0x1>
     7c2:	0e 94 12 23 	call	0x4624	; 0x4624 <xQueueSemaphoreTake>
	Res=ADCA.CH0.RES;
     7c6:	c0 91 24 02 	lds	r28, 0x0224	; 0x800224 <__TEXT_REGION_LENGTH__+0x700224>
     7ca:	d0 91 25 02 	lds	r29, 0x0225	; 0x800225 <__TEXT_REGION_LENGTH__+0x700225>
	xSemaphoreGive(AdcBusySema);
     7ce:	20 e0       	ldi	r18, 0x00	; 0
     7d0:	40 e0       	ldi	r20, 0x00	; 0
     7d2:	50 e0       	ldi	r21, 0x00	; 0
     7d4:	60 e0       	ldi	r22, 0x00	; 0
     7d6:	70 e0       	ldi	r23, 0x00	; 0
     7d8:	80 91 bf 2d 	lds	r24, 0x2DBF	; 0x802dbf <AdcBusySema>
     7dc:	90 91 c0 2d 	lds	r25, 0x2DC0	; 0x802dc0 <AdcBusySema+0x1>
     7e0:	0e 94 be 20 	call	0x417c	; 0x417c <xQueueGenericSend>
	return Res;
     7e4:	ce 01       	movw	r24, r28
}
     7e6:	df 91       	pop	r29
     7e8:	cf 91       	pop	r28
     7ea:	08 95       	ret
		{			
		ADCA.CH0.CTRL=0b00000010; //Differential mode, no gain
		ADCA.CTRLB|=0b00010000;   //Signed mode
		ADCA.CH0.MUXCTRL|=PinNeg;
		}						
	else if (PinNeg>=4 && PinNeg<8)
     7ec:	d4 50       	subi	r29, 0x04	; 4
     7ee:	d4 30       	cpi	r29, 0x04	; 4
     7f0:	10 f6       	brcc	.-124    	; 0x776 <DriverAdcGetCh+0x1c>
		{
		ADCA.CH0.CTRL=0b00011111; //Differential mode, div 2
     7f2:	8f e1       	ldi	r24, 0x1F	; 31
     7f4:	cf cf       	rjmp	.-98     	; 0x794 <DriverAdcGetCh+0x3a>
	else
		return 10000; //Invalid settings

	if (PinNeg==-1) 
		{			
		ADCA.CH0.CTRL=0b00000001; //Single ended mode, no gain
     7f6:	81 e0       	ldi	r24, 0x01	; 1
     7f8:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
		ADCA.CTRLB&=~0b00010000;  //Unsigned mode		
     7fc:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
     800:	8f 7e       	andi	r24, 0xEF	; 239
     802:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
     806:	d2 cf       	rjmp	.-92     	; 0x7ac <DriverAdcGetCh+0x52>

00000808 <__vector_71>:
	xSemaphoreGive(AdcBusySema);
	return Res;
}

ISR(ADCA_CH0_vect)
{
     808:	1f 92       	push	r1
     80a:	0f 92       	push	r0
     80c:	0f b6       	in	r0, 0x3f	; 63
     80e:	0f 92       	push	r0
     810:	11 24       	eor	r1, r1
     812:	0b b6       	in	r0, 0x3b	; 59
     814:	0f 92       	push	r0
     816:	2f 93       	push	r18
     818:	3f 93       	push	r19
     81a:	4f 93       	push	r20
     81c:	5f 93       	push	r21
     81e:	6f 93       	push	r22
     820:	7f 93       	push	r23
     822:	8f 93       	push	r24
     824:	9f 93       	push	r25
     826:	af 93       	push	r26
     828:	bf 93       	push	r27
     82a:	ef 93       	push	r30
     82c:	ff 93       	push	r31
     82e:	cf 93       	push	r28
     830:	df 93       	push	r29
     832:	1f 92       	push	r1
     834:	cd b7       	in	r28, 0x3d	; 61
     836:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
     838:	19 82       	std	Y+1, r1	; 0x01
	xSemaphoreGiveFromISR(ConversionCompleteSema,&xHigherPriorityTaskWoken);
     83a:	be 01       	movw	r22, r28
     83c:	6f 5f       	subi	r22, 0xFF	; 255
     83e:	7f 4f       	sbci	r23, 0xFF	; 255
     840:	80 91 bd 2d 	lds	r24, 0x2DBD	; 0x802dbd <ConversionCompleteSema>
     844:	90 91 be 2d 	lds	r25, 0x2DBE	; 0x802dbe <ConversionCompleteSema+0x1>
     848:	0e 94 02 22 	call	0x4404	; 0x4404 <xQueueGiveFromISR>
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     84c:	89 81       	ldd	r24, Y+1	; 0x01
     84e:	81 11       	cpse	r24, r1
     850:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <vPortYieldISR>
     854:	0f 90       	pop	r0
     856:	df 91       	pop	r29
     858:	cf 91       	pop	r28
     85a:	ff 91       	pop	r31
     85c:	ef 91       	pop	r30
     85e:	bf 91       	pop	r27
     860:	af 91       	pop	r26
     862:	9f 91       	pop	r25
     864:	8f 91       	pop	r24
     866:	7f 91       	pop	r23
     868:	6f 91       	pop	r22
     86a:	5f 91       	pop	r21
     86c:	4f 91       	pop	r20
     86e:	3f 91       	pop	r19
     870:	2f 91       	pop	r18
     872:	0f 90       	pop	r0
     874:	0b be       	out	0x3b, r0	; 59
     876:	0f 90       	pop	r0
     878:	0f be       	out	0x3f, r0	; 63
     87a:	0f 90       	pop	r0
     87c:	1f 90       	pop	r1
     87e:	18 95       	reti

00000880 <DriverAdps9960Init>:

#define REG_ID 0x92
#define ID 0xAB

void DriverAdps9960Init(void)
{
     880:	0f 93       	push	r16
     882:	cf 93       	push	r28
     884:	df 93       	push	r29
     886:	1f 92       	push	r1
     888:	1f 92       	push	r1
     88a:	cd b7       	in	r28, 0x3d	; 61
     88c:	de b7       	in	r29, 0x3e	; 62
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=REG_ENABLE;
     88e:	80 e8       	ldi	r24, 0x80	; 128
     890:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=(1<<REG_ENABLE_PON);
     892:	81 e0       	ldi	r24, 0x01	; 1
     894:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);
     896:	42 e0       	ldi	r20, 0x02	; 2
     898:	be 01       	movw	r22, r28
     89a:	6f 5f       	subi	r22, 0xFF	; 255
     89c:	7f 4f       	sbci	r23, 0xFF	; 255
     89e:	89 e3       	ldi	r24, 0x39	; 57
     8a0:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
	//printf ("TwimWrite:%d\r\n",res);
	
	Buffer[0]=REG_ID;
     8a4:	82 e9       	ldi	r24, 0x92	; 146
     8a6:	89 83       	std	Y+1, r24	; 0x01
	res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,1);
     8a8:	01 e0       	ldi	r16, 0x01	; 1
     8aa:	9e 01       	movw	r18, r28
     8ac:	2f 5f       	subi	r18, 0xFF	; 255
     8ae:	3f 4f       	sbci	r19, 0xFF	; 255
     8b0:	41 e0       	ldi	r20, 0x01	; 1
     8b2:	b9 01       	movw	r22, r18
     8b4:	89 e3       	ldi	r24, 0x39	; 57
     8b6:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
	if (Buffer[0]!=ID)
     8ba:	89 81       	ldd	r24, Y+1	; 0x01
     8bc:	8b 3a       	cpi	r24, 0xAB	; 171
     8be:	61 f0       	breq	.+24     	; 0x8d8 <DriverAdps9960Init+0x58>
		printf ("ADPS9960 ID readback fail: %d read\r\n",Buffer[0]);
     8c0:	1f 92       	push	r1
     8c2:	8f 93       	push	r24
     8c4:	8e ed       	ldi	r24, 0xDE	; 222
     8c6:	90 e2       	ldi	r25, 0x20	; 32
     8c8:	9f 93       	push	r25
     8ca:	8f 93       	push	r24
     8cc:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
     8d0:	0f 90       	pop	r0
     8d2:	0f 90       	pop	r0
     8d4:	0f 90       	pop	r0
     8d6:	0f 90       	pop	r0

	Buffer[0]=REG_ATIME;
     8d8:	81 e8       	ldi	r24, 0x81	; 129
     8da:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=219; //100ms integration time
     8dc:	8b ed       	ldi	r24, 0xDB	; 219
     8de:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);
     8e0:	42 e0       	ldi	r20, 0x02	; 2
     8e2:	be 01       	movw	r22, r28
     8e4:	6f 5f       	subi	r22, 0xFF	; 255
     8e6:	7f 4f       	sbci	r23, 0xFF	; 255
     8e8:	89 e3       	ldi	r24, 0x39	; 57
     8ea:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>

	Buffer[0]=REG_CTRL1;
     8ee:	8f e8       	ldi	r24, 0x8F	; 143
     8f0:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=0b11<<REG_CTRL1_AGAIN; //max gain
     8f2:	83 e0       	ldi	r24, 0x03	; 3
     8f4:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);
     8f6:	42 e0       	ldi	r20, 0x02	; 2
     8f8:	be 01       	movw	r22, r28
     8fa:	6f 5f       	subi	r22, 0xFF	; 255
     8fc:	7f 4f       	sbci	r23, 0xFF	; 255
     8fe:	89 e3       	ldi	r24, 0x39	; 57
     900:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>

}
     904:	0f 90       	pop	r0
     906:	0f 90       	pop	r0
     908:	df 91       	pop	r29
     90a:	cf 91       	pop	r28
     90c:	0f 91       	pop	r16
     90e:	08 95       	ret

00000910 <DriverAdps9960Get>:

void DriverAdps9960Get(uint16_t *Clear,uint16_t *Red,uint16_t *Green, uint16_t *Blue)
{
     910:	8f 92       	push	r8
     912:	9f 92       	push	r9
     914:	af 92       	push	r10
     916:	bf 92       	push	r11
     918:	cf 92       	push	r12
     91a:	df 92       	push	r13
     91c:	ef 92       	push	r14
     91e:	ff 92       	push	r15
     920:	0f 93       	push	r16
     922:	1f 93       	push	r17
     924:	cf 93       	push	r28
     926:	df 93       	push	r29
     928:	cd b7       	in	r28, 0x3d	; 61
     92a:	de b7       	in	r29, 0x3e	; 62
     92c:	29 97       	sbiw	r28, 0x09	; 9
     92e:	cd bf       	out	0x3d, r28	; 61
     930:	de bf       	out	0x3e, r29	; 62
     932:	4c 01       	movw	r8, r24
     934:	5b 01       	movw	r10, r22
     936:	6a 01       	movw	r12, r20
     938:	79 01       	movw	r14, r18
	uint8_t Buffer[9];
	uint16_t *C=(uint16_t *) &(Buffer[0]),*R=(uint16_t *) &(Buffer[2]),*G=(uint16_t *) &(Buffer[4]),*B=(uint16_t *) &(Buffer[6]);
	uint8_t *Status=&(Buffer[0]);


	Buffer[0]=REG_ENABLE;
     93a:	80 e8       	ldi	r24, 0x80	; 128
     93c:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=(1<<REG_ENABLE_PON) | (1<<REG_ENABLE_AEN);
     93e:	83 e0       	ldi	r24, 0x03	; 3
     940:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);
     942:	42 e0       	ldi	r20, 0x02	; 2
     944:	be 01       	movw	r22, r28
     946:	6f 5f       	subi	r22, 0xFF	; 255
     948:	7f 4f       	sbci	r23, 0xFF	; 255
     94a:	89 e3       	ldi	r24, 0x39	; 57
     94c:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>


	do 
	{
		Buffer[0]=REG_STATUS;
     950:	13 e9       	ldi	r17, 0x93	; 147
     952:	03 c0       	rjmp	.+6      	; 0x95a <DriverAdps9960Get+0x4a>
		res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,1);
		configASSERT(res);
		//printf ("STATUS:%d\r\n",Buffer[0]);
	} while (!(Buffer[0] & (1<<REG_STATUX_AVALID)) );
     954:	89 81       	ldd	r24, Y+1	; 0x01
     956:	80 fd       	sbrc	r24, 0
     958:	15 c0       	rjmp	.+42     	; 0x984 <DriverAdps9960Get+0x74>
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);


	do 
	{
		Buffer[0]=REG_STATUS;
     95a:	19 83       	std	Y+1, r17	; 0x01
		res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,1);
     95c:	01 e0       	ldi	r16, 0x01	; 1
     95e:	9e 01       	movw	r18, r28
     960:	2f 5f       	subi	r18, 0xFF	; 255
     962:	3f 4f       	sbci	r19, 0xFF	; 255
     964:	41 e0       	ldi	r20, 0x01	; 1
     966:	b9 01       	movw	r22, r18
     968:	89 e3       	ldi	r24, 0x39	; 57
     96a:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
		configASSERT(res);
     96e:	81 11       	cpse	r24, r1
     970:	f1 cf       	rjmp	.-30     	; 0x954 <DriverAdps9960Get+0x44>
     972:	63 e4       	ldi	r22, 0x43	; 67
     974:	70 e0       	ldi	r23, 0x00	; 0
     976:	83 e0       	ldi	r24, 0x03	; 3
     978:	91 e2       	ldi	r25, 0x21	; 33
     97a:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
		//printf ("STATUS:%d\r\n",Buffer[0]);
	} while (!(Buffer[0] & (1<<REG_STATUX_AVALID)) );
     97e:	89 81       	ldd	r24, Y+1	; 0x01
     980:	80 ff       	sbrs	r24, 0
     982:	eb cf       	rjmp	.-42     	; 0x95a <DriverAdps9960Get+0x4a>


	Buffer[0]=REG_CDATA;
     984:	84 e9       	ldi	r24, 0x94	; 148
     986:	89 83       	std	Y+1, r24	; 0x01
	res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,8);
     988:	08 e0       	ldi	r16, 0x08	; 8
     98a:	9e 01       	movw	r18, r28
     98c:	2f 5f       	subi	r18, 0xFF	; 255
     98e:	3f 4f       	sbci	r19, 0xFF	; 255
     990:	41 e0       	ldi	r20, 0x01	; 1
     992:	b9 01       	movw	r22, r18
     994:	89 e3       	ldi	r24, 0x39	; 57
     996:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
	configASSERT(res);
     99a:	88 23       	and	r24, r24
     99c:	81 f1       	breq	.+96     	; 0x9fe <DriverAdps9960Get+0xee>
	//printf ("TwimWriteRead:%d\r\n",res);

	if (Clear!=NULL) *Clear=*C;	
     99e:	81 14       	cp	r8, r1
     9a0:	91 04       	cpc	r9, r1
     9a2:	29 f0       	breq	.+10     	; 0x9ae <DriverAdps9960Get+0x9e>
     9a4:	89 81       	ldd	r24, Y+1	; 0x01
     9a6:	9a 81       	ldd	r25, Y+2	; 0x02
     9a8:	f4 01       	movw	r30, r8
     9aa:	80 83       	st	Z, r24
     9ac:	91 83       	std	Z+1, r25	; 0x01
	if (Red!=NULL) *Red=*R;
     9ae:	a1 14       	cp	r10, r1
     9b0:	b1 04       	cpc	r11, r1
     9b2:	29 f0       	breq	.+10     	; 0x9be <DriverAdps9960Get+0xae>
     9b4:	8b 81       	ldd	r24, Y+3	; 0x03
     9b6:	9c 81       	ldd	r25, Y+4	; 0x04
     9b8:	f5 01       	movw	r30, r10
     9ba:	80 83       	st	Z, r24
     9bc:	91 83       	std	Z+1, r25	; 0x01
	if (Green!=NULL) *Green=*G;
     9be:	c1 14       	cp	r12, r1
     9c0:	d1 04       	cpc	r13, r1
     9c2:	29 f0       	breq	.+10     	; 0x9ce <DriverAdps9960Get+0xbe>
     9c4:	8d 81       	ldd	r24, Y+5	; 0x05
     9c6:	9e 81       	ldd	r25, Y+6	; 0x06
     9c8:	f6 01       	movw	r30, r12
     9ca:	80 83       	st	Z, r24
     9cc:	91 83       	std	Z+1, r25	; 0x01
	if (Blue!=NULL) *Blue=*B;
     9ce:	e1 14       	cp	r14, r1
     9d0:	f1 04       	cpc	r15, r1
     9d2:	29 f0       	breq	.+10     	; 0x9de <DriverAdps9960Get+0xce>
     9d4:	8f 81       	ldd	r24, Y+7	; 0x07
     9d6:	98 85       	ldd	r25, Y+8	; 0x08
     9d8:	f7 01       	movw	r30, r14
     9da:	80 83       	st	Z, r24
     9dc:	91 83       	std	Z+1, r25	; 0x01

     9de:	29 96       	adiw	r28, 0x09	; 9
     9e0:	cd bf       	out	0x3d, r28	; 61
     9e2:	de bf       	out	0x3e, r29	; 62
     9e4:	df 91       	pop	r29
     9e6:	cf 91       	pop	r28
     9e8:	1f 91       	pop	r17
     9ea:	0f 91       	pop	r16
     9ec:	ff 90       	pop	r15
     9ee:	ef 90       	pop	r14
     9f0:	df 90       	pop	r13
     9f2:	cf 90       	pop	r12
     9f4:	bf 90       	pop	r11
     9f6:	af 90       	pop	r10
     9f8:	9f 90       	pop	r9
     9fa:	8f 90       	pop	r8
     9fc:	08 95       	ret
	} while (!(Buffer[0] & (1<<REG_STATUX_AVALID)) );


	Buffer[0]=REG_CDATA;
	res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,8);
	configASSERT(res);
     9fe:	6a e4       	ldi	r22, 0x4A	; 74
     a00:	70 e0       	ldi	r23, 0x00	; 0
     a02:	83 e0       	ldi	r24, 0x03	; 3
     a04:	91 e2       	ldi	r25, 0x21	; 33
     a06:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
     a0a:	c9 cf       	rjmp	.-110    	; 0x99e <DriverAdps9960Get+0x8e>

00000a0c <DriverCursorstickInit>:

static QueueHandle_t CursorstickQueue;

void DriverCursorstickInit(void)
{
	PORTB.DIRCLR=0b11111000;
     a0c:	e0 e2       	ldi	r30, 0x20	; 32
     a0e:	f6 e0       	ldi	r31, 0x06	; 6
     a10:	98 ef       	ldi	r25, 0xF8	; 248
     a12:	92 83       	std	Z+2, r25	; 0x02
	PORTB.PIN3CTRL=0b01011001; //Pull up, inverted
     a14:	89 e5       	ldi	r24, 0x59	; 89
     a16:	83 8b       	std	Z+19, r24	; 0x13
	PORTB.PIN4CTRL=0b01011001; //Pull up, inverted	
     a18:	84 8b       	std	Z+20, r24	; 0x14
	PORTB.PIN5CTRL=0b01011001; //Pull up, inverted
     a1a:	85 8b       	std	Z+21, r24	; 0x15
	PORTB.PIN6CTRL=0b01011001; //Pull up, inverted
     a1c:	86 8b       	std	Z+22, r24	; 0x16
	PORTB.PIN7CTRL=0b01011001; //Pull up, inverted
     a1e:	87 8b       	std	Z+23, r24	; 0x17
	PORTB.INT0MASK=0b11111000; //Interrupt on all cursor stick lines
     a20:	92 87       	std	Z+10, r25	; 0x0a
	PORTB.INTCTRL=0b01;		   //Enable interrupt0
     a22:	81 e0       	ldi	r24, 0x01	; 1
     a24:	81 87       	std	Z+9, r24	; 0x09
	
	CursorstickQueue=xQueueCreate(CURSOR_FIFO_LENGTH,1);
     a26:	40 e0       	ldi	r20, 0x00	; 0
     a28:	61 e0       	ldi	r22, 0x01	; 1
     a2a:	8a e0       	ldi	r24, 0x0A	; 10
     a2c:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueGenericCreate>
     a30:	80 93 76 28 	sts	0x2876, r24	; 0x802876 <CursorstickQueue>
     a34:	90 93 77 28 	sts	0x2877, r25	; 0x802877 <CursorstickQueue+0x1>
     a38:	08 95       	ret

00000a3a <DriverCursorstickGet>:
}

uint8_t DriverCursorstickGet(void)
{
	uint8_t ret=0;
	if (PORTB.IN & (1<<3)) ret|=(1<<4);
     a3a:	80 91 28 06 	lds	r24, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     a3e:	83 ff       	sbrs	r24, 3
     a40:	12 c0       	rjmp	.+36     	; 0xa66 <DriverCursorstickGet+0x2c>
     a42:	80 e1       	ldi	r24, 0x10	; 16
	if (PORTB.IN & (1<<4)) ret|=(1<<3);
     a44:	90 91 28 06 	lds	r25, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     a48:	94 fd       	sbrc	r25, 4
     a4a:	88 60       	ori	r24, 0x08	; 8
	if (PORTB.IN & (1<<5)) ret|=(1<<2);
     a4c:	90 91 28 06 	lds	r25, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     a50:	95 fd       	sbrc	r25, 5
     a52:	84 60       	ori	r24, 0x04	; 4
	if (PORTB.IN & (1<<6)) ret|=(1<<1);
     a54:	90 91 28 06 	lds	r25, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     a58:	96 fd       	sbrc	r25, 6
     a5a:	82 60       	ori	r24, 0x02	; 2
	if (PORTB.IN & (1<<7)) ret|=(1<<0);
     a5c:	90 91 28 06 	lds	r25, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     a60:	97 fd       	sbrc	r25, 7
     a62:	03 c0       	rjmp	.+6      	; 0xa6a <DriverCursorstickGet+0x30>

	return ret;
}
     a64:	08 95       	ret
	CursorstickQueue=xQueueCreate(CURSOR_FIFO_LENGTH,1);
}

uint8_t DriverCursorstickGet(void)
{
	uint8_t ret=0;
     a66:	80 e0       	ldi	r24, 0x00	; 0
     a68:	ed cf       	rjmp	.-38     	; 0xa44 <DriverCursorstickGet+0xa>
	if (PORTB.IN & (1<<3)) ret|=(1<<4);
	if (PORTB.IN & (1<<4)) ret|=(1<<3);
	if (PORTB.IN & (1<<5)) ret|=(1<<2);
	if (PORTB.IN & (1<<6)) ret|=(1<<1);
	if (PORTB.IN & (1<<7)) ret|=(1<<0);
     a6a:	81 60       	ori	r24, 0x01	; 1

	return ret;
}
     a6c:	08 95       	ret

00000a6e <DriverCursorStickGetFifo>:

uint8_t DriverCursorStickGetFifo(TickType_t BlockTime)
{
     a6e:	cf 93       	push	r28
     a70:	df 93       	push	r29
     a72:	1f 92       	push	r1
     a74:	cd b7       	in	r28, 0x3d	; 61
     a76:	de b7       	in	r29, 0x3e	; 62
	uint8_t ButtonState;
	BaseType_t res;
	res=xQueueReceive(CursorstickQueue,&ButtonState,BlockTime);
     a78:	ac 01       	movw	r20, r24
     a7a:	be 01       	movw	r22, r28
     a7c:	6f 5f       	subi	r22, 0xFF	; 255
     a7e:	7f 4f       	sbci	r23, 0xFF	; 255
     a80:	80 91 76 28 	lds	r24, 0x2876	; 0x802876 <CursorstickQueue>
     a84:	90 91 77 28 	lds	r25, 0x2877	; 0x802877 <CursorstickQueue+0x1>
     a88:	0e 94 55 22 	call	0x44aa	; 0x44aa <xQueueReceive>
	if (res==pdTRUE) return ButtonState;
     a8c:	81 30       	cpi	r24, 0x01	; 1
     a8e:	29 f0       	breq	.+10     	; 0xa9a <DriverCursorStickGetFifo+0x2c>
	else return 0;
     a90:	80 e0       	ldi	r24, 0x00	; 0

}
     a92:	0f 90       	pop	r0
     a94:	df 91       	pop	r29
     a96:	cf 91       	pop	r28
     a98:	08 95       	ret
uint8_t DriverCursorStickGetFifo(TickType_t BlockTime)
{
	uint8_t ButtonState;
	BaseType_t res;
	res=xQueueReceive(CursorstickQueue,&ButtonState,BlockTime);
	if (res==pdTRUE) return ButtonState;
     a9a:	89 81       	ldd	r24, Y+1	; 0x01
	else return 0;

}
     a9c:	0f 90       	pop	r0
     a9e:	df 91       	pop	r29
     aa0:	cf 91       	pop	r28
     aa2:	08 95       	ret

00000aa4 <__vector_34>:

ISR (PORTB_INT0_vect)
{
     aa4:	1f 92       	push	r1
     aa6:	0f 92       	push	r0
     aa8:	0f b6       	in	r0, 0x3f	; 63
     aaa:	0f 92       	push	r0
     aac:	11 24       	eor	r1, r1
     aae:	0b b6       	in	r0, 0x3b	; 59
     ab0:	0f 92       	push	r0
     ab2:	cf 92       	push	r12
     ab4:	df 92       	push	r13
     ab6:	ef 92       	push	r14
     ab8:	ff 92       	push	r15
     aba:	0f 93       	push	r16
     abc:	1f 93       	push	r17
     abe:	2f 93       	push	r18
     ac0:	3f 93       	push	r19
     ac2:	4f 93       	push	r20
     ac4:	5f 93       	push	r21
     ac6:	6f 93       	push	r22
     ac8:	7f 93       	push	r23
     aca:	8f 93       	push	r24
     acc:	9f 93       	push	r25
     ace:	af 93       	push	r26
     ad0:	bf 93       	push	r27
     ad2:	ef 93       	push	r30
     ad4:	ff 93       	push	r31
     ad6:	cf 93       	push	r28
     ad8:	df 93       	push	r29
     ada:	1f 92       	push	r1
     adc:	1f 92       	push	r1
     ade:	cd b7       	in	r28, 0x3d	; 61
     ae0:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastIntTime=0;
	uint32_t CurTime;
	uint8_t ButtonState;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
     ae2:	19 82       	std	Y+1, r1	; 0x01
	
	CurTime=portGET_RUN_TIME_COUNTER_VALUE();
     ae4:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
     ae8:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
     aec:	c0 90 cf 2d 	lds	r12, 0x2DCF	; 0x802dcf <StatsTimer>
     af0:	d0 90 d0 2d 	lds	r13, 0x2DD0	; 0x802dd0 <StatsTimer+0x1>
     af4:	e0 90 d1 2d 	lds	r14, 0x2DD1	; 0x802dd1 <StatsTimer+0x2>
     af8:	f0 90 d2 2d 	lds	r15, 0x2DD2	; 0x802dd2 <StatsTimer+0x3>
     afc:	c8 0e       	add	r12, r24
     afe:	d9 1e       	adc	r13, r25
     b00:	e1 1c       	adc	r14, r1
     b02:	f1 1c       	adc	r15, r1
	ButtonState=DriverCursorstickGet();
     b04:	0e 94 1d 05 	call	0xa3a	; 0xa3a <DriverCursorstickGet>
     b08:	8a 83       	std	Y+2, r24	; 0x02
	
	if ((CurTime-LastIntTime)>CURSOR_MIN_INTERVAL) //debounce
     b0a:	40 91 72 28 	lds	r20, 0x2872	; 0x802872 <LastIntTime.4302>
     b0e:	50 91 73 28 	lds	r21, 0x2873	; 0x802873 <LastIntTime.4302+0x1>
     b12:	60 91 74 28 	lds	r22, 0x2874	; 0x802874 <LastIntTime.4302+0x2>
     b16:	70 91 75 28 	lds	r23, 0x2875	; 0x802875 <LastIntTime.4302+0x3>
     b1a:	97 01       	movw	r18, r14
     b1c:	86 01       	movw	r16, r12
     b1e:	04 1b       	sub	r16, r20
     b20:	15 0b       	sbc	r17, r21
     b22:	26 0b       	sbc	r18, r22
     b24:	37 0b       	sbc	r19, r23
     b26:	b9 01       	movw	r22, r18
     b28:	a8 01       	movw	r20, r16
     b2a:	41 30       	cpi	r20, 0x01	; 1
     b2c:	58 4a       	sbci	r21, 0xA8	; 168
     b2e:	61 46       	sbci	r22, 0x61	; 97
     b30:	71 05       	cpc	r23, r1
     b32:	10 f0       	brcs	.+4      	; 0xb38 <__vector_34+0x94>
		if (ButtonState>0) 
     b34:	81 11       	cpse	r24, r1
     b36:	21 c0       	rjmp	.+66     	; 0xb7a <__vector_34+0xd6>
		{
			xQueueSendToBackFromISR(CursorstickQueue,&ButtonState,&xHigherPriorityTaskWoken);
			LastIntTime=CurTime;
		}
		
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     b38:	89 81       	ldd	r24, Y+1	; 0x01
     b3a:	81 11       	cpse	r24, r1
     b3c:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <vPortYieldISR>
     b40:	0f 90       	pop	r0
     b42:	0f 90       	pop	r0
     b44:	df 91       	pop	r29
     b46:	cf 91       	pop	r28
     b48:	ff 91       	pop	r31
     b4a:	ef 91       	pop	r30
     b4c:	bf 91       	pop	r27
     b4e:	af 91       	pop	r26
     b50:	9f 91       	pop	r25
     b52:	8f 91       	pop	r24
     b54:	7f 91       	pop	r23
     b56:	6f 91       	pop	r22
     b58:	5f 91       	pop	r21
     b5a:	4f 91       	pop	r20
     b5c:	3f 91       	pop	r19
     b5e:	2f 91       	pop	r18
     b60:	1f 91       	pop	r17
     b62:	0f 91       	pop	r16
     b64:	ff 90       	pop	r15
     b66:	ef 90       	pop	r14
     b68:	df 90       	pop	r13
     b6a:	cf 90       	pop	r12
     b6c:	0f 90       	pop	r0
     b6e:	0b be       	out	0x3b, r0	; 59
     b70:	0f 90       	pop	r0
     b72:	0f be       	out	0x3f, r0	; 63
     b74:	0f 90       	pop	r0
     b76:	1f 90       	pop	r1
     b78:	18 95       	reti
	ButtonState=DriverCursorstickGet();
	
	if ((CurTime-LastIntTime)>CURSOR_MIN_INTERVAL) //debounce
		if (ButtonState>0) 
		{
			xQueueSendToBackFromISR(CursorstickQueue,&ButtonState,&xHigherPriorityTaskWoken);
     b7a:	20 e0       	ldi	r18, 0x00	; 0
     b7c:	ae 01       	movw	r20, r28
     b7e:	4f 5f       	subi	r20, 0xFF	; 255
     b80:	5f 4f       	sbci	r21, 0xFF	; 255
     b82:	be 01       	movw	r22, r28
     b84:	6e 5f       	subi	r22, 0xFE	; 254
     b86:	7f 4f       	sbci	r23, 0xFF	; 255
     b88:	80 91 76 28 	lds	r24, 0x2876	; 0x802876 <CursorstickQueue>
     b8c:	90 91 77 28 	lds	r25, 0x2877	; 0x802877 <CursorstickQueue+0x1>
     b90:	0e 94 a7 21 	call	0x434e	; 0x434e <xQueueGenericSendFromISR>
			LastIntTime=CurTime;
     b94:	c0 92 72 28 	sts	0x2872, r12	; 0x802872 <LastIntTime.4302>
     b98:	d0 92 73 28 	sts	0x2873, r13	; 0x802873 <LastIntTime.4302+0x1>
     b9c:	e0 92 74 28 	sts	0x2874, r14	; 0x802874 <LastIntTime.4302+0x2>
     ba0:	f0 92 75 28 	sts	0x2875, r15	; 0x802875 <LastIntTime.4302+0x3>
     ba4:	c9 cf       	rjmp	.-110    	; 0xb38 <__vector_34+0x94>

00000ba6 <DbgPrint>:
#include "DriverDbgUSART.h"


void DbgPrint(char *Text)
{
     ba6:	dc 01       	movw	r26, r24
}

void DbgPrintn(char *Text,int n)
{
	static int i;
	i=0;
     ba8:	10 92 7b 28 	sts	0x287B, r1	; 0x80287b <i.3624>
     bac:	10 92 7c 28 	sts	0x287C, r1	; 0x80287c <i.3624+0x1>
	while (*Text!=0 && (i<n || n==0))
     bb0:	9c 91       	ld	r25, X
     bb2:	99 23       	and	r25, r25
     bb4:	b1 f0       	breq	.+44     	; 0xbe2 <DbgPrint+0x3c>
     bb6:	fd 01       	movw	r30, r26
     bb8:	31 96       	adiw	r30, 0x01	; 1
	{
		USART.DATA = *Text;
		while (!(USART.STATUS & 0b01000000));
		USART.STATUS=0b01000000;
     bba:	80 e4       	ldi	r24, 0x40	; 64
{
	static int i;
	i=0;
	while (*Text!=0 && (i<n || n==0))
	{
		USART.DATA = *Text;
     bbc:	90 93 a0 0a 	sts	0x0AA0, r25	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
		while (!(USART.STATUS & 0b01000000));
     bc0:	90 91 a1 0a 	lds	r25, 0x0AA1	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
     bc4:	96 ff       	sbrs	r25, 6
     bc6:	fc cf       	rjmp	.-8      	; 0xbc0 <DbgPrint+0x1a>
		USART.STATUS=0b01000000;
     bc8:	80 93 a1 0a 	sts	0x0AA1, r24	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
     bcc:	9f 01       	movw	r18, r30
     bce:	2a 1b       	sub	r18, r26
     bd0:	3b 0b       	sbc	r19, r27

void DbgPrintn(char *Text,int n)
{
	static int i;
	i=0;
	while (*Text!=0 && (i<n || n==0))
     bd2:	91 91       	ld	r25, Z+
     bd4:	91 11       	cpse	r25, r1
     bd6:	f2 cf       	rjmp	.-28     	; 0xbbc <DbgPrint+0x16>
     bd8:	20 93 7b 28 	sts	0x287B, r18	; 0x80287b <i.3624>
     bdc:	30 93 7c 28 	sts	0x287C, r19	; 0x80287c <i.3624+0x1>
     be0:	08 95       	ret
     be2:	08 95       	ret

00000be4 <DbgPrintn>:
{
	DbgPrintn(Text,0);	
}

void DbgPrintn(char *Text,int n)
{
     be4:	fc 01       	movw	r30, r24
	static int i;
	i=0;
     be6:	10 92 7b 28 	sts	0x287B, r1	; 0x80287b <i.3624>
     bea:	10 92 7c 28 	sts	0x287C, r1	; 0x80287c <i.3624+0x1>
	while (*Text!=0 && (i<n || n==0))
     bee:	90 81       	ld	r25, Z
     bf0:	99 23       	and	r25, r25
     bf2:	e1 f0       	breq	.+56     	; 0xc2c <DbgPrintn+0x48>
     bf4:	31 96       	adiw	r30, 0x01	; 1
     bf6:	20 e0       	ldi	r18, 0x00	; 0
     bf8:	30 e0       	ldi	r19, 0x00	; 0
	{
		USART.DATA = *Text;
		while (!(USART.STATUS & 0b01000000));
		USART.STATUS=0b01000000;
     bfa:	80 e4       	ldi	r24, 0x40	; 64

void DbgPrintn(char *Text,int n)
{
	static int i;
	i=0;
	while (*Text!=0 && (i<n || n==0))
     bfc:	26 17       	cp	r18, r22
     bfe:	37 07       	cpc	r19, r23
     c00:	1c f0       	brlt	.+6      	; 0xc08 <DbgPrintn+0x24>
     c02:	61 15       	cp	r22, r1
     c04:	71 05       	cpc	r23, r1
     c06:	69 f4       	brne	.+26     	; 0xc22 <DbgPrintn+0x3e>
	{
		USART.DATA = *Text;
     c08:	90 93 a0 0a 	sts	0x0AA0, r25	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
		while (!(USART.STATUS & 0b01000000));
     c0c:	90 91 a1 0a 	lds	r25, 0x0AA1	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
     c10:	96 ff       	sbrs	r25, 6
     c12:	fc cf       	rjmp	.-8      	; 0xc0c <DbgPrintn+0x28>
		USART.STATUS=0b01000000;
     c14:	80 93 a1 0a 	sts	0x0AA1, r24	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
		Text++;
		i++;
     c18:	2f 5f       	subi	r18, 0xFF	; 255
     c1a:	3f 4f       	sbci	r19, 0xFF	; 255

void DbgPrintn(char *Text,int n)
{
	static int i;
	i=0;
	while (*Text!=0 && (i<n || n==0))
     c1c:	91 91       	ld	r25, Z+
     c1e:	91 11       	cpse	r25, r1
     c20:	ed cf       	rjmp	.-38     	; 0xbfc <DbgPrintn+0x18>
     c22:	20 93 7b 28 	sts	0x287B, r18	; 0x80287b <i.3624>
     c26:	30 93 7c 28 	sts	0x287C, r19	; 0x80287c <i.3624+0x1>
     c2a:	08 95       	ret
     c2c:	08 95       	ret

00000c2e <DbgPrintInt>:
		i++;
	}
}

void DbgPrintInt(uint16_t Data)
{
     c2e:	cf 92       	push	r12
     c30:	df 92       	push	r13
     c32:	ef 92       	push	r14
     c34:	ff 92       	push	r15
     c36:	0f 93       	push	r16
     c38:	1f 93       	push	r17
     c3a:	cf 93       	push	r28
     c3c:	df 93       	push	r29
     c3e:	7c 01       	movw	r14, r24
	//Use statics to minimize stack usage
	static int i;
	static uint8_t pf;
	
	i=10000;
     c40:	80 e1       	ldi	r24, 0x10	; 16
     c42:	97 e2       	ldi	r25, 0x27	; 39
     c44:	80 93 79 28 	sts	0x2879, r24	; 0x802879 <i.3634>
     c48:	90 93 7a 28 	sts	0x287A, r25	; 0x80287a <i.3634+0x1>
	pf=0;
     c4c:	10 92 78 28 	sts	0x2878, r1	; 0x802878 <pf.3635>
     c50:	c5 e0       	ldi	r28, 0x05	; 5
     c52:	d0 e0       	ldi	r29, 0x00	; 0
     c54:	c1 2c       	mov	r12, r1
     c56:	e0 e1       	ldi	r30, 0x10	; 16
     c58:	f7 e2       	ldi	r31, 0x27	; 39
	{
		if (((Data/i)%10)!=0 || pf) //Trim leading 0's
		{
			USART.DATA = '0'+ ((Data/i)%10);
			while (!(USART.STATUS & 0b01000000));
			USART.STATUS=0b01000000;
     c5a:	a0 e4       	ldi	r26, 0x40	; 64
     c5c:	da 2e       	mov	r13, r26
			pf=1;		
		}
		i/=10;
     c5e:	0a e0       	ldi	r16, 0x0A	; 10
     c60:	10 e0       	ldi	r17, 0x00	; 0
	
	i=10000;
	pf=0;
	while (i>0)
	{
		if (((Data/i)%10)!=0 || pf) //Trim leading 0's
     c62:	c7 01       	movw	r24, r14
     c64:	bf 01       	movw	r22, r30
     c66:	0e 94 0b 49 	call	0x9216	; 0x9216 <__udivmodhi4>
     c6a:	ab 01       	movw	r20, r22
     c6c:	9b 01       	movw	r18, r22
     c6e:	ad ec       	ldi	r26, 0xCD	; 205
     c70:	bc ec       	ldi	r27, 0xCC	; 204
     c72:	0e 94 55 49 	call	0x92aa	; 0x92aa <__umulhisi3>
     c76:	96 95       	lsr	r25
     c78:	87 95       	ror	r24
     c7a:	96 95       	lsr	r25
     c7c:	87 95       	ror	r24
     c7e:	96 95       	lsr	r25
     c80:	87 95       	ror	r24
     c82:	9c 01       	movw	r18, r24
     c84:	22 0f       	add	r18, r18
     c86:	33 1f       	adc	r19, r19
     c88:	88 0f       	add	r24, r24
     c8a:	99 1f       	adc	r25, r25
     c8c:	88 0f       	add	r24, r24
     c8e:	99 1f       	adc	r25, r25
     c90:	88 0f       	add	r24, r24
     c92:	99 1f       	adc	r25, r25
     c94:	82 0f       	add	r24, r18
     c96:	93 1f       	adc	r25, r19
     c98:	9a 01       	movw	r18, r20
     c9a:	28 1b       	sub	r18, r24
     c9c:	39 0b       	sbc	r19, r25
     c9e:	c9 01       	movw	r24, r18
     ca0:	00 97       	sbiw	r24, 0x00	; 0
     ca2:	11 f4       	brne	.+4      	; 0xca8 <DbgPrintInt+0x7a>
     ca4:	cc 20       	and	r12, r12
     ca6:	59 f0       	breq	.+22     	; 0xcbe <DbgPrintInt+0x90>
		{
			USART.DATA = '0'+ ((Data/i)%10);
     ca8:	80 5d       	subi	r24, 0xD0	; 208
     caa:	80 93 a0 0a 	sts	0x0AA0, r24	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
			while (!(USART.STATUS & 0b01000000));
     cae:	80 91 a1 0a 	lds	r24, 0x0AA1	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
     cb2:	86 ff       	sbrs	r24, 6
     cb4:	fc cf       	rjmp	.-8      	; 0xcae <DbgPrintInt+0x80>
			USART.STATUS=0b01000000;
     cb6:	d0 92 a1 0a 	sts	0x0AA1, r13	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
			pf=1;		
     cba:	cc 24       	eor	r12, r12
     cbc:	c3 94       	inc	r12
		}
		i/=10;
     cbe:	cf 01       	movw	r24, r30
     cc0:	b8 01       	movw	r22, r16
     cc2:	0e 94 1f 49 	call	0x923e	; 0x923e <__divmodhi4>
     cc6:	fb 01       	movw	r30, r22
     cc8:	21 97       	sbiw	r28, 0x01	; 1
	static int i;
	static uint8_t pf;
	
	i=10000;
	pf=0;
	while (i>0)
     cca:	59 f6       	brne	.-106    	; 0xc62 <DbgPrintInt+0x34>
     ccc:	c0 92 78 28 	sts	0x2878, r12	; 0x802878 <pf.3635>
     cd0:	60 93 79 28 	sts	0x2879, r22	; 0x802879 <i.3634>
     cd4:	70 93 7a 28 	sts	0x287A, r23	; 0x80287a <i.3634+0x1>
			USART.STATUS=0b01000000;
			pf=1;		
		}
		i/=10;
	}
}
     cd8:	df 91       	pop	r29
     cda:	cf 91       	pop	r28
     cdc:	1f 91       	pop	r17
     cde:	0f 91       	pop	r16
     ce0:	ff 90       	pop	r15
     ce2:	ef 90       	pop	r14
     ce4:	df 90       	pop	r13
     ce6:	cf 90       	pop	r12
     ce8:	08 95       	ret

00000cea <DriverLedInit>:
}

void DriverLedWrite(uint8_t LedData)
{
	PORTB.OUT=(PORTB.OUT & 0b11111000) | (LedData & 0b00000111);
	PORTA.OUT=(PORTA.OUT & 0b01111111) | ((LedData & 0b00001000) << 4); 
     cea:	e0 e2       	ldi	r30, 0x20	; 32
     cec:	f6 e0       	ldi	r31, 0x06	; 6
     cee:	87 e0       	ldi	r24, 0x07	; 7
     cf0:	81 83       	std	Z+1, r24	; 0x01
     cf2:	80 e4       	ldi	r24, 0x40	; 64
     cf4:	80 8b       	std	Z+16, r24	; 0x10
     cf6:	81 8b       	std	Z+17, r24	; 0x11
     cf8:	82 8b       	std	Z+18, r24	; 0x12
     cfa:	e0 e0       	ldi	r30, 0x00	; 0
     cfc:	f6 e0       	ldi	r31, 0x06	; 6
     cfe:	90 e8       	ldi	r25, 0x80	; 128
     d00:	91 83       	std	Z+1, r25	; 0x01
     d02:	87 8b       	std	Z+23, r24	; 0x17
     d04:	08 95       	ret

00000d06 <DriverLedSet>:
}

void DriverLedSet(uint8_t LedData)
{
	PORTB.OUT=PORTB.OUT | (LedData & 0b00000111);
     d06:	e0 e2       	ldi	r30, 0x20	; 32
     d08:	f6 e0       	ldi	r31, 0x06	; 6
     d0a:	94 81       	ldd	r25, Z+4	; 0x04
     d0c:	28 2f       	mov	r18, r24
     d0e:	27 70       	andi	r18, 0x07	; 7
     d10:	92 2b       	or	r25, r18
     d12:	94 83       	std	Z+4, r25	; 0x04
	PORTA.OUT=PORTA.OUT | ((LedData & 0b00001000) << 4);
     d14:	e0 e0       	ldi	r30, 0x00	; 0
     d16:	f6 e0       	ldi	r31, 0x06	; 6
     d18:	94 81       	ldd	r25, Z+4	; 0x04
     d1a:	88 70       	andi	r24, 0x08	; 8
     d1c:	82 95       	swap	r24
     d1e:	80 7f       	andi	r24, 0xF0	; 240
     d20:	89 2b       	or	r24, r25
     d22:	84 83       	std	Z+4, r24	; 0x04
     d24:	08 95       	ret

00000d26 <DriverLedClear>:
}

void DriverLedClear(uint8_t LedData)
{
	PORTB.OUT=PORTB.OUT & ~(LedData & 0b00000111);
     d26:	e0 e2       	ldi	r30, 0x20	; 32
     d28:	f6 e0       	ldi	r31, 0x06	; 6
     d2a:	24 81       	ldd	r18, Z+4	; 0x04
     d2c:	98 2f       	mov	r25, r24
     d2e:	97 70       	andi	r25, 0x07	; 7
     d30:	90 95       	com	r25
     d32:	92 23       	and	r25, r18
     d34:	94 83       	std	Z+4, r25	; 0x04
	PORTA.OUT=PORTA.OUT & ~((LedData & 0b00001000) << 4);
     d36:	e0 e0       	ldi	r30, 0x00	; 0
     d38:	f6 e0       	ldi	r31, 0x06	; 6
     d3a:	94 81       	ldd	r25, Z+4	; 0x04
     d3c:	88 70       	andi	r24, 0x08	; 8
     d3e:	82 95       	swap	r24
     d40:	80 7f       	andi	r24, 0xF0	; 240
     d42:	80 95       	com	r24
     d44:	89 23       	and	r24, r25
     d46:	84 83       	std	Z+4, r24	; 0x04
     d48:	08 95       	ret

00000d4a <DriverMotorInit>:


void DriverMotorInit(void)
{
	//GPIO init
	PORTF.DIRSET=0b11111;
     d4a:	e0 ea       	ldi	r30, 0xA0	; 160
     d4c:	f6 e0       	ldi	r31, 0x06	; 6
     d4e:	8f e1       	ldi	r24, 0x1F	; 31
     d50:	81 83       	std	Z+1, r24	; 0x01
	PORTF.PIN4CTRL=0b01000000; //Invert
     d52:	80 e4       	ldi	r24, 0x40	; 64
     d54:	84 8b       	std	Z+20, r24	; 0x14
	PORTF.OUTSET=0b10000; //Sleep enable
     d56:	20 e1       	ldi	r18, 0x10	; 16
     d58:	25 83       	std	Z+5, r18	; 0x05
	
	//Timer init, hbridge
	TCF0.CTRLA=0b00000001; //DIV1
     d5a:	e0 e0       	ldi	r30, 0x00	; 0
     d5c:	fb e0       	ldi	r31, 0x0B	; 11
     d5e:	91 e0       	ldi	r25, 0x01	; 1
     d60:	90 83       	st	Z, r25
	TCF0.CTRLB=0b11110011; //OCA,OCB,OCC,OCD enable, SS PWM
     d62:	93 ef       	ldi	r25, 0xF3	; 243
     d64:	91 83       	std	Z+1, r25	; 0x01
	TCF0.PER=4096; //7812 Hz PWM
     d66:	40 e0       	ldi	r20, 0x00	; 0
     d68:	50 e1       	ldi	r21, 0x10	; 16
     d6a:	46 a3       	std	Z+38, r20	; 0x26
     d6c:	57 a3       	std	Z+39, r21	; 0x27
	
	//Encoder 1A, 1B
	PORTC.DIRCLR=0b11000000; 
     d6e:	e0 e4       	ldi	r30, 0x40	; 64
     d70:	f6 e0       	ldi	r31, 0x06	; 6
     d72:	90 ec       	ldi	r25, 0xC0	; 192
     d74:	92 83       	std	Z+2, r25	; 0x02
	PORTC.PIN6CTRL=0b01000000; //any edge detect
     d76:	86 8b       	std	Z+22, r24	; 0x16
	PORTC.PIN7CTRL=0b01000000; //any edge detect
     d78:	87 8b       	std	Z+23, r24	; 0x17
	PORTC.INT0MASK=1<<6;
     d7a:	82 87       	std	Z+10, r24	; 0x0a
	PORTC.INT1MASK=1<<7;
     d7c:	90 e8       	ldi	r25, 0x80	; 128
     d7e:	93 87       	std	Z+11, r25	; 0x0b
	PORTC.INTCTRL=0b0101;
     d80:	95 e0       	ldi	r25, 0x05	; 5
     d82:	91 87       	std	Z+9, r25	; 0x09

	//Encoder 2A, 2B
	PORTE.DIRCLR=0b00110000;
     d84:	e0 e8       	ldi	r30, 0x80	; 128
     d86:	f6 e0       	ldi	r31, 0x06	; 6
     d88:	30 e3       	ldi	r19, 0x30	; 48
     d8a:	32 83       	std	Z+2, r19	; 0x02
	PORTE.PIN4CTRL=0b01000000; //any edge detect
     d8c:	84 8b       	std	Z+20, r24	; 0x14
	PORTE.PIN5CTRL=0b01000000; //any edge detect
     d8e:	85 8b       	std	Z+21, r24	; 0x15
	PORTE.INT0MASK=1<<4;
     d90:	22 87       	std	Z+10, r18	; 0x0a
	PORTE.INT1MASK=1<<5;
     d92:	80 e2       	ldi	r24, 0x20	; 32
     d94:	83 87       	std	Z+11, r24	; 0x0b
	PORTE.INTCTRL=0b0101;
     d96:	91 87       	std	Z+9, r25	; 0x09
	
	EncoderEventQueue=xQueueCreate(ENCODER_EVENT_QUEUE_LENGTH,sizeof(EncoderEventStruct));
     d98:	40 e0       	ldi	r20, 0x00	; 0
     d9a:	65 e0       	ldi	r22, 0x05	; 5
     d9c:	84 e1       	ldi	r24, 0x14	; 20
     d9e:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueGenericCreate>
     da2:	80 93 c5 2d 	sts	0x2DC5, r24	; 0x802dc5 <EncoderEventQueue>
     da6:	90 93 c6 2d 	sts	0x2DC6, r25	; 0x802dc6 <EncoderEventQueue+0x1>
     daa:	08 95       	ret

00000dac <DriverMotorSet>:

void DriverMotorSet(int16_t MotorLeft,int16_t MotorRight)
{
	//Sleep mode handling
	if (MotorLeft==0 && MotorRight==0)
		PORTF.OUTSET=0b10000; //DRV8833 in sleep mode
     dac:	20 e1       	ldi	r18, 0x10	; 16


void DriverMotorSet(int16_t MotorLeft,int16_t MotorRight)
{
	//Sleep mode handling
	if (MotorLeft==0 && MotorRight==0)
     dae:	00 97       	sbiw	r24, 0x00	; 0
     db0:	69 f5       	brne	.+90     	; 0xe0c <DriverMotorSet+0x60>
     db2:	61 15       	cp	r22, r1
     db4:	71 05       	cpc	r23, r1
     db6:	09 f4       	brne	.+2      	; 0xdba <DriverMotorSet+0xe>
     db8:	57 c0       	rjmp	.+174    	; 0xe68 <DriverMotorSet+0xbc>
		PORTF.OUTSET=0b10000; //DRV8833 in sleep mode
	else
		PORTF.OUTCLR=0b10000; //DRV8833 in active mode
     dba:	20 93 a6 06 	sts	0x06A6, r18	; 0x8006a6 <__TEXT_REGION_LENGTH__+0x7006a6>
		TCF0.CCB=MotorLeft;
	}
	else
	{
		if (MotorLeft<-4095) MotorLeft=-4095;
		TCF0.CCA=-MotorLeft;	
     dbe:	81 30       	cpi	r24, 0x01	; 1
     dc0:	20 ef       	ldi	r18, 0xF0	; 240
     dc2:	92 07       	cpc	r25, r18
     dc4:	0c f4       	brge	.+2      	; 0xdc8 <DriverMotorSet+0x1c>
     dc6:	57 c0       	rjmp	.+174    	; 0xe76 <DriverMotorSet+0xca>
     dc8:	91 95       	neg	r25
     dca:	81 95       	neg	r24
     dcc:	91 09       	sbc	r25, r1
     dce:	80 93 28 0b 	sts	0x0B28, r24	; 0x800b28 <__TEXT_REGION_LENGTH__+0x700b28>
     dd2:	90 93 29 0b 	sts	0x0B29, r25	; 0x800b29 <__TEXT_REGION_LENGTH__+0x700b29>
		TCF0.CCB=0;
     dd6:	10 92 2a 0b 	sts	0x0B2A, r1	; 0x800b2a <__TEXT_REGION_LENGTH__+0x700b2a>
     dda:	10 92 2b 0b 	sts	0x0B2B, r1	; 0x800b2b <__TEXT_REGION_LENGTH__+0x700b2b>
	}

	//Right motor
	if (MOTOR_RIGHT_INVERT==1) MotorRight=-MotorRight;
     dde:	71 95       	neg	r23
     de0:	61 95       	neg	r22
     de2:	71 09       	sbc	r23, r1
	if (MotorRight>0)
     de4:	16 16       	cp	r1, r22
     de6:	17 06       	cpc	r1, r23
     de8:	44 f1       	brlt	.+80     	; 0xe3a <DriverMotorSet+0x8e>
		TCF0.CCD=MotorRight;
	}
	else
	{
		if (MotorRight<-4095) MotorRight=-4095;
		TCF0.CCC=-MotorRight;
     dea:	61 30       	cpi	r22, 0x01	; 1
     dec:	20 ef       	ldi	r18, 0xF0	; 240
     dee:	72 07       	cpc	r23, r18
     df0:	0c f4       	brge	.+2      	; 0xdf4 <DriverMotorSet+0x48>
     df2:	44 c0       	rjmp	.+136    	; 0xe7c <DriverMotorSet+0xd0>
     df4:	71 95       	neg	r23
     df6:	61 95       	neg	r22
     df8:	71 09       	sbc	r23, r1
     dfa:	60 93 2c 0b 	sts	0x0B2C, r22	; 0x800b2c <__TEXT_REGION_LENGTH__+0x700b2c>
     dfe:	70 93 2d 0b 	sts	0x0B2D, r23	; 0x800b2d <__TEXT_REGION_LENGTH__+0x700b2d>
		TCF0.CCD=0;
     e02:	10 92 2e 0b 	sts	0x0B2E, r1	; 0x800b2e <__TEXT_REGION_LENGTH__+0x700b2e>
     e06:	10 92 2f 0b 	sts	0x0B2F, r1	; 0x800b2f <__TEXT_REGION_LENGTH__+0x700b2f>
	}
	
}
     e0a:	08 95       	ret
{
	//Sleep mode handling
	if (MotorLeft==0 && MotorRight==0)
		PORTF.OUTSET=0b10000; //DRV8833 in sleep mode
	else
		PORTF.OUTCLR=0b10000; //DRV8833 in active mode
     e0c:	20 93 a6 06 	sts	0x06A6, r18	; 0x8006a6 <__TEXT_REGION_LENGTH__+0x7006a6>
	
	//Left motor
	if (MOTOR_LEFT_INVERT==1) MotorLeft=-MotorLeft;
	if (MotorLeft>0)
     e10:	18 16       	cp	r1, r24
     e12:	19 06       	cpc	r1, r25
     e14:	a4 f6       	brge	.-88     	; 0xdbe <DriverMotorSet+0x12>
	{
		if (MotorLeft>4095) MotorLeft=4095;
		TCF0.CCA=0;
     e16:	10 92 28 0b 	sts	0x0B28, r1	; 0x800b28 <__TEXT_REGION_LENGTH__+0x700b28>
     e1a:	10 92 29 0b 	sts	0x0B29, r1	; 0x800b29 <__TEXT_REGION_LENGTH__+0x700b29>
		TCF0.CCB=MotorLeft;
     e1e:	81 15       	cp	r24, r1
     e20:	20 e1       	ldi	r18, 0x10	; 16
     e22:	92 07       	cpc	r25, r18
     e24:	f4 f4       	brge	.+60     	; 0xe62 <DriverMotorSet+0xb6>
     e26:	80 93 2a 0b 	sts	0x0B2A, r24	; 0x800b2a <__TEXT_REGION_LENGTH__+0x700b2a>
     e2a:	90 93 2b 0b 	sts	0x0B2B, r25	; 0x800b2b <__TEXT_REGION_LENGTH__+0x700b2b>
		TCF0.CCA=-MotorLeft;	
		TCF0.CCB=0;
	}

	//Right motor
	if (MOTOR_RIGHT_INVERT==1) MotorRight=-MotorRight;
     e2e:	71 95       	neg	r23
     e30:	61 95       	neg	r22
     e32:	71 09       	sbc	r23, r1
	if (MotorRight>0)
     e34:	16 16       	cp	r1, r22
     e36:	17 06       	cpc	r1, r23
     e38:	c4 f6       	brge	.-80     	; 0xdea <DriverMotorSet+0x3e>
	{
		if (MotorRight>4095) MotorRight=4095;
		TCF0.CCC=0;
     e3a:	10 92 2c 0b 	sts	0x0B2C, r1	; 0x800b2c <__TEXT_REGION_LENGTH__+0x700b2c>
     e3e:	10 92 2d 0b 	sts	0x0B2D, r1	; 0x800b2d <__TEXT_REGION_LENGTH__+0x700b2d>
		TCF0.CCD=MotorRight;
     e42:	61 15       	cp	r22, r1
     e44:	80 e1       	ldi	r24, 0x10	; 16
     e46:	78 07       	cpc	r23, r24
     e48:	2c f4       	brge	.+10     	; 0xe54 <DriverMotorSet+0xa8>
     e4a:	60 93 2e 0b 	sts	0x0B2E, r22	; 0x800b2e <__TEXT_REGION_LENGTH__+0x700b2e>
     e4e:	70 93 2f 0b 	sts	0x0B2F, r23	; 0x800b2f <__TEXT_REGION_LENGTH__+0x700b2f>
     e52:	08 95       	ret
     e54:	6f ef       	ldi	r22, 0xFF	; 255
     e56:	7f e0       	ldi	r23, 0x0F	; 15
     e58:	60 93 2e 0b 	sts	0x0B2E, r22	; 0x800b2e <__TEXT_REGION_LENGTH__+0x700b2e>
     e5c:	70 93 2f 0b 	sts	0x0B2F, r23	; 0x800b2f <__TEXT_REGION_LENGTH__+0x700b2f>
     e60:	08 95       	ret
	if (MOTOR_LEFT_INVERT==1) MotorLeft=-MotorLeft;
	if (MotorLeft>0)
	{
		if (MotorLeft>4095) MotorLeft=4095;
		TCF0.CCA=0;
		TCF0.CCB=MotorLeft;
     e62:	8f ef       	ldi	r24, 0xFF	; 255
     e64:	9f e0       	ldi	r25, 0x0F	; 15
     e66:	df cf       	rjmp	.-66     	; 0xe26 <DriverMotorSet+0x7a>

void DriverMotorSet(int16_t MotorLeft,int16_t MotorRight)
{
	//Sleep mode handling
	if (MotorLeft==0 && MotorRight==0)
		PORTF.OUTSET=0b10000; //DRV8833 in sleep mode
     e68:	20 93 a5 06 	sts	0x06A5, r18	; 0x8006a5 <__TEXT_REGION_LENGTH__+0x7006a5>
		TCF0.CCB=MotorLeft;
	}
	else
	{
		if (MotorLeft<-4095) MotorLeft=-4095;
		TCF0.CCA=-MotorLeft;	
     e6c:	81 30       	cpi	r24, 0x01	; 1
     e6e:	20 ef       	ldi	r18, 0xF0	; 240
     e70:	92 07       	cpc	r25, r18
     e72:	0c f0       	brlt	.+2      	; 0xe76 <DriverMotorSet+0xca>
     e74:	a9 cf       	rjmp	.-174    	; 0xdc8 <DriverMotorSet+0x1c>
     e76:	81 e0       	ldi	r24, 0x01	; 1
     e78:	90 ef       	ldi	r25, 0xF0	; 240
     e7a:	a6 cf       	rjmp	.-180    	; 0xdc8 <DriverMotorSet+0x1c>
		TCF0.CCD=MotorRight;
	}
	else
	{
		if (MotorRight<-4095) MotorRight=-4095;
		TCF0.CCC=-MotorRight;
     e7c:	61 e0       	ldi	r22, 0x01	; 1
     e7e:	70 ef       	ldi	r23, 0xF0	; 240
     e80:	b9 cf       	rjmp	.-142    	; 0xdf4 <DriverMotorSet+0x48>

00000e82 <DriverMotorGetEncoder>:

EncoderStruct DriverMotorGetEncoder(void)
{
	EncoderStruct EncoderInfo;

	portENTER_CRITICAL();
     e82:	0f b6       	in	r0, 0x3f	; 63
     e84:	f8 94       	cli
     e86:	0f 92       	push	r0
	if (!ENCODER_LEFT_INVERT)
		EncoderInfo.Cnt1=Cnt1;
     e88:	40 91 c1 2d 	lds	r20, 0x2DC1	; 0x802dc1 <Cnt1>
     e8c:	50 91 c2 2d 	lds	r21, 0x2DC2	; 0x802dc2 <Cnt1+0x1>
	else
		EncoderInfo.Cnt1=-Cnt1;
	
	if (!ENCODER_RIGHT_INVERT)
		EncoderInfo.Cnt2=Cnt2;
     e90:	20 91 c3 2d 	lds	r18, 0x2DC3	; 0x802dc3 <Cnt2>
     e94:	30 91 c4 2d 	lds	r19, 0x2DC4	; 0x802dc4 <Cnt2+0x1>
	else
		EncoderInfo.Cnt2=-Cnt2;
	portEXIT_CRITICAL();
     e98:	0f 90       	pop	r0
     e9a:	0f be       	out	0x3f, r0	; 63
	return EncoderInfo;
     e9c:	ba 01       	movw	r22, r20
     e9e:	c9 01       	movw	r24, r18
}
     ea0:	08 95       	ret

00000ea2 <DriverMotorGetEncoderEvent>:

EncoderEventStruct DriverMotorGetEncoderEvent(void)
{
     ea2:	cf 93       	push	r28
     ea4:	df 93       	push	r29
     ea6:	cd b7       	in	r28, 0x3d	; 61
     ea8:	de b7       	in	r29, 0x3e	; 62
     eaa:	2a 97       	sbiw	r28, 0x0a	; 10
     eac:	cd bf       	out	0x3d, r28	; 61
     eae:	de bf       	out	0x3e, r29	; 62
	EncoderEventStruct Event={0,NONE};
     eb0:	1e 82       	std	Y+6, r1	; 0x06
     eb2:	1f 82       	std	Y+7, r1	; 0x07
     eb4:	18 86       	std	Y+8, r1	; 0x08
     eb6:	19 86       	std	Y+9, r1	; 0x09
     eb8:	1a 86       	std	Y+10, r1	; 0x0a
	int res;
	res=xQueueReceive(EncoderEventQueue,&Event,0);
     eba:	40 e0       	ldi	r20, 0x00	; 0
     ebc:	50 e0       	ldi	r21, 0x00	; 0
     ebe:	be 01       	movw	r22, r28
     ec0:	6a 5f       	subi	r22, 0xFA	; 250
     ec2:	7f 4f       	sbci	r23, 0xFF	; 255
     ec4:	80 91 c5 2d 	lds	r24, 0x2DC5	; 0x802dc5 <EncoderEventQueue>
     ec8:	90 91 c6 2d 	lds	r25, 0x2DC6	; 0x802dc6 <EncoderEventQueue+0x1>
     ecc:	0e 94 55 22 	call	0x44aa	; 0x44aa <xQueueReceive>
	return Event;
     ed0:	85 e0       	ldi	r24, 0x05	; 5
     ed2:	fe 01       	movw	r30, r28
     ed4:	36 96       	adiw	r30, 0x06	; 6
     ed6:	de 01       	movw	r26, r28
     ed8:	11 96       	adiw	r26, 0x01	; 1
     eda:	01 90       	ld	r0, Z+
     edc:	0d 92       	st	X+, r0
     ede:	8a 95       	dec	r24
     ee0:	e1 f7       	brne	.-8      	; 0xeda <DriverMotorGetEncoderEvent+0x38>
     ee2:	29 81       	ldd	r18, Y+1	; 0x01
     ee4:	3a 81       	ldd	r19, Y+2	; 0x02
     ee6:	4b 81       	ldd	r20, Y+3	; 0x03
     ee8:	5c 81       	ldd	r21, Y+4	; 0x04
     eea:	6d 81       	ldd	r22, Y+5	; 0x05
}
     eec:	70 e0       	ldi	r23, 0x00	; 0
     eee:	80 e0       	ldi	r24, 0x00	; 0
     ef0:	90 e0       	ldi	r25, 0x00	; 0
     ef2:	2a 96       	adiw	r28, 0x0a	; 10
     ef4:	cd bf       	out	0x3d, r28	; 61
     ef6:	de bf       	out	0x3e, r29	; 62
     ef8:	df 91       	pop	r29
     efa:	cf 91       	pop	r28
     efc:	08 95       	ret

00000efe <__vector_2>:

//Encoder 1 ISR's
ISR (PORTC_INT0_vect)
{	
     efe:	1f 92       	push	r1
     f00:	0f 92       	push	r0
     f02:	0f b6       	in	r0, 0x3f	; 63
     f04:	0f 92       	push	r0
     f06:	11 24       	eor	r1, r1
     f08:	0b b6       	in	r0, 0x3b	; 59
     f0a:	0f 92       	push	r0
     f0c:	1f 93       	push	r17
     f0e:	2f 93       	push	r18
     f10:	3f 93       	push	r19
     f12:	4f 93       	push	r20
     f14:	5f 93       	push	r21
     f16:	6f 93       	push	r22
     f18:	7f 93       	push	r23
     f1a:	8f 93       	push	r24
     f1c:	9f 93       	push	r25
     f1e:	af 93       	push	r26
     f20:	bf 93       	push	r27
     f22:	ef 93       	push	r30
     f24:	ff 93       	push	r31
     f26:	cf 93       	push	r28
     f28:	df 93       	push	r29
     f2a:	00 d0       	rcall	.+0      	; 0xf2c <__vector_2+0x2e>
     f2c:	00 d0       	rcall	.+0      	; 0xf2e <__vector_2+0x30>
     f2e:	cd b7       	in	r28, 0x3d	; 61
     f30:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastTriggerTime=0;
	uint8_t Data,l0,l1;
	EncoderEventStruct Event;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
     f32:	1e 82       	std	Y+6, r1	; 0x06
	Event.Time=portGET_RUN_TIME_COUNTER_VALUE();
     f34:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
     f38:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
     f3c:	80 91 cf 2d 	lds	r24, 0x2DCF	; 0x802dcf <StatsTimer>
     f40:	90 91 d0 2d 	lds	r25, 0x2DD0	; 0x802dd0 <StatsTimer+0x1>
     f44:	a0 91 d1 2d 	lds	r26, 0x2DD1	; 0x802dd1 <StatsTimer+0x2>
     f48:	b0 91 d2 2d 	lds	r27, 0x2DD2	; 0x802dd2 <StatsTimer+0x3>
     f4c:	82 0f       	add	r24, r18
     f4e:	93 1f       	adc	r25, r19
     f50:	a1 1d       	adc	r26, r1
     f52:	b1 1d       	adc	r27, r1
     f54:	89 83       	std	Y+1, r24	; 0x01
     f56:	9a 83       	std	Y+2, r25	; 0x02
     f58:	ab 83       	std	Y+3, r26	; 0x03
     f5a:	bc 83       	std	Y+4, r27	; 0x04
	#ifdef ENCODER_FILTER_ENABLE
		if ((Event.Time-LastTriggerTime)<ENCODER_FILTER_TIME) return;
	#endif

	Data=PORTC.IN;
     f5c:	80 91 48 06 	lds	r24, 0x0648	; 0x800648 <__TEXT_REGION_LENGTH__+0x700648>
	l0=Data & (1<<6);
	l1=Data & (1<<7);
     f60:	18 2f       	mov	r17, r24
     f62:	10 78       	andi	r17, 0x80	; 128
		
	//Process events
	if (l0) 
     f64:	86 ff       	sbrs	r24, 6
     f66:	37 c0       	rjmp	.+110    	; 0xfd6 <__vector_2+0xd8>
		Event.Event=RISING_1A;
     f68:	81 e0       	ldi	r24, 0x01	; 1
     f6a:	8d 83       	std	Y+5, r24	; 0x05
	else
		Event.Event=FALLING_1A;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
     f6c:	20 e0       	ldi	r18, 0x00	; 0
     f6e:	ae 01       	movw	r20, r28
     f70:	4a 5f       	subi	r20, 0xFA	; 250
     f72:	5f 4f       	sbci	r21, 0xFF	; 255
     f74:	be 01       	movw	r22, r28
     f76:	6f 5f       	subi	r22, 0xFF	; 255
     f78:	7f 4f       	sbci	r23, 0xFF	; 255
     f7a:	80 91 c5 2d 	lds	r24, 0x2DC5	; 0x802dc5 <EncoderEventQueue>
     f7e:	90 91 c6 2d 	lds	r25, 0x2DC6	; 0x802dc6 <EncoderEventQueue+0x1>
     f82:	0e 94 a7 21 	call	0x434e	; 0x434e <xQueueGenericSendFromISR>
	//Process counter
	if ( l0 && !l1) Cnt1--; //Rising edge on Line0, Line1 low
     f86:	11 23       	and	r17, r17
     f88:	b9 f1       	breq	.+110    	; 0xff8 <__vector_2+0xfa>
	if ( l0 &&  l1) Cnt1++; //Rising edge on Line0, Line1 high	
	if (!l0 &&  l1) Cnt1--; //Falling edge on Line0, Line1 high
	if (!l0 && !l1) Cnt1++;//Falling edge on Line1, Line1 low
     f8a:	80 91 c1 2d 	lds	r24, 0x2DC1	; 0x802dc1 <Cnt1>
     f8e:	90 91 c2 2d 	lds	r25, 0x2DC2	; 0x802dc2 <Cnt1+0x1>
     f92:	01 96       	adiw	r24, 0x01	; 1
     f94:	80 93 c1 2d 	sts	0x2DC1, r24	; 0x802dc1 <Cnt1>
     f98:	90 93 c2 2d 	sts	0x2DC2, r25	; 0x802dc2 <Cnt1+0x1>

	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     f9c:	8e 81       	ldd	r24, Y+6	; 0x06
     f9e:	81 11       	cpse	r24, r1
     fa0:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <vPortYieldISR>
	LastTriggerTime=Event.Time;
}
     fa4:	26 96       	adiw	r28, 0x06	; 6
     fa6:	cd bf       	out	0x3d, r28	; 61
     fa8:	de bf       	out	0x3e, r29	; 62
     faa:	df 91       	pop	r29
     fac:	cf 91       	pop	r28
     fae:	ff 91       	pop	r31
     fb0:	ef 91       	pop	r30
     fb2:	bf 91       	pop	r27
     fb4:	af 91       	pop	r26
     fb6:	9f 91       	pop	r25
     fb8:	8f 91       	pop	r24
     fba:	7f 91       	pop	r23
     fbc:	6f 91       	pop	r22
     fbe:	5f 91       	pop	r21
     fc0:	4f 91       	pop	r20
     fc2:	3f 91       	pop	r19
     fc4:	2f 91       	pop	r18
     fc6:	1f 91       	pop	r17
     fc8:	0f 90       	pop	r0
     fca:	0b be       	out	0x3b, r0	; 59
     fcc:	0f 90       	pop	r0
     fce:	0f be       	out	0x3f, r0	; 63
     fd0:	0f 90       	pop	r0
     fd2:	1f 90       	pop	r1
     fd4:	18 95       	reti
		
	//Process events
	if (l0) 
		Event.Event=RISING_1A;
	else
		Event.Event=FALLING_1A;
     fd6:	85 e0       	ldi	r24, 0x05	; 5
     fd8:	8d 83       	std	Y+5, r24	; 0x05

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
     fda:	20 e0       	ldi	r18, 0x00	; 0
     fdc:	ae 01       	movw	r20, r28
     fde:	4a 5f       	subi	r20, 0xFA	; 250
     fe0:	5f 4f       	sbci	r21, 0xFF	; 255
     fe2:	be 01       	movw	r22, r28
     fe4:	6f 5f       	subi	r22, 0xFF	; 255
     fe6:	7f 4f       	sbci	r23, 0xFF	; 255
     fe8:	80 91 c5 2d 	lds	r24, 0x2DC5	; 0x802dc5 <EncoderEventQueue>
     fec:	90 91 c6 2d 	lds	r25, 0x2DC6	; 0x802dc6 <EncoderEventQueue+0x1>
     ff0:	0e 94 a7 21 	call	0x434e	; 0x434e <xQueueGenericSendFromISR>
	//Process counter
	if ( l0 && !l1) Cnt1--; //Rising edge on Line0, Line1 low
	if ( l0 &&  l1) Cnt1++; //Rising edge on Line0, Line1 high	
	if (!l0 &&  l1) Cnt1--; //Falling edge on Line0, Line1 high
     ff4:	11 23       	and	r17, r17
     ff6:	49 f2       	breq	.-110    	; 0xf8a <__vector_2+0x8c>
     ff8:	80 91 c1 2d 	lds	r24, 0x2DC1	; 0x802dc1 <Cnt1>
     ffc:	90 91 c2 2d 	lds	r25, 0x2DC2	; 0x802dc2 <Cnt1+0x1>
    1000:	01 97       	sbiw	r24, 0x01	; 1
    1002:	80 93 c1 2d 	sts	0x2DC1, r24	; 0x802dc1 <Cnt1>
    1006:	90 93 c2 2d 	sts	0x2DC2, r25	; 0x802dc2 <Cnt1+0x1>
    100a:	c8 cf       	rjmp	.-112    	; 0xf9c <__vector_2+0x9e>

0000100c <__vector_3>:
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	LastTriggerTime=Event.Time;
}

ISR (PORTC_INT1_vect)
{
    100c:	1f 92       	push	r1
    100e:	0f 92       	push	r0
    1010:	0f b6       	in	r0, 0x3f	; 63
    1012:	0f 92       	push	r0
    1014:	11 24       	eor	r1, r1
    1016:	0b b6       	in	r0, 0x3b	; 59
    1018:	0f 92       	push	r0
    101a:	1f 93       	push	r17
    101c:	2f 93       	push	r18
    101e:	3f 93       	push	r19
    1020:	4f 93       	push	r20
    1022:	5f 93       	push	r21
    1024:	6f 93       	push	r22
    1026:	7f 93       	push	r23
    1028:	8f 93       	push	r24
    102a:	9f 93       	push	r25
    102c:	af 93       	push	r26
    102e:	bf 93       	push	r27
    1030:	ef 93       	push	r30
    1032:	ff 93       	push	r31
    1034:	cf 93       	push	r28
    1036:	df 93       	push	r29
    1038:	00 d0       	rcall	.+0      	; 0x103a <__vector_3+0x2e>
    103a:	00 d0       	rcall	.+0      	; 0x103c <__vector_3+0x30>
    103c:	cd b7       	in	r28, 0x3d	; 61
    103e:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastTriggerTime=0;
	uint8_t Data,l0,l1;
	EncoderEventStruct Event;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    1040:	1e 82       	std	Y+6, r1	; 0x06
	Event.Time=portGET_RUN_TIME_COUNTER_VALUE();
    1042:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    1046:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    104a:	80 91 cf 2d 	lds	r24, 0x2DCF	; 0x802dcf <StatsTimer>
    104e:	90 91 d0 2d 	lds	r25, 0x2DD0	; 0x802dd0 <StatsTimer+0x1>
    1052:	a0 91 d1 2d 	lds	r26, 0x2DD1	; 0x802dd1 <StatsTimer+0x2>
    1056:	b0 91 d2 2d 	lds	r27, 0x2DD2	; 0x802dd2 <StatsTimer+0x3>
    105a:	82 0f       	add	r24, r18
    105c:	93 1f       	adc	r25, r19
    105e:	a1 1d       	adc	r26, r1
    1060:	b1 1d       	adc	r27, r1
    1062:	89 83       	std	Y+1, r24	; 0x01
    1064:	9a 83       	std	Y+2, r25	; 0x02
    1066:	ab 83       	std	Y+3, r26	; 0x03
    1068:	bc 83       	std	Y+4, r27	; 0x04
	#ifdef ENCODER_FILTER_ENABLE
		if ((Event.Time-LastTriggerTime)<ENCODER_FILTER_TIME) return;
	#endif
	
	Data=PORTC.IN;
    106a:	80 91 48 06 	lds	r24, 0x0648	; 0x800648 <__TEXT_REGION_LENGTH__+0x700648>
	l0=Data & (1<<6);
    106e:	18 2f       	mov	r17, r24
    1070:	10 74       	andi	r17, 0x40	; 64
	l1=Data & (1<<7);
	
	//Process events
	if (l1)
    1072:	87 ff       	sbrs	r24, 7
    1074:	37 c0       	rjmp	.+110    	; 0x10e4 <__vector_3+0xd8>
		Event.Event=RISING_1B;
    1076:	82 e0       	ldi	r24, 0x02	; 2
    1078:	8d 83       	std	Y+5, r24	; 0x05
	else
		Event.Event=FALLING_1B;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    107a:	20 e0       	ldi	r18, 0x00	; 0
    107c:	ae 01       	movw	r20, r28
    107e:	4a 5f       	subi	r20, 0xFA	; 250
    1080:	5f 4f       	sbci	r21, 0xFF	; 255
    1082:	be 01       	movw	r22, r28
    1084:	6f 5f       	subi	r22, 0xFF	; 255
    1086:	7f 4f       	sbci	r23, 0xFF	; 255
    1088:	80 91 c5 2d 	lds	r24, 0x2DC5	; 0x802dc5 <EncoderEventQueue>
    108c:	90 91 c6 2d 	lds	r25, 0x2DC6	; 0x802dc6 <EncoderEventQueue+0x1>
    1090:	0e 94 a7 21 	call	0x434e	; 0x434e <xQueueGenericSendFromISR>
	//Process counter
	if ( l1 && !l0) Cnt1++;//Rising edge on Line1, Line0 low
    1094:	11 23       	and	r17, r17
    1096:	b9 f1       	breq	.+110    	; 0x1106 <__vector_3+0xfa>
	if ( l1 &&  l0) Cnt1--;//Rising edge on Line1, Line0 high
	if (!l1 &&  l0) Cnt1++;//Falling edge on Line1, Line0 high
	if (!l1 && !l0) Cnt1--;//Falling edge on Line1, Line0 low
    1098:	80 91 c1 2d 	lds	r24, 0x2DC1	; 0x802dc1 <Cnt1>
    109c:	90 91 c2 2d 	lds	r25, 0x2DC2	; 0x802dc2 <Cnt1+0x1>
    10a0:	01 97       	sbiw	r24, 0x01	; 1
    10a2:	80 93 c1 2d 	sts	0x2DC1, r24	; 0x802dc1 <Cnt1>
    10a6:	90 93 c2 2d 	sts	0x2DC2, r25	; 0x802dc2 <Cnt1+0x1>

	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    10aa:	8e 81       	ldd	r24, Y+6	; 0x06
    10ac:	81 11       	cpse	r24, r1
    10ae:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <vPortYieldISR>
	LastTriggerTime=Event.Time;
}
    10b2:	26 96       	adiw	r28, 0x06	; 6
    10b4:	cd bf       	out	0x3d, r28	; 61
    10b6:	de bf       	out	0x3e, r29	; 62
    10b8:	df 91       	pop	r29
    10ba:	cf 91       	pop	r28
    10bc:	ff 91       	pop	r31
    10be:	ef 91       	pop	r30
    10c0:	bf 91       	pop	r27
    10c2:	af 91       	pop	r26
    10c4:	9f 91       	pop	r25
    10c6:	8f 91       	pop	r24
    10c8:	7f 91       	pop	r23
    10ca:	6f 91       	pop	r22
    10cc:	5f 91       	pop	r21
    10ce:	4f 91       	pop	r20
    10d0:	3f 91       	pop	r19
    10d2:	2f 91       	pop	r18
    10d4:	1f 91       	pop	r17
    10d6:	0f 90       	pop	r0
    10d8:	0b be       	out	0x3b, r0	; 59
    10da:	0f 90       	pop	r0
    10dc:	0f be       	out	0x3f, r0	; 63
    10de:	0f 90       	pop	r0
    10e0:	1f 90       	pop	r1
    10e2:	18 95       	reti
	
	//Process events
	if (l1)
		Event.Event=RISING_1B;
	else
		Event.Event=FALLING_1B;
    10e4:	86 e0       	ldi	r24, 0x06	; 6
    10e6:	8d 83       	std	Y+5, r24	; 0x05

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    10e8:	20 e0       	ldi	r18, 0x00	; 0
    10ea:	ae 01       	movw	r20, r28
    10ec:	4a 5f       	subi	r20, 0xFA	; 250
    10ee:	5f 4f       	sbci	r21, 0xFF	; 255
    10f0:	be 01       	movw	r22, r28
    10f2:	6f 5f       	subi	r22, 0xFF	; 255
    10f4:	7f 4f       	sbci	r23, 0xFF	; 255
    10f6:	80 91 c5 2d 	lds	r24, 0x2DC5	; 0x802dc5 <EncoderEventQueue>
    10fa:	90 91 c6 2d 	lds	r25, 0x2DC6	; 0x802dc6 <EncoderEventQueue+0x1>
    10fe:	0e 94 a7 21 	call	0x434e	; 0x434e <xQueueGenericSendFromISR>
	//Process counter
	if ( l1 && !l0) Cnt1++;//Rising edge on Line1, Line0 low
	if ( l1 &&  l0) Cnt1--;//Rising edge on Line1, Line0 high
	if (!l1 &&  l0) Cnt1++;//Falling edge on Line1, Line0 high
    1102:	11 23       	and	r17, r17
    1104:	49 f2       	breq	.-110    	; 0x1098 <__vector_3+0x8c>
    1106:	80 91 c1 2d 	lds	r24, 0x2DC1	; 0x802dc1 <Cnt1>
    110a:	90 91 c2 2d 	lds	r25, 0x2DC2	; 0x802dc2 <Cnt1+0x1>
    110e:	01 96       	adiw	r24, 0x01	; 1
    1110:	80 93 c1 2d 	sts	0x2DC1, r24	; 0x802dc1 <Cnt1>
    1114:	90 93 c2 2d 	sts	0x2DC2, r25	; 0x802dc2 <Cnt1+0x1>
    1118:	c8 cf       	rjmp	.-112    	; 0x10aa <__vector_3+0x9e>

0000111a <__vector_43>:
	LastTriggerTime=Event.Time;
}

//Encoder 2 ISR's
ISR (PORTE_INT0_vect)
{
    111a:	1f 92       	push	r1
    111c:	0f 92       	push	r0
    111e:	0f b6       	in	r0, 0x3f	; 63
    1120:	0f 92       	push	r0
    1122:	11 24       	eor	r1, r1
    1124:	0b b6       	in	r0, 0x3b	; 59
    1126:	0f 92       	push	r0
    1128:	1f 93       	push	r17
    112a:	2f 93       	push	r18
    112c:	3f 93       	push	r19
    112e:	4f 93       	push	r20
    1130:	5f 93       	push	r21
    1132:	6f 93       	push	r22
    1134:	7f 93       	push	r23
    1136:	8f 93       	push	r24
    1138:	9f 93       	push	r25
    113a:	af 93       	push	r26
    113c:	bf 93       	push	r27
    113e:	ef 93       	push	r30
    1140:	ff 93       	push	r31
    1142:	cf 93       	push	r28
    1144:	df 93       	push	r29
    1146:	00 d0       	rcall	.+0      	; 0x1148 <__vector_43+0x2e>
    1148:	00 d0       	rcall	.+0      	; 0x114a <__vector_43+0x30>
    114a:	cd b7       	in	r28, 0x3d	; 61
    114c:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastTriggerTime=0;
	uint8_t Data,l0,l1;
	EncoderEventStruct Event;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    114e:	1e 82       	std	Y+6, r1	; 0x06
	Event.Time=portGET_RUN_TIME_COUNTER_VALUE();
    1150:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    1154:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    1158:	80 91 cf 2d 	lds	r24, 0x2DCF	; 0x802dcf <StatsTimer>
    115c:	90 91 d0 2d 	lds	r25, 0x2DD0	; 0x802dd0 <StatsTimer+0x1>
    1160:	a0 91 d1 2d 	lds	r26, 0x2DD1	; 0x802dd1 <StatsTimer+0x2>
    1164:	b0 91 d2 2d 	lds	r27, 0x2DD2	; 0x802dd2 <StatsTimer+0x3>
    1168:	82 0f       	add	r24, r18
    116a:	93 1f       	adc	r25, r19
    116c:	a1 1d       	adc	r26, r1
    116e:	b1 1d       	adc	r27, r1
    1170:	89 83       	std	Y+1, r24	; 0x01
    1172:	9a 83       	std	Y+2, r25	; 0x02
    1174:	ab 83       	std	Y+3, r26	; 0x03
    1176:	bc 83       	std	Y+4, r27	; 0x04
	#ifdef ENCODER_FILTER_ENABLE
		if ((Event.Time-LastTriggerTime)<ENCODER_FILTER_TIME) return;
	#endif
	
	Data=PORTE.IN;
    1178:	80 91 88 06 	lds	r24, 0x0688	; 0x800688 <__TEXT_REGION_LENGTH__+0x700688>
	l0=Data & (1<<4);
	l1=Data & (1<<5);
    117c:	18 2f       	mov	r17, r24
    117e:	10 72       	andi	r17, 0x20	; 32
	
	//Process events
	if (l0)
    1180:	84 ff       	sbrs	r24, 4
    1182:	37 c0       	rjmp	.+110    	; 0x11f2 <__vector_43+0xd8>
		Event.Event=RISING_2A;
    1184:	83 e0       	ldi	r24, 0x03	; 3
    1186:	8d 83       	std	Y+5, r24	; 0x05
	else
		Event.Event=FALLING_2A;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    1188:	20 e0       	ldi	r18, 0x00	; 0
    118a:	ae 01       	movw	r20, r28
    118c:	4a 5f       	subi	r20, 0xFA	; 250
    118e:	5f 4f       	sbci	r21, 0xFF	; 255
    1190:	be 01       	movw	r22, r28
    1192:	6f 5f       	subi	r22, 0xFF	; 255
    1194:	7f 4f       	sbci	r23, 0xFF	; 255
    1196:	80 91 c5 2d 	lds	r24, 0x2DC5	; 0x802dc5 <EncoderEventQueue>
    119a:	90 91 c6 2d 	lds	r25, 0x2DC6	; 0x802dc6 <EncoderEventQueue+0x1>
    119e:	0e 94 a7 21 	call	0x434e	; 0x434e <xQueueGenericSendFromISR>
	//Process counter
	if ( l0 && !l1) Cnt2--; //Rising edge on Line0, Line1 low
    11a2:	11 23       	and	r17, r17
    11a4:	b9 f1       	breq	.+110    	; 0x1214 <__vector_43+0xfa>
	if ( l0 &&  l1) Cnt2++; //Rising edge on Line0, Line1 high
	if (!l0 &&  l1) Cnt2--; //Falling edge on Line0, Line1 high
	if (!l0 && !l1) Cnt2++;//Falling edge on Line1, Line1 low
    11a6:	80 91 c3 2d 	lds	r24, 0x2DC3	; 0x802dc3 <Cnt2>
    11aa:	90 91 c4 2d 	lds	r25, 0x2DC4	; 0x802dc4 <Cnt2+0x1>
    11ae:	01 96       	adiw	r24, 0x01	; 1
    11b0:	80 93 c3 2d 	sts	0x2DC3, r24	; 0x802dc3 <Cnt2>
    11b4:	90 93 c4 2d 	sts	0x2DC4, r25	; 0x802dc4 <Cnt2+0x1>
	
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    11b8:	8e 81       	ldd	r24, Y+6	; 0x06
    11ba:	81 11       	cpse	r24, r1
    11bc:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <vPortYieldISR>
	LastTriggerTime=Event.Time;
}
    11c0:	26 96       	adiw	r28, 0x06	; 6
    11c2:	cd bf       	out	0x3d, r28	; 61
    11c4:	de bf       	out	0x3e, r29	; 62
    11c6:	df 91       	pop	r29
    11c8:	cf 91       	pop	r28
    11ca:	ff 91       	pop	r31
    11cc:	ef 91       	pop	r30
    11ce:	bf 91       	pop	r27
    11d0:	af 91       	pop	r26
    11d2:	9f 91       	pop	r25
    11d4:	8f 91       	pop	r24
    11d6:	7f 91       	pop	r23
    11d8:	6f 91       	pop	r22
    11da:	5f 91       	pop	r21
    11dc:	4f 91       	pop	r20
    11de:	3f 91       	pop	r19
    11e0:	2f 91       	pop	r18
    11e2:	1f 91       	pop	r17
    11e4:	0f 90       	pop	r0
    11e6:	0b be       	out	0x3b, r0	; 59
    11e8:	0f 90       	pop	r0
    11ea:	0f be       	out	0x3f, r0	; 63
    11ec:	0f 90       	pop	r0
    11ee:	1f 90       	pop	r1
    11f0:	18 95       	reti
	
	//Process events
	if (l0)
		Event.Event=RISING_2A;
	else
		Event.Event=FALLING_2A;
    11f2:	87 e0       	ldi	r24, 0x07	; 7
    11f4:	8d 83       	std	Y+5, r24	; 0x05

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    11f6:	20 e0       	ldi	r18, 0x00	; 0
    11f8:	ae 01       	movw	r20, r28
    11fa:	4a 5f       	subi	r20, 0xFA	; 250
    11fc:	5f 4f       	sbci	r21, 0xFF	; 255
    11fe:	be 01       	movw	r22, r28
    1200:	6f 5f       	subi	r22, 0xFF	; 255
    1202:	7f 4f       	sbci	r23, 0xFF	; 255
    1204:	80 91 c5 2d 	lds	r24, 0x2DC5	; 0x802dc5 <EncoderEventQueue>
    1208:	90 91 c6 2d 	lds	r25, 0x2DC6	; 0x802dc6 <EncoderEventQueue+0x1>
    120c:	0e 94 a7 21 	call	0x434e	; 0x434e <xQueueGenericSendFromISR>
	//Process counter
	if ( l0 && !l1) Cnt2--; //Rising edge on Line0, Line1 low
	if ( l0 &&  l1) Cnt2++; //Rising edge on Line0, Line1 high
	if (!l0 &&  l1) Cnt2--; //Falling edge on Line0, Line1 high
    1210:	11 23       	and	r17, r17
    1212:	49 f2       	breq	.-110    	; 0x11a6 <__vector_43+0x8c>
    1214:	80 91 c3 2d 	lds	r24, 0x2DC3	; 0x802dc3 <Cnt2>
    1218:	90 91 c4 2d 	lds	r25, 0x2DC4	; 0x802dc4 <Cnt2+0x1>
    121c:	01 97       	sbiw	r24, 0x01	; 1
    121e:	80 93 c3 2d 	sts	0x2DC3, r24	; 0x802dc3 <Cnt2>
    1222:	90 93 c4 2d 	sts	0x2DC4, r25	; 0x802dc4 <Cnt2+0x1>
    1226:	c8 cf       	rjmp	.-112    	; 0x11b8 <__vector_43+0x9e>

00001228 <__vector_44>:
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	LastTriggerTime=Event.Time;
}

ISR (PORTE_INT1_vect)
{
    1228:	1f 92       	push	r1
    122a:	0f 92       	push	r0
    122c:	0f b6       	in	r0, 0x3f	; 63
    122e:	0f 92       	push	r0
    1230:	11 24       	eor	r1, r1
    1232:	0b b6       	in	r0, 0x3b	; 59
    1234:	0f 92       	push	r0
    1236:	1f 93       	push	r17
    1238:	2f 93       	push	r18
    123a:	3f 93       	push	r19
    123c:	4f 93       	push	r20
    123e:	5f 93       	push	r21
    1240:	6f 93       	push	r22
    1242:	7f 93       	push	r23
    1244:	8f 93       	push	r24
    1246:	9f 93       	push	r25
    1248:	af 93       	push	r26
    124a:	bf 93       	push	r27
    124c:	ef 93       	push	r30
    124e:	ff 93       	push	r31
    1250:	cf 93       	push	r28
    1252:	df 93       	push	r29
    1254:	00 d0       	rcall	.+0      	; 0x1256 <__vector_44+0x2e>
    1256:	00 d0       	rcall	.+0      	; 0x1258 <__vector_44+0x30>
    1258:	cd b7       	in	r28, 0x3d	; 61
    125a:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastTriggerTime=0;
	uint8_t Data,l0,l1;
	EncoderEventStruct Event;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    125c:	1e 82       	std	Y+6, r1	; 0x06
	Event.Time=portGET_RUN_TIME_COUNTER_VALUE();
    125e:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    1262:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    1266:	80 91 cf 2d 	lds	r24, 0x2DCF	; 0x802dcf <StatsTimer>
    126a:	90 91 d0 2d 	lds	r25, 0x2DD0	; 0x802dd0 <StatsTimer+0x1>
    126e:	a0 91 d1 2d 	lds	r26, 0x2DD1	; 0x802dd1 <StatsTimer+0x2>
    1272:	b0 91 d2 2d 	lds	r27, 0x2DD2	; 0x802dd2 <StatsTimer+0x3>
    1276:	82 0f       	add	r24, r18
    1278:	93 1f       	adc	r25, r19
    127a:	a1 1d       	adc	r26, r1
    127c:	b1 1d       	adc	r27, r1
    127e:	89 83       	std	Y+1, r24	; 0x01
    1280:	9a 83       	std	Y+2, r25	; 0x02
    1282:	ab 83       	std	Y+3, r26	; 0x03
    1284:	bc 83       	std	Y+4, r27	; 0x04
	#ifdef ENCODER_FILTER_ENABLE
		if ((Event.Time-LastTriggerTime)<ENCODER_FILTER_TIME) return;
	#endif
	
	Data=PORTE.IN;
    1286:	80 91 88 06 	lds	r24, 0x0688	; 0x800688 <__TEXT_REGION_LENGTH__+0x700688>
	l0=Data & (1<<4);
	l1=Data & (1<<5);
    128a:	18 2f       	mov	r17, r24
    128c:	10 72       	andi	r17, 0x20	; 32
	
	//Process events
	if (l0)
    128e:	84 ff       	sbrs	r24, 4
    1290:	1c c0       	rjmp	.+56     	; 0x12ca <__vector_44+0xa2>
	Event.Event=RISING_2B;
    1292:	84 e0       	ldi	r24, 0x04	; 4
    1294:	8d 83       	std	Y+5, r24	; 0x05
	else
	Event.Event=FALLING_2B;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    1296:	20 e0       	ldi	r18, 0x00	; 0
    1298:	ae 01       	movw	r20, r28
    129a:	4a 5f       	subi	r20, 0xFA	; 250
    129c:	5f 4f       	sbci	r21, 0xFF	; 255
    129e:	be 01       	movw	r22, r28
    12a0:	6f 5f       	subi	r22, 0xFF	; 255
    12a2:	7f 4f       	sbci	r23, 0xFF	; 255
    12a4:	80 91 c5 2d 	lds	r24, 0x2DC5	; 0x802dc5 <EncoderEventQueue>
    12a8:	90 91 c6 2d 	lds	r25, 0x2DC6	; 0x802dc6 <EncoderEventQueue+0x1>
    12ac:	0e 94 a7 21 	call	0x434e	; 0x434e <xQueueGenericSendFromISR>
	//Process counter
	if ( l1 && !l0) Cnt2++;//Rising edge on Line1, Line0 low
    12b0:	11 23       	and	r17, r17
    12b2:	09 f4       	brne	.+2      	; 0x12b6 <__vector_44+0x8e>
    12b4:	47 c0       	rjmp	.+142    	; 0x1344 <__vector_44+0x11c>
	if ( l1 &&  l0) Cnt2--;//Rising edge on Line1, Line0 high
    12b6:	80 91 c3 2d 	lds	r24, 0x2DC3	; 0x802dc3 <Cnt2>
    12ba:	90 91 c4 2d 	lds	r25, 0x2DC4	; 0x802dc4 <Cnt2+0x1>
    12be:	01 97       	sbiw	r24, 0x01	; 1
    12c0:	80 93 c3 2d 	sts	0x2DC3, r24	; 0x802dc3 <Cnt2>
    12c4:	90 93 c4 2d 	sts	0x2DC4, r25	; 0x802dc4 <Cnt2+0x1>
    12c8:	1a c0       	rjmp	.+52     	; 0x12fe <__vector_44+0xd6>
	
	//Process events
	if (l0)
	Event.Event=RISING_2B;
	else
	Event.Event=FALLING_2B;
    12ca:	88 e0       	ldi	r24, 0x08	; 8
    12cc:	8d 83       	std	Y+5, r24	; 0x05

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    12ce:	20 e0       	ldi	r18, 0x00	; 0
    12d0:	ae 01       	movw	r20, r28
    12d2:	4a 5f       	subi	r20, 0xFA	; 250
    12d4:	5f 4f       	sbci	r21, 0xFF	; 255
    12d6:	be 01       	movw	r22, r28
    12d8:	6f 5f       	subi	r22, 0xFF	; 255
    12da:	7f 4f       	sbci	r23, 0xFF	; 255
    12dc:	80 91 c5 2d 	lds	r24, 0x2DC5	; 0x802dc5 <EncoderEventQueue>
    12e0:	90 91 c6 2d 	lds	r25, 0x2DC6	; 0x802dc6 <EncoderEventQueue+0x1>
    12e4:	0e 94 a7 21 	call	0x434e	; 0x434e <xQueueGenericSendFromISR>
	//Process counter
	if ( l1 && !l0) Cnt2++;//Rising edge on Line1, Line0 low
    12e8:	80 91 c3 2d 	lds	r24, 0x2DC3	; 0x802dc3 <Cnt2>
    12ec:	90 91 c4 2d 	lds	r25, 0x2DC4	; 0x802dc4 <Cnt2+0x1>
    12f0:	11 11       	cpse	r17, r1
    12f2:	22 c0       	rjmp	.+68     	; 0x1338 <__vector_44+0x110>
	if ( l1 &&  l0) Cnt2--;//Rising edge on Line1, Line0 high
	if (!l1 &&  l0) Cnt2++;//Falling edge on Line1, Line0 high
	if (!l1 && !l0) Cnt2--;//Falling edge on Line1, Line0 low
    12f4:	01 97       	sbiw	r24, 0x01	; 1
    12f6:	80 93 c3 2d 	sts	0x2DC3, r24	; 0x802dc3 <Cnt2>
    12fa:	90 93 c4 2d 	sts	0x2DC4, r25	; 0x802dc4 <Cnt2+0x1>

	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    12fe:	8e 81       	ldd	r24, Y+6	; 0x06
    1300:	81 11       	cpse	r24, r1
    1302:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <vPortYieldISR>
	LastTriggerTime=Event.Time;
}
    1306:	26 96       	adiw	r28, 0x06	; 6
    1308:	cd bf       	out	0x3d, r28	; 61
    130a:	de bf       	out	0x3e, r29	; 62
    130c:	df 91       	pop	r29
    130e:	cf 91       	pop	r28
    1310:	ff 91       	pop	r31
    1312:	ef 91       	pop	r30
    1314:	bf 91       	pop	r27
    1316:	af 91       	pop	r26
    1318:	9f 91       	pop	r25
    131a:	8f 91       	pop	r24
    131c:	7f 91       	pop	r23
    131e:	6f 91       	pop	r22
    1320:	5f 91       	pop	r21
    1322:	4f 91       	pop	r20
    1324:	3f 91       	pop	r19
    1326:	2f 91       	pop	r18
    1328:	1f 91       	pop	r17
    132a:	0f 90       	pop	r0
    132c:	0b be       	out	0x3b, r0	; 59
    132e:	0f 90       	pop	r0
    1330:	0f be       	out	0x3f, r0	; 63
    1332:	0f 90       	pop	r0
    1334:	1f 90       	pop	r1
    1336:	18 95       	reti
	else
	Event.Event=FALLING_2B;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
	//Process counter
	if ( l1 && !l0) Cnt2++;//Rising edge on Line1, Line0 low
    1338:	01 96       	adiw	r24, 0x01	; 1
    133a:	80 93 c3 2d 	sts	0x2DC3, r24	; 0x802dc3 <Cnt2>
    133e:	90 93 c4 2d 	sts	0x2DC4, r25	; 0x802dc4 <Cnt2+0x1>
    1342:	dd cf       	rjmp	.-70     	; 0x12fe <__vector_44+0xd6>
	if ( l1 &&  l0) Cnt2--;//Rising edge on Line1, Line0 high
	if (!l1 &&  l0) Cnt2++;//Falling edge on Line1, Line0 high
    1344:	80 91 c3 2d 	lds	r24, 0x2DC3	; 0x802dc3 <Cnt2>
    1348:	90 91 c4 2d 	lds	r25, 0x2DC4	; 0x802dc4 <Cnt2+0x1>
    134c:	01 96       	adiw	r24, 0x01	; 1
    134e:	80 93 c3 2d 	sts	0x2DC3, r24	; 0x802dc3 <Cnt2>
    1352:	90 93 c4 2d 	sts	0x2DC4, r25	; 0x802dc4 <Cnt2+0x1>
    1356:	d3 cf       	rjmp	.-90     	; 0x12fe <__vector_44+0xd6>

00001358 <DriverMotorResetEncoder>:
}


void DriverMotorResetEncoder(void)
{
	portENTER_CRITICAL();	
    1358:	0f b6       	in	r0, 0x3f	; 63
    135a:	f8 94       	cli
    135c:	0f 92       	push	r0
	Cnt1=0;
    135e:	10 92 c1 2d 	sts	0x2DC1, r1	; 0x802dc1 <Cnt1>
    1362:	10 92 c2 2d 	sts	0x2DC2, r1	; 0x802dc2 <Cnt1+0x1>
	Cnt2=0;
    1366:	10 92 c3 2d 	sts	0x2DC3, r1	; 0x802dc3 <Cnt2>
    136a:	10 92 c4 2d 	sts	0x2DC4, r1	; 0x802dc4 <Cnt2+0x1>
	portEXIT_CRITICAL();
    136e:	0f 90       	pop	r0
    1370:	0f be       	out	0x3f, r0	; 63
    1372:	08 95       	ret

00001374 <DriverMPU6050Init>:
#define MPU6050_PWR_MGMT_1 0x6B



void DriverMPU6050Init(void)
{
    1374:	0f 93       	push	r16
    1376:	1f 93       	push	r17
    1378:	cf 93       	push	r28
    137a:	df 93       	push	r29
    137c:	1f 92       	push	r1
    137e:	1f 92       	push	r1
    1380:	cd b7       	in	r28, 0x3d	; 61
    1382:	de b7       	in	r29, 0x3e	; 62
	uint8_t res;
	uint8_t Buffer[2];
	int a;
	
	Buffer[0]=MPU6050_WHO_AM_I;
    1384:	85 e7       	ldi	r24, 0x75	; 117
    1386:	89 83       	std	Y+1, r24	; 0x01
	res=TWIMWriteRead(MPU6050_ADDR,Buffer,1,Buffer,1);
    1388:	01 e0       	ldi	r16, 0x01	; 1
    138a:	9e 01       	movw	r18, r28
    138c:	2f 5f       	subi	r18, 0xFF	; 255
    138e:	3f 4f       	sbci	r19, 0xFF	; 255
    1390:	41 e0       	ldi	r20, 0x01	; 1
    1392:	b9 01       	movw	r22, r18
    1394:	88 e6       	ldi	r24, 0x68	; 104
    1396:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
	if (!res)
    139a:	88 23       	and	r24, r24
    139c:	d9 f0       	breq	.+54     	; 0x13d4 <DriverMPU6050Init+0x60>
	{
		printf ("MPU6050: comms fail\r\n");
		return;
	}
	if (Buffer[0]!=MPU6050_ADDR)
    139e:	89 81       	ldd	r24, Y+1	; 0x01
    13a0:	88 36       	cpi	r24, 0x68	; 104
    13a2:	19 f1       	breq	.+70     	; 0x13ea <DriverMPU6050Init+0x76>
	{
		printf ("MPU6050 WHO_AM_I readback fail: %x read, %x expected\r\n",Buffer[0],MPU6050_ADDR);
    13a4:	1f 92       	push	r1
    13a6:	98 e6       	ldi	r25, 0x68	; 104
    13a8:	9f 93       	push	r25
    13aa:	1f 92       	push	r1
    13ac:	8f 93       	push	r24
    13ae:	84 e3       	ldi	r24, 0x34	; 52
    13b0:	91 e2       	ldi	r25, 0x21	; 33
    13b2:	9f 93       	push	r25
    13b4:	8f 93       	push	r24
    13b6:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
		return;
    13ba:	0f 90       	pop	r0
    13bc:	0f 90       	pop	r0
    13be:	0f 90       	pop	r0
    13c0:	0f 90       	pop	r0
    13c2:	0f 90       	pop	r0
    13c4:	0f 90       	pop	r0
	//Setup PWR_MGMT1
	Buffer[0]=MPU6050_PWR_MGMT_1;
	Buffer[1]=1;	//Gyro X as clock
	res=TWIMWrite(MPU6050_ADDR,Buffer,2);

}
    13c6:	0f 90       	pop	r0
    13c8:	0f 90       	pop	r0
    13ca:	df 91       	pop	r29
    13cc:	cf 91       	pop	r28
    13ce:	1f 91       	pop	r17
    13d0:	0f 91       	pop	r16
    13d2:	08 95       	ret
	
	Buffer[0]=MPU6050_WHO_AM_I;
	res=TWIMWriteRead(MPU6050_ADDR,Buffer,1,Buffer,1);
	if (!res)
	{
		printf ("MPU6050: comms fail\r\n");
    13d4:	8f e1       	ldi	r24, 0x1F	; 31
    13d6:	91 e2       	ldi	r25, 0x21	; 33
    13d8:	0e 94 9e 4e 	call	0x9d3c	; 0x9d3c <puts>
	//Setup PWR_MGMT1
	Buffer[0]=MPU6050_PWR_MGMT_1;
	Buffer[1]=1;	//Gyro X as clock
	res=TWIMWrite(MPU6050_ADDR,Buffer,2);

}
    13dc:	0f 90       	pop	r0
    13de:	0f 90       	pop	r0
    13e0:	df 91       	pop	r29
    13e2:	cf 91       	pop	r28
    13e4:	1f 91       	pop	r17
    13e6:	0f 91       	pop	r16
    13e8:	08 95       	ret
		printf ("MPU6050 WHO_AM_I readback fail: %x read, %x expected\r\n",Buffer[0],MPU6050_ADDR);
		return;
	}

	//Setup sample rate
	Buffer[0]=MPU6050_SMPRT_DIV;
    13ea:	89 e1       	ldi	r24, 0x19	; 25
    13ec:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=0;	//Output rate/1 --> 1kHz
    13ee:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(MPU6050_ADDR,Buffer,2);
    13f0:	42 e0       	ldi	r20, 0x02	; 2
    13f2:	be 01       	movw	r22, r28
    13f4:	6f 5f       	subi	r22, 0xFF	; 255
    13f6:	7f 4f       	sbci	r23, 0xFF	; 255
    13f8:	88 e6       	ldi	r24, 0x68	; 104
    13fa:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
	
	//Setup CONFIG
	Buffer[0]=MPU6050_CONFIG;
    13fe:	8a e1       	ldi	r24, 0x1A	; 26
    1400:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=1;	//Fs=1kHz, 188Hz BW
    1402:	11 e0       	ldi	r17, 0x01	; 1
    1404:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(MPU6050_ADDR,Buffer,2);	
    1406:	42 e0       	ldi	r20, 0x02	; 2
    1408:	be 01       	movw	r22, r28
    140a:	6f 5f       	subi	r22, 0xFF	; 255
    140c:	7f 4f       	sbci	r23, 0xFF	; 255
    140e:	88 e6       	ldi	r24, 0x68	; 104
    1410:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
	
	//Setup GYRO_CONFIG
	Buffer[0]=MPU6050_GYRO_CONFIG;
    1414:	8b e1       	ldi	r24, 0x1B	; 27
    1416:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=0;	//250/s max rate
    1418:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(MPU6050_ADDR,Buffer,2);	
    141a:	42 e0       	ldi	r20, 0x02	; 2
    141c:	be 01       	movw	r22, r28
    141e:	6f 5f       	subi	r22, 0xFF	; 255
    1420:	7f 4f       	sbci	r23, 0xFF	; 255
    1422:	88 e6       	ldi	r24, 0x68	; 104
    1424:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>

	//Setup INT_PIN_CFG
	Buffer[0]=MPU6050_INT_PIN_CFG;
    1428:	87 e3       	ldi	r24, 0x37	; 55
    142a:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=1<<4;	//Clear INT on any read
    142c:	80 e1       	ldi	r24, 0x10	; 16
    142e:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(MPU6050_ADDR,Buffer,2);
    1430:	42 e0       	ldi	r20, 0x02	; 2
    1432:	be 01       	movw	r22, r28
    1434:	6f 5f       	subi	r22, 0xFF	; 255
    1436:	7f 4f       	sbci	r23, 0xFF	; 255
    1438:	88 e6       	ldi	r24, 0x68	; 104
    143a:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>

	//Setup INT_ENABLE
	Buffer[0]=MPU6050_INT_ENABLE;
    143e:	88 e3       	ldi	r24, 0x38	; 56
    1440:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=1;	//Set INT on data ready
    1442:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(MPU6050_ADDR,Buffer,2);
    1444:	42 e0       	ldi	r20, 0x02	; 2
    1446:	be 01       	movw	r22, r28
    1448:	6f 5f       	subi	r22, 0xFF	; 255
    144a:	7f 4f       	sbci	r23, 0xFF	; 255
    144c:	88 e6       	ldi	r24, 0x68	; 104
    144e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
	
	//Setup PWR_MGMT1
	Buffer[0]=MPU6050_PWR_MGMT_1;
    1452:	8b e6       	ldi	r24, 0x6B	; 107
    1454:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=1;	//Gyro X as clock
    1456:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(MPU6050_ADDR,Buffer,2);
    1458:	42 e0       	ldi	r20, 0x02	; 2
    145a:	be 01       	movw	r22, r28
    145c:	6f 5f       	subi	r22, 0xFF	; 255
    145e:	7f 4f       	sbci	r23, 0xFF	; 255
    1460:	88 e6       	ldi	r24, 0x68	; 104
    1462:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>

}
    1466:	0f 90       	pop	r0
    1468:	0f 90       	pop	r0
    146a:	df 91       	pop	r29
    146c:	cf 91       	pop	r28
    146e:	1f 91       	pop	r17
    1470:	0f 91       	pop	r16
    1472:	08 95       	ret

00001474 <DriverMPU6050GyroGet>:

void DriverMPU6050GyroGet(int16_t *Gx,int16_t *Gy,int16_t *Gz)
{
    1474:	af 92       	push	r10
    1476:	bf 92       	push	r11
    1478:	cf 92       	push	r12
    147a:	df 92       	push	r13
    147c:	ef 92       	push	r14
    147e:	ff 92       	push	r15
    1480:	0f 93       	push	r16
    1482:	cf 93       	push	r28
    1484:	df 93       	push	r29
    1486:	cd b7       	in	r28, 0x3d	; 61
    1488:	de b7       	in	r29, 0x3e	; 62
    148a:	2c 97       	sbiw	r28, 0x0c	; 12
    148c:	cd bf       	out	0x3d, r28	; 61
    148e:	de bf       	out	0x3e, r29	; 62
    1490:	5c 01       	movw	r10, r24
    1492:	6b 01       	movw	r12, r22
    1494:	7a 01       	movw	r14, r20
	uint8_t res;
	uint16_t x,y,z;
	uint8_t Buffer[6];

	//Read Gyro data
	Buffer[0]=MPU6050_GX;
    1496:	83 e4       	ldi	r24, 0x43	; 67
    1498:	89 83       	std	Y+1, r24	; 0x01
	res=TWIMWriteRead(MPU6050_ADDR,Buffer,1,Buffer,6);
    149a:	06 e0       	ldi	r16, 0x06	; 6
    149c:	9e 01       	movw	r18, r28
    149e:	2f 5f       	subi	r18, 0xFF	; 255
    14a0:	3f 4f       	sbci	r19, 0xFF	; 255
    14a2:	41 e0       	ldi	r20, 0x01	; 1
    14a4:	b9 01       	movw	r22, r18
    14a6:	88 e6       	ldi	r24, 0x68	; 104
    14a8:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
	configASSERT(res);
    14ac:	88 23       	and	r24, r24
    14ae:	89 f1       	breq	.+98     	; 0x1512 <DriverMPU6050GyroGet+0x9e>
	((char *) (&x))[0]=Buffer[1];
    14b0:	8a 81       	ldd	r24, Y+2	; 0x02
    14b2:	8b 87       	std	Y+11, r24	; 0x0b
	((char *) (&x))[1]=Buffer[0];
    14b4:	89 81       	ldd	r24, Y+1	; 0x01
    14b6:	8c 87       	std	Y+12, r24	; 0x0c
	
	((char *) (&y))[0]=Buffer[3];
    14b8:	8c 81       	ldd	r24, Y+4	; 0x04
    14ba:	89 87       	std	Y+9, r24	; 0x09
	((char *) (&y))[1]=Buffer[2];
    14bc:	8b 81       	ldd	r24, Y+3	; 0x03
    14be:	8a 87       	std	Y+10, r24	; 0x0a
		
	((char *) (&z))[0]=Buffer[5];
    14c0:	8e 81       	ldd	r24, Y+6	; 0x06
    14c2:	8f 83       	std	Y+7, r24	; 0x07
	((char *) (&z))[1]=Buffer[4];
    14c4:	8d 81       	ldd	r24, Y+5	; 0x05
    14c6:	88 87       	std	Y+8, r24	; 0x08

	if (Gx!=NULL) *Gx=x;	
    14c8:	a1 14       	cp	r10, r1
    14ca:	b1 04       	cpc	r11, r1
    14cc:	29 f0       	breq	.+10     	; 0x14d8 <DriverMPU6050GyroGet+0x64>
    14ce:	8b 85       	ldd	r24, Y+11	; 0x0b
    14d0:	9c 85       	ldd	r25, Y+12	; 0x0c
    14d2:	f5 01       	movw	r30, r10
    14d4:	80 83       	st	Z, r24
    14d6:	91 83       	std	Z+1, r25	; 0x01
	if (Gy!=NULL) *Gy=y;	
    14d8:	c1 14       	cp	r12, r1
    14da:	d1 04       	cpc	r13, r1
    14dc:	29 f0       	breq	.+10     	; 0x14e8 <DriverMPU6050GyroGet+0x74>
    14de:	89 85       	ldd	r24, Y+9	; 0x09
    14e0:	9a 85       	ldd	r25, Y+10	; 0x0a
    14e2:	f6 01       	movw	r30, r12
    14e4:	80 83       	st	Z, r24
    14e6:	91 83       	std	Z+1, r25	; 0x01
	if (Gz!=NULL) *Gz=z;	
    14e8:	e1 14       	cp	r14, r1
    14ea:	f1 04       	cpc	r15, r1
    14ec:	29 f0       	breq	.+10     	; 0x14f8 <DriverMPU6050GyroGet+0x84>
    14ee:	8f 81       	ldd	r24, Y+7	; 0x07
    14f0:	98 85       	ldd	r25, Y+8	; 0x08
    14f2:	f7 01       	movw	r30, r14
    14f4:	80 83       	st	Z, r24
    14f6:	91 83       	std	Z+1, r25	; 0x01
}
    14f8:	2c 96       	adiw	r28, 0x0c	; 12
    14fa:	cd bf       	out	0x3d, r28	; 61
    14fc:	de bf       	out	0x3e, r29	; 62
    14fe:	df 91       	pop	r29
    1500:	cf 91       	pop	r28
    1502:	0f 91       	pop	r16
    1504:	ff 90       	pop	r15
    1506:	ef 90       	pop	r14
    1508:	df 90       	pop	r13
    150a:	cf 90       	pop	r12
    150c:	bf 90       	pop	r11
    150e:	af 90       	pop	r10
    1510:	08 95       	ret
	uint8_t Buffer[6];

	//Read Gyro data
	Buffer[0]=MPU6050_GX;
	res=TWIMWriteRead(MPU6050_ADDR,Buffer,1,Buffer,6);
	configASSERT(res);
    1512:	65 e5       	ldi	r22, 0x55	; 85
    1514:	70 e0       	ldi	r23, 0x00	; 0
    1516:	8b e6       	ldi	r24, 0x6B	; 107
    1518:	91 e2       	ldi	r25, 0x21	; 33
    151a:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    151e:	c8 cf       	rjmp	.-112    	; 0x14b0 <DriverMPU6050GyroGet+0x3c>

00001520 <set_page_address.part.0>:

void DriverOLEDWake()
{
	if (!DriverOLEDInitialized) return;
	send_command(0xAF);
}
    1520:	1f 93       	push	r17
    1522:	cf 93       	push	r28
    1524:	df 93       	push	r29
    1526:	1f 92       	push	r1
    1528:	1f 92       	push	r1
    152a:	cd b7       	in	r28, 0x3d	; 61
    152c:	de b7       	in	r29, 0x3e	; 62
    152e:	10 e8       	ldi	r17, 0x80	; 128
    1530:	19 83       	std	Y+1, r17	; 0x01
    1532:	82 e2       	ldi	r24, 0x22	; 34
    1534:	8a 83       	std	Y+2, r24	; 0x02
    1536:	42 e0       	ldi	r20, 0x02	; 2
    1538:	be 01       	movw	r22, r28
    153a:	6f 5f       	subi	r22, 0xFF	; 255
    153c:	7f 4f       	sbci	r23, 0xFF	; 255
    153e:	8c e3       	ldi	r24, 0x3C	; 60
    1540:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
    1544:	19 83       	std	Y+1, r17	; 0x01
    1546:	1a 82       	std	Y+2, r1	; 0x02
    1548:	42 e0       	ldi	r20, 0x02	; 2
    154a:	be 01       	movw	r22, r28
    154c:	6f 5f       	subi	r22, 0xFF	; 255
    154e:	7f 4f       	sbci	r23, 0xFF	; 255
    1550:	8c e3       	ldi	r24, 0x3C	; 60
    1552:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
    1556:	19 83       	std	Y+1, r17	; 0x01
    1558:	87 e0       	ldi	r24, 0x07	; 7
    155a:	8a 83       	std	Y+2, r24	; 0x02
    155c:	42 e0       	ldi	r20, 0x02	; 2
    155e:	be 01       	movw	r22, r28
    1560:	6f 5f       	subi	r22, 0xFF	; 255
    1562:	7f 4f       	sbci	r23, 0xFF	; 255
    1564:	8c e3       	ldi	r24, 0x3C	; 60
    1566:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
    156a:	0f 90       	pop	r0
    156c:	0f 90       	pop	r0
    156e:	df 91       	pop	r29
    1570:	cf 91       	pop	r28
    1572:	1f 91       	pop	r17
    1574:	08 95       	ret

00001576 <set_column_address.part.1>:
    1576:	1f 93       	push	r17
    1578:	cf 93       	push	r28
    157a:	df 93       	push	r29
    157c:	1f 92       	push	r1
    157e:	1f 92       	push	r1
    1580:	cd b7       	in	r28, 0x3d	; 61
    1582:	de b7       	in	r29, 0x3e	; 62
    1584:	10 e8       	ldi	r17, 0x80	; 128
    1586:	19 83       	std	Y+1, r17	; 0x01
    1588:	81 e2       	ldi	r24, 0x21	; 33
    158a:	8a 83       	std	Y+2, r24	; 0x02
    158c:	42 e0       	ldi	r20, 0x02	; 2
    158e:	be 01       	movw	r22, r28
    1590:	6f 5f       	subi	r22, 0xFF	; 255
    1592:	7f 4f       	sbci	r23, 0xFF	; 255
    1594:	8c e3       	ldi	r24, 0x3C	; 60
    1596:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
    159a:	19 83       	std	Y+1, r17	; 0x01
    159c:	1a 82       	std	Y+2, r1	; 0x02
    159e:	42 e0       	ldi	r20, 0x02	; 2
    15a0:	be 01       	movw	r22, r28
    15a2:	6f 5f       	subi	r22, 0xFF	; 255
    15a4:	7f 4f       	sbci	r23, 0xFF	; 255
    15a6:	8c e3       	ldi	r24, 0x3C	; 60
    15a8:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
    15ac:	19 83       	std	Y+1, r17	; 0x01
    15ae:	8f e7       	ldi	r24, 0x7F	; 127
    15b0:	8a 83       	std	Y+2, r24	; 0x02
    15b2:	42 e0       	ldi	r20, 0x02	; 2
    15b4:	be 01       	movw	r22, r28
    15b6:	6f 5f       	subi	r22, 0xFF	; 255
    15b8:	7f 4f       	sbci	r23, 0xFF	; 255
    15ba:	8c e3       	ldi	r24, 0x3C	; 60
    15bc:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
    15c0:	0f 90       	pop	r0
    15c2:	0f 90       	pop	r0
    15c4:	df 91       	pop	r29
    15c6:	cf 91       	pop	r28
    15c8:	1f 91       	pop	r17
    15ca:	08 95       	ret

000015cc <DriverOLEDDrawPixel.part.3>:
    15cc:	90 91 7e 28 	lds	r25, 0x287E	; 0x80287e <GlobOrientation>
    15d0:	91 11       	cpse	r25, r1
    15d2:	1c c0       	rjmp	.+56     	; 0x160c <DriverOLEDDrawPixel.part.3+0x40>
    15d4:	87 fd       	sbrc	r24, 7
    15d6:	19 c0       	rjmp	.+50     	; 0x160a <DriverOLEDDrawPixel.part.3+0x3e>
    15d8:	60 34       	cpi	r22, 0x40	; 64
    15da:	b8 f4       	brcc	.+46     	; 0x160a <DriverOLEDDrawPixel.part.3+0x3e>
    15dc:	96 2f       	mov	r25, r22
    15de:	96 95       	lsr	r25
    15e0:	96 95       	lsr	r25
    15e2:	96 95       	lsr	r25
    15e4:	e8 2f       	mov	r30, r24
    15e6:	f0 e0       	ldi	r31, 0x00	; 0
    15e8:	20 e8       	ldi	r18, 0x80	; 128
    15ea:	92 9f       	mul	r25, r18
    15ec:	e0 0d       	add	r30, r0
    15ee:	f1 1d       	adc	r31, r1
    15f0:	11 24       	eor	r1, r1
    15f2:	e1 58       	subi	r30, 0x81	; 129
    15f4:	f7 4d       	sbci	r31, 0xD7	; 215
    15f6:	67 70       	andi	r22, 0x07	; 7
    15f8:	81 e0       	ldi	r24, 0x01	; 1
    15fa:	90 e0       	ldi	r25, 0x00	; 0
    15fc:	01 c0       	rjmp	.+2      	; 0x1600 <DriverOLEDDrawPixel.part.3+0x34>
    15fe:	88 0f       	add	r24, r24
    1600:	6a 95       	dec	r22
    1602:	ea f7       	brpl	.-6      	; 0x15fe <DriverOLEDDrawPixel.part.3+0x32>
    1604:	90 81       	ld	r25, Z
    1606:	89 2b       	or	r24, r25
    1608:	80 83       	st	Z, r24
    160a:	08 95       	ret
    160c:	91 30       	cpi	r25, 0x01	; 1
    160e:	21 f1       	breq	.+72     	; 0x1658 <DriverOLEDDrawPixel.part.3+0x8c>
    1610:	92 30       	cpi	r25, 0x02	; 2
    1612:	d9 f7       	brne	.-10     	; 0x160a <DriverOLEDDrawPixel.part.3+0x3e>
    1614:	87 fd       	sbrc	r24, 7
    1616:	f9 cf       	rjmp	.-14     	; 0x160a <DriverOLEDDrawPixel.part.3+0x3e>
    1618:	60 34       	cpi	r22, 0x40	; 64
    161a:	b8 f7       	brcc	.-18     	; 0x160a <DriverOLEDDrawPixel.part.3+0x3e>
    161c:	70 e0       	ldi	r23, 0x00	; 0
    161e:	ef e3       	ldi	r30, 0x3F	; 63
    1620:	f0 e0       	ldi	r31, 0x00	; 0
    1622:	e6 1b       	sub	r30, r22
    1624:	f7 0b       	sbc	r31, r23
    1626:	f5 95       	asr	r31
    1628:	e7 95       	ror	r30
    162a:	f5 95       	asr	r31
    162c:	e7 95       	ror	r30
    162e:	f5 95       	asr	r31
    1630:	e7 95       	ror	r30
    1632:	f6 95       	lsr	r31
    1634:	fe 2f       	mov	r31, r30
    1636:	ee 27       	eor	r30, r30
    1638:	f7 95       	ror	r31
    163a:	e7 95       	ror	r30
    163c:	2f e7       	ldi	r18, 0x7F	; 127
    163e:	30 e0       	ldi	r19, 0x00	; 0
    1640:	a9 01       	movw	r20, r18
    1642:	48 1b       	sub	r20, r24
    1644:	51 09       	sbc	r21, r1
    1646:	e4 0f       	add	r30, r20
    1648:	f5 1f       	adc	r31, r21
    164a:	e1 58       	subi	r30, 0x81	; 129
    164c:	f7 4d       	sbci	r31, 0xD7	; 215
    164e:	60 95       	com	r22
    1650:	70 95       	com	r23
    1652:	67 70       	andi	r22, 0x07	; 7
    1654:	77 27       	eor	r23, r23
    1656:	d0 cf       	rjmp	.-96     	; 0x15f8 <DriverOLEDDrawPixel.part.3+0x2c>
    1658:	80 34       	cpi	r24, 0x40	; 64
    165a:	b8 f6       	brcc	.-82     	; 0x160a <DriverOLEDDrawPixel.part.3+0x3e>
    165c:	67 fd       	sbrc	r22, 7
    165e:	d5 cf       	rjmp	.-86     	; 0x160a <DriverOLEDDrawPixel.part.3+0x3e>
    1660:	98 2f       	mov	r25, r24
    1662:	96 95       	lsr	r25
    1664:	96 95       	lsr	r25
    1666:	96 95       	lsr	r25
    1668:	af e7       	ldi	r26, 0x7F	; 127
    166a:	b0 e0       	ldi	r27, 0x00	; 0
    166c:	a6 1b       	sub	r26, r22
    166e:	b1 09       	sbc	r27, r1
    1670:	40 e8       	ldi	r20, 0x80	; 128
    1672:	94 9f       	mul	r25, r20
    1674:	a0 0d       	add	r26, r0
    1676:	b1 1d       	adc	r27, r1
    1678:	11 24       	eor	r1, r1
    167a:	a1 58       	subi	r26, 0x81	; 129
    167c:	b7 4d       	sbci	r27, 0xD7	; 215
    167e:	e8 2f       	mov	r30, r24
    1680:	e7 70       	andi	r30, 0x07	; 7
    1682:	81 e0       	ldi	r24, 0x01	; 1
    1684:	90 e0       	ldi	r25, 0x00	; 0
    1686:	01 c0       	rjmp	.+2      	; 0x168a <DriverOLEDDrawPixel.part.3+0xbe>
    1688:	88 0f       	add	r24, r24
    168a:	ea 95       	dec	r30
    168c:	ea f7       	brpl	.-6      	; 0x1688 <DriverOLEDDrawPixel.part.3+0xbc>
    168e:	9c 91       	ld	r25, X
    1690:	89 2b       	or	r24, r25
    1692:	8c 93       	st	X, r24
    1694:	08 95       	ret

00001696 <DriverOLEDClearPixel.part.4>:
    1696:	90 91 7e 28 	lds	r25, 0x287E	; 0x80287e <GlobOrientation>
    169a:	91 11       	cpse	r25, r1
    169c:	1d c0       	rjmp	.+58     	; 0x16d8 <DriverOLEDClearPixel.part.4+0x42>
    169e:	87 fd       	sbrc	r24, 7
    16a0:	1a c0       	rjmp	.+52     	; 0x16d6 <DriverOLEDClearPixel.part.4+0x40>
    16a2:	60 34       	cpi	r22, 0x40	; 64
    16a4:	c0 f4       	brcc	.+48     	; 0x16d6 <DriverOLEDClearPixel.part.4+0x40>
    16a6:	96 2f       	mov	r25, r22
    16a8:	96 95       	lsr	r25
    16aa:	96 95       	lsr	r25
    16ac:	96 95       	lsr	r25
    16ae:	e8 2f       	mov	r30, r24
    16b0:	f0 e0       	ldi	r31, 0x00	; 0
    16b2:	20 e8       	ldi	r18, 0x80	; 128
    16b4:	92 9f       	mul	r25, r18
    16b6:	e0 0d       	add	r30, r0
    16b8:	f1 1d       	adc	r31, r1
    16ba:	11 24       	eor	r1, r1
    16bc:	e1 58       	subi	r30, 0x81	; 129
    16be:	f7 4d       	sbci	r31, 0xD7	; 215
    16c0:	67 70       	andi	r22, 0x07	; 7
    16c2:	81 e0       	ldi	r24, 0x01	; 1
    16c4:	90 e0       	ldi	r25, 0x00	; 0
    16c6:	01 c0       	rjmp	.+2      	; 0x16ca <DriverOLEDClearPixel.part.4+0x34>
    16c8:	88 0f       	add	r24, r24
    16ca:	6a 95       	dec	r22
    16cc:	ea f7       	brpl	.-6      	; 0x16c8 <DriverOLEDClearPixel.part.4+0x32>
    16ce:	80 95       	com	r24
    16d0:	90 81       	ld	r25, Z
    16d2:	89 23       	and	r24, r25
    16d4:	80 83       	st	Z, r24
    16d6:	08 95       	ret
    16d8:	91 30       	cpi	r25, 0x01	; 1
    16da:	21 f1       	breq	.+72     	; 0x1724 <DriverOLEDClearPixel.part.4+0x8e>
    16dc:	92 30       	cpi	r25, 0x02	; 2
    16de:	d9 f7       	brne	.-10     	; 0x16d6 <DriverOLEDClearPixel.part.4+0x40>
    16e0:	87 fd       	sbrc	r24, 7
    16e2:	f9 cf       	rjmp	.-14     	; 0x16d6 <DriverOLEDClearPixel.part.4+0x40>
    16e4:	60 34       	cpi	r22, 0x40	; 64
    16e6:	b8 f7       	brcc	.-18     	; 0x16d6 <DriverOLEDClearPixel.part.4+0x40>
    16e8:	70 e0       	ldi	r23, 0x00	; 0
    16ea:	ef e3       	ldi	r30, 0x3F	; 63
    16ec:	f0 e0       	ldi	r31, 0x00	; 0
    16ee:	e6 1b       	sub	r30, r22
    16f0:	f7 0b       	sbc	r31, r23
    16f2:	f5 95       	asr	r31
    16f4:	e7 95       	ror	r30
    16f6:	f5 95       	asr	r31
    16f8:	e7 95       	ror	r30
    16fa:	f5 95       	asr	r31
    16fc:	e7 95       	ror	r30
    16fe:	f6 95       	lsr	r31
    1700:	fe 2f       	mov	r31, r30
    1702:	ee 27       	eor	r30, r30
    1704:	f7 95       	ror	r31
    1706:	e7 95       	ror	r30
    1708:	2f e7       	ldi	r18, 0x7F	; 127
    170a:	30 e0       	ldi	r19, 0x00	; 0
    170c:	a9 01       	movw	r20, r18
    170e:	48 1b       	sub	r20, r24
    1710:	51 09       	sbc	r21, r1
    1712:	e4 0f       	add	r30, r20
    1714:	f5 1f       	adc	r31, r21
    1716:	e1 58       	subi	r30, 0x81	; 129
    1718:	f7 4d       	sbci	r31, 0xD7	; 215
    171a:	60 95       	com	r22
    171c:	70 95       	com	r23
    171e:	67 70       	andi	r22, 0x07	; 7
    1720:	77 27       	eor	r23, r23
    1722:	cf cf       	rjmp	.-98     	; 0x16c2 <DriverOLEDClearPixel.part.4+0x2c>
    1724:	80 34       	cpi	r24, 0x40	; 64
    1726:	b8 f6       	brcc	.-82     	; 0x16d6 <DriverOLEDClearPixel.part.4+0x40>
    1728:	67 fd       	sbrc	r22, 7
    172a:	d5 cf       	rjmp	.-86     	; 0x16d6 <DriverOLEDClearPixel.part.4+0x40>
    172c:	98 2f       	mov	r25, r24
    172e:	96 95       	lsr	r25
    1730:	96 95       	lsr	r25
    1732:	96 95       	lsr	r25
    1734:	af e7       	ldi	r26, 0x7F	; 127
    1736:	b0 e0       	ldi	r27, 0x00	; 0
    1738:	a6 1b       	sub	r26, r22
    173a:	b1 09       	sbc	r27, r1
    173c:	40 e8       	ldi	r20, 0x80	; 128
    173e:	94 9f       	mul	r25, r20
    1740:	a0 0d       	add	r26, r0
    1742:	b1 1d       	adc	r27, r1
    1744:	11 24       	eor	r1, r1
    1746:	a1 58       	subi	r26, 0x81	; 129
    1748:	b7 4d       	sbci	r27, 0xD7	; 215
    174a:	e8 2f       	mov	r30, r24
    174c:	e7 70       	andi	r30, 0x07	; 7
    174e:	81 e0       	ldi	r24, 0x01	; 1
    1750:	90 e0       	ldi	r25, 0x00	; 0
    1752:	01 c0       	rjmp	.+2      	; 0x1756 <DriverOLEDClearPixel.part.4+0xc0>
    1754:	88 0f       	add	r24, r24
    1756:	ea 95       	dec	r30
    1758:	ea f7       	brpl	.-6      	; 0x1754 <DriverOLEDClearPixel.part.4+0xbe>
    175a:	80 95       	com	r24
    175c:	9c 91       	ld	r25, X
    175e:	89 23       	and	r24, r25
    1760:	8c 93       	st	X, r24
    1762:	08 95       	ret

00001764 <DriverOLEDPrintSmChar.part.5>:
    1764:	6f 92       	push	r6
    1766:	7f 92       	push	r7
    1768:	8f 92       	push	r8
    176a:	9f 92       	push	r9
    176c:	af 92       	push	r10
    176e:	bf 92       	push	r11
    1770:	cf 92       	push	r12
    1772:	df 92       	push	r13
    1774:	ef 92       	push	r14
    1776:	ff 92       	push	r15
    1778:	0f 93       	push	r16
    177a:	1f 93       	push	r17
    177c:	cf 93       	push	r28
    177e:	df 93       	push	r29
    1780:	90 91 7e 28 	lds	r25, 0x287E	; 0x80287e <GlobOrientation>
    1784:	91 11       	cpse	r25, r1
    1786:	28 c0       	rjmp	.+80     	; 0x17d8 <DriverOLEDPrintSmChar.part.5+0x74>
    1788:	22 23       	and	r18, r18
    178a:	d1 f1       	breq	.+116    	; 0x1800 <DriverOLEDPrintSmChar.part.5+0x9c>
    178c:	26 e0       	ldi	r18, 0x06	; 6
    178e:	82 9f       	mul	r24, r18
    1790:	c0 01       	movw	r24, r0
    1792:	11 24       	eor	r1, r1
    1794:	20 e8       	ldi	r18, 0x80	; 128
    1796:	62 9f       	mul	r22, r18
    1798:	80 0d       	add	r24, r0
    179a:	91 1d       	adc	r25, r1
    179c:	11 24       	eor	r1, r1
    179e:	50 e0       	ldi	r21, 0x00	; 0
    17a0:	40 52       	subi	r20, 0x20	; 32
    17a2:	51 09       	sbc	r21, r1
    17a4:	fa 01       	movw	r30, r20
    17a6:	ee 0f       	add	r30, r30
    17a8:	ff 1f       	adc	r31, r31
    17aa:	ee 0f       	add	r30, r30
    17ac:	ff 1f       	adc	r31, r31
    17ae:	e4 0f       	add	r30, r20
    17b0:	f5 1f       	adc	r31, r21
    17b2:	ea 57       	subi	r30, 0x7A	; 122
    17b4:	fe 4d       	sbci	r31, 0xDE	; 222
    17b6:	dc 01       	movw	r26, r24
    17b8:	a1 58       	subi	r26, 0x81	; 129
    17ba:	b7 4d       	sbci	r27, 0xD7	; 215
    17bc:	ac 01       	movw	r20, r24
    17be:	4b 5f       	subi	r20, 0xFB	; 251
    17c0:	5f 4f       	sbci	r21, 0xFF	; 255
    17c2:	01 96       	adiw	r24, 0x01	; 1
    17c4:	21 91       	ld	r18, Z+
    17c6:	2d 93       	st	X+, r18
    17c8:	84 17       	cp	r24, r20
    17ca:	95 07       	cpc	r25, r21
    17cc:	d1 f7       	brne	.-12     	; 0x17c2 <DriverOLEDPrintSmChar.part.5+0x5e>
    17ce:	fc 01       	movw	r30, r24
    17d0:	e1 58       	subi	r30, 0x81	; 129
    17d2:	f7 4d       	sbci	r31, 0xD7	; 215
    17d4:	10 82       	st	Z, r1
    17d6:	05 c0       	rjmp	.+10     	; 0x17e2 <DriverOLEDPrintSmChar.part.5+0x7e>
    17d8:	91 30       	cpi	r25, 0x01	; 1
    17da:	e9 f0       	breq	.+58     	; 0x1816 <DriverOLEDPrintSmChar.part.5+0xb2>
    17dc:	92 30       	cpi	r25, 0x02	; 2
    17de:	09 f4       	brne	.+2      	; 0x17e2 <DriverOLEDPrintSmChar.part.5+0x7e>
    17e0:	77 c0       	rjmp	.+238    	; 0x18d0 <DriverOLEDPrintSmChar.part.5+0x16c>
    17e2:	df 91       	pop	r29
    17e4:	cf 91       	pop	r28
    17e6:	1f 91       	pop	r17
    17e8:	0f 91       	pop	r16
    17ea:	ff 90       	pop	r15
    17ec:	ef 90       	pop	r14
    17ee:	df 90       	pop	r13
    17f0:	cf 90       	pop	r12
    17f2:	bf 90       	pop	r11
    17f4:	af 90       	pop	r10
    17f6:	9f 90       	pop	r9
    17f8:	8f 90       	pop	r8
    17fa:	7f 90       	pop	r7
    17fc:	6f 90       	pop	r6
    17fe:	08 95       	ret
    1800:	26 e0       	ldi	r18, 0x06	; 6
    1802:	82 9f       	mul	r24, r18
    1804:	c0 01       	movw	r24, r0
    1806:	11 24       	eor	r1, r1
    1808:	8b 37       	cpi	r24, 0x7B	; 123
    180a:	91 05       	cpc	r25, r1
    180c:	1c f2       	brlt	.-122    	; 0x1794 <DriverOLEDPrintSmChar.part.5+0x30>
    180e:	6f 5f       	subi	r22, 0xFF	; 255
    1810:	80 e0       	ldi	r24, 0x00	; 0
    1812:	90 e0       	ldi	r25, 0x00	; 0
    1814:	bf cf       	rjmp	.-130    	; 0x1794 <DriverOLEDPrintSmChar.part.5+0x30>
    1816:	88 2e       	mov	r8, r24
    1818:	88 0c       	add	r8, r8
    181a:	88 0d       	add	r24, r8
    181c:	88 2e       	mov	r8, r24
    181e:	88 0c       	add	r8, r8
    1820:	66 2e       	mov	r6, r22
    1822:	66 0c       	add	r6, r6
    1824:	66 0c       	add	r6, r6
    1826:	66 0c       	add	r6, r6
    1828:	e6 2c       	mov	r14, r6
    182a:	f1 2c       	mov	r15, r1
    182c:	87 e0       	ldi	r24, 0x07	; 7
    182e:	e8 0e       	add	r14, r24
    1830:	f1 1c       	adc	r15, r1
    1832:	a8 2c       	mov	r10, r8
    1834:	b1 2c       	mov	r11, r1
    1836:	24 e0       	ldi	r18, 0x04	; 4
    1838:	a2 0e       	add	r10, r18
    183a:	b1 1c       	adc	r11, r1
    183c:	76 2c       	mov	r7, r6
    183e:	50 e0       	ldi	r21, 0x00	; 0
    1840:	40 52       	subi	r20, 0x20	; 32
    1842:	51 09       	sbc	r21, r1
    1844:	cc 24       	eor	r12, r12
    1846:	c3 94       	inc	r12
    1848:	d1 2c       	mov	r13, r1
    184a:	ea 01       	movw	r28, r20
    184c:	cc 0f       	add	r28, r28
    184e:	dd 1f       	adc	r29, r29
    1850:	cc 0f       	add	r28, r28
    1852:	dd 1f       	adc	r29, r29
    1854:	4c 0f       	add	r20, r28
    1856:	5d 1f       	adc	r21, r29
    1858:	ea 01       	movw	r28, r20
    185a:	ca 57       	subi	r28, 0x7A	; 122
    185c:	de 4d       	sbci	r29, 0xDE	; 222
    185e:	87 2d       	mov	r24, r7
    1860:	86 19       	sub	r24, r6
    1862:	86 01       	movw	r16, r12
    1864:	02 c0       	rjmp	.+4      	; 0x186a <DriverOLEDPrintSmChar.part.5+0x106>
    1866:	00 0f       	add	r16, r16
    1868:	11 1f       	adc	r17, r17
    186a:	8a 95       	dec	r24
    186c:	e2 f7       	brpl	.-8      	; 0x1866 <DriverOLEDPrintSmChar.part.5+0x102>
    186e:	98 2c       	mov	r9, r8
    1870:	0a c0       	rjmp	.+20     	; 0x1886 <DriverOLEDPrintSmChar.part.5+0x122>
    1872:	80 91 7d 28 	lds	r24, 0x287D	; 0x80287d <DriverOLEDInitialized>
    1876:	81 11       	cpse	r24, r1
    1878:	26 c0       	rjmp	.+76     	; 0x18c6 <DriverOLEDPrintSmChar.part.5+0x162>
    187a:	93 94       	inc	r9
    187c:	89 2d       	mov	r24, r9
    187e:	90 e0       	ldi	r25, 0x00	; 0
    1880:	a8 16       	cp	r10, r24
    1882:	b9 06       	cpc	r11, r25
    1884:	cc f0       	brlt	.+50     	; 0x18b8 <DriverOLEDPrintSmChar.part.5+0x154>
    1886:	89 2d       	mov	r24, r9
    1888:	88 19       	sub	r24, r8
    188a:	fe 01       	movw	r30, r28
    188c:	e8 0f       	add	r30, r24
    188e:	f1 1d       	adc	r31, r1
    1890:	80 81       	ld	r24, Z
    1892:	90 e0       	ldi	r25, 0x00	; 0
    1894:	80 23       	and	r24, r16
    1896:	91 23       	and	r25, r17
    1898:	89 2b       	or	r24, r25
    189a:	59 f7       	brne	.-42     	; 0x1872 <DriverOLEDPrintSmChar.part.5+0x10e>
    189c:	80 91 7d 28 	lds	r24, 0x287D	; 0x80287d <DriverOLEDInitialized>
    18a0:	88 23       	and	r24, r24
    18a2:	59 f3       	breq	.-42     	; 0x187a <DriverOLEDPrintSmChar.part.5+0x116>
    18a4:	67 2d       	mov	r22, r7
    18a6:	89 2d       	mov	r24, r9
    18a8:	0e 94 4b 0b 	call	0x1696	; 0x1696 <DriverOLEDClearPixel.part.4>
    18ac:	93 94       	inc	r9
    18ae:	89 2d       	mov	r24, r9
    18b0:	90 e0       	ldi	r25, 0x00	; 0
    18b2:	a8 16       	cp	r10, r24
    18b4:	b9 06       	cpc	r11, r25
    18b6:	3c f7       	brge	.-50     	; 0x1886 <DriverOLEDPrintSmChar.part.5+0x122>
    18b8:	73 94       	inc	r7
    18ba:	87 2d       	mov	r24, r7
    18bc:	90 e0       	ldi	r25, 0x00	; 0
    18be:	e8 16       	cp	r14, r24
    18c0:	f9 06       	cpc	r15, r25
    18c2:	6c f6       	brge	.-102    	; 0x185e <DriverOLEDPrintSmChar.part.5+0xfa>
    18c4:	8e cf       	rjmp	.-228    	; 0x17e2 <DriverOLEDPrintSmChar.part.5+0x7e>
    18c6:	67 2d       	mov	r22, r7
    18c8:	89 2d       	mov	r24, r9
    18ca:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <DriverOLEDDrawPixel.part.3>
    18ce:	d5 cf       	rjmp	.-86     	; 0x187a <DriverOLEDPrintSmChar.part.5+0x116>
    18d0:	88 2e       	mov	r8, r24
    18d2:	88 0c       	add	r8, r8
    18d4:	88 0d       	add	r24, r8
    18d6:	88 2e       	mov	r8, r24
    18d8:	88 0c       	add	r8, r8
    18da:	66 2e       	mov	r6, r22
    18dc:	66 0c       	add	r6, r6
    18de:	66 0c       	add	r6, r6
    18e0:	66 0c       	add	r6, r6
    18e2:	e6 2c       	mov	r14, r6
    18e4:	f1 2c       	mov	r15, r1
    18e6:	87 e0       	ldi	r24, 0x07	; 7
    18e8:	e8 0e       	add	r14, r24
    18ea:	f1 1c       	adc	r15, r1
    18ec:	a8 2c       	mov	r10, r8
    18ee:	b1 2c       	mov	r11, r1
    18f0:	24 e0       	ldi	r18, 0x04	; 4
    18f2:	a2 0e       	add	r10, r18
    18f4:	b1 1c       	adc	r11, r1
    18f6:	76 2c       	mov	r7, r6
    18f8:	50 e0       	ldi	r21, 0x00	; 0
    18fa:	40 52       	subi	r20, 0x20	; 32
    18fc:	51 09       	sbc	r21, r1
    18fe:	cc 24       	eor	r12, r12
    1900:	c3 94       	inc	r12
    1902:	d1 2c       	mov	r13, r1
    1904:	ea 01       	movw	r28, r20
    1906:	cc 0f       	add	r28, r28
    1908:	dd 1f       	adc	r29, r29
    190a:	cc 0f       	add	r28, r28
    190c:	dd 1f       	adc	r29, r29
    190e:	4c 0f       	add	r20, r28
    1910:	5d 1f       	adc	r21, r29
    1912:	ea 01       	movw	r28, r20
    1914:	ca 57       	subi	r28, 0x7A	; 122
    1916:	de 4d       	sbci	r29, 0xDE	; 222
    1918:	87 2d       	mov	r24, r7
    191a:	86 19       	sub	r24, r6
    191c:	86 01       	movw	r16, r12
    191e:	02 c0       	rjmp	.+4      	; 0x1924 <DriverOLEDPrintSmChar.part.5+0x1c0>
    1920:	00 0f       	add	r16, r16
    1922:	11 1f       	adc	r17, r17
    1924:	8a 95       	dec	r24
    1926:	e2 f7       	brpl	.-8      	; 0x1920 <DriverOLEDPrintSmChar.part.5+0x1bc>
    1928:	98 2c       	mov	r9, r8
    192a:	0a c0       	rjmp	.+20     	; 0x1940 <DriverOLEDPrintSmChar.part.5+0x1dc>
    192c:	80 91 7d 28 	lds	r24, 0x287D	; 0x80287d <DriverOLEDInitialized>
    1930:	81 11       	cpse	r24, r1
    1932:	26 c0       	rjmp	.+76     	; 0x1980 <DriverOLEDPrintSmChar.part.5+0x21c>
    1934:	93 94       	inc	r9
    1936:	89 2d       	mov	r24, r9
    1938:	90 e0       	ldi	r25, 0x00	; 0
    193a:	a8 16       	cp	r10, r24
    193c:	b9 06       	cpc	r11, r25
    193e:	cc f0       	brlt	.+50     	; 0x1972 <DriverOLEDPrintSmChar.part.5+0x20e>
    1940:	89 2d       	mov	r24, r9
    1942:	88 19       	sub	r24, r8
    1944:	fe 01       	movw	r30, r28
    1946:	e8 0f       	add	r30, r24
    1948:	f1 1d       	adc	r31, r1
    194a:	80 81       	ld	r24, Z
    194c:	90 e0       	ldi	r25, 0x00	; 0
    194e:	80 23       	and	r24, r16
    1950:	91 23       	and	r25, r17
    1952:	89 2b       	or	r24, r25
    1954:	59 f7       	brne	.-42     	; 0x192c <DriverOLEDPrintSmChar.part.5+0x1c8>
    1956:	80 91 7d 28 	lds	r24, 0x287D	; 0x80287d <DriverOLEDInitialized>
    195a:	88 23       	and	r24, r24
    195c:	59 f3       	breq	.-42     	; 0x1934 <DriverOLEDPrintSmChar.part.5+0x1d0>
    195e:	67 2d       	mov	r22, r7
    1960:	89 2d       	mov	r24, r9
    1962:	0e 94 4b 0b 	call	0x1696	; 0x1696 <DriverOLEDClearPixel.part.4>
    1966:	93 94       	inc	r9
    1968:	89 2d       	mov	r24, r9
    196a:	90 e0       	ldi	r25, 0x00	; 0
    196c:	a8 16       	cp	r10, r24
    196e:	b9 06       	cpc	r11, r25
    1970:	3c f7       	brge	.-50     	; 0x1940 <DriverOLEDPrintSmChar.part.5+0x1dc>
    1972:	73 94       	inc	r7
    1974:	87 2d       	mov	r24, r7
    1976:	90 e0       	ldi	r25, 0x00	; 0
    1978:	e8 16       	cp	r14, r24
    197a:	f9 06       	cpc	r15, r25
    197c:	6c f6       	brge	.-102    	; 0x1918 <DriverOLEDPrintSmChar.part.5+0x1b4>
    197e:	31 cf       	rjmp	.-414    	; 0x17e2 <DriverOLEDPrintSmChar.part.5+0x7e>
    1980:	67 2d       	mov	r22, r7
    1982:	89 2d       	mov	r24, r9
    1984:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <DriverOLEDDrawPixel.part.3>
    1988:	d5 cf       	rjmp	.-86     	; 0x1934 <DriverOLEDPrintSmChar.part.5+0x1d0>

0000198a <DriverOLEDUpdate>:
    198a:	bf 92       	push	r11
    198c:	cf 92       	push	r12
    198e:	df 92       	push	r13
    1990:	ef 92       	push	r14
    1992:	ff 92       	push	r15
    1994:	0f 93       	push	r16
    1996:	1f 93       	push	r17
    1998:	cf 93       	push	r28
    199a:	df 93       	push	r29
    199c:	cd b7       	in	r28, 0x3d	; 61
    199e:	de b7       	in	r29, 0x3e	; 62
    19a0:	61 97       	sbiw	r28, 0x11	; 17
    19a2:	cd bf       	out	0x3d, r28	; 61
    19a4:	de bf       	out	0x3e, r29	; 62
    19a6:	80 91 7d 28 	lds	r24, 0x287D	; 0x80287d <DriverOLEDInitialized>
    19aa:	88 23       	and	r24, r24
    19ac:	49 f1       	breq	.+82     	; 0x1a00 <DriverOLEDUpdate+0x76>
    19ae:	0e 94 bb 0a 	call	0x1576	; 0x1576 <set_column_address.part.1>
    19b2:	80 91 7d 28 	lds	r24, 0x287D	; 0x80287d <DriverOLEDInitialized>
    19b6:	81 11       	cpse	r24, r1
    19b8:	30 c0       	rjmp	.+96     	; 0x1a1a <DriverOLEDUpdate+0x90>
    19ba:	8f e7       	ldi	r24, 0x7F	; 127
    19bc:	c8 2e       	mov	r12, r24
    19be:	88 e2       	ldi	r24, 0x28	; 40
    19c0:	d8 2e       	mov	r13, r24
    19c2:	9f e7       	ldi	r25, 0x7F	; 127
    19c4:	e9 2e       	mov	r14, r25
    19c6:	9c e2       	ldi	r25, 0x2C	; 44
    19c8:	f9 2e       	mov	r15, r25
    19ca:	8e 01       	movw	r16, r28
    19cc:	0e 5e       	subi	r16, 0xEE	; 238
    19ce:	1f 4f       	sbci	r17, 0xFF	; 255
    19d0:	20 e4       	ldi	r18, 0x40	; 64
    19d2:	b2 2e       	mov	r11, r18
    19d4:	b9 82       	std	Y+1, r11	; 0x01
    19d6:	fe 01       	movw	r30, r28
    19d8:	32 96       	adiw	r30, 0x02	; 2
    19da:	d6 01       	movw	r26, r12
    19dc:	8d 91       	ld	r24, X+
    19de:	81 93       	st	Z+, r24
    19e0:	e0 17       	cp	r30, r16
    19e2:	f1 07       	cpc	r31, r17
    19e4:	d9 f7       	brne	.-10     	; 0x19dc <DriverOLEDUpdate+0x52>
    19e6:	41 e1       	ldi	r20, 0x11	; 17
    19e8:	be 01       	movw	r22, r28
    19ea:	6f 5f       	subi	r22, 0xFF	; 255
    19ec:	7f 4f       	sbci	r23, 0xFF	; 255
    19ee:	8c e3       	ldi	r24, 0x3C	; 60
    19f0:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
    19f4:	80 e1       	ldi	r24, 0x10	; 16
    19f6:	c8 0e       	add	r12, r24
    19f8:	d1 1c       	adc	r13, r1
    19fa:	ec 14       	cp	r14, r12
    19fc:	fd 04       	cpc	r15, r13
    19fe:	51 f7       	brne	.-44     	; 0x19d4 <DriverOLEDUpdate+0x4a>
    1a00:	61 96       	adiw	r28, 0x11	; 17
    1a02:	cd bf       	out	0x3d, r28	; 61
    1a04:	de bf       	out	0x3e, r29	; 62
    1a06:	df 91       	pop	r29
    1a08:	cf 91       	pop	r28
    1a0a:	1f 91       	pop	r17
    1a0c:	0f 91       	pop	r16
    1a0e:	ff 90       	pop	r15
    1a10:	ef 90       	pop	r14
    1a12:	df 90       	pop	r13
    1a14:	cf 90       	pop	r12
    1a16:	bf 90       	pop	r11
    1a18:	08 95       	ret
    1a1a:	0e 94 90 0a 	call	0x1520	; 0x1520 <set_page_address.part.0>
    1a1e:	cd cf       	rjmp	.-102    	; 0x19ba <DriverOLEDUpdate+0x30>

00001a20 <DriverOLEDPrintSmChar>:
    1a20:	90 91 7d 28 	lds	r25, 0x287D	; 0x80287d <DriverOLEDInitialized>
    1a24:	99 23       	and	r25, r25
    1a26:	31 f0       	breq	.+12     	; 0x1a34 <DriverOLEDPrintSmChar+0x14>
    1a28:	81 38       	cpi	r24, 0x81	; 129
    1a2a:	20 f4       	brcc	.+8      	; 0x1a34 <DriverOLEDPrintSmChar+0x14>
    1a2c:	61 34       	cpi	r22, 0x41	; 65
    1a2e:	10 f4       	brcc	.+4      	; 0x1a34 <DriverOLEDPrintSmChar+0x14>
    1a30:	0c 94 b2 0b 	jmp	0x1764	; 0x1764 <DriverOLEDPrintSmChar.part.5>
    1a34:	08 95       	ret

00001a36 <DriverOLEDPrintSmText>:
    1a36:	ff 92       	push	r15
    1a38:	0f 93       	push	r16
    1a3a:	1f 93       	push	r17
    1a3c:	cf 93       	push	r28
    1a3e:	df 93       	push	r29
    1a40:	f8 2e       	mov	r15, r24
    1a42:	04 2f       	mov	r16, r20
    1a44:	80 91 7d 28 	lds	r24, 0x287D	; 0x80287d <DriverOLEDInitialized>
    1a48:	88 23       	and	r24, r24
    1a4a:	39 f1       	breq	.+78     	; 0x1a9a <DriverOLEDPrintSmText+0x64>
    1a4c:	80 91 7e 28 	lds	r24, 0x287E	; 0x80287e <GlobOrientation>
    1a50:	98 2f       	mov	r25, r24
    1a52:	9d 7f       	andi	r25, 0xFD	; 253
    1a54:	41 f5       	brne	.+80     	; 0x1aa6 <DriverOLEDPrintSmText+0x70>
    1a56:	27 e0       	ldi	r18, 0x07	; 7
    1a58:	2f 15       	cp	r18, r15
    1a5a:	f8 f0       	brcs	.+62     	; 0x1a9a <DriverOLEDPrintSmText+0x64>
    1a5c:	fb 01       	movw	r30, r22
    1a5e:	40 81       	ld	r20, Z
    1a60:	44 23       	and	r20, r20
    1a62:	d9 f0       	breq	.+54     	; 0x1a9a <DriverOLEDPrintSmText+0x64>
    1a64:	eb 01       	movw	r28, r22
    1a66:	21 96       	adiw	r28, 0x01	; 1
    1a68:	10 e0       	ldi	r17, 0x00	; 0
    1a6a:	0c c0       	rjmp	.+24     	; 0x1a84 <DriverOLEDPrintSmText+0x4e>
    1a6c:	26 e0       	ldi	r18, 0x06	; 6
    1a6e:	12 9f       	mul	r17, r18
    1a70:	c0 01       	movw	r24, r0
    1a72:	11 24       	eor	r1, r1
    1a74:	8b 37       	cpi	r24, 0x7B	; 123
    1a76:	91 05       	cpc	r25, r1
    1a78:	64 f0       	brlt	.+24     	; 0x1a92 <DriverOLEDPrintSmText+0x5c>
    1a7a:	f3 94       	inc	r15
    1a7c:	11 e0       	ldi	r17, 0x01	; 1
    1a7e:	49 91       	ld	r20, Y+
    1a80:	44 23       	and	r20, r20
    1a82:	59 f0       	breq	.+22     	; 0x1a9a <DriverOLEDPrintSmText+0x64>
    1a84:	11 38       	cpi	r17, 0x81	; 129
    1a86:	18 f4       	brcc	.+6      	; 0x1a8e <DriverOLEDPrintSmText+0x58>
    1a88:	f0 e4       	ldi	r31, 0x40	; 64
    1a8a:	ff 15       	cp	r31, r15
    1a8c:	68 f5       	brcc	.+90     	; 0x1ae8 <DriverOLEDPrintSmText+0xb2>
    1a8e:	00 23       	and	r16, r16
    1a90:	69 f3       	breq	.-38     	; 0x1a6c <DriverOLEDPrintSmText+0x36>
    1a92:	1f 5f       	subi	r17, 0xFF	; 255
    1a94:	49 91       	ld	r20, Y+
    1a96:	41 11       	cpse	r20, r1
    1a98:	f5 cf       	rjmp	.-22     	; 0x1a84 <DriverOLEDPrintSmText+0x4e>
    1a9a:	df 91       	pop	r29
    1a9c:	cf 91       	pop	r28
    1a9e:	1f 91       	pop	r17
    1aa0:	0f 91       	pop	r16
    1aa2:	ff 90       	pop	r15
    1aa4:	08 95       	ret
    1aa6:	81 30       	cpi	r24, 0x01	; 1
    1aa8:	c1 f7       	brne	.-16     	; 0x1a9a <DriverOLEDPrintSmText+0x64>
    1aaa:	8f e0       	ldi	r24, 0x0F	; 15
    1aac:	8f 15       	cp	r24, r15
    1aae:	a8 f3       	brcs	.-22     	; 0x1a9a <DriverOLEDPrintSmText+0x64>
    1ab0:	fb 01       	movw	r30, r22
    1ab2:	40 81       	ld	r20, Z
    1ab4:	44 23       	and	r20, r20
    1ab6:	89 f3       	breq	.-30     	; 0x1a9a <DriverOLEDPrintSmText+0x64>
    1ab8:	eb 01       	movw	r28, r22
    1aba:	21 96       	adiw	r28, 0x01	; 1
    1abc:	10 e0       	ldi	r17, 0x00	; 0
    1abe:	0b c0       	rjmp	.+22     	; 0x1ad6 <DriverOLEDPrintSmText+0xa0>
    1ac0:	26 e0       	ldi	r18, 0x06	; 6
    1ac2:	12 9f       	mul	r17, r18
    1ac4:	c0 01       	movw	r24, r0
    1ac6:	11 24       	eor	r1, r1
    1ac8:	cb 97       	sbiw	r24, 0x3b	; 59
    1aca:	64 f0       	brlt	.+24     	; 0x1ae4 <DriverOLEDPrintSmText+0xae>
    1acc:	f3 94       	inc	r15
    1ace:	11 e0       	ldi	r17, 0x01	; 1
    1ad0:	49 91       	ld	r20, Y+
    1ad2:	44 23       	and	r20, r20
    1ad4:	11 f3       	breq	.-60     	; 0x1a9a <DriverOLEDPrintSmText+0x64>
    1ad6:	11 38       	cpi	r17, 0x81	; 129
    1ad8:	18 f4       	brcc	.+6      	; 0x1ae0 <DriverOLEDPrintSmText+0xaa>
    1ada:	f0 e4       	ldi	r31, 0x40	; 64
    1adc:	ff 15       	cp	r31, r15
    1ade:	50 f4       	brcc	.+20     	; 0x1af4 <DriverOLEDPrintSmText+0xbe>
    1ae0:	00 23       	and	r16, r16
    1ae2:	71 f3       	breq	.-36     	; 0x1ac0 <DriverOLEDPrintSmText+0x8a>
    1ae4:	1f 5f       	subi	r17, 0xFF	; 255
    1ae6:	f4 cf       	rjmp	.-24     	; 0x1ad0 <DriverOLEDPrintSmText+0x9a>
    1ae8:	20 2f       	mov	r18, r16
    1aea:	6f 2d       	mov	r22, r15
    1aec:	81 2f       	mov	r24, r17
    1aee:	0e 94 b2 0b 	call	0x1764	; 0x1764 <DriverOLEDPrintSmChar.part.5>
    1af2:	cd cf       	rjmp	.-102    	; 0x1a8e <DriverOLEDPrintSmText+0x58>
    1af4:	20 2f       	mov	r18, r16
    1af6:	6f 2d       	mov	r22, r15
    1af8:	81 2f       	mov	r24, r17
    1afa:	0e 94 b2 0b 	call	0x1764	; 0x1764 <DriverOLEDPrintSmChar.part.5>
    1afe:	f0 cf       	rjmp	.-32     	; 0x1ae0 <DriverOLEDPrintSmText+0xaa>

00001b00 <DriverOLEDClearScreen>:
    1b00:	80 e0       	ldi	r24, 0x00	; 0
    1b02:	94 e0       	ldi	r25, 0x04	; 4
    1b04:	ef e7       	ldi	r30, 0x7F	; 127
    1b06:	f8 e2       	ldi	r31, 0x28	; 40
    1b08:	df 01       	movw	r26, r30
    1b0a:	9c 01       	movw	r18, r24
    1b0c:	1d 92       	st	X+, r1
    1b0e:	21 50       	subi	r18, 0x01	; 1
    1b10:	30 40       	sbci	r19, 0x00	; 0
    1b12:	e1 f7       	brne	.-8      	; 0x1b0c <DriverOLEDClearScreen+0xc>
    1b14:	08 95       	ret

00001b16 <DriverOLEDInit>:

void DriverOLEDInit(uint8_t Orientation)
{
    1b16:	0f 93       	push	r16
    1b18:	1f 93       	push	r17
    1b1a:	cf 93       	push	r28
    1b1c:	df 93       	push	r29
    1b1e:	00 d0       	rcall	.+0      	; 0x1b20 <DriverOLEDInit+0xa>
    1b20:	1f 92       	push	r1
    1b22:	cd b7       	in	r28, 0x3d	; 61
    1b24:	de b7       	in	r29, 0x3e	; 62
	uint8_t res;
	DriverOLEDInitialized=0;
    1b26:	10 92 7d 28 	sts	0x287D, r1	; 0x80287d <DriverOLEDInitialized>
	GlobOrientation=Orientation;
    1b2a:	80 93 7e 28 	sts	0x287E, r24	; 0x80287e <GlobOrientation>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1b2e:	10 e8       	ldi	r17, 0x80	; 128
    1b30:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1b32:	8e ea       	ldi	r24, 0xAE	; 174
    1b34:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1b36:	42 e0       	ldi	r20, 0x02	; 2
    1b38:	be 01       	movw	r22, r28
    1b3a:	6f 5f       	subi	r22, 0xFF	; 255
    1b3c:	7f 4f       	sbci	r23, 0xFF	; 255
    1b3e:	8c e3       	ldi	r24, 0x3C	; 60
    1b40:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
	DriverOLEDInitialized=0;
	GlobOrientation=Orientation;

	
	res=send_command(0xAE);
	if (!res) return;
    1b44:	88 23       	and	r24, r24
    1b46:	09 f4       	brne	.+2      	; 0x1b4a <DriverOLEDInit+0x34>
    1b48:	c3 c0       	rjmp	.+390    	; 0x1cd0 <DriverOLEDInit+0x1ba>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1b4a:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1b4c:	85 ed       	ldi	r24, 0xD5	; 213
    1b4e:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1b50:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1b52:	1c 83       	std	Y+4, r17	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1b54:	44 e0       	ldi	r20, 0x04	; 4
    1b56:	be 01       	movw	r22, r28
    1b58:	6f 5f       	subi	r22, 0xFF	; 255
    1b5a:	7f 4f       	sbci	r23, 0xFF	; 255
    1b5c:	8c e3       	ldi	r24, 0x3C	; 60
    1b5e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1b62:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1b64:	88 ea       	ldi	r24, 0xA8	; 168
    1b66:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1b68:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1b6a:	8f e3       	ldi	r24, 0x3F	; 63
    1b6c:	8c 83       	std	Y+4, r24	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1b6e:	44 e0       	ldi	r20, 0x04	; 4
    1b70:	be 01       	movw	r22, r28
    1b72:	6f 5f       	subi	r22, 0xFF	; 255
    1b74:	7f 4f       	sbci	r23, 0xFF	; 255
    1b76:	8c e3       	ldi	r24, 0x3C	; 60
    1b78:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1b7c:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1b7e:	83 ed       	ldi	r24, 0xD3	; 211
    1b80:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1b82:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1b84:	1c 82       	std	Y+4, r1	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1b86:	44 e0       	ldi	r20, 0x04	; 4
    1b88:	be 01       	movw	r22, r28
    1b8a:	6f 5f       	subi	r22, 0xFF	; 255
    1b8c:	7f 4f       	sbci	r23, 0xFF	; 255
    1b8e:	8c e3       	ldi	r24, 0x3C	; 60
    1b90:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1b94:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1b96:	8d e8       	ldi	r24, 0x8D	; 141
    1b98:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1b9a:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1b9c:	84 e1       	ldi	r24, 0x14	; 20
    1b9e:	8c 83       	std	Y+4, r24	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1ba0:	44 e0       	ldi	r20, 0x04	; 4
    1ba2:	be 01       	movw	r22, r28
    1ba4:	6f 5f       	subi	r22, 0xFF	; 255
    1ba6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ba8:	8c e3       	ldi	r24, 0x3C	; 60
    1baa:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1bae:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1bb0:	00 e4       	ldi	r16, 0x40	; 64
    1bb2:	0a 83       	std	Y+2, r16	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1bb4:	42 e0       	ldi	r20, 0x02	; 2
    1bb6:	be 01       	movw	r22, r28
    1bb8:	6f 5f       	subi	r22, 0xFF	; 255
    1bba:	7f 4f       	sbci	r23, 0xFF	; 255
    1bbc:	8c e3       	ldi	r24, 0x3C	; 60
    1bbe:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1bc2:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1bc4:	86 ea       	ldi	r24, 0xA6	; 166
    1bc6:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1bc8:	42 e0       	ldi	r20, 0x02	; 2
    1bca:	be 01       	movw	r22, r28
    1bcc:	6f 5f       	subi	r22, 0xFF	; 255
    1bce:	7f 4f       	sbci	r23, 0xFF	; 255
    1bd0:	8c e3       	ldi	r24, 0x3C	; 60
    1bd2:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1bd6:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1bd8:	84 ea       	ldi	r24, 0xA4	; 164
    1bda:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1bdc:	42 e0       	ldi	r20, 0x02	; 2
    1bde:	be 01       	movw	r22, r28
    1be0:	6f 5f       	subi	r22, 0xFF	; 255
    1be2:	7f 4f       	sbci	r23, 0xFF	; 255
    1be4:	8c e3       	ldi	r24, 0x3C	; 60
    1be6:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1bea:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1bec:	81 ea       	ldi	r24, 0xA1	; 161
    1bee:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1bf0:	42 e0       	ldi	r20, 0x02	; 2
    1bf2:	be 01       	movw	r22, r28
    1bf4:	6f 5f       	subi	r22, 0xFF	; 255
    1bf6:	7f 4f       	sbci	r23, 0xFF	; 255
    1bf8:	8c e3       	ldi	r24, 0x3C	; 60
    1bfa:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1bfe:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1c00:	88 ec       	ldi	r24, 0xC8	; 200
    1c02:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1c04:	42 e0       	ldi	r20, 0x02	; 2
    1c06:	be 01       	movw	r22, r28
    1c08:	6f 5f       	subi	r22, 0xFF	; 255
    1c0a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c0c:	8c e3       	ldi	r24, 0x3C	; 60
    1c0e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1c12:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1c14:	80 e2       	ldi	r24, 0x20	; 32
    1c16:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1c18:	42 e0       	ldi	r20, 0x02	; 2
    1c1a:	be 01       	movw	r22, r28
    1c1c:	6f 5f       	subi	r22, 0xFF	; 255
    1c1e:	7f 4f       	sbci	r23, 0xFF	; 255
    1c20:	8c e3       	ldi	r24, 0x3C	; 60
    1c22:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1c26:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1c28:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1c2a:	42 e0       	ldi	r20, 0x02	; 2
    1c2c:	be 01       	movw	r22, r28
    1c2e:	6f 5f       	subi	r22, 0xFF	; 255
    1c30:	7f 4f       	sbci	r23, 0xFF	; 255
    1c32:	8c e3       	ldi	r24, 0x3C	; 60
    1c34:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1c38:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1c3a:	8a ed       	ldi	r24, 0xDA	; 218
    1c3c:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1c3e:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1c40:	82 e1       	ldi	r24, 0x12	; 18
    1c42:	8c 83       	std	Y+4, r24	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1c44:	44 e0       	ldi	r20, 0x04	; 4
    1c46:	be 01       	movw	r22, r28
    1c48:	6f 5f       	subi	r22, 0xFF	; 255
    1c4a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c4c:	8c e3       	ldi	r24, 0x3C	; 60
    1c4e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1c52:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1c54:	81 e8       	ldi	r24, 0x81	; 129
    1c56:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1c58:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1c5a:	8f e8       	ldi	r24, 0x8F	; 143
    1c5c:	8c 83       	std	Y+4, r24	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1c5e:	44 e0       	ldi	r20, 0x04	; 4
    1c60:	be 01       	movw	r22, r28
    1c62:	6f 5f       	subi	r22, 0xFF	; 255
    1c64:	7f 4f       	sbci	r23, 0xFF	; 255
    1c66:	8c e3       	ldi	r24, 0x3C	; 60
    1c68:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1c6c:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1c6e:	89 ed       	ldi	r24, 0xD9	; 217
    1c70:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1c72:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1c74:	81 ef       	ldi	r24, 0xF1	; 241
    1c76:	8c 83       	std	Y+4, r24	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1c78:	44 e0       	ldi	r20, 0x04	; 4
    1c7a:	be 01       	movw	r22, r28
    1c7c:	6f 5f       	subi	r22, 0xFF	; 255
    1c7e:	7f 4f       	sbci	r23, 0xFF	; 255
    1c80:	8c e3       	ldi	r24, 0x3C	; 60
    1c82:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1c86:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1c88:	8b ed       	ldi	r24, 0xDB	; 219
    1c8a:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1c8c:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1c8e:	0c 83       	std	Y+4, r16	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1c90:	44 e0       	ldi	r20, 0x04	; 4
    1c92:	be 01       	movw	r22, r28
    1c94:	6f 5f       	subi	r22, 0xFF	; 255
    1c96:	7f 4f       	sbci	r23, 0xFF	; 255
    1c98:	8c e3       	ldi	r24, 0x3C	; 60
    1c9a:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1c9e:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1ca0:	8f ea       	ldi	r24, 0xAF	; 175
    1ca2:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1ca4:	42 e0       	ldi	r20, 0x02	; 2
    1ca6:	be 01       	movw	r22, r28
    1ca8:	6f 5f       	subi	r22, 0xFF	; 255
    1caa:	7f 4f       	sbci	r23, 0xFF	; 255
    1cac:	8c e3       	ldi	r24, 0x3C	; 60
    1cae:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
		return;
	}
}

void DriverOLEDClearScreen() {
	memset(buffer, 0, BUFFER_SIZE);
    1cb2:	80 e0       	ldi	r24, 0x00	; 0
    1cb4:	94 e0       	ldi	r25, 0x04	; 4
    1cb6:	ef e7       	ldi	r30, 0x7F	; 127
    1cb8:	f8 e2       	ldi	r31, 0x28	; 40
    1cba:	df 01       	movw	r26, r30
    1cbc:	9c 01       	movw	r18, r24
    1cbe:	1d 92       	st	X+, r1
    1cc0:	21 50       	subi	r18, 0x01	; 1
    1cc2:	30 40       	sbci	r19, 0x00	; 0
    1cc4:	e1 f7       	brne	.-8      	; 0x1cbe <DriverOLEDInit+0x1a8>
	send_command_data(0xdb, 0x40);
	send_command(0xaf);


	DriverOLEDClearScreen();
	DriverOLEDUpdate();
    1cc6:	0e 94 c5 0c 	call	0x198a	; 0x198a <DriverOLEDUpdate>
	DriverOLEDInitialized=1;
    1cca:	81 e0       	ldi	r24, 0x01	; 1
    1ccc:	80 93 7d 28 	sts	0x287D, r24	; 0x80287d <DriverOLEDInitialized>
    1cd0:	24 96       	adiw	r28, 0x04	; 4
    1cd2:	cd bf       	out	0x3d, r28	; 61
    1cd4:	de bf       	out	0x3e, r29	; 62
    1cd6:	df 91       	pop	r29
    1cd8:	cf 91       	pop	r28
    1cda:	1f 91       	pop	r17
    1cdc:	0f 91       	pop	r16
    1cde:	08 95       	ret

00001ce0 <ShiftInBit>:
	PORTD.DIRSET=1<<3;
	PORTD.PIN3CTRL=0b01000000;
	USARTD0.CTRLA=0b00000000;
	USARTD0.CTRLB=0b1000;
	USARTD0.CTRLC=0b11000000;
	USARTD0.BAUDCTRLA=5; //0.375s per bit, 
    1ce0:	cf 93       	push	r28
    1ce2:	c8 2f       	mov	r28, r24
    1ce4:	80 91 ce 2c 	lds	r24, 0x2CCE	; 0x802cce <ByteIdx>
    1ce8:	8e 34       	cpi	r24, 0x4E	; 78
    1cea:	50 f5       	brcc	.+84     	; 0x1d40 <ShiftInBit+0x60>
    1cec:	90 91 cf 2c 	lds	r25, 0x2CCF	; 0x802ccf <BitIdx>
    1cf0:	91 11       	cpse	r25, r1
    1cf2:	06 c0       	rjmp	.+12     	; 0x1d00 <ShiftInBit+0x20>
    1cf4:	e8 2f       	mov	r30, r24
    1cf6:	f0 e0       	ldi	r31, 0x00	; 0
    1cf8:	e0 58       	subi	r30, 0x80	; 128
    1cfa:	f3 4d       	sbci	r31, 0xD3	; 211
    1cfc:	2f ef       	ldi	r18, 0xFF	; 255
    1cfe:	20 83       	st	Z, r18
    1d00:	c1 11       	cpse	r28, r1
    1d02:	10 c0       	rjmp	.+32     	; 0x1d24 <ShiftInBit+0x44>
    1d04:	e8 2f       	mov	r30, r24
    1d06:	f0 e0       	ldi	r31, 0x00	; 0
    1d08:	e0 58       	subi	r30, 0x80	; 128
    1d0a:	f3 4d       	sbci	r31, 0xD3	; 211
    1d0c:	20 e8       	ldi	r18, 0x80	; 128
    1d0e:	30 e0       	ldi	r19, 0x00	; 0
    1d10:	09 2e       	mov	r0, r25
    1d12:	02 c0       	rjmp	.+4      	; 0x1d18 <ShiftInBit+0x38>
    1d14:	35 95       	asr	r19
    1d16:	27 95       	ror	r18
    1d18:	0a 94       	dec	r0
    1d1a:	e2 f7       	brpl	.-8      	; 0x1d14 <ShiftInBit+0x34>
    1d1c:	20 95       	com	r18
    1d1e:	30 81       	ld	r19, Z
    1d20:	23 23       	and	r18, r19
    1d22:	20 83       	st	Z, r18
    1d24:	9f 5f       	subi	r25, 0xFF	; 255
    1d26:	98 30       	cpi	r25, 0x08	; 8
    1d28:	39 f4       	brne	.+14     	; 0x1d38 <ShiftInBit+0x58>
    1d2a:	10 92 cf 2c 	sts	0x2CCF, r1	; 0x802ccf <BitIdx>
    1d2e:	8f 5f       	subi	r24, 0xFF	; 255
    1d30:	80 93 ce 2c 	sts	0x2CCE, r24	; 0x802cce <ByteIdx>
    1d34:	cf 91       	pop	r28
    1d36:	08 95       	ret
    1d38:	90 93 cf 2c 	sts	0x2CCF, r25	; 0x802ccf <BitIdx>
    1d3c:	cf 91       	pop	r28
    1d3e:	08 95       	ret
    1d40:	67 e2       	ldi	r22, 0x27	; 39
    1d42:	70 e0       	ldi	r23, 0x00	; 0
    1d44:	8c e5       	ldi	r24, 0x5C	; 92
    1d46:	93 e2       	ldi	r25, 0x23	; 35
    1d48:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    1d4c:	90 91 cf 2c 	lds	r25, 0x2CCF	; 0x802ccf <BitIdx>
    1d50:	80 91 ce 2c 	lds	r24, 0x2CCE	; 0x802cce <ByteIdx>
    1d54:	91 11       	cpse	r25, r1
    1d56:	0d c0       	rjmp	.+26     	; 0x1d72 <ShiftInBit+0x92>
    1d58:	e8 2f       	mov	r30, r24
    1d5a:	f0 e0       	ldi	r31, 0x00	; 0
    1d5c:	e0 58       	subi	r30, 0x80	; 128
    1d5e:	f3 4d       	sbci	r31, 0xD3	; 211
    1d60:	2f ef       	ldi	r18, 0xFF	; 255
    1d62:	20 83       	st	Z, r18
    1d64:	8e 34       	cpi	r24, 0x4E	; 78
    1d66:	60 f2       	brcs	.-104    	; 0x1d00 <ShiftInBit+0x20>
    1d68:	81 e0       	ldi	r24, 0x01	; 1
    1d6a:	80 93 cf 2c 	sts	0x2CCF, r24	; 0x802ccf <BitIdx>
    1d6e:	cf 91       	pop	r28
    1d70:	08 95       	ret
    1d72:	8e 34       	cpi	r24, 0x4E	; 78
    1d74:	28 f2       	brcs	.-118    	; 0x1d00 <ShiftInBit+0x20>
    1d76:	9f 5f       	subi	r25, 0xFF	; 255
    1d78:	98 30       	cpi	r25, 0x08	; 8
    1d7a:	b9 f2       	breq	.-82     	; 0x1d2a <ShiftInBit+0x4a>
    1d7c:	dd cf       	rjmp	.-70     	; 0x1d38 <ShiftInBit+0x58>

00001d7e <ShiftIn0>:
    1d7e:	80 e0       	ldi	r24, 0x00	; 0
    1d80:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <ShiftInBit>
    1d84:	81 e0       	ldi	r24, 0x01	; 1
    1d86:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <ShiftInBit>
    1d8a:	81 e0       	ldi	r24, 0x01	; 1
    1d8c:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <ShiftInBit>
    1d90:	81 e0       	ldi	r24, 0x01	; 1
    1d92:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <ShiftInBit>
    1d96:	81 e0       	ldi	r24, 0x01	; 1
    1d98:	0c 94 70 0e 	jmp	0x1ce0	; 0x1ce0 <ShiftInBit>

00001d9c <ShiftIn1>:
    1d9c:	80 e0       	ldi	r24, 0x00	; 0
    1d9e:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <ShiftInBit>
    1da2:	80 e0       	ldi	r24, 0x00	; 0
    1da4:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <ShiftInBit>
    1da8:	80 e0       	ldi	r24, 0x00	; 0
    1daa:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <ShiftInBit>
    1dae:	80 e0       	ldi	r24, 0x00	; 0
    1db0:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <ShiftInBit>
    1db4:	81 e0       	ldi	r24, 0x01	; 1
    1db6:	0c 94 70 0e 	jmp	0x1ce0	; 0x1ce0 <ShiftInBit>

00001dba <ShiftInByte>:
    1dba:	cf 93       	push	r28
    1dbc:	df 93       	push	r29
    1dbe:	d8 2f       	mov	r29, r24
    1dc0:	c8 e0       	ldi	r28, 0x08	; 8
    1dc2:	05 c0       	rjmp	.+10     	; 0x1dce <ShiftInByte+0x14>
    1dc4:	0e 94 bf 0e 	call	0x1d7e	; 0x1d7e <ShiftIn0>
    1dc8:	dd 0f       	add	r29, r29
    1dca:	c1 50       	subi	r28, 0x01	; 1
    1dcc:	39 f0       	breq	.+14     	; 0x1ddc <ShiftInByte+0x22>
    1dce:	d7 ff       	sbrs	r29, 7
    1dd0:	f9 cf       	rjmp	.-14     	; 0x1dc4 <ShiftInByte+0xa>
    1dd2:	0e 94 ce 0e 	call	0x1d9c	; 0x1d9c <ShiftIn1>
    1dd6:	dd 0f       	add	r29, r29
    1dd8:	c1 50       	subi	r28, 0x01	; 1
    1dda:	c9 f7       	brne	.-14     	; 0x1dce <ShiftInByte+0x14>
    1ddc:	df 91       	pop	r29
    1dde:	cf 91       	pop	r28
    1de0:	08 95       	ret

00001de2 <DriverPL9823Init>:
}

void DriverPL9823Init()
{
	//CS init
	PORTA.DIRSET=1<<6;
    1de2:	e0 e0       	ldi	r30, 0x00	; 0
    1de4:	f6 e0       	ldi	r31, 0x06	; 6
    1de6:	80 e4       	ldi	r24, 0x40	; 64
    1de8:	81 83       	std	Z+1, r24	; 0x01
	PORTA.OUTCLR=1<<6;
    1dea:	86 83       	std	Z+6, r24	; 0x06
    1dec:	08 95       	ret

00001dee <DriverPL9823Set>:
}

void DriverPL9823Set(uint32_t FrontLeft,uint32_t FrontRight,uint32_t RearRight,uint32_t RearLeft)
{
    1dee:	3f 92       	push	r3
    1df0:	4f 92       	push	r4
    1df2:	5f 92       	push	r5
    1df4:	6f 92       	push	r6
    1df6:	7f 92       	push	r7
    1df8:	8f 92       	push	r8
    1dfa:	9f 92       	push	r9
    1dfc:	af 92       	push	r10
    1dfe:	bf 92       	push	r11
    1e00:	cf 92       	push	r12
    1e02:	df 92       	push	r13
    1e04:	ef 92       	push	r14
    1e06:	ff 92       	push	r15
    1e08:	0f 93       	push	r16
    1e0a:	1f 93       	push	r17
    1e0c:	cf 93       	push	r28
    1e0e:	df 93       	push	r29
    1e10:	36 2e       	mov	r3, r22
    1e12:	47 2e       	mov	r4, r23
    1e14:	58 2e       	mov	r5, r24
    1e16:	d2 2e       	mov	r13, r18
    1e18:	13 2f       	mov	r17, r19
    1e1a:	d4 2f       	mov	r29, r20
}

void PortSetup(void)
{
	//Data init
	PORTD.DIRSET=1<<3;
    1e1c:	88 e0       	ldi	r24, 0x08	; 8
    1e1e:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <__TEXT_REGION_LENGTH__+0x700661>
	PORTD.PIN3CTRL=0b01000000;
    1e22:	90 e4       	ldi	r25, 0x40	; 64
    1e24:	90 93 73 06 	sts	0x0673, r25	; 0x800673 <__TEXT_REGION_LENGTH__+0x700673>
	USARTD0.CTRLA=0b00000000;
    1e28:	10 92 a3 09 	sts	0x09A3, r1	; 0x8009a3 <__TEXT_REGION_LENGTH__+0x7009a3>
	USARTD0.CTRLB=0b1000;
    1e2c:	80 93 a4 09 	sts	0x09A4, r24	; 0x8009a4 <__TEXT_REGION_LENGTH__+0x7009a4>
	USARTD0.CTRLC=0b11000000;
    1e30:	80 ec       	ldi	r24, 0xC0	; 192
    1e32:	80 93 a5 09 	sts	0x09A5, r24	; 0x8009a5 <__TEXT_REGION_LENGTH__+0x7009a5>
	USARTD0.BAUDCTRLA=5; //0.375s per bit, 
    1e36:	85 e0       	ldi	r24, 0x05	; 5
    1e38:	80 93 a6 09 	sts	0x09A6, r24	; 0x8009a6 <__TEXT_REGION_LENGTH__+0x7009a6>
    1e3c:	80 e8       	ldi	r24, 0x80	; 128
    1e3e:	88 2e       	mov	r8, r24
    1e40:	8c e2       	ldi	r24, 0x2C	; 44
    1e42:	98 2e       	mov	r9, r24
    1e44:	9e ec       	ldi	r25, 0xCE	; 206
    1e46:	69 2e       	mov	r6, r25
    1e48:	9c e2       	ldi	r25, 0x2C	; 44
    1e4a:	79 2e       	mov	r7, r25
    1e4c:	f4 01       	movw	r30, r8

void ShiftReset()
{
	uint8_t a;
	for (a=0;a<BUFFER_SIZE;a++)
		DataBuffer[a]=255;	
    1e4e:	8f ef       	ldi	r24, 0xFF	; 255
    1e50:	81 93       	st	Z+, r24
}

void ShiftReset()
{
	uint8_t a;
	for (a=0;a<BUFFER_SIZE;a++)
    1e52:	6e 16       	cp	r6, r30
    1e54:	7f 06       	cpc	r7, r31
    1e56:	e1 f7       	brne	.-8      	; 0x1e50 <DriverPL9823Set+0x62>
		DataBuffer[a]=255;	
	ByteIdx=0;	
    1e58:	10 92 ce 2c 	sts	0x2CCE, r1	; 0x802cce <ByteIdx>
    1e5c:	c5 e8       	ldi	r28, 0x85	; 133
}
void ShiftInReset()
{
	uint8_t a;
	for (a=0;a<133;a++) ShiftInBit(1);
    1e5e:	81 e0       	ldi	r24, 0x01	; 1
    1e60:	0e 94 70 0e 	call	0x1ce0	; 0x1ce0 <ShiftInBit>
    1e64:	c1 50       	subi	r28, 0x01	; 1
    1e66:	d9 f7       	brne	.-10     	; 0x1e5e <DriverPL9823Set+0x70>
	
	ShiftReset();

	ShiftInReset();
	
	ShiftInByte((uint8_t) ((FrontLeft>>0) & 0xFF));
    1e68:	83 2d       	mov	r24, r3
    1e6a:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <ShiftInByte>
	ShiftInByte((uint8_t) ((FrontLeft>>8) & 0xFF));
    1e6e:	84 2d       	mov	r24, r4
    1e70:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <ShiftInByte>
	ShiftInByte((uint8_t) ((FrontLeft>>16) & 0xFF));
    1e74:	85 2d       	mov	r24, r5
    1e76:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <ShiftInByte>

	ShiftInByte((uint8_t) ((FrontRight>>0) & 0xFF));
    1e7a:	8d 2d       	mov	r24, r13
    1e7c:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <ShiftInByte>
	ShiftInByte((uint8_t) ((FrontRight>>8) & 0xFF));
    1e80:	81 2f       	mov	r24, r17
    1e82:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <ShiftInByte>
	ShiftInByte((uint8_t) ((FrontRight>>16) & 0xFF));
    1e86:	8d 2f       	mov	r24, r29
    1e88:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <ShiftInByte>
	
	ShiftInByte((uint8_t) ((RearRight>>0) & 0xFF));
    1e8c:	8e 2d       	mov	r24, r14
    1e8e:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <ShiftInByte>
	ShiftInByte((uint8_t) ((RearRight>>8) & 0xFF));
    1e92:	8f 2d       	mov	r24, r15
    1e94:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <ShiftInByte>
	ShiftInByte((uint8_t) ((RearRight>>16) & 0xFF));
    1e98:	80 2f       	mov	r24, r16
    1e9a:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <ShiftInByte>
	
	ShiftInByte((uint8_t) ((RearLeft>>0) & 0xFF));
    1e9e:	8a 2d       	mov	r24, r10
    1ea0:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <ShiftInByte>
	ShiftInByte((uint8_t) ((RearLeft>>8) & 0xFF));
    1ea4:	8b 2d       	mov	r24, r11
    1ea6:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <ShiftInByte>
	ShiftInByte((uint8_t) ((RearLeft>>16) & 0xFF));
    1eaa:	8c 2d       	mov	r24, r12
    1eac:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <ShiftInByte>
	
	portENTER_CRITICAL();
    1eb0:	0f b6       	in	r0, 0x3f	; 63
    1eb2:	f8 94       	cli
    1eb4:	0f 92       	push	r0


void SendBuffer()
{
	uint8_t a;
	TxIdx=0;
    1eb6:	10 92 7f 2c 	sts	0x2C7F, r1	; 0x802c7f <TxIdx>
	
	PORTA.OUTSET=1<<6; //CS enable
    1eba:	80 e4       	ldi	r24, 0x40	; 64
    1ebc:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>


void SendByte(uint8_t Data)
{
	while (!(USARTD0.STATUS&(1<<5)));
	USARTD0.STATUS=(1<<6); //Clear TXCIF
    1ec0:	20 e4       	ldi	r18, 0x40	; 64
	uint8_t a;
	TxIdx=0;
	
	PORTA.OUTSET=1<<6; //CS enable
	for (a=0;a<BUFFER_SIZE;a++)
		SendByte(DataBuffer[a]);
    1ec2:	f4 01       	movw	r30, r8
    1ec4:	91 91       	ld	r25, Z+
    1ec6:	4f 01       	movw	r8, r30
static volatile uint8_t TxIdx;


void SendByte(uint8_t Data)
{
	while (!(USARTD0.STATUS&(1<<5)));
    1ec8:	80 91 a1 09 	lds	r24, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    1ecc:	85 ff       	sbrs	r24, 5
    1ece:	fc cf       	rjmp	.-8      	; 0x1ec8 <DriverPL9823Set+0xda>
	USARTD0.STATUS=(1<<6); //Clear TXCIF
    1ed0:	20 93 a1 09 	sts	0x09A1, r18	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
	USARTD0.DATA=Data;
    1ed4:	90 93 a0 09 	sts	0x09A0, r25	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
{
	uint8_t a;
	TxIdx=0;
	
	PORTA.OUTSET=1<<6; //CS enable
	for (a=0;a<BUFFER_SIZE;a++)
    1ed8:	68 14       	cp	r6, r8
    1eda:	79 04       	cpc	r7, r9
    1edc:	91 f7       	brne	.-28     	; 0x1ec2 <DriverPL9823Set+0xd4>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1ede:	8f ee       	ldi	r24, 0xEF	; 239
    1ee0:	90 e0       	ldi	r25, 0x00	; 0
    1ee2:	01 97       	sbiw	r24, 0x01	; 1
    1ee4:	f1 f7       	brne	.-4      	; 0x1ee2 <DriverPL9823Set+0xf4>
    1ee6:	00 c0       	rjmp	.+0      	; 0x1ee8 <DriverPL9823Set+0xfa>
    1ee8:	00 00       	nop
		SendByte(DataBuffer[a]);
	_delay_us(30);	
	PORTA.OUTCLR=1<<6; //CS disable
    1eea:	80 e4       	ldi	r24, 0x40	; 64
    1eec:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
	ShiftInByte((uint8_t) ((RearLeft>>8) & 0xFF));
	ShiftInByte((uint8_t) ((RearLeft>>16) & 0xFF));
	
	portENTER_CRITICAL();
	SendBuffer(); //Approx 260 s for entire buffer
	portEXIT_CRITICAL();
    1ef0:	0f 90       	pop	r0
    1ef2:	0f be       	out	0x3f, r0	; 63
}
    1ef4:	df 91       	pop	r29
    1ef6:	cf 91       	pop	r28
    1ef8:	1f 91       	pop	r17
    1efa:	0f 91       	pop	r16
    1efc:	ff 90       	pop	r15
    1efe:	ef 90       	pop	r14
    1f00:	df 90       	pop	r13
    1f02:	cf 90       	pop	r12
    1f04:	bf 90       	pop	r11
    1f06:	af 90       	pop	r10
    1f08:	9f 90       	pop	r9
    1f0a:	8f 90       	pop	r8
    1f0c:	7f 90       	pop	r7
    1f0e:	6f 90       	pop	r6
    1f10:	5f 90       	pop	r5
    1f12:	4f 90       	pop	r4
    1f14:	3f 90       	pop	r3
    1f16:	08 95       	ret

00001f18 <DriverPowerInit>:
#include "DriverPower.h"

void DriverPowerInit(void)
{
	//Aux Vcc GPIO setup
	PORTC.DIRSET=1<<5;
    1f18:	80 e2       	ldi	r24, 0x20	; 32
    1f1a:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
    1f1e:	08 95       	ret

00001f20 <DriverPowerVccAuxSet>:
}


void DriverPowerVccAuxSet(uint8_t State)
{
	if (State)
    1f20:	81 11       	cpse	r24, r1
    1f22:	04 c0       	rjmp	.+8      	; 0x1f2c <DriverPowerVccAuxSet+0xc>
		PORTC.OUTSET=1<<5;
	else
		PORTC.OUTCLR=1<<5;
    1f24:	80 e2       	ldi	r24, 0x20	; 32
    1f26:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
    1f2a:	08 95       	ret


void DriverPowerVccAuxSet(uint8_t State)
{
	if (State)
		PORTC.OUTSET=1<<5;
    1f2c:	80 e2       	ldi	r24, 0x20	; 32
    1f2e:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
    1f32:	08 95       	ret

00001f34 <DriverSysClkXtalInit>:
    // Clock setup          
    if (F_XTAL<400E3) return -1; //Invalid frequency
    if (F_XTAL<=2E6) OSC.XOSCCTRL=0b00001011; //Select <2 Mhz XTAL osc, max startup time
    else if(F_XTAL<=9E6) OSC.XOSCCTRL=0b01001011; //Select <2 Mhz XTAL osc, max startup time 
    else if(F_XTAL<=12E6) OSC.XOSCCTRL=0b10001011; //Select <2 Mhz XTAL osc, max startup time 
    else if(F_XTAL<=16E6) OSC.XOSCCTRL=0b11001011; //Select <2 Mhz XTAL osc, max startup time 
    1f34:	8b ec       	ldi	r24, 0xCB	; 203
    1f36:	80 93 52 00 	sts	0x0052, r24	; 0x800052 <__TEXT_REGION_LENGTH__+0x700052>
    else return -1; //Invalid frequency
    OSC.CTRL=0b01000; //Enable oscillator
    1f3a:	88 e0       	ldi	r24, 0x08	; 8
    1f3c:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
    
	//Wait until XTAL osc is ready
    while (!(OSC.STATUS&0b1000)); 
    1f40:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
    1f44:	83 ff       	sbrs	r24, 3
    1f46:	fc cf       	rjmp	.-8      	; 0x1f40 <DriverSysClkXtalInit+0xc>
	{
		//Configure PLL
		Mult=F_CPU/F_XTAL;
		if (Mult>31) return -1; //Invalid frequency; too high
		if (F_XTAL * (uint32_t) Mult !=F_CPU) return -1; //Only supports whole dividers
		OSC.PLLCTRL=0b11000000 | (Mult);
    1f48:	82 ec       	ldi	r24, 0xC2	; 194
    1f4a:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>
		OSC.CTRL=0b00011000; //Enable PLL
    1f4e:	88 e1       	ldi	r24, 0x18	; 24
    1f50:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
		
		//Wait until PLL is ready
		while (!(OSC.STATUS & 0b00010000));
    1f54:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
    1f58:	84 ff       	sbrs	r24, 4
    1f5a:	fc cf       	rjmp	.-8      	; 0x1f54 <DriverSysClkXtalInit+0x20>
		
		//Select PLL as system CLK source
		CCP=0xd8;
    1f5c:	88 ed       	ldi	r24, 0xD8	; 216
    1f5e:	84 bf       	out	0x34, r24	; 52
		CLK.CTRL=0b100;
    1f60:	84 e0       	ldi	r24, 0x04	; 4
    1f62:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
	}
	return 0;
}
    1f66:	80 e0       	ldi	r24, 0x00	; 0
    1f68:	08 95       	ret

00001f6a <DriverTWIMInit>:
}

void TWIMTransactionFinished( uint8_t result)
{
	Twim_result = result;
	Twim_status = TWIM_STATUS_READY;
    1f6a:	10 92 d5 2c 	sts	0x2CD5, r1	; 0x802cd5 <Twim_status>
    1f6e:	e0 e8       	ldi	r30, 0x80	; 128
    1f70:	f6 e0       	ldi	r31, 0x06	; 6
    1f72:	88 e1       	ldi	r24, 0x18	; 24
    1f74:	80 8b       	std	Z+16, r24	; 0x10
    1f76:	81 8b       	std	Z+17, r24	; 0x11
    1f78:	e0 ea       	ldi	r30, 0xA0	; 160
    1f7a:	f4 e0       	ldi	r31, 0x04	; 4
    1f7c:	88 e7       	ldi	r24, 0x78	; 120
    1f7e:	81 83       	std	Z+1, r24	; 0x01
    1f80:	83 e2       	ldi	r24, 0x23	; 35
    1f82:	85 83       	std	Z+5, r24	; 0x05
    1f84:	81 e0       	ldi	r24, 0x01	; 1
    1f86:	84 83       	std	Z+4, r24	; 0x04
    1f88:	0e 94 8d 21 	call	0x431a	; 0x431a <xQueueCreateMutex>
    1f8c:	80 93 d2 2c 	sts	0x2CD2, r24	; 0x802cd2 <SemaBus>
    1f90:	90 93 d3 2c 	sts	0x2CD3, r25	; 0x802cd3 <SemaBus+0x1>
    1f94:	43 e0       	ldi	r20, 0x03	; 3
    1f96:	60 e0       	ldi	r22, 0x00	; 0
    1f98:	81 e0       	ldi	r24, 0x01	; 1
    1f9a:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueGenericCreate>
    1f9e:	80 93 d0 2c 	sts	0x2CD0, r24	; 0x802cd0 <SemaRx>
    1fa2:	90 93 d1 2c 	sts	0x2CD1, r25	; 0x802cd1 <SemaRx+0x1>
    1fa6:	08 95       	ret

00001fa8 <TWIMWriteRead>:
    1fa8:	cf 92       	push	r12
    1faa:	df 92       	push	r13
    1fac:	ef 92       	push	r14
    1fae:	ff 92       	push	r15
    1fb0:	0f 93       	push	r16
    1fb2:	1f 93       	push	r17
    1fb4:	cf 93       	push	r28
    1fb6:	df 93       	push	r29
    1fb8:	d8 2f       	mov	r29, r24
    1fba:	6b 01       	movw	r12, r22
    1fbc:	14 2f       	mov	r17, r20
    1fbe:	79 01       	movw	r14, r18
    1fc0:	6f ef       	ldi	r22, 0xFF	; 255
    1fc2:	7f ef       	ldi	r23, 0xFF	; 255
    1fc4:	80 91 d2 2c 	lds	r24, 0x2CD2	; 0x802cd2 <SemaBus>
    1fc8:	90 91 d3 2c 	lds	r25, 0x2CD3	; 0x802cd3 <SemaBus+0x1>
    1fcc:	0e 94 12 23 	call	0x4624	; 0x4624 <xQueueSemaphoreTake>
    1fd0:	c0 92 dc 2c 	sts	0x2CDC, r12	; 0x802cdc <Twim_writeData>
    1fd4:	d0 92 dd 2c 	sts	0x2CDD, r13	; 0x802cdd <Twim_writeData+0x1>
    1fd8:	e0 92 da 2c 	sts	0x2CDA, r14	; 0x802cda <Twim_readData>
    1fdc:	f0 92 db 2c 	sts	0x2CDB, r15	; 0x802cdb <Twim_readData+0x1>
    1fe0:	c0 91 d5 2c 	lds	r28, 0x2CD5	; 0x802cd5 <Twim_status>
    1fe4:	c1 11       	cpse	r28, r1
    1fe6:	55 c0       	rjmp	.+170    	; 0x2092 <TWIMWriteRead+0xea>
    1fe8:	81 e0       	ldi	r24, 0x01	; 1
    1fea:	80 93 d5 2c 	sts	0x2CD5, r24	; 0x802cd5 <Twim_status>
    1fee:	10 92 d4 2c 	sts	0x2CD4, r1	; 0x802cd4 <Twim_result>
    1ff2:	8d 2f       	mov	r24, r29
    1ff4:	88 0f       	add	r24, r24
    1ff6:	80 93 de 2c 	sts	0x2CDE, r24	; 0x802cde <Twim_address>
    1ffa:	10 93 d9 2c 	sts	0x2CD9, r17	; 0x802cd9 <Twim_bytesToWrite>
    1ffe:	00 93 d8 2c 	sts	0x2CD8, r16	; 0x802cd8 <Twim_bytesToRead>
    2002:	10 92 d7 2c 	sts	0x2CD7, r1	; 0x802cd7 <Twim_bytesWritten>
    2006:	10 92 d6 2c 	sts	0x2CD6, r1	; 0x802cd6 <Twim_bytesRead>
    200a:	80 91 d9 2c 	lds	r24, 0x2CD9	; 0x802cd9 <Twim_bytesToWrite>
    200e:	88 23       	and	r24, r24
    2010:	b1 f1       	breq	.+108    	; 0x207e <TWIMWriteRead+0xd6>
    2012:	80 91 de 2c 	lds	r24, 0x2CDE	; 0x802cde <Twim_address>
    2016:	8e 7f       	andi	r24, 0xFE	; 254
    2018:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <__TEXT_REGION_LENGTH__+0x7004a6>
    201c:	6f ef       	ldi	r22, 0xFF	; 255
    201e:	7f ef       	ldi	r23, 0xFF	; 255
    2020:	80 91 d0 2c 	lds	r24, 0x2CD0	; 0x802cd0 <SemaRx>
    2024:	90 91 d1 2c 	lds	r25, 0x2CD1	; 0x802cd1 <SemaRx+0x1>
    2028:	0e 94 12 23 	call	0x4624	; 0x4624 <xQueueSemaphoreTake>
    202c:	80 91 d4 2c 	lds	r24, 0x2CD4	; 0x802cd4 <Twim_result>
    2030:	81 30       	cpi	r24, 0x01	; 1
    2032:	e1 f1       	breq	.+120    	; 0x20ac <TWIMWriteRead+0x104>
    2034:	1f 92       	push	r1
    2036:	8f 93       	push	r24
    2038:	1f 92       	push	r1
    203a:	df 93       	push	r29
    203c:	8b e7       	ldi	r24, 0x7B	; 123
    203e:	93 e2       	ldi	r25, 0x23	; 35
    2040:	9f 93       	push	r25
    2042:	8f 93       	push	r24
    2044:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
    2048:	20 e0       	ldi	r18, 0x00	; 0
    204a:	40 e0       	ldi	r20, 0x00	; 0
    204c:	50 e0       	ldi	r21, 0x00	; 0
    204e:	60 e0       	ldi	r22, 0x00	; 0
    2050:	70 e0       	ldi	r23, 0x00	; 0
    2052:	80 91 d2 2c 	lds	r24, 0x2CD2	; 0x802cd2 <SemaBus>
    2056:	90 91 d3 2c 	lds	r25, 0x2CD3	; 0x802cd3 <SemaBus+0x1>
    205a:	0e 94 be 20 	call	0x417c	; 0x417c <xQueueGenericSend>
    205e:	0f 90       	pop	r0
    2060:	0f 90       	pop	r0
    2062:	0f 90       	pop	r0
    2064:	0f 90       	pop	r0
    2066:	0f 90       	pop	r0
    2068:	0f 90       	pop	r0
    206a:	8c 2f       	mov	r24, r28
    206c:	df 91       	pop	r29
    206e:	cf 91       	pop	r28
    2070:	1f 91       	pop	r17
    2072:	0f 91       	pop	r16
    2074:	ff 90       	pop	r15
    2076:	ef 90       	pop	r14
    2078:	df 90       	pop	r13
    207a:	cf 90       	pop	r12
    207c:	08 95       	ret
    207e:	80 91 d8 2c 	lds	r24, 0x2CD8	; 0x802cd8 <Twim_bytesToRead>
    2082:	88 23       	and	r24, r24
    2084:	59 f2       	breq	.-106    	; 0x201c <TWIMWriteRead+0x74>
    2086:	80 91 de 2c 	lds	r24, 0x2CDE	; 0x802cde <Twim_address>
    208a:	81 60       	ori	r24, 0x01	; 1
    208c:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <__TEXT_REGION_LENGTH__+0x7004a6>
    2090:	c5 cf       	rjmp	.-118    	; 0x201c <TWIMWriteRead+0x74>
    2092:	20 e0       	ldi	r18, 0x00	; 0
    2094:	40 e0       	ldi	r20, 0x00	; 0
    2096:	50 e0       	ldi	r21, 0x00	; 0
    2098:	60 e0       	ldi	r22, 0x00	; 0
    209a:	70 e0       	ldi	r23, 0x00	; 0
    209c:	80 91 d2 2c 	lds	r24, 0x2CD2	; 0x802cd2 <SemaBus>
    20a0:	90 91 d3 2c 	lds	r25, 0x2CD3	; 0x802cd3 <SemaBus+0x1>
    20a4:	0e 94 be 20 	call	0x417c	; 0x417c <xQueueGenericSend>
    20a8:	c0 e0       	ldi	r28, 0x00	; 0
    20aa:	df cf       	rjmp	.-66     	; 0x206a <TWIMWriteRead+0xc2>
    20ac:	20 e0       	ldi	r18, 0x00	; 0
    20ae:	40 e0       	ldi	r20, 0x00	; 0
    20b0:	50 e0       	ldi	r21, 0x00	; 0
    20b2:	60 e0       	ldi	r22, 0x00	; 0
    20b4:	70 e0       	ldi	r23, 0x00	; 0
    20b6:	80 91 d2 2c 	lds	r24, 0x2CD2	; 0x802cd2 <SemaBus>
    20ba:	90 91 d3 2c 	lds	r25, 0x2CD3	; 0x802cd3 <SemaBus+0x1>
    20be:	0e 94 be 20 	call	0x417c	; 0x417c <xQueueGenericSend>
    20c2:	c1 e0       	ldi	r28, 0x01	; 1
    20c4:	d2 cf       	rjmp	.-92     	; 0x206a <TWIMWriteRead+0xc2>

000020c6 <TWIMWrite>:
    20c6:	0f 93       	push	r16
    20c8:	00 e0       	ldi	r16, 0x00	; 0
    20ca:	20 e0       	ldi	r18, 0x00	; 0
    20cc:	30 e0       	ldi	r19, 0x00	; 0
    20ce:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
    20d2:	0f 91       	pop	r16
    20d4:	08 95       	ret

000020d6 <TWIMWriteHandler>:
    20d6:	90 91 d9 2c 	lds	r25, 0x2CD9	; 0x802cd9 <Twim_bytesToWrite>
    20da:	20 91 d8 2c 	lds	r18, 0x2CD8	; 0x802cd8 <Twim_bytesToRead>
    20de:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>
    20e2:	84 fd       	sbrc	r24, 4
    20e4:	22 c0       	rjmp	.+68     	; 0x212a <TWIMWriteHandler+0x54>
    20e6:	80 91 d7 2c 	lds	r24, 0x2CD7	; 0x802cd7 <Twim_bytesWritten>
    20ea:	89 17       	cp	r24, r25
    20ec:	68 f0       	brcs	.+26     	; 0x2108 <TWIMWriteHandler+0x32>
    20ee:	80 91 d6 2c 	lds	r24, 0x2CD6	; 0x802cd6 <Twim_bytesRead>
    20f2:	82 17       	cp	r24, r18
    20f4:	18 f1       	brcs	.+70     	; 0x213c <TWIMWriteHandler+0x66>
    20f6:	83 e0       	ldi	r24, 0x03	; 3
    20f8:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    20fc:	81 e0       	ldi	r24, 0x01	; 1
    20fe:	80 93 d4 2c 	sts	0x2CD4, r24	; 0x802cd4 <Twim_result>
    2102:	10 92 d5 2c 	sts	0x2CD5, r1	; 0x802cd5 <Twim_status>
    2106:	08 95       	ret
    2108:	80 91 d7 2c 	lds	r24, 0x2CD7	; 0x802cd7 <Twim_bytesWritten>
    210c:	e0 91 dc 2c 	lds	r30, 0x2CDC	; 0x802cdc <Twim_writeData>
    2110:	f0 91 dd 2c 	lds	r31, 0x2CDD	; 0x802cdd <Twim_writeData+0x1>
    2114:	e8 0f       	add	r30, r24
    2116:	f1 1d       	adc	r31, r1
    2118:	80 81       	ld	r24, Z
    211a:	80 93 a7 04 	sts	0x04A7, r24	; 0x8004a7 <__TEXT_REGION_LENGTH__+0x7004a7>
    211e:	80 91 d7 2c 	lds	r24, 0x2CD7	; 0x802cd7 <Twim_bytesWritten>
    2122:	8f 5f       	subi	r24, 0xFF	; 255
    2124:	80 93 d7 2c 	sts	0x2CD7, r24	; 0x802cd7 <Twim_bytesWritten>
    2128:	08 95       	ret
    212a:	83 e0       	ldi	r24, 0x03	; 3
    212c:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    2130:	85 e0       	ldi	r24, 0x05	; 5
    2132:	80 93 d4 2c 	sts	0x2CD4, r24	; 0x802cd4 <Twim_result>
    2136:	10 92 d5 2c 	sts	0x2CD5, r1	; 0x802cd5 <Twim_status>
    213a:	08 95       	ret
    213c:	80 91 de 2c 	lds	r24, 0x2CDE	; 0x802cde <Twim_address>
    2140:	81 60       	ori	r24, 0x01	; 1
    2142:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <__TEXT_REGION_LENGTH__+0x7004a6>
    2146:	08 95       	ret

00002148 <TWIMReadHandler>:
    2148:	80 91 d6 2c 	lds	r24, 0x2CD6	; 0x802cd6 <Twim_bytesRead>
    214c:	80 32       	cpi	r24, 0x20	; 32
    214e:	f8 f4       	brcc	.+62     	; 0x218e <TWIMReadHandler+0x46>
    2150:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <__TEXT_REGION_LENGTH__+0x7004a7>
    2154:	90 91 d6 2c 	lds	r25, 0x2CD6	; 0x802cd6 <Twim_bytesRead>
    2158:	e0 91 da 2c 	lds	r30, 0x2CDA	; 0x802cda <Twim_readData>
    215c:	f0 91 db 2c 	lds	r31, 0x2CDB	; 0x802cdb <Twim_readData+0x1>
    2160:	e9 0f       	add	r30, r25
    2162:	f1 1d       	adc	r31, r1
    2164:	80 83       	st	Z, r24
    2166:	80 91 d6 2c 	lds	r24, 0x2CD6	; 0x802cd6 <Twim_bytesRead>
    216a:	8f 5f       	subi	r24, 0xFF	; 255
    216c:	80 93 d6 2c 	sts	0x2CD6, r24	; 0x802cd6 <Twim_bytesRead>
    2170:	90 91 d8 2c 	lds	r25, 0x2CD8	; 0x802cd8 <Twim_bytesToRead>
    2174:	80 91 d6 2c 	lds	r24, 0x2CD6	; 0x802cd6 <Twim_bytesRead>
    2178:	89 17       	cp	r24, r25
    217a:	b8 f0       	brcs	.+46     	; 0x21aa <TWIMReadHandler+0x62>
    217c:	87 e0       	ldi	r24, 0x07	; 7
    217e:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    2182:	81 e0       	ldi	r24, 0x01	; 1
    2184:	80 93 d4 2c 	sts	0x2CD4, r24	; 0x802cd4 <Twim_result>
    2188:	10 92 d5 2c 	sts	0x2CD5, r1	; 0x802cd5 <Twim_status>
    218c:	08 95       	ret
    218e:	83 e0       	ldi	r24, 0x03	; 3
    2190:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    2194:	82 e0       	ldi	r24, 0x02	; 2
    2196:	80 93 d4 2c 	sts	0x2CD4, r24	; 0x802cd4 <Twim_result>
    219a:	10 92 d5 2c 	sts	0x2CD5, r1	; 0x802cd5 <Twim_status>
    219e:	90 91 d8 2c 	lds	r25, 0x2CD8	; 0x802cd8 <Twim_bytesToRead>
    21a2:	80 91 d6 2c 	lds	r24, 0x2CD6	; 0x802cd6 <Twim_bytesRead>
    21a6:	89 17       	cp	r24, r25
    21a8:	48 f7       	brcc	.-46     	; 0x217c <TWIMReadHandler+0x34>
    21aa:	82 e0       	ldi	r24, 0x02	; 2
    21ac:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    21b0:	08 95       	ret

000021b2 <__vector_46>:
}

ISR (TWIM_BUS_vect)
{
    21b2:	1f 92       	push	r1
    21b4:	0f 92       	push	r0
    21b6:	0f b6       	in	r0, 0x3f	; 63
    21b8:	0f 92       	push	r0
    21ba:	11 24       	eor	r1, r1
    21bc:	0b b6       	in	r0, 0x3b	; 59
    21be:	0f 92       	push	r0
    21c0:	2f 93       	push	r18
    21c2:	3f 93       	push	r19
    21c4:	4f 93       	push	r20
    21c6:	5f 93       	push	r21
    21c8:	6f 93       	push	r22
    21ca:	7f 93       	push	r23
    21cc:	8f 93       	push	r24
    21ce:	9f 93       	push	r25
    21d0:	af 93       	push	r26
    21d2:	bf 93       	push	r27
    21d4:	ef 93       	push	r30
    21d6:	ff 93       	push	r31
    21d8:	cf 93       	push	r28
    21da:	df 93       	push	r29
    21dc:	1f 92       	push	r1
    21de:	cd b7       	in	r28, 0x3d	; 61
    21e0:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    21e2:	19 82       	std	Y+1, r1	; 0x01
	uint8_t currentStatus = TWIM_BUS.MASTER.STATUS;
    21e4:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>

	/* If arbitration lost or bus error. */
	if ((currentStatus & TWI_MASTER_ARBLOST_bm) ||
    21e8:	98 2f       	mov	r25, r24
    21ea:	9c 70       	andi	r25, 0x0C	; 12
    21ec:	e1 f4       	brne	.+56     	; 0x2226 <__vector_46+0x74>

		TWIMArbitrationLostBusErrorHandler();
	}

	/* If master write interrupt. */
	else if (currentStatus & TWI_MASTER_WIF_bm) {
    21ee:	86 fd       	sbrc	r24, 6
    21f0:	44 c0       	rjmp	.+136    	; 0x227a <__vector_46+0xc8>
		TWIMWriteHandler();
	}

	/* If master read interrupt. */
	else if (currentStatus & TWI_MASTER_RIF_bm) {
    21f2:	87 fd       	sbrc	r24, 7
    21f4:	45 c0       	rjmp	.+138    	; 0x2280 <__vector_46+0xce>
	}
}

void TWIMTransactionFinished( uint8_t result)
{
	Twim_result = result;
    21f6:	86 e0       	ldi	r24, 0x06	; 6
    21f8:	80 93 d4 2c 	sts	0x2CD4, r24	; 0x802cd4 <Twim_result>
	Twim_status = TWIM_STATUS_READY;
    21fc:	10 92 d5 2c 	sts	0x2CD5, r1	; 0x802cd5 <Twim_status>
	/* If unexpected state. */
	else {
		TWIMTransactionFinished(TWIM_RESULT_FAIL);
	}
	
	if (Twim_status == TWIM_STATUS_READY) //Transaction finished
    2200:	80 91 d5 2c 	lds	r24, 0x2CD5	; 0x802cd5 <Twim_status>
    2204:	81 11       	cpse	r24, r1
    2206:	1f c0       	rjmp	.+62     	; 0x2246 <__vector_46+0x94>
	{
		BaseType_t res=xSemaphoreGiveFromISR( SemaRx, &xHigherPriorityTaskWoken );
    2208:	be 01       	movw	r22, r28
    220a:	6f 5f       	subi	r22, 0xFF	; 255
    220c:	7f 4f       	sbci	r23, 0xFF	; 255
    220e:	80 91 d0 2c 	lds	r24, 0x2CD0	; 0x802cd0 <SemaRx>
    2212:	90 91 d1 2c 	lds	r25, 0x2CD1	; 0x802cd1 <SemaRx+0x1>
    2216:	0e 94 02 22 	call	0x4404	; 0x4404 <xQueueGiveFromISR>

		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );		
    221a:	89 81       	ldd	r24, Y+1	; 0x01
    221c:	88 23       	and	r24, r24
    221e:	99 f0       	breq	.+38     	; 0x2246 <__vector_46+0x94>
    2220:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <vPortYieldISR>
	}
}
    2224:	10 c0       	rjmp	.+32     	; 0x2246 <__vector_46+0x94>
	}
}

void TWIMArbitrationLostBusErrorHandler()
{
	uint8_t currentStatus = TWIM_BUS.MASTER.STATUS;
    2226:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>

	/* If bus error. */
	if (currentStatus & TWI_MASTER_BUSERR_bm) {
    222a:	82 fd       	sbrc	r24, 2
    222c:	22 c0       	rjmp	.+68     	; 0x2272 <__vector_46+0xc0>
		Twim_result = TWIM_RESULT_BUS_ERROR;
	}
	/* If arbitration lost. */
	else {
		Twim_result = TWIM_RESULT_ARBITRATION_LOST;
    222e:	93 e0       	ldi	r25, 0x03	; 3
    2230:	90 93 d4 2c 	sts	0x2CD4, r25	; 0x802cd4 <Twim_result>
	}

	/* Clear interrupt flag. */
	TWIM_BUS.MASTER.STATUS = currentStatus | TWI_MASTER_ARBLOST_bm;
    2234:	88 60       	ori	r24, 0x08	; 8
    2236:	80 93 a4 04 	sts	0x04A4, r24	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>

	Twim_status = TWIM_STATUS_READY;
    223a:	10 92 d5 2c 	sts	0x2CD5, r1	; 0x802cd5 <Twim_status>
	/* If unexpected state. */
	else {
		TWIMTransactionFinished(TWIM_RESULT_FAIL);
	}
	
	if (Twim_status == TWIM_STATUS_READY) //Transaction finished
    223e:	80 91 d5 2c 	lds	r24, 0x2CD5	; 0x802cd5 <Twim_status>
    2242:	88 23       	and	r24, r24
    2244:	09 f3       	breq	.-62     	; 0x2208 <__vector_46+0x56>
	{
		BaseType_t res=xSemaphoreGiveFromISR( SemaRx, &xHigherPriorityTaskWoken );

		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );		
	}
}
    2246:	0f 90       	pop	r0
    2248:	df 91       	pop	r29
    224a:	cf 91       	pop	r28
    224c:	ff 91       	pop	r31
    224e:	ef 91       	pop	r30
    2250:	bf 91       	pop	r27
    2252:	af 91       	pop	r26
    2254:	9f 91       	pop	r25
    2256:	8f 91       	pop	r24
    2258:	7f 91       	pop	r23
    225a:	6f 91       	pop	r22
    225c:	5f 91       	pop	r21
    225e:	4f 91       	pop	r20
    2260:	3f 91       	pop	r19
    2262:	2f 91       	pop	r18
    2264:	0f 90       	pop	r0
    2266:	0b be       	out	0x3b, r0	; 59
    2268:	0f 90       	pop	r0
    226a:	0f be       	out	0x3f, r0	; 63
    226c:	0f 90       	pop	r0
    226e:	1f 90       	pop	r1
    2270:	18 95       	reti
{
	uint8_t currentStatus = TWIM_BUS.MASTER.STATUS;

	/* If bus error. */
	if (currentStatus & TWI_MASTER_BUSERR_bm) {
		Twim_result = TWIM_RESULT_BUS_ERROR;
    2272:	94 e0       	ldi	r25, 0x04	; 4
    2274:	90 93 d4 2c 	sts	0x2CD4, r25	; 0x802cd4 <Twim_result>
    2278:	dd cf       	rjmp	.-70     	; 0x2234 <__vector_46+0x82>
		TWIMArbitrationLostBusErrorHandler();
	}

	/* If master write interrupt. */
	else if (currentStatus & TWI_MASTER_WIF_bm) {
		TWIMWriteHandler();
    227a:	0e 94 6b 10 	call	0x20d6	; 0x20d6 <TWIMWriteHandler>
    227e:	df cf       	rjmp	.-66     	; 0x223e <__vector_46+0x8c>
	}

	/* If master read interrupt. */
	else if (currentStatus & TWI_MASTER_RIF_bm) {
		TWIMReadHandler();
    2280:	0e 94 a4 10 	call	0x2148	; 0x2148 <TWIMReadHandler>
    2284:	dc cf       	rjmp	.-72     	; 0x223e <__vector_46+0x8c>

00002286 <stdio_getchar>:
		
	return 0;
}
	
static int stdio_getchar(FILE *stream)
{
    2286:	cf 93       	push	r28
    2288:	df 93       	push	r29
    228a:	1f 92       	push	r1
    228c:	cd b7       	in	r28, 0x3d	; 61
    228e:	de b7       	in	r29, 0x3e	; 62
	char c;
	xQueueReceive(UsartRxQueue,&c,portMAX_DELAY);
    2290:	4f ef       	ldi	r20, 0xFF	; 255
    2292:	5f ef       	ldi	r21, 0xFF	; 255
    2294:	be 01       	movw	r22, r28
    2296:	6f 5f       	subi	r22, 0xFF	; 255
    2298:	7f 4f       	sbci	r23, 0xFF	; 255
    229a:	80 91 c7 2d 	lds	r24, 0x2DC7	; 0x802dc7 <UsartRxQueue>
    229e:	90 91 c8 2d 	lds	r25, 0x2DC8	; 0x802dc8 <UsartRxQueue+0x1>
    22a2:	0e 94 55 22 	call	0x44aa	; 0x44aa <xQueueReceive>
	return c;
    22a6:	89 81       	ldd	r24, Y+1	; 0x01
}
    22a8:	90 e0       	ldi	r25, 0x00	; 0
    22aa:	0f 90       	pop	r0
    22ac:	df 91       	pop	r29
    22ae:	cf 91       	pop	r28
    22b0:	08 95       	ret

000022b2 <stdio_putchar>:

}


static int stdio_putchar(char c, FILE * stream)
{
    22b2:	cf 93       	push	r28
    22b4:	df 93       	push	r29
    22b6:	1f 92       	push	r1
    22b8:	1f 92       	push	r1
    22ba:	cd b7       	in	r28, 0x3d	; 61
    22bc:	de b7       	in	r29, 0x3e	; 62
    22be:	8a 83       	std	Y+2, r24	; 0x02
	int res;
	char cbuf;

	xQueueSend(UsartTxQueue,&c,portMAX_DELAY);
    22c0:	20 e0       	ldi	r18, 0x00	; 0
    22c2:	4f ef       	ldi	r20, 0xFF	; 255
    22c4:	5f ef       	ldi	r21, 0xFF	; 255
    22c6:	be 01       	movw	r22, r28
    22c8:	6e 5f       	subi	r22, 0xFE	; 254
    22ca:	7f 4f       	sbci	r23, 0xFF	; 255
    22cc:	80 91 c9 2d 	lds	r24, 0x2DC9	; 0x802dc9 <UsartTxQueue>
    22d0:	90 91 ca 2d 	lds	r25, 0x2DCA	; 0x802dca <UsartTxQueue+0x1>
    22d4:	0e 94 be 20 	call	0x417c	; 0x417c <xQueueGenericSend>

	if (USART.STATUS & (1<<5))
    22d8:	80 91 a1 0a 	lds	r24, 0x0AA1	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
    22dc:	85 ff       	sbrs	r24, 5
    22de:	0e c0       	rjmp	.+28     	; 0x22fc <stdio_putchar+0x4a>
	{
		xQueueReceive(UsartTxQueue,&cbuf,0);
    22e0:	40 e0       	ldi	r20, 0x00	; 0
    22e2:	50 e0       	ldi	r21, 0x00	; 0
    22e4:	be 01       	movw	r22, r28
    22e6:	6f 5f       	subi	r22, 0xFF	; 255
    22e8:	7f 4f       	sbci	r23, 0xFF	; 255
    22ea:	80 91 c9 2d 	lds	r24, 0x2DC9	; 0x802dc9 <UsartTxQueue>
    22ee:	90 91 ca 2d 	lds	r25, 0x2DCA	; 0x802dca <UsartTxQueue+0x1>
    22f2:	0e 94 55 22 	call	0x44aa	; 0x44aa <xQueueReceive>
		USART.DATA=cbuf;
    22f6:	89 81       	ldd	r24, Y+1	; 0x01
    22f8:	80 93 a0 0a 	sts	0x0AA0, r24	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
	}
		
	return 0;
}
    22fc:	80 e0       	ldi	r24, 0x00	; 0
    22fe:	90 e0       	ldi	r25, 0x00	; 0
    2300:	0f 90       	pop	r0
    2302:	0f 90       	pop	r0
    2304:	df 91       	pop	r29
    2306:	cf 91       	pop	r28
    2308:	08 95       	ret

0000230a <DriverUSARTInit>:
QueueHandle_t UsartTxQueue;
QueueHandle_t UsartRxQueue;

void DriverUSARTInit(void)
{
	UsartTxQueue=xQueueCreate(UART_QUEUE_LENGTH,sizeof(char));
    230a:	40 e0       	ldi	r20, 0x00	; 0
    230c:	61 e0       	ldi	r22, 0x01	; 1
    230e:	80 e8       	ldi	r24, 0x80	; 128
    2310:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueGenericCreate>
    2314:	80 93 c9 2d 	sts	0x2DC9, r24	; 0x802dc9 <UsartTxQueue>
    2318:	90 93 ca 2d 	sts	0x2DCA, r25	; 0x802dca <UsartTxQueue+0x1>
	UsartRxQueue=xQueueCreate(UART_QUEUE_LENGTH,sizeof(char));
    231c:	40 e0       	ldi	r20, 0x00	; 0
    231e:	61 e0       	ldi	r22, 0x01	; 1
    2320:	80 e8       	ldi	r24, 0x80	; 128
    2322:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueGenericCreate>
    2326:	80 93 c7 2d 	sts	0x2DC7, r24	; 0x802dc7 <UsartRxQueue>
    232a:	90 93 c8 2d 	sts	0x2DC8, r25	; 0x802dc8 <UsartRxQueue+0x1>
		
	USART_PORT.DIRSET=0b00001000;	
    232e:	e0 e8       	ldi	r30, 0x80	; 128
    2330:	f6 e0       	ldi	r31, 0x06	; 6
    2332:	88 e0       	ldi	r24, 0x08	; 8
    2334:	81 83       	std	Z+1, r24	; 0x01
	USART_PORT.DIRCLR=0b00000100;
    2336:	84 e0       	ldi	r24, 0x04	; 4
    2338:	82 83       	std	Z+2, r24	; 0x02
	
	USART.CTRLA=0b00010100;
    233a:	e0 ea       	ldi	r30, 0xA0	; 160
    233c:	fa e0       	ldi	r31, 0x0A	; 10
    233e:	84 e1       	ldi	r24, 0x14	; 20
    2340:	83 83       	std	Z+3, r24	; 0x03
	USART.CTRLB=0b00011000;
    2342:	88 e1       	ldi	r24, 0x18	; 24
    2344:	84 83       	std	Z+4, r24	; 0x04
	USART.CTRLC=0b00000011;
    2346:	83 e0       	ldi	r24, 0x03	; 3
    2348:	85 83       	std	Z+5, r24	; 0x05
	
	USART.BAUDCTRLA=0xE5; //BSEL=3301, BSCALE=-5 19200 baud
    234a:	85 ee       	ldi	r24, 0xE5	; 229
    234c:	86 83       	std	Z+6, r24	; 0x06
	USART.BAUDCTRLB=0xBC; 
    234e:	8c eb       	ldi	r24, 0xBC	; 188
    2350:	87 83       	std	Z+7, r24	; 0x07
	
	stdout=&UsartStdio;
    2352:	ed ed       	ldi	r30, 0xDD	; 221
    2354:	fd e2       	ldi	r31, 0x2D	; 45
    2356:	86 e0       	ldi	r24, 0x06	; 6
    2358:	90 e2       	ldi	r25, 0x20	; 32
    235a:	82 83       	std	Z+2, r24	; 0x02
    235c:	93 83       	std	Z+3, r25	; 0x03
	stdin=&UsartStdio;
    235e:	80 83       	st	Z, r24
    2360:	91 83       	std	Z+1, r25	; 0x01
    2362:	08 95       	ret

00002364 <__vector_60>:
}



ISR(USART_TXC_vect)
{
    2364:	1f 92       	push	r1
    2366:	0f 92       	push	r0
    2368:	0f b6       	in	r0, 0x3f	; 63
    236a:	0f 92       	push	r0
    236c:	11 24       	eor	r1, r1
    236e:	0b b6       	in	r0, 0x3b	; 59
    2370:	0f 92       	push	r0
    2372:	2f 93       	push	r18
    2374:	3f 93       	push	r19
    2376:	4f 93       	push	r20
    2378:	5f 93       	push	r21
    237a:	6f 93       	push	r22
    237c:	7f 93       	push	r23
    237e:	8f 93       	push	r24
    2380:	9f 93       	push	r25
    2382:	af 93       	push	r26
    2384:	bf 93       	push	r27
    2386:	ef 93       	push	r30
    2388:	ff 93       	push	r31
    238a:	cf 93       	push	r28
    238c:	df 93       	push	r29
    238e:	1f 92       	push	r1
    2390:	1f 92       	push	r1
    2392:	cd b7       	in	r28, 0x3d	; 61
    2394:	de b7       	in	r29, 0x3e	; 62
	char c;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    2396:	19 82       	std	Y+1, r1	; 0x01
	if (xQueueReceiveFromISR(UsartTxQueue,&c,&xHigherPriorityTaskWoken)==pdPASS)
    2398:	ae 01       	movw	r20, r28
    239a:	4f 5f       	subi	r20, 0xFF	; 255
    239c:	5f 4f       	sbci	r21, 0xFF	; 255
    239e:	be 01       	movw	r22, r28
    23a0:	6e 5f       	subi	r22, 0xFE	; 254
    23a2:	7f 4f       	sbci	r23, 0xFF	; 255
    23a4:	80 91 c9 2d 	lds	r24, 0x2DC9	; 0x802dc9 <UsartTxQueue>
    23a8:	90 91 ca 2d 	lds	r25, 0x2DCA	; 0x802dca <UsartTxQueue+0x1>
    23ac:	0e 94 c9 24 	call	0x4992	; 0x4992 <xQueueReceiveFromISR>
    23b0:	81 30       	cpi	r24, 0x01	; 1
    23b2:	d9 f0       	breq	.+54     	; 0x23ea <__vector_60+0x86>
	{
		USART.DATA=c;	
	}
	
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    23b4:	89 81       	ldd	r24, Y+1	; 0x01
    23b6:	81 11       	cpse	r24, r1
    23b8:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <vPortYieldISR>
}
    23bc:	0f 90       	pop	r0
    23be:	0f 90       	pop	r0
    23c0:	df 91       	pop	r29
    23c2:	cf 91       	pop	r28
    23c4:	ff 91       	pop	r31
    23c6:	ef 91       	pop	r30
    23c8:	bf 91       	pop	r27
    23ca:	af 91       	pop	r26
    23cc:	9f 91       	pop	r25
    23ce:	8f 91       	pop	r24
    23d0:	7f 91       	pop	r23
    23d2:	6f 91       	pop	r22
    23d4:	5f 91       	pop	r21
    23d6:	4f 91       	pop	r20
    23d8:	3f 91       	pop	r19
    23da:	2f 91       	pop	r18
    23dc:	0f 90       	pop	r0
    23de:	0b be       	out	0x3b, r0	; 59
    23e0:	0f 90       	pop	r0
    23e2:	0f be       	out	0x3f, r0	; 63
    23e4:	0f 90       	pop	r0
    23e6:	1f 90       	pop	r1
    23e8:	18 95       	reti
{
	char c;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
	if (xQueueReceiveFromISR(UsartTxQueue,&c,&xHigherPriorityTaskWoken)==pdPASS)
	{
		USART.DATA=c;	
    23ea:	8a 81       	ldd	r24, Y+2	; 0x02
    23ec:	80 93 a0 0a 	sts	0x0AA0, r24	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    23f0:	e1 cf       	rjmp	.-62     	; 0x23b4 <__vector_60+0x50>

000023f2 <__vector_58>:
	
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

ISR(USART_RXC_vect)
{
    23f2:	1f 92       	push	r1
    23f4:	0f 92       	push	r0
    23f6:	0f b6       	in	r0, 0x3f	; 63
    23f8:	0f 92       	push	r0
    23fa:	11 24       	eor	r1, r1
    23fc:	0b b6       	in	r0, 0x3b	; 59
    23fe:	0f 92       	push	r0
    2400:	2f 93       	push	r18
    2402:	3f 93       	push	r19
    2404:	4f 93       	push	r20
    2406:	5f 93       	push	r21
    2408:	6f 93       	push	r22
    240a:	7f 93       	push	r23
    240c:	8f 93       	push	r24
    240e:	9f 93       	push	r25
    2410:	af 93       	push	r26
    2412:	bf 93       	push	r27
    2414:	ef 93       	push	r30
    2416:	ff 93       	push	r31
    2418:	cf 93       	push	r28
    241a:	df 93       	push	r29
    241c:	1f 92       	push	r1
    241e:	1f 92       	push	r1
    2420:	cd b7       	in	r28, 0x3d	; 61
    2422:	de b7       	in	r29, 0x3e	; 62
	char c;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    2424:	19 82       	std	Y+1, r1	; 0x01
	
	c=USART.DATA;
    2426:	80 91 a0 0a 	lds	r24, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    242a:	8a 83       	std	Y+2, r24	; 0x02
	xQueueSendToBackFromISR(UsartRxQueue,&c,&xHigherPriorityTaskWoken);
    242c:	20 e0       	ldi	r18, 0x00	; 0
    242e:	ae 01       	movw	r20, r28
    2430:	4f 5f       	subi	r20, 0xFF	; 255
    2432:	5f 4f       	sbci	r21, 0xFF	; 255
    2434:	be 01       	movw	r22, r28
    2436:	6e 5f       	subi	r22, 0xFE	; 254
    2438:	7f 4f       	sbci	r23, 0xFF	; 255
    243a:	80 91 c7 2d 	lds	r24, 0x2DC7	; 0x802dc7 <UsartRxQueue>
    243e:	90 91 c8 2d 	lds	r25, 0x2DC8	; 0x802dc8 <UsartRxQueue+0x1>
    2442:	0e 94 a7 21 	call	0x434e	; 0x434e <xQueueGenericSendFromISR>
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    2446:	89 81       	ldd	r24, Y+1	; 0x01
    2448:	81 11       	cpse	r24, r1
    244a:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <vPortYieldISR>
	
    244e:	0f 90       	pop	r0
    2450:	0f 90       	pop	r0
    2452:	df 91       	pop	r29
    2454:	cf 91       	pop	r28
    2456:	ff 91       	pop	r31
    2458:	ef 91       	pop	r30
    245a:	bf 91       	pop	r27
    245c:	af 91       	pop	r26
    245e:	9f 91       	pop	r25
    2460:	8f 91       	pop	r24
    2462:	7f 91       	pop	r23
    2464:	6f 91       	pop	r22
    2466:	5f 91       	pop	r21
    2468:	4f 91       	pop	r20
    246a:	3f 91       	pop	r19
    246c:	2f 91       	pop	r18
    246e:	0f 90       	pop	r0
    2470:	0b be       	out	0x3b, r0	; 59
    2472:	0f 90       	pop	r0
    2474:	0f be       	out	0x3f, r0	; 63
    2476:	0f 90       	pop	r0
    2478:	1f 90       	pop	r1
    247a:	18 95       	reti

0000247c <getSequenceStepEnables>:
	#ifdef VL53L0X_ASSERT_COMMS_ERROR
		configASSERT(res);
	#endif
	
	return res;
}
    247c:	ef 92       	push	r14
    247e:	ff 92       	push	r15
    2480:	0f 93       	push	r16
    2482:	cf 93       	push	r28
    2484:	df 93       	push	r29
    2486:	00 d0       	rcall	.+0      	; 0x2488 <getSequenceStepEnables+0xc>
    2488:	1f 92       	push	r1
    248a:	cd b7       	in	r28, 0x3d	; 61
    248c:	de b7       	in	r29, 0x3e	; 62
    248e:	7c 01       	movw	r14, r24
    2490:	81 e0       	ldi	r24, 0x01	; 1
    2492:	89 83       	std	Y+1, r24	; 0x01
    2494:	01 e0       	ldi	r16, 0x01	; 1
    2496:	9e 01       	movw	r18, r28
    2498:	2f 5f       	subi	r18, 0xFF	; 255
    249a:	3f 4f       	sbci	r19, 0xFF	; 255
    249c:	41 e0       	ldi	r20, 0x01	; 1
    249e:	b9 01       	movw	r22, r18
    24a0:	89 e2       	ldi	r24, 0x29	; 41
    24a2:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
    24a6:	89 81       	ldd	r24, Y+1	; 0x01
    24a8:	84 fb       	bst	r24, 4
    24aa:	99 27       	eor	r25, r25
    24ac:	90 f9       	bld	r25, 0
    24ae:	f7 01       	movw	r30, r14
    24b0:	90 83       	st	Z, r25
    24b2:	83 fb       	bst	r24, 3
    24b4:	99 27       	eor	r25, r25
    24b6:	90 f9       	bld	r25, 0
    24b8:	92 83       	std	Z+2, r25	; 0x02
    24ba:	82 fb       	bst	r24, 2
    24bc:	99 27       	eor	r25, r25
    24be:	90 f9       	bld	r25, 0
    24c0:	91 83       	std	Z+1, r25	; 0x01
    24c2:	86 fb       	bst	r24, 6
    24c4:	99 27       	eor	r25, r25
    24c6:	90 f9       	bld	r25, 0
    24c8:	93 83       	std	Z+3, r25	; 0x03
    24ca:	88 1f       	adc	r24, r24
    24cc:	88 27       	eor	r24, r24
    24ce:	88 1f       	adc	r24, r24
    24d0:	84 83       	std	Z+4, r24	; 0x04
    24d2:	24 96       	adiw	r28, 0x04	; 4
    24d4:	cd bf       	out	0x3d, r28	; 61
    24d6:	de bf       	out	0x3e, r29	; 62
    24d8:	df 91       	pop	r29
    24da:	cf 91       	pop	r28
    24dc:	0f 91       	pop	r16
    24de:	ff 90       	pop	r15
    24e0:	ef 90       	pop	r14
    24e2:	08 95       	ret

000024e4 <performSingleRefCalibration>:
    24e4:	0f 93       	push	r16
    24e6:	1f 93       	push	r17
    24e8:	cf 93       	push	r28
    24ea:	df 93       	push	r29
    24ec:	00 d0       	rcall	.+0      	; 0x24ee <performSingleRefCalibration+0xa>
    24ee:	1f 92       	push	r1
    24f0:	cd b7       	in	r28, 0x3d	; 61
    24f2:	de b7       	in	r29, 0x3e	; 62
    24f4:	19 82       	std	Y+1, r1	; 0x01
    24f6:	81 60       	ori	r24, 0x01	; 1
    24f8:	8a 83       	std	Y+2, r24	; 0x02
    24fa:	42 e0       	ldi	r20, 0x02	; 2
    24fc:	be 01       	movw	r22, r28
    24fe:	6f 5f       	subi	r22, 0xFF	; 255
    2500:	7f 4f       	sbci	r23, 0xFF	; 255
    2502:	89 e2       	ldi	r24, 0x29	; 41
    2504:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
    2508:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    250c:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2510:	80 91 cf 2d 	lds	r24, 0x2DCF	; 0x802dcf <StatsTimer>
    2514:	90 91 d0 2d 	lds	r25, 0x2DD0	; 0x802dd0 <StatsTimer+0x1>
    2518:	a0 91 d1 2d 	lds	r26, 0x2DD1	; 0x802dd1 <StatsTimer+0x2>
    251c:	b0 91 d2 2d 	lds	r27, 0x2DD2	; 0x802dd2 <StatsTimer+0x3>
    2520:	82 0f       	add	r24, r18
    2522:	93 1f       	adc	r25, r19
    2524:	a1 1d       	adc	r26, r1
    2526:	b1 1d       	adc	r27, r1
    2528:	80 93 df 2c 	sts	0x2CDF, r24	; 0x802cdf <timeout_start_ticks>
    252c:	90 93 e0 2c 	sts	0x2CE0, r25	; 0x802ce0 <timeout_start_ticks+0x1>
    2530:	a0 93 e1 2c 	sts	0x2CE1, r26	; 0x802ce1 <timeout_start_ticks+0x2>
    2534:	b0 93 e2 2c 	sts	0x2CE2, r27	; 0x802ce2 <timeout_start_ticks+0x3>
    2538:	13 e1       	ldi	r17, 0x13	; 19
    253a:	19 83       	std	Y+1, r17	; 0x01
    253c:	01 e0       	ldi	r16, 0x01	; 1
    253e:	9e 01       	movw	r18, r28
    2540:	2f 5f       	subi	r18, 0xFF	; 255
    2542:	3f 4f       	sbci	r19, 0xFF	; 255
    2544:	41 e0       	ldi	r20, 0x01	; 1
    2546:	b9 01       	movw	r22, r18
    2548:	89 e2       	ldi	r24, 0x29	; 41
    254a:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
    254e:	89 81       	ldd	r24, Y+1	; 0x01
    2550:	87 70       	andi	r24, 0x07	; 7
    2552:	99 f3       	breq	.-26     	; 0x253a <performSingleRefCalibration+0x56>
    2554:	8b e0       	ldi	r24, 0x0B	; 11
    2556:	89 83       	std	Y+1, r24	; 0x01
    2558:	81 e0       	ldi	r24, 0x01	; 1
    255a:	8a 83       	std	Y+2, r24	; 0x02
    255c:	42 e0       	ldi	r20, 0x02	; 2
    255e:	be 01       	movw	r22, r28
    2560:	6f 5f       	subi	r22, 0xFF	; 255
    2562:	7f 4f       	sbci	r23, 0xFF	; 255
    2564:	89 e2       	ldi	r24, 0x29	; 41
    2566:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
    256a:	19 82       	std	Y+1, r1	; 0x01
    256c:	1a 82       	std	Y+2, r1	; 0x02
    256e:	42 e0       	ldi	r20, 0x02	; 2
    2570:	be 01       	movw	r22, r28
    2572:	6f 5f       	subi	r22, 0xFF	; 255
    2574:	7f 4f       	sbci	r23, 0xFF	; 255
    2576:	89 e2       	ldi	r24, 0x29	; 41
    2578:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
    257c:	81 e0       	ldi	r24, 0x01	; 1
    257e:	24 96       	adiw	r28, 0x04	; 4
    2580:	cd bf       	out	0x3d, r28	; 61
    2582:	de bf       	out	0x3e, r29	; 62
    2584:	df 91       	pop	r29
    2586:	cf 91       	pop	r28
    2588:	1f 91       	pop	r17
    258a:	0f 91       	pop	r16
    258c:	08 95       	ret

0000258e <readReg16Bit>:
    258e:	ef 92       	push	r14
    2590:	ff 92       	push	r15
    2592:	0f 93       	push	r16
    2594:	cf 93       	push	r28
    2596:	df 93       	push	r29
    2598:	00 d0       	rcall	.+0      	; 0x259a <readReg16Bit+0xc>
    259a:	1f 92       	push	r1
    259c:	cd b7       	in	r28, 0x3d	; 61
    259e:	de b7       	in	r29, 0x3e	; 62
    25a0:	7b 01       	movw	r14, r22
    25a2:	89 83       	std	Y+1, r24	; 0x01
    25a4:	02 e0       	ldi	r16, 0x02	; 2
    25a6:	9e 01       	movw	r18, r28
    25a8:	2f 5f       	subi	r18, 0xFF	; 255
    25aa:	3f 4f       	sbci	r19, 0xFF	; 255
    25ac:	41 e0       	ldi	r20, 0x01	; 1
    25ae:	b9 01       	movw	r22, r18
    25b0:	89 e2       	ldi	r24, 0x29	; 41
    25b2:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
    25b6:	e1 14       	cp	r14, r1
    25b8:	f1 04       	cpc	r15, r1
    25ba:	61 f0       	breq	.+24     	; 0x25d4 <readReg16Bit+0x46>
    25bc:	29 81       	ldd	r18, Y+1	; 0x01
    25be:	30 e0       	ldi	r19, 0x00	; 0
    25c0:	9a 81       	ldd	r25, Y+2	; 0x02
    25c2:	98 5f       	subi	r25, 0xF8	; 248
    25c4:	02 c0       	rjmp	.+4      	; 0x25ca <readReg16Bit+0x3c>
    25c6:	22 0f       	add	r18, r18
    25c8:	33 1f       	adc	r19, r19
    25ca:	9a 95       	dec	r25
    25cc:	e2 f7       	brpl	.-8      	; 0x25c6 <readReg16Bit+0x38>
    25ce:	f7 01       	movw	r30, r14
    25d0:	20 83       	st	Z, r18
    25d2:	31 83       	std	Z+1, r19	; 0x01
    25d4:	24 96       	adiw	r28, 0x04	; 4
    25d6:	cd bf       	out	0x3d, r28	; 61
    25d8:	de bf       	out	0x3e, r29	; 62
    25da:	df 91       	pop	r29
    25dc:	cf 91       	pop	r28
    25de:	0f 91       	pop	r16
    25e0:	ff 90       	pop	r15
    25e2:	ef 90       	pop	r14
    25e4:	08 95       	ret

000025e6 <getSequenceStepTimeouts.isra.1>:
    25e6:	8f 92       	push	r8
    25e8:	9f 92       	push	r9
    25ea:	af 92       	push	r10
    25ec:	bf 92       	push	r11
    25ee:	cf 92       	push	r12
    25f0:	df 92       	push	r13
    25f2:	ef 92       	push	r14
    25f4:	ff 92       	push	r15
    25f6:	0f 93       	push	r16
    25f8:	1f 93       	push	r17
    25fa:	cf 93       	push	r28
    25fc:	df 93       	push	r29
    25fe:	00 d0       	rcall	.+0      	; 0x2600 <getSequenceStepTimeouts.isra.1+0x1a>
    2600:	00 d0       	rcall	.+0      	; 0x2602 <getSequenceStepTimeouts.isra.1+0x1c>
    2602:	cd b7       	in	r28, 0x3d	; 61
    2604:	de b7       	in	r29, 0x3e	; 62
    2606:	6c 01       	movw	r12, r24
    2608:	7b 01       	movw	r14, r22
    260a:	80 e5       	ldi	r24, 0x50	; 80
    260c:	89 83       	std	Y+1, r24	; 0x01
    260e:	01 e0       	ldi	r16, 0x01	; 1
    2610:	9e 01       	movw	r18, r28
    2612:	2f 5f       	subi	r18, 0xFF	; 255
    2614:	3f 4f       	sbci	r19, 0xFF	; 255
    2616:	41 e0       	ldi	r20, 0x01	; 1
    2618:	b9 01       	movw	r22, r18
    261a:	89 e2       	ldi	r24, 0x29	; 41
    261c:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
    2620:	89 81       	ldd	r24, Y+1	; 0x01
    2622:	8f 5f       	subi	r24, 0xFF	; 255
    2624:	88 0f       	add	r24, r24
    2626:	90 e0       	ldi	r25, 0x00	; 0
    2628:	f7 01       	movw	r30, r14
    262a:	80 83       	st	Z, r24
    262c:	91 83       	std	Z+1, r25	; 0x01
    262e:	86 e4       	ldi	r24, 0x46	; 70
    2630:	89 83       	std	Y+1, r24	; 0x01
    2632:	9e 01       	movw	r18, r28
    2634:	2f 5f       	subi	r18, 0xFF	; 255
    2636:	3f 4f       	sbci	r19, 0xFF	; 255
    2638:	41 e0       	ldi	r20, 0x01	; 1
    263a:	b9 01       	movw	r22, r18
    263c:	89 e2       	ldi	r24, 0x29	; 41
    263e:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
    2642:	09 81       	ldd	r16, Y+1	; 0x01
    2644:	10 e0       	ldi	r17, 0x00	; 0
    2646:	0f 5f       	subi	r16, 0xFF	; 255
    2648:	1f 4f       	sbci	r17, 0xFF	; 255
    264a:	f7 01       	movw	r30, r14
    264c:	04 83       	std	Z+4, r16	; 0x04
    264e:	15 83       	std	Z+5, r17	; 0x05
    2650:	a0 81       	ld	r26, Z
    2652:	b0 e0       	ldi	r27, 0x00	; 0
    2654:	20 e0       	ldi	r18, 0x00	; 0
    2656:	3f e2       	ldi	r19, 0x2F	; 47
    2658:	4a e3       	ldi	r20, 0x3A	; 58
    265a:	50 e0       	ldi	r21, 0x00	; 0
    265c:	0e 94 64 49 	call	0x92c8	; 0x92c8 <__muluhisi3>
    2660:	6c 50       	subi	r22, 0x0C	; 12
    2662:	7e 4f       	sbci	r23, 0xFE	; 254
    2664:	8f 4f       	sbci	r24, 0xFF	; 255
    2666:	9f 4f       	sbci	r25, 0xFF	; 255
    2668:	38 ee       	ldi	r19, 0xE8	; 232
    266a:	83 2e       	mov	r8, r19
    266c:	33 e0       	ldi	r19, 0x03	; 3
    266e:	93 2e       	mov	r9, r19
    2670:	a1 2c       	mov	r10, r1
    2672:	b1 2c       	mov	r11, r1
    2674:	a5 01       	movw	r20, r10
    2676:	94 01       	movw	r18, r8
    2678:	0e 94 33 49 	call	0x9266	; 0x9266 <__udivmodsi4>
    267c:	d8 01       	movw	r26, r16
    267e:	0e 94 6f 49 	call	0x92de	; 0x92de <__mulshisi3>
    2682:	6c 50       	subi	r22, 0x0C	; 12
    2684:	7e 4f       	sbci	r23, 0xFE	; 254
    2686:	8f 4f       	sbci	r24, 0xFF	; 255
    2688:	9f 4f       	sbci	r25, 0xFF	; 255
    268a:	a5 01       	movw	r20, r10
    268c:	94 01       	movw	r18, r8
    268e:	0e 94 33 49 	call	0x9266	; 0x9266 <__udivmodsi4>
    2692:	f7 01       	movw	r30, r14
    2694:	22 87       	std	Z+10, r18	; 0x0a
    2696:	33 87       	std	Z+11, r19	; 0x0b
    2698:	44 87       	std	Z+12, r20	; 0x0c
    269a:	55 87       	std	Z+13, r21	; 0x0d
    269c:	be 01       	movw	r22, r28
    269e:	6b 5f       	subi	r22, 0xFB	; 251
    26a0:	7f 4f       	sbci	r23, 0xFF	; 255
    26a2:	81 e5       	ldi	r24, 0x51	; 81
    26a4:	0e 94 c7 12 	call	0x258e	; 0x258e <readReg16Bit>
    26a8:	8d 81       	ldd	r24, Y+5	; 0x05
    26aa:	9e 81       	ldd	r25, Y+6	; 0x06
    26ac:	8c 01       	movw	r16, r24
    26ae:	11 27       	eor	r17, r17
    26b0:	02 c0       	rjmp	.+4      	; 0x26b6 <getSequenceStepTimeouts.isra.1+0xd0>
    26b2:	00 0f       	add	r16, r16
    26b4:	11 1f       	adc	r17, r17
    26b6:	9a 95       	dec	r25
    26b8:	e2 f7       	brpl	.-8      	; 0x26b2 <getSequenceStepTimeouts.isra.1+0xcc>
    26ba:	0f 5f       	subi	r16, 0xFF	; 255
    26bc:	1f 4f       	sbci	r17, 0xFF	; 255
    26be:	f7 01       	movw	r30, r14
    26c0:	06 83       	std	Z+6, r16	; 0x06
    26c2:	17 83       	std	Z+7, r17	; 0x07
    26c4:	a0 81       	ld	r26, Z
    26c6:	b0 e0       	ldi	r27, 0x00	; 0
    26c8:	20 e0       	ldi	r18, 0x00	; 0
    26ca:	3f e2       	ldi	r19, 0x2F	; 47
    26cc:	4a e3       	ldi	r20, 0x3A	; 58
    26ce:	50 e0       	ldi	r21, 0x00	; 0
    26d0:	0e 94 64 49 	call	0x92c8	; 0x92c8 <__muluhisi3>
    26d4:	6c 50       	subi	r22, 0x0C	; 12
    26d6:	7e 4f       	sbci	r23, 0xFE	; 254
    26d8:	8f 4f       	sbci	r24, 0xFF	; 255
    26da:	9f 4f       	sbci	r25, 0xFF	; 255
    26dc:	a5 01       	movw	r20, r10
    26de:	94 01       	movw	r18, r8
    26e0:	0e 94 33 49 	call	0x9266	; 0x9266 <__udivmodsi4>
    26e4:	d8 01       	movw	r26, r16
    26e6:	0e 94 64 49 	call	0x92c8	; 0x92c8 <__muluhisi3>
    26ea:	6c 50       	subi	r22, 0x0C	; 12
    26ec:	7e 4f       	sbci	r23, 0xFE	; 254
    26ee:	8f 4f       	sbci	r24, 0xFF	; 255
    26f0:	9f 4f       	sbci	r25, 0xFF	; 255
    26f2:	a5 01       	movw	r20, r10
    26f4:	94 01       	movw	r18, r8
    26f6:	0e 94 33 49 	call	0x9266	; 0x9266 <__udivmodsi4>
    26fa:	f7 01       	movw	r30, r14
    26fc:	26 87       	std	Z+14, r18	; 0x0e
    26fe:	37 87       	std	Z+15, r19	; 0x0f
    2700:	40 8b       	std	Z+16, r20	; 0x10
    2702:	51 8b       	std	Z+17, r21	; 0x11
    2704:	80 e7       	ldi	r24, 0x70	; 112
    2706:	89 83       	std	Y+1, r24	; 0x01
    2708:	01 e0       	ldi	r16, 0x01	; 1
    270a:	9e 01       	movw	r18, r28
    270c:	2f 5f       	subi	r18, 0xFF	; 255
    270e:	3f 4f       	sbci	r19, 0xFF	; 255
    2710:	41 e0       	ldi	r20, 0x01	; 1
    2712:	b9 01       	movw	r22, r18
    2714:	89 e2       	ldi	r24, 0x29	; 41
    2716:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
    271a:	89 81       	ldd	r24, Y+1	; 0x01
    271c:	8f 5f       	subi	r24, 0xFF	; 255
    271e:	88 0f       	add	r24, r24
    2720:	90 e0       	ldi	r25, 0x00	; 0
    2722:	f7 01       	movw	r30, r14
    2724:	82 83       	std	Z+2, r24	; 0x02
    2726:	93 83       	std	Z+3, r25	; 0x03
    2728:	be 01       	movw	r22, r28
    272a:	6b 5f       	subi	r22, 0xFB	; 251
    272c:	7f 4f       	sbci	r23, 0xFF	; 255
    272e:	81 e7       	ldi	r24, 0x71	; 113
    2730:	0e 94 c7 12 	call	0x258e	; 0x258e <readReg16Bit>
    2734:	8d 81       	ldd	r24, Y+5	; 0x05
    2736:	9e 81       	ldd	r25, Y+6	; 0x06
    2738:	8c 01       	movw	r16, r24
    273a:	11 27       	eor	r17, r17
    273c:	02 c0       	rjmp	.+4      	; 0x2742 <getSequenceStepTimeouts.isra.1+0x15c>
    273e:	00 0f       	add	r16, r16
    2740:	11 1f       	adc	r17, r17
    2742:	9a 95       	dec	r25
    2744:	e2 f7       	brpl	.-8      	; 0x273e <getSequenceStepTimeouts.isra.1+0x158>
    2746:	0f 5f       	subi	r16, 0xFF	; 255
    2748:	1f 4f       	sbci	r17, 0xFF	; 255
    274a:	f7 01       	movw	r30, r14
    274c:	00 87       	std	Z+8, r16	; 0x08
    274e:	11 87       	std	Z+9, r17	; 0x09
    2750:	f6 01       	movw	r30, r12
    2752:	80 81       	ld	r24, Z
    2754:	88 23       	and	r24, r24
    2756:	39 f0       	breq	.+14     	; 0x2766 <getSequenceStepTimeouts.isra.1+0x180>
    2758:	f7 01       	movw	r30, r14
    275a:	86 81       	ldd	r24, Z+6	; 0x06
    275c:	97 81       	ldd	r25, Z+7	; 0x07
    275e:	08 1b       	sub	r16, r24
    2760:	19 0b       	sbc	r17, r25
    2762:	00 87       	std	Z+8, r16	; 0x08
    2764:	11 87       	std	Z+9, r17	; 0x09
    2766:	f7 01       	movw	r30, r14
    2768:	a2 81       	ldd	r26, Z+2	; 0x02
    276a:	b0 e0       	ldi	r27, 0x00	; 0
    276c:	20 e0       	ldi	r18, 0x00	; 0
    276e:	3f e2       	ldi	r19, 0x2F	; 47
    2770:	4a e3       	ldi	r20, 0x3A	; 58
    2772:	50 e0       	ldi	r21, 0x00	; 0
    2774:	0e 94 64 49 	call	0x92c8	; 0x92c8 <__muluhisi3>
    2778:	6c 50       	subi	r22, 0x0C	; 12
    277a:	7e 4f       	sbci	r23, 0xFE	; 254
    277c:	8f 4f       	sbci	r24, 0xFF	; 255
    277e:	9f 4f       	sbci	r25, 0xFF	; 255
    2780:	28 ee       	ldi	r18, 0xE8	; 232
    2782:	82 2e       	mov	r8, r18
    2784:	23 e0       	ldi	r18, 0x03	; 3
    2786:	92 2e       	mov	r9, r18
    2788:	a1 2c       	mov	r10, r1
    278a:	b1 2c       	mov	r11, r1
    278c:	a5 01       	movw	r20, r10
    278e:	94 01       	movw	r18, r8
    2790:	0e 94 33 49 	call	0x9266	; 0x9266 <__udivmodsi4>
    2794:	d8 01       	movw	r26, r16
    2796:	0e 94 64 49 	call	0x92c8	; 0x92c8 <__muluhisi3>
    279a:	6c 50       	subi	r22, 0x0C	; 12
    279c:	7e 4f       	sbci	r23, 0xFE	; 254
    279e:	8f 4f       	sbci	r24, 0xFF	; 255
    27a0:	9f 4f       	sbci	r25, 0xFF	; 255
    27a2:	a5 01       	movw	r20, r10
    27a4:	94 01       	movw	r18, r8
    27a6:	0e 94 33 49 	call	0x9266	; 0x9266 <__udivmodsi4>
    27aa:	f7 01       	movw	r30, r14
    27ac:	22 8b       	std	Z+18, r18	; 0x12
    27ae:	33 8b       	std	Z+19, r19	; 0x13
    27b0:	44 8b       	std	Z+20, r20	; 0x14
    27b2:	55 8b       	std	Z+21, r21	; 0x15
    27b4:	26 96       	adiw	r28, 0x06	; 6
    27b6:	cd bf       	out	0x3d, r28	; 61
    27b8:	de bf       	out	0x3e, r29	; 62
    27ba:	df 91       	pop	r29
    27bc:	cf 91       	pop	r28
    27be:	1f 91       	pop	r17
    27c0:	0f 91       	pop	r16
    27c2:	ff 90       	pop	r15
    27c4:	ef 90       	pop	r14
    27c6:	df 90       	pop	r13
    27c8:	cf 90       	pop	r12
    27ca:	bf 90       	pop	r11
    27cc:	af 90       	pop	r10
    27ce:	9f 90       	pop	r9
    27d0:	8f 90       	pop	r8
    27d2:	08 95       	ret

000027d4 <setMeasurementTimingBudget.part.4>:
    27d4:	4f 92       	push	r4
    27d6:	5f 92       	push	r5
    27d8:	6f 92       	push	r6
    27da:	7f 92       	push	r7
    27dc:	8f 92       	push	r8
    27de:	9f 92       	push	r9
    27e0:	af 92       	push	r10
    27e2:	bf 92       	push	r11
    27e4:	cf 92       	push	r12
    27e6:	df 92       	push	r13
    27e8:	ef 92       	push	r14
    27ea:	ff 92       	push	r15
    27ec:	1f 93       	push	r17
    27ee:	cf 93       	push	r28
    27f0:	df 93       	push	r29
    27f2:	cd b7       	in	r28, 0x3d	; 61
    27f4:	de b7       	in	r29, 0x3e	; 62
    27f6:	6f 97       	sbiw	r28, 0x1f	; 31
    27f8:	cd bf       	out	0x3d, r28	; 61
    27fa:	de bf       	out	0x3e, r29	; 62
    27fc:	6b 01       	movw	r12, r22
    27fe:	7c 01       	movw	r14, r24
    2800:	ce 01       	movw	r24, r28
    2802:	47 96       	adiw	r24, 0x17	; 23
    2804:	0e 94 3e 12 	call	0x247c	; 0x247c <getSequenceStepEnables>
    2808:	be 01       	movw	r22, r28
    280a:	6f 5f       	subi	r22, 0xFF	; 255
    280c:	7f 4f       	sbci	r23, 0xFF	; 255
    280e:	ce 01       	movw	r24, r28
    2810:	4a 96       	adiw	r24, 0x1a	; 26
    2812:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <getSequenceStepTimeouts.isra.1>
    2816:	8f 89       	ldd	r24, Y+23	; 0x17
    2818:	88 23       	and	r24, r24
    281a:	09 f4       	brne	.+2      	; 0x281e <setMeasurementTimingBudget.part.4+0x4a>
    281c:	b0 c0       	rjmp	.+352    	; 0x297e <setMeasurementTimingBudget.part.4+0x1aa>
    281e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2820:	9c 85       	ldd	r25, Y+12	; 0x0c
    2822:	ad 85       	ldd	r26, Y+13	; 0x0d
    2824:	be 85       	ldd	r27, Y+14	; 0x0e
    2826:	8c 57       	subi	r24, 0x7C	; 124
    2828:	92 4f       	sbci	r25, 0xF2	; 242
    282a:	af 4f       	sbci	r26, 0xFF	; 255
    282c:	bf 4f       	sbci	r27, 0xFF	; 255
    282e:	29 8d       	ldd	r18, Y+25	; 0x19
    2830:	22 23       	and	r18, r18
    2832:	09 f4       	brne	.+2      	; 0x2836 <setMeasurementTimingBudget.part.4+0x62>
    2834:	93 c0       	rjmp	.+294    	; 0x295c <setMeasurementTimingBudget.part.4+0x188>
    2836:	4b 85       	ldd	r20, Y+11	; 0x0b
    2838:	5c 85       	ldd	r21, Y+12	; 0x0c
    283a:	6d 85       	ldd	r22, Y+13	; 0x0d
    283c:	7e 85       	ldd	r23, Y+14	; 0x0e
    283e:	4e 54       	subi	r20, 0x4E	; 78
    2840:	5d 4f       	sbci	r21, 0xFD	; 253
    2842:	6f 4f       	sbci	r22, 0xFF	; 255
    2844:	7f 4f       	sbci	r23, 0xFF	; 255
    2846:	44 0f       	add	r20, r20
    2848:	55 1f       	adc	r21, r21
    284a:	66 1f       	adc	r22, r22
    284c:	77 1f       	adc	r23, r23
    284e:	84 0f       	add	r24, r20
    2850:	95 1f       	adc	r25, r21
    2852:	a6 1f       	adc	r26, r22
    2854:	b7 1f       	adc	r27, r23
    2856:	1a 8d       	ldd	r17, Y+26	; 0x1a
    2858:	11 23       	and	r17, r17
    285a:	61 f0       	breq	.+24     	; 0x2874 <setMeasurementTimingBudget.part.4+0xa0>
    285c:	4f 85       	ldd	r20, Y+15	; 0x0f
    285e:	58 89       	ldd	r21, Y+16	; 0x10
    2860:	69 89       	ldd	r22, Y+17	; 0x11
    2862:	7a 89       	ldd	r23, Y+18	; 0x12
    2864:	4c 56       	subi	r20, 0x6C	; 108
    2866:	5d 4f       	sbci	r21, 0xFD	; 253
    2868:	6f 4f       	sbci	r22, 0xFF	; 255
    286a:	7f 4f       	sbci	r23, 0xFF	; 255
    286c:	84 0f       	add	r24, r20
    286e:	95 1f       	adc	r25, r21
    2870:	a6 1f       	adc	r26, r22
    2872:	b7 1f       	adc	r27, r23
    2874:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2876:	22 23       	and	r18, r18
    2878:	09 f4       	brne	.+2      	; 0x287c <setMeasurementTimingBudget.part.4+0xa8>
    287a:	9a c0       	rjmp	.+308    	; 0x29b0 <setMeasurementTimingBudget.part.4+0x1dc>
    287c:	2c 01       	movw	r4, r24
    287e:	3d 01       	movw	r6, r26
    2880:	26 e2       	ldi	r18, 0x26	; 38
    2882:	42 0e       	add	r4, r18
    2884:	22 e0       	ldi	r18, 0x02	; 2
    2886:	52 1e       	adc	r5, r18
    2888:	61 1c       	adc	r6, r1
    288a:	71 1c       	adc	r7, r1
    288c:	c4 14       	cp	r12, r4
    288e:	d5 04       	cpc	r13, r5
    2890:	e6 04       	cpc	r14, r6
    2892:	f7 04       	cpc	r15, r7
    2894:	08 f4       	brcc	.+2      	; 0x2898 <setMeasurementTimingBudget.part.4+0xc4>
    2896:	78 c0       	rjmp	.+240    	; 0x2988 <setMeasurementTimingBudget.part.4+0x1b4>
    2898:	ab 81       	ldd	r26, Y+3	; 0x03
    289a:	b0 e0       	ldi	r27, 0x00	; 0
    289c:	20 e0       	ldi	r18, 0x00	; 0
    289e:	3f e2       	ldi	r19, 0x2F	; 47
    28a0:	4a e3       	ldi	r20, 0x3A	; 58
    28a2:	50 e0       	ldi	r21, 0x00	; 0
    28a4:	0e 94 64 49 	call	0x92c8	; 0x92c8 <__muluhisi3>
    28a8:	4b 01       	movw	r8, r22
    28aa:	5c 01       	movw	r10, r24
    28ac:	24 ef       	ldi	r18, 0xF4	; 244
    28ae:	82 0e       	add	r8, r18
    28b0:	21 e0       	ldi	r18, 0x01	; 1
    28b2:	92 1e       	adc	r9, r18
    28b4:	a1 1c       	adc	r10, r1
    28b6:	b1 1c       	adc	r11, r1
    28b8:	a7 01       	movw	r20, r14
    28ba:	96 01       	movw	r18, r12
    28bc:	24 19       	sub	r18, r4
    28be:	35 09       	sbc	r19, r5
    28c0:	46 09       	sbc	r20, r6
    28c2:	57 09       	sbc	r21, r7
    28c4:	a8 ee       	ldi	r26, 0xE8	; 232
    28c6:	b3 e0       	ldi	r27, 0x03	; 3
    28c8:	0e 94 64 49 	call	0x92c8	; 0x92c8 <__muluhisi3>
    28cc:	2b 01       	movw	r4, r22
    28ce:	3c 01       	movw	r6, r24
    28d0:	c5 01       	movw	r24, r10
    28d2:	b4 01       	movw	r22, r8
    28d4:	20 ed       	ldi	r18, 0xD0	; 208
    28d6:	37 e0       	ldi	r19, 0x07	; 7
    28d8:	40 e0       	ldi	r20, 0x00	; 0
    28da:	50 e0       	ldi	r21, 0x00	; 0
    28dc:	0e 94 33 49 	call	0x9266	; 0x9266 <__udivmodsi4>
    28e0:	42 0e       	add	r4, r18
    28e2:	53 1e       	adc	r5, r19
    28e4:	64 1e       	adc	r6, r20
    28e6:	75 1e       	adc	r7, r21
    28e8:	c5 01       	movw	r24, r10
    28ea:	b4 01       	movw	r22, r8
    28ec:	28 ee       	ldi	r18, 0xE8	; 232
    28ee:	33 e0       	ldi	r19, 0x03	; 3
    28f0:	40 e0       	ldi	r20, 0x00	; 0
    28f2:	50 e0       	ldi	r21, 0x00	; 0
    28f4:	0e 94 33 49 	call	0x9266	; 0x9266 <__udivmodsi4>
    28f8:	c3 01       	movw	r24, r6
    28fa:	b2 01       	movw	r22, r4
    28fc:	0e 94 33 49 	call	0x9266	; 0x9266 <__udivmodsi4>
    2900:	11 23       	and	r17, r17
    2902:	31 f0       	breq	.+12     	; 0x2910 <setMeasurementTimingBudget.part.4+0x13c>
    2904:	8f 81       	ldd	r24, Y+7	; 0x07
    2906:	98 85       	ldd	r25, Y+8	; 0x08
    2908:	28 0f       	add	r18, r24
    290a:	39 1f       	adc	r19, r25
    290c:	41 1d       	adc	r20, r1
    290e:	51 1d       	adc	r21, r1
    2910:	21 15       	cp	r18, r1
    2912:	31 05       	cpc	r19, r1
    2914:	41 05       	cpc	r20, r1
    2916:	51 05       	cpc	r21, r1
    2918:	09 f4       	brne	.+2      	; 0x291c <setMeasurementTimingBudget.part.4+0x148>
    291a:	4c c0       	rjmp	.+152    	; 0x29b4 <setMeasurementTimingBudget.part.4+0x1e0>
    291c:	da 01       	movw	r26, r20
    291e:	c9 01       	movw	r24, r18
    2920:	01 97       	sbiw	r24, 0x01	; 1
    2922:	a1 09       	sbc	r26, r1
    2924:	b1 09       	sbc	r27, r1
    2926:	ac 01       	movw	r20, r24
    2928:	bd 01       	movw	r22, r26
    292a:	44 27       	eor	r20, r20
    292c:	20 e0       	ldi	r18, 0x00	; 0
    292e:	30 e0       	ldi	r19, 0x00	; 0
    2930:	45 2b       	or	r20, r21
    2932:	46 2b       	or	r20, r22
    2934:	47 2b       	or	r20, r23
    2936:	79 f0       	breq	.+30     	; 0x2956 <setMeasurementTimingBudget.part.4+0x182>
    2938:	b6 95       	lsr	r27
    293a:	a7 95       	ror	r26
    293c:	97 95       	ror	r25
    293e:	87 95       	ror	r24
    2940:	2f 5f       	subi	r18, 0xFF	; 255
    2942:	3f 4f       	sbci	r19, 0xFF	; 255
    2944:	ac 01       	movw	r20, r24
    2946:	bd 01       	movw	r22, r26
    2948:	44 27       	eor	r20, r20
    294a:	45 2b       	or	r20, r21
    294c:	46 2b       	or	r20, r22
    294e:	47 2b       	or	r20, r23
    2950:	99 f7       	brne	.-26     	; 0x2938 <setMeasurementTimingBudget.part.4+0x164>
    2952:	32 2f       	mov	r19, r18
    2954:	22 27       	eor	r18, r18
    2956:	82 2b       	or	r24, r18
    2958:	93 2b       	or	r25, r19
    295a:	2e c0       	rjmp	.+92     	; 0x29b8 <setMeasurementTimingBudget.part.4+0x1e4>
    295c:	28 8d       	ldd	r18, Y+24	; 0x18
    295e:	22 23       	and	r18, r18
    2960:	09 f4       	brne	.+2      	; 0x2964 <setMeasurementTimingBudget.part.4+0x190>
    2962:	79 cf       	rjmp	.-270    	; 0x2856 <setMeasurementTimingBudget.part.4+0x82>
    2964:	4b 85       	ldd	r20, Y+11	; 0x0b
    2966:	5c 85       	ldd	r21, Y+12	; 0x0c
    2968:	6d 85       	ldd	r22, Y+13	; 0x0d
    296a:	7e 85       	ldd	r23, Y+14	; 0x0e
    296c:	4c 56       	subi	r20, 0x6C	; 108
    296e:	5d 4f       	sbci	r21, 0xFD	; 253
    2970:	6f 4f       	sbci	r22, 0xFF	; 255
    2972:	7f 4f       	sbci	r23, 0xFF	; 255
    2974:	84 0f       	add	r24, r20
    2976:	95 1f       	adc	r25, r21
    2978:	a6 1f       	adc	r26, r22
    297a:	b7 1f       	adc	r27, r23
    297c:	6c cf       	rjmp	.-296    	; 0x2856 <setMeasurementTimingBudget.part.4+0x82>
    297e:	86 e3       	ldi	r24, 0x36	; 54
    2980:	9b e0       	ldi	r25, 0x0B	; 11
    2982:	a0 e0       	ldi	r26, 0x00	; 0
    2984:	b0 e0       	ldi	r27, 0x00	; 0
    2986:	53 cf       	rjmp	.-346    	; 0x282e <setMeasurementTimingBudget.part.4+0x5a>
    2988:	80 e0       	ldi	r24, 0x00	; 0
    298a:	6f 96       	adiw	r28, 0x1f	; 31
    298c:	cd bf       	out	0x3d, r28	; 61
    298e:	de bf       	out	0x3e, r29	; 62
    2990:	df 91       	pop	r29
    2992:	cf 91       	pop	r28
    2994:	1f 91       	pop	r17
    2996:	ff 90       	pop	r15
    2998:	ef 90       	pop	r14
    299a:	df 90       	pop	r13
    299c:	cf 90       	pop	r12
    299e:	bf 90       	pop	r11
    29a0:	af 90       	pop	r10
    29a2:	9f 90       	pop	r9
    29a4:	8f 90       	pop	r8
    29a6:	7f 90       	pop	r7
    29a8:	6f 90       	pop	r6
    29aa:	5f 90       	pop	r5
    29ac:	4f 90       	pop	r4
    29ae:	08 95       	ret
    29b0:	81 e0       	ldi	r24, 0x01	; 1
    29b2:	eb cf       	rjmp	.-42     	; 0x298a <setMeasurementTimingBudget.part.4+0x1b6>
    29b4:	80 e0       	ldi	r24, 0x00	; 0
    29b6:	90 e0       	ldi	r25, 0x00	; 0
    29b8:	21 e7       	ldi	r18, 0x71	; 113
    29ba:	2c 8f       	std	Y+28, r18	; 0x1c
    29bc:	9d 8f       	std	Y+29, r25	; 0x1d
    29be:	8e 8f       	std	Y+30, r24	; 0x1e
    29c0:	43 e0       	ldi	r20, 0x03	; 3
    29c2:	be 01       	movw	r22, r28
    29c4:	64 5e       	subi	r22, 0xE4	; 228
    29c6:	7f 4f       	sbci	r23, 0xFF	; 255
    29c8:	89 e2       	ldi	r24, 0x29	; 41
    29ca:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
    29ce:	c0 92 cb 2d 	sts	0x2DCB, r12	; 0x802dcb <measurement_timing_budget_us>
    29d2:	d0 92 cc 2d 	sts	0x2DCC, r13	; 0x802dcc <measurement_timing_budget_us+0x1>
    29d6:	e0 92 cd 2d 	sts	0x2DCD, r14	; 0x802dcd <measurement_timing_budget_us+0x2>
    29da:	f0 92 ce 2d 	sts	0x2DCE, r15	; 0x802dce <measurement_timing_budget_us+0x3>
    29de:	81 e0       	ldi	r24, 0x01	; 1
    29e0:	d4 cf       	rjmp	.-88     	; 0x298a <setMeasurementTimingBudget.part.4+0x1b6>

000029e2 <DriverVL53L0XInit>:


uint8_t DriverVL53L0XInit(void)
{
    29e2:	2f 92       	push	r2
    29e4:	3f 92       	push	r3
    29e6:	4f 92       	push	r4
    29e8:	5f 92       	push	r5
    29ea:	6f 92       	push	r6
    29ec:	7f 92       	push	r7
    29ee:	8f 92       	push	r8
    29f0:	9f 92       	push	r9
    29f2:	af 92       	push	r10
    29f4:	bf 92       	push	r11
    29f6:	cf 92       	push	r12
    29f8:	df 92       	push	r13
    29fa:	ef 92       	push	r14
    29fc:	ff 92       	push	r15
    29fe:	0f 93       	push	r16
    2a00:	1f 93       	push	r17
    2a02:	cf 93       	push	r28
    2a04:	df 93       	push	r29
    2a06:	cd b7       	in	r28, 0x3d	; 61
    2a08:	de b7       	in	r29, 0x3e	; 62
    2a0a:	a1 97       	sbiw	r28, 0x21	; 33
    2a0c:	cd bf       	out	0x3d, r28	; 61
    2a0e:	de bf       	out	0x3e, r29	; 62
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2a10:	80 ec       	ldi	r24, 0xC0	; 192
    2a12:	89 83       	std	Y+1, r24	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2a14:	01 e0       	ldi	r16, 0x01	; 1
    2a16:	9e 01       	movw	r18, r28
    2a18:	2f 5f       	subi	r18, 0xFF	; 255
    2a1a:	3f 4f       	sbci	r19, 0xFF	; 255
    2a1c:	41 e0       	ldi	r20, 0x01	; 1
    2a1e:	b9 01       	movw	r22, r18
    2a20:	89 e2       	ldi	r24, 0x29	; 41
    2a22:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2a26:	99 81       	ldd	r25, Y+1	; 0x01
	uint8_t res;
	int a;
	
	//Check Model ID
	res=readReg(IDENTIFICATION_MODEL_ID,&Data);
	if (!res)
    2a28:	88 23       	and	r24, r24
    2a2a:	09 f4       	brne	.+2      	; 0x2a2e <DriverVL53L0XInit+0x4c>
    2a2c:	ef c5       	rjmp	.+3038   	; 0x360c <DriverVL53L0XInit+0xc2a>
		#ifdef VL53L0X_DEBUG
			printf ("VL53L0X:Cannot access.\r\n");
		#endif
		return false;
	}
	if (Data != 0xEE)
    2a2e:	9e 3e       	cpi	r25, 0xEE	; 238
    2a30:	d9 f0       	breq	.+54     	; 0x2a68 <DriverVL53L0XInit+0x86>
	{
		#ifdef VL53L0X_DEBUG
			printf ("VL53L0X:Incorrect ID_MODEL_ID\r\n");
    2a32:	8b ea       	ldi	r24, 0xAB	; 171
    2a34:	93 e2       	ldi	r25, 0x23	; 35
    2a36:	0e 94 9e 4e 	call	0x9d3c	; 0x9d3c <puts>
		#endif
		return false;
    2a3a:	80 e0       	ldi	r24, 0x00	; 0
	writeReg(SYSTEM_SEQUENCE_CONFIG, 0xE8);

	// VL53L0X_PerformRefCalibration() end

	return true;
}
    2a3c:	a1 96       	adiw	r28, 0x21	; 33
    2a3e:	cd bf       	out	0x3d, r28	; 61
    2a40:	de bf       	out	0x3e, r29	; 62
    2a42:	df 91       	pop	r29
    2a44:	cf 91       	pop	r28
    2a46:	1f 91       	pop	r17
    2a48:	0f 91       	pop	r16
    2a4a:	ff 90       	pop	r15
    2a4c:	ef 90       	pop	r14
    2a4e:	df 90       	pop	r13
    2a50:	cf 90       	pop	r12
    2a52:	bf 90       	pop	r11
    2a54:	af 90       	pop	r10
    2a56:	9f 90       	pop	r9
    2a58:	8f 90       	pop	r8
    2a5a:	7f 90       	pop	r7
    2a5c:	6f 90       	pop	r6
    2a5e:	5f 90       	pop	r5
    2a60:	4f 90       	pop	r4
    2a62:	3f 90       	pop	r3
    2a64:	2f 90       	pop	r2
    2a66:	08 95       	ret
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2a68:	88 e8       	ldi	r24, 0x88	; 136
    2a6a:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2a6c:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2a6e:	42 e0       	ldi	r20, 0x02	; 2
    2a70:	be 01       	movw	r22, r28
    2a72:	6f 5f       	subi	r22, 0xFF	; 255
    2a74:	7f 4f       	sbci	r23, 0xFF	; 255
    2a76:	89 e2       	ldi	r24, 0x29	; 41
    2a78:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2a7c:	e0 e8       	ldi	r30, 0x80	; 128
    2a7e:	ee 2e       	mov	r14, r30
    2a80:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2a82:	11 e0       	ldi	r17, 0x01	; 1
    2a84:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2a86:	42 e0       	ldi	r20, 0x02	; 2
    2a88:	be 01       	movw	r22, r28
    2a8a:	6f 5f       	subi	r22, 0xFF	; 255
    2a8c:	7f 4f       	sbci	r23, 0xFF	; 255
    2a8e:	89 e2       	ldi	r24, 0x29	; 41
    2a90:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2a94:	ff 24       	eor	r15, r15
    2a96:	fa 94       	dec	r15
    2a98:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    2a9a:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2a9c:	42 e0       	ldi	r20, 0x02	; 2
    2a9e:	be 01       	movw	r22, r28
    2aa0:	6f 5f       	subi	r22, 0xFF	; 255
    2aa2:	7f 4f       	sbci	r23, 0xFF	; 255
    2aa4:	89 e2       	ldi	r24, 0x29	; 41
    2aa6:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2aaa:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    2aac:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2aae:	42 e0       	ldi	r20, 0x02	; 2
    2ab0:	be 01       	movw	r22, r28
    2ab2:	6f 5f       	subi	r22, 0xFF	; 255
    2ab4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ab6:	89 e2       	ldi	r24, 0x29	; 41
    2ab8:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2abc:	81 e9       	ldi	r24, 0x91	; 145
    2abe:	89 83       	std	Y+1, r24	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2ac0:	01 e0       	ldi	r16, 0x01	; 1
    2ac2:	9e 01       	movw	r18, r28
    2ac4:	2f 5f       	subi	r18, 0xFF	; 255
    2ac6:	3f 4f       	sbci	r19, 0xFF	; 255
    2ac8:	41 e0       	ldi	r20, 0x01	; 1
    2aca:	b9 01       	movw	r22, r18
    2acc:	89 e2       	ldi	r24, 0x29	; 41
    2ace:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2ad2:	89 81       	ldd	r24, Y+1	; 0x01
    2ad4:	80 93 e3 2c 	sts	0x2CE3, r24	; 0x802ce3 <stop_variable>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2ad8:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    2ada:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2adc:	42 e0       	ldi	r20, 0x02	; 2
    2ade:	be 01       	movw	r22, r28
    2ae0:	6f 5f       	subi	r22, 0xFF	; 255
    2ae2:	7f 4f       	sbci	r23, 0xFF	; 255
    2ae4:	89 e2       	ldi	r24, 0x29	; 41
    2ae6:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2aea:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    2aec:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2aee:	42 e0       	ldi	r20, 0x02	; 2
    2af0:	be 01       	movw	r22, r28
    2af2:	6f 5f       	subi	r22, 0xFF	; 255
    2af4:	7f 4f       	sbci	r23, 0xFF	; 255
    2af6:	89 e2       	ldi	r24, 0x29	; 41
    2af8:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2afc:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2afe:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2b00:	42 e0       	ldi	r20, 0x02	; 2
    2b02:	be 01       	movw	r22, r28
    2b04:	6f 5f       	subi	r22, 0xFF	; 255
    2b06:	7f 4f       	sbci	r23, 0xFF	; 255
    2b08:	89 e2       	ldi	r24, 0x29	; 41
    2b0a:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2b0e:	f0 e6       	ldi	r31, 0x60	; 96
    2b10:	df 2e       	mov	r13, r31
    2b12:	d9 82       	std	Y+1, r13	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2b14:	9e 01       	movw	r18, r28
    2b16:	2f 5f       	subi	r18, 0xFF	; 255
    2b18:	3f 4f       	sbci	r19, 0xFF	; 255
    2b1a:	41 e0       	ldi	r20, 0x01	; 1
    2b1c:	b9 01       	movw	r22, r18
    2b1e:	89 e2       	ldi	r24, 0x29	; 41
    2b20:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2b24:	89 81       	ldd	r24, Y+1	; 0x01
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2b26:	d9 82       	std	Y+1, r13	; 0x01
	Buffer[1]=value;
    2b28:	82 61       	ori	r24, 0x12	; 18
    2b2a:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2b2c:	42 e0       	ldi	r20, 0x02	; 2
    2b2e:	be 01       	movw	r22, r28
    2b30:	6f 5f       	subi	r22, 0xFF	; 255
    2b32:	7f 4f       	sbci	r23, 0xFF	; 255
    2b34:	89 e2       	ldi	r24, 0x29	; 41
    2b36:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write a 16-bit register
uint8_t writeReg16Bit(uint8_t reg, uint16_t value)
{
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg,
    2b3a:	84 e4       	ldi	r24, 0x44	; 68
    2b3c:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value>>8;
    2b3e:	1a 82       	std	Y+2, r1	; 0x02
	Buffer[2]=value;
    2b40:	80 e2       	ldi	r24, 0x20	; 32
    2b42:	8b 83       	std	Y+3, r24	; 0x03
	res=TWIMWrite(VL53L0X_ADDR,Buffer,3);
    2b44:	43 e0       	ldi	r20, 0x03	; 3
    2b46:	be 01       	movw	r22, r28
    2b48:	6f 5f       	subi	r22, 0xFF	; 255
    2b4a:	7f 4f       	sbci	r23, 0xFF	; 255
    2b4c:	89 e2       	ldi	r24, 0x29	; 41
    2b4e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2b52:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2b54:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2b56:	42 e0       	ldi	r20, 0x02	; 2
    2b58:	be 01       	movw	r22, r28
    2b5a:	6f 5f       	subi	r22, 0xFF	; 255
    2b5c:	7f 4f       	sbci	r23, 0xFF	; 255
    2b5e:	89 e2       	ldi	r24, 0x29	; 41
    2b60:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2b64:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2b66:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2b68:	42 e0       	ldi	r20, 0x02	; 2
    2b6a:	be 01       	movw	r22, r28
    2b6c:	6f 5f       	subi	r22, 0xFF	; 255
    2b6e:	7f 4f       	sbci	r23, 0xFF	; 255
    2b70:	89 e2       	ldi	r24, 0x29	; 41
    2b72:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2b76:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    2b78:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2b7a:	42 e0       	ldi	r20, 0x02	; 2
    2b7c:	be 01       	movw	r22, r28
    2b7e:	6f 5f       	subi	r22, 0xFF	; 255
    2b80:	7f 4f       	sbci	r23, 0xFF	; 255
    2b82:	89 e2       	ldi	r24, 0x29	; 41
    2b84:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2b88:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    2b8a:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2b8c:	42 e0       	ldi	r20, 0x02	; 2
    2b8e:	be 01       	movw	r22, r28
    2b90:	6f 5f       	subi	r22, 0xFF	; 255
    2b92:	7f 4f       	sbci	r23, 0xFF	; 255
    2b94:	89 e2       	ldi	r24, 0x29	; 41
    2b96:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2b9a:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    2b9c:	86 e0       	ldi	r24, 0x06	; 6
    2b9e:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2ba0:	42 e0       	ldi	r20, 0x02	; 2
    2ba2:	be 01       	movw	r22, r28
    2ba4:	6f 5f       	subi	r22, 0xFF	; 255
    2ba6:	7f 4f       	sbci	r23, 0xFF	; 255
    2ba8:	89 e2       	ldi	r24, 0x29	; 41
    2baa:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2bae:	a3 e8       	ldi	r26, 0x83	; 131
    2bb0:	da 2e       	mov	r13, r26
    2bb2:	d9 82       	std	Y+1, r13	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2bb4:	9e 01       	movw	r18, r28
    2bb6:	2f 5f       	subi	r18, 0xFF	; 255
    2bb8:	3f 4f       	sbci	r19, 0xFF	; 255
    2bba:	41 e0       	ldi	r20, 0x01	; 1
    2bbc:	b9 01       	movw	r22, r18
    2bbe:	89 e2       	ldi	r24, 0x29	; 41
    2bc0:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2bc4:	89 81       	ldd	r24, Y+1	; 0x01
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2bc6:	d9 82       	std	Y+1, r13	; 0x01
	Buffer[1]=value;
    2bc8:	84 60       	ori	r24, 0x04	; 4
    2bca:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2bcc:	42 e0       	ldi	r20, 0x02	; 2
    2bce:	be 01       	movw	r22, r28
    2bd0:	6f 5f       	subi	r22, 0xFF	; 255
    2bd2:	7f 4f       	sbci	r23, 0xFF	; 255
    2bd4:	89 e2       	ldi	r24, 0x29	; 41
    2bd6:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2bda:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    2bdc:	87 e0       	ldi	r24, 0x07	; 7
    2bde:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2be0:	42 e0       	ldi	r20, 0x02	; 2
    2be2:	be 01       	movw	r22, r28
    2be4:	6f 5f       	subi	r22, 0xFF	; 255
    2be6:	7f 4f       	sbci	r23, 0xFF	; 255
    2be8:	89 e2       	ldi	r24, 0x29	; 41
    2bea:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2bee:	81 e8       	ldi	r24, 0x81	; 129
    2bf0:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2bf2:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2bf4:	42 e0       	ldi	r20, 0x02	; 2
    2bf6:	be 01       	movw	r22, r28
    2bf8:	6f 5f       	subi	r22, 0xFF	; 255
    2bfa:	7f 4f       	sbci	r23, 0xFF	; 255
    2bfc:	89 e2       	ldi	r24, 0x29	; 41
    2bfe:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2c02:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2c04:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2c06:	42 e0       	ldi	r20, 0x02	; 2
    2c08:	be 01       	movw	r22, r28
    2c0a:	6f 5f       	subi	r22, 0xFF	; 255
    2c0c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c0e:	89 e2       	ldi	r24, 0x29	; 41
    2c10:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2c14:	84 e9       	ldi	r24, 0x94	; 148
    2c16:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2c18:	8b e6       	ldi	r24, 0x6B	; 107
    2c1a:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2c1c:	42 e0       	ldi	r20, 0x02	; 2
    2c1e:	be 01       	movw	r22, r28
    2c20:	6f 5f       	subi	r22, 0xFF	; 255
    2c22:	7f 4f       	sbci	r23, 0xFF	; 255
    2c24:	89 e2       	ldi	r24, 0x29	; 41
    2c26:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2c2a:	d9 82       	std	Y+1, r13	; 0x01
	Buffer[1]=value;
    2c2c:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2c2e:	42 e0       	ldi	r20, 0x02	; 2
    2c30:	be 01       	movw	r22, r28
    2c32:	6f 5f       	subi	r22, 0xFF	; 255
    2c34:	7f 4f       	sbci	r23, 0xFF	; 255
    2c36:	89 e2       	ldi	r24, 0x29	; 41
    2c38:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
	return true;
}

static void startTimeout(void)
{
	timeout_start_ticks=portGET_RUN_TIME_COUNTER_VALUE();
    2c3c:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2c40:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2c44:	80 91 cf 2d 	lds	r24, 0x2DCF	; 0x802dcf <StatsTimer>
    2c48:	90 91 d0 2d 	lds	r25, 0x2DD0	; 0x802dd0 <StatsTimer+0x1>
    2c4c:	a0 91 d1 2d 	lds	r26, 0x2DD1	; 0x802dd1 <StatsTimer+0x2>
    2c50:	b0 91 d2 2d 	lds	r27, 0x2DD2	; 0x802dd2 <StatsTimer+0x3>
    2c54:	82 0f       	add	r24, r18
    2c56:	93 1f       	adc	r25, r19
    2c58:	a1 1d       	adc	r26, r1
    2c5a:	b1 1d       	adc	r27, r1
    2c5c:	80 93 df 2c 	sts	0x2CDF, r24	; 0x802cdf <timeout_start_ticks>
    2c60:	90 93 e0 2c 	sts	0x2CE0, r25	; 0x802ce0 <timeout_start_ticks+0x1>
    2c64:	a0 93 e1 2c 	sts	0x2CE1, r26	; 0x802ce1 <timeout_start_ticks+0x2>
    2c68:	b0 93 e2 2c 	sts	0x2CE2, r27	; 0x802ce2 <timeout_start_ticks+0x3>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2c6c:	b3 e8       	ldi	r27, 0x83	; 131
    2c6e:	fb 2e       	mov	r15, r27
    2c70:	13 e8       	ldi	r17, 0x83	; 131
    2c72:	f9 82       	std	Y+1, r15	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2c74:	01 e0       	ldi	r16, 0x01	; 1
    2c76:	9e 01       	movw	r18, r28
    2c78:	2f 5f       	subi	r18, 0xFF	; 255
    2c7a:	3f 4f       	sbci	r19, 0xFF	; 255
    2c7c:	41 e0       	ldi	r20, 0x01	; 1
    2c7e:	b9 01       	movw	r22, r18
    2c80:	89 e2       	ldi	r24, 0x29	; 41
    2c82:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2c86:	89 81       	ldd	r24, Y+1	; 0x01
	startTimeout();
	
	while (1)
	{
		readReg(0x83,&Data);
		if (Data!=0x00) break;
    2c88:	88 23       	and	r24, r24
    2c8a:	91 f3       	breq	.-28     	; 0x2c70 <DriverVL53L0XInit+0x28e>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2c8c:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2c8e:	dd 24       	eor	r13, r13
    2c90:	d3 94       	inc	r13
    2c92:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2c94:	42 e0       	ldi	r20, 0x02	; 2
    2c96:	be 01       	movw	r22, r28
    2c98:	6f 5f       	subi	r22, 0xFF	; 255
    2c9a:	7f 4f       	sbci	r23, 0xFF	; 255
    2c9c:	89 e2       	ldi	r24, 0x29	; 41
    2c9e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2ca2:	82 e9       	ldi	r24, 0x92	; 146
    2ca4:	89 83       	std	Y+1, r24	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2ca6:	9e 01       	movw	r18, r28
    2ca8:	2f 5f       	subi	r18, 0xFF	; 255
    2caa:	3f 4f       	sbci	r19, 0xFF	; 255
    2cac:	41 e0       	ldi	r20, 0x01	; 1
    2cae:	b9 01       	movw	r22, r18
    2cb0:	89 e2       	ldi	r24, 0x29	; 41
    2cb2:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2cb6:	f9 80       	ldd	r15, Y+1	; 0x01
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2cb8:	81 e8       	ldi	r24, 0x81	; 129
    2cba:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2cbc:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2cbe:	42 e0       	ldi	r20, 0x02	; 2
    2cc0:	be 01       	movw	r22, r28
    2cc2:	6f 5f       	subi	r22, 0xFF	; 255
    2cc4:	7f 4f       	sbci	r23, 0xFF	; 255
    2cc6:	89 e2       	ldi	r24, 0x29	; 41
    2cc8:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2ccc:	ee 24       	eor	r14, r14
    2cce:	ea 94       	dec	r14
    2cd0:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2cd2:	86 e0       	ldi	r24, 0x06	; 6
    2cd4:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2cd6:	42 e0       	ldi	r20, 0x02	; 2
    2cd8:	be 01       	movw	r22, r28
    2cda:	6f 5f       	subi	r22, 0xFF	; 255
    2cdc:	7f 4f       	sbci	r23, 0xFF	; 255
    2cde:	89 e2       	ldi	r24, 0x29	; 41
    2ce0:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2ce4:	19 83       	std	Y+1, r17	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2ce6:	9e 01       	movw	r18, r28
    2ce8:	2f 5f       	subi	r18, 0xFF	; 255
    2cea:	3f 4f       	sbci	r19, 0xFF	; 255
    2cec:	41 e0       	ldi	r20, 0x01	; 1
    2cee:	b9 01       	movw	r22, r18
    2cf0:	89 e2       	ldi	r24, 0x29	; 41
    2cf2:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2cf6:	89 81       	ldd	r24, Y+1	; 0x01
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2cf8:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2cfa:	8b 7f       	andi	r24, 0xFB	; 251
    2cfc:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2cfe:	42 e0       	ldi	r20, 0x02	; 2
    2d00:	be 01       	movw	r22, r28
    2d02:	6f 5f       	subi	r22, 0xFF	; 255
    2d04:	7f 4f       	sbci	r23, 0xFF	; 255
    2d06:	89 e2       	ldi	r24, 0x29	; 41
    2d08:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d0c:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2d0e:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d10:	42 e0       	ldi	r20, 0x02	; 2
    2d12:	be 01       	movw	r22, r28
    2d14:	6f 5f       	subi	r22, 0xFF	; 255
    2d16:	7f 4f       	sbci	r23, 0xFF	; 255
    2d18:	89 e2       	ldi	r24, 0x29	; 41
    2d1a:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d1e:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    2d20:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d22:	42 e0       	ldi	r20, 0x02	; 2
    2d24:	be 01       	movw	r22, r28
    2d26:	6f 5f       	subi	r22, 0xFF	; 255
    2d28:	7f 4f       	sbci	r23, 0xFF	; 255
    2d2a:	89 e2       	ldi	r24, 0x29	; 41
    2d2c:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d30:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2d32:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d34:	42 e0       	ldi	r20, 0x02	; 2
    2d36:	be 01       	movw	r22, r28
    2d38:	6f 5f       	subi	r22, 0xFF	; 255
    2d3a:	7f 4f       	sbci	r23, 0xFF	; 255
    2d3c:	89 e2       	ldi	r24, 0x29	; 41
    2d3e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d42:	80 e8       	ldi	r24, 0x80	; 128
    2d44:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2d46:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d48:	42 e0       	ldi	r20, 0x02	; 2
    2d4a:	be 01       	movw	r22, r28
    2d4c:	6f 5f       	subi	r22, 0xFF	; 255
    2d4e:	7f 4f       	sbci	r23, 0xFF	; 255
    2d50:	89 e2       	ldi	r24, 0x29	; 41
    2d52:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// register, into the given array
uint8_t readMulti(uint8_t reg, uint8_t * dst, uint8_t count)
{
	uint8_t res;
	uint8_t Buffer[1];
	Buffer[0]=reg;
    2d56:	80 eb       	ldi	r24, 0xB0	; 176
    2d58:	89 83       	std	Y+1, r24	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,dst,count);
    2d5a:	06 e0       	ldi	r16, 0x06	; 6
    2d5c:	9e 01       	movw	r18, r28
    2d5e:	29 5e       	subi	r18, 0xE9	; 233
    2d60:	3f 4f       	sbci	r19, 0xFF	; 255
    2d62:	41 e0       	ldi	r20, 0x01	; 1
    2d64:	be 01       	movw	r22, r28
    2d66:	6f 5f       	subi	r22, 0xFF	; 255
    2d68:	7f 4f       	sbci	r23, 0xFF	; 255
    2d6a:	89 e2       	ldi	r24, 0x29	; 41
    2d6c:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d70:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2d72:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d74:	42 e0       	ldi	r20, 0x02	; 2
    2d76:	be 01       	movw	r22, r28
    2d78:	6f 5f       	subi	r22, 0xFF	; 255
    2d7a:	7f 4f       	sbci	r23, 0xFF	; 255
    2d7c:	89 e2       	ldi	r24, 0x29	; 41
    2d7e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d82:	8f e4       	ldi	r24, 0x4F	; 79
    2d84:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2d86:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d88:	42 e0       	ldi	r20, 0x02	; 2
    2d8a:	be 01       	movw	r22, r28
    2d8c:	6f 5f       	subi	r22, 0xFF	; 255
    2d8e:	7f 4f       	sbci	r23, 0xFF	; 255
    2d90:	89 e2       	ldi	r24, 0x29	; 41
    2d92:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d96:	8e e4       	ldi	r24, 0x4E	; 78
    2d98:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2d9a:	8c e2       	ldi	r24, 0x2C	; 44
    2d9c:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d9e:	42 e0       	ldi	r20, 0x02	; 2
    2da0:	be 01       	movw	r22, r28
    2da2:	6f 5f       	subi	r22, 0xFF	; 255
    2da4:	7f 4f       	sbci	r23, 0xFF	; 255
    2da6:	89 e2       	ldi	r24, 0x29	; 41
    2da8:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2dac:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2dae:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2db0:	42 e0       	ldi	r20, 0x02	; 2
    2db2:	be 01       	movw	r22, r28
    2db4:	6f 5f       	subi	r22, 0xFF	; 255
    2db6:	7f 4f       	sbci	r23, 0xFF	; 255
    2db8:	89 e2       	ldi	r24, 0x29	; 41
    2dba:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2dbe:	86 eb       	ldi	r24, 0xB6	; 182
    2dc0:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2dc2:	84 eb       	ldi	r24, 0xB4	; 180
    2dc4:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2dc6:	42 e0       	ldi	r20, 0x02	; 2
    2dc8:	be 01       	movw	r22, r28
    2dca:	6f 5f       	subi	r22, 0xFF	; 255
    2dcc:	7f 4f       	sbci	r23, 0xFF	; 255
    2dce:	89 e2       	ldi	r24, 0x29	; 41
    2dd0:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
	writeReg(DYNAMIC_SPAD_REF_EN_START_OFFSET, 0x00);
	writeReg(DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);
	writeReg(0xFF, 0x00);
	writeReg(GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);

	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
    2dd4:	f7 fc       	sbrc	r15, 7
    2dd6:	20 c4       	rjmp	.+2112   	; 0x3618 <DriverVL53L0XInit+0xc36>
    2dd8:	40 e0       	ldi	r20, 0x00	; 0
	uint8_t spads_enabled = 0;

	for (uint8_t i = 0; i < 48; i++)
    2dda:	00 e0       	ldi	r16, 0x00	; 0
	writeReg(DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);
	writeReg(0xFF, 0x00);
	writeReg(GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);

	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
	uint8_t spads_enabled = 0;
    2ddc:	50 e0       	ldi	r21, 0x00	; 0
	{
		if (i < first_spad_to_enable || spads_enabled == spad_count)
		{
			// This bit is lower than the first one that should be enabled, or
			// (reference_spad_count) bits have already been enabled, so zero this bit
			ref_spad_map[i / 8] &= ~(1 << (i % 8));
    2dde:	21 e0       	ldi	r18, 0x01	; 1
    2de0:	30 e0       	ldi	r19, 0x00	; 0
	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
	uint8_t spads_enabled = 0;

	for (uint8_t i = 0; i < 48; i++)
	{
		if (i < first_spad_to_enable || spads_enabled == spad_count)
    2de2:	7f 2d       	mov	r23, r15
    2de4:	7f 77       	andi	r23, 0x7F	; 127
    2de6:	10 c0       	rjmp	.+32     	; 0x2e08 <DriverVL53L0XInit+0x426>
    2de8:	57 17       	cp	r21, r23
    2dea:	d1 f0       	breq	.+52     	; 0x2e20 <DriverVL53L0XInit+0x43e>
		{
			// This bit is lower than the first one that should be enabled, or
			// (reference_spad_count) bits have already been enabled, so zero this bit
			ref_spad_map[i / 8] &= ~(1 << (i % 8));
		}
		else if ((ref_spad_map[i / 8] >> (i % 8)) & 0x1)
    2dec:	80 81       	ld	r24, Z
    2dee:	90 e0       	ldi	r25, 0x00	; 0
    2df0:	60 2f       	mov	r22, r16
    2df2:	67 70       	andi	r22, 0x07	; 7
    2df4:	02 c0       	rjmp	.+4      	; 0x2dfa <DriverVL53L0XInit+0x418>
    2df6:	95 95       	asr	r25
    2df8:	87 95       	ror	r24
    2dfa:	6a 95       	dec	r22
    2dfc:	e2 f7       	brpl	.-8      	; 0x2df6 <DriverVL53L0XInit+0x414>
    2dfe:	80 fd       	sbrc	r24, 0
		{
			spads_enabled++;
    2e00:	5f 5f       	subi	r21, 0xFF	; 255
	writeReg(GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);

	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
	uint8_t spads_enabled = 0;

	for (uint8_t i = 0; i < 48; i++)
    2e02:	0f 5f       	subi	r16, 0xFF	; 255
    2e04:	00 33       	cpi	r16, 0x30	; 48
    2e06:	e1 f0       	breq	.+56     	; 0x2e40 <DriverVL53L0XInit+0x45e>
	{
		if (i < first_spad_to_enable || spads_enabled == spad_count)
		{
			// This bit is lower than the first one that should be enabled, or
			// (reference_spad_count) bits have already been enabled, so zero this bit
			ref_spad_map[i / 8] &= ~(1 << (i % 8));
    2e08:	80 2f       	mov	r24, r16
    2e0a:	86 95       	lsr	r24
    2e0c:	86 95       	lsr	r24
    2e0e:	86 95       	lsr	r24
    2e10:	e7 e1       	ldi	r30, 0x17	; 23
    2e12:	f0 e0       	ldi	r31, 0x00	; 0
    2e14:	ec 0f       	add	r30, r28
    2e16:	fd 1f       	adc	r31, r29
    2e18:	e8 0f       	add	r30, r24
    2e1a:	f1 1d       	adc	r31, r1
	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
	uint8_t spads_enabled = 0;

	for (uint8_t i = 0; i < 48; i++)
	{
		if (i < first_spad_to_enable || spads_enabled == spad_count)
    2e1c:	04 17       	cp	r16, r20
    2e1e:	20 f7       	brcc	.-56     	; 0x2de8 <DriverVL53L0XInit+0x406>
		{
			// This bit is lower than the first one that should be enabled, or
			// (reference_spad_count) bits have already been enabled, so zero this bit
			ref_spad_map[i / 8] &= ~(1 << (i % 8));
    2e20:	80 2f       	mov	r24, r16
    2e22:	87 70       	andi	r24, 0x07	; 7
    2e24:	d9 01       	movw	r26, r18
    2e26:	02 c0       	rjmp	.+4      	; 0x2e2c <DriverVL53L0XInit+0x44a>
    2e28:	aa 0f       	add	r26, r26
    2e2a:	bb 1f       	adc	r27, r27
    2e2c:	8a 95       	dec	r24
    2e2e:	e2 f7       	brpl	.-8      	; 0x2e28 <DriverVL53L0XInit+0x446>
    2e30:	cd 01       	movw	r24, r26
    2e32:	80 95       	com	r24
    2e34:	90 81       	ld	r25, Z
    2e36:	89 23       	and	r24, r25
    2e38:	80 83       	st	Z, r24
	writeReg(GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);

	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
	uint8_t spads_enabled = 0;

	for (uint8_t i = 0; i < 48; i++)
    2e3a:	0f 5f       	subi	r16, 0xFF	; 255
    2e3c:	00 33       	cpi	r16, 0x30	; 48
    2e3e:	21 f7       	brne	.-56     	; 0x2e08 <DriverVL53L0XInit+0x426>
	uint8_t res;
	uint8_t Buffer[16];
	
	if (count>15) return -2;
	
	Buffer[0]=reg;
    2e40:	80 eb       	ldi	r24, 0xB0	; 176
    2e42:	89 83       	std	Y+1, r24	; 0x01
	memcpy(&Buffer[1],src,count);
    2e44:	86 e0       	ldi	r24, 0x06	; 6
    2e46:	fe 01       	movw	r30, r28
    2e48:	77 96       	adiw	r30, 0x17	; 23
    2e4a:	de 01       	movw	r26, r28
    2e4c:	12 96       	adiw	r26, 0x02	; 2
    2e4e:	01 90       	ld	r0, Z+
    2e50:	0d 92       	st	X+, r0
    2e52:	8a 95       	dec	r24
    2e54:	e1 f7       	brne	.-8      	; 0x2e4e <DriverVL53L0XInit+0x46c>
	
	res=TWIMWrite(VL53L0X_ADDR,Buffer,count+1);
    2e56:	47 e0       	ldi	r20, 0x07	; 7
    2e58:	be 01       	movw	r22, r28
    2e5a:	6f 5f       	subi	r22, 0xFF	; 255
    2e5c:	7f 4f       	sbci	r23, 0xFF	; 255
    2e5e:	89 e2       	ldi	r24, 0x29	; 41
    2e60:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2e64:	1f ef       	ldi	r17, 0xFF	; 255
    2e66:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2e68:	ff 24       	eor	r15, r15
    2e6a:	f3 94       	inc	r15
    2e6c:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2e6e:	42 e0       	ldi	r20, 0x02	; 2
    2e70:	be 01       	movw	r22, r28
    2e72:	6f 5f       	subi	r22, 0xFF	; 255
    2e74:	7f 4f       	sbci	r23, 0xFF	; 255
    2e76:	89 e2       	ldi	r24, 0x29	; 41
    2e78:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2e7c:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    2e7e:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2e80:	42 e0       	ldi	r20, 0x02	; 2
    2e82:	be 01       	movw	r22, r28
    2e84:	6f 5f       	subi	r22, 0xFF	; 255
    2e86:	7f 4f       	sbci	r23, 0xFF	; 255
    2e88:	89 e2       	ldi	r24, 0x29	; 41
    2e8a:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2e8e:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2e90:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2e92:	42 e0       	ldi	r20, 0x02	; 2
    2e94:	be 01       	movw	r22, r28
    2e96:	6f 5f       	subi	r22, 0xFF	; 255
    2e98:	7f 4f       	sbci	r23, 0xFF	; 255
    2e9a:	89 e2       	ldi	r24, 0x29	; 41
    2e9c:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2ea0:	39 e0       	ldi	r19, 0x09	; 9
    2ea2:	b3 2e       	mov	r11, r19
    2ea4:	b9 82       	std	Y+1, r11	; 0x01
	Buffer[1]=value;
    2ea6:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2ea8:	42 e0       	ldi	r20, 0x02	; 2
    2eaa:	be 01       	movw	r22, r28
    2eac:	6f 5f       	subi	r22, 0xFF	; 255
    2eae:	7f 4f       	sbci	r23, 0xFF	; 255
    2eb0:	89 e2       	ldi	r24, 0x29	; 41
    2eb2:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2eb6:	80 e1       	ldi	r24, 0x10	; 16
    2eb8:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2eba:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2ebc:	42 e0       	ldi	r20, 0x02	; 2
    2ebe:	be 01       	movw	r22, r28
    2ec0:	6f 5f       	subi	r22, 0xFF	; 255
    2ec2:	7f 4f       	sbci	r23, 0xFF	; 255
    2ec4:	89 e2       	ldi	r24, 0x29	; 41
    2ec6:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2eca:	81 e1       	ldi	r24, 0x11	; 17
    2ecc:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2ece:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2ed0:	42 e0       	ldi	r20, 0x02	; 2
    2ed2:	be 01       	movw	r22, r28
    2ed4:	6f 5f       	subi	r22, 0xFF	; 255
    2ed6:	7f 4f       	sbci	r23, 0xFF	; 255
    2ed8:	89 e2       	ldi	r24, 0x29	; 41
    2eda:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2ede:	84 e2       	ldi	r24, 0x24	; 36
    2ee0:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2ee2:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2ee4:	42 e0       	ldi	r20, 0x02	; 2
    2ee6:	be 01       	movw	r22, r28
    2ee8:	6f 5f       	subi	r22, 0xFF	; 255
    2eea:	7f 4f       	sbci	r23, 0xFF	; 255
    2eec:	89 e2       	ldi	r24, 0x29	; 41
    2eee:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2ef2:	45 e2       	ldi	r20, 0x25	; 37
    2ef4:	94 2e       	mov	r9, r20
    2ef6:	99 82       	std	Y+1, r9	; 0x01
	Buffer[1]=value;
    2ef8:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2efa:	42 e0       	ldi	r20, 0x02	; 2
    2efc:	be 01       	movw	r22, r28
    2efe:	6f 5f       	subi	r22, 0xFF	; 255
    2f00:	7f 4f       	sbci	r23, 0xFF	; 255
    2f02:	89 e2       	ldi	r24, 0x29	; 41
    2f04:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f08:	85 e7       	ldi	r24, 0x75	; 117
    2f0a:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2f0c:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f0e:	42 e0       	ldi	r20, 0x02	; 2
    2f10:	be 01       	movw	r22, r28
    2f12:	6f 5f       	subi	r22, 0xFF	; 255
    2f14:	7f 4f       	sbci	r23, 0xFF	; 255
    2f16:	89 e2       	ldi	r24, 0x29	; 41
    2f18:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f1c:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2f1e:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f20:	42 e0       	ldi	r20, 0x02	; 2
    2f22:	be 01       	movw	r22, r28
    2f24:	6f 5f       	subi	r22, 0xFF	; 255
    2f26:	7f 4f       	sbci	r23, 0xFF	; 255
    2f28:	89 e2       	ldi	r24, 0x29	; 41
    2f2a:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f2e:	8e e4       	ldi	r24, 0x4E	; 78
    2f30:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2f32:	8c e2       	ldi	r24, 0x2C	; 44
    2f34:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f36:	42 e0       	ldi	r20, 0x02	; 2
    2f38:	be 01       	movw	r22, r28
    2f3a:	6f 5f       	subi	r22, 0xFF	; 255
    2f3c:	7f 4f       	sbci	r23, 0xFF	; 255
    2f3e:	89 e2       	ldi	r24, 0x29	; 41
    2f40:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f44:	58 e4       	ldi	r21, 0x48	; 72
    2f46:	a5 2e       	mov	r10, r21
    2f48:	a9 82       	std	Y+1, r10	; 0x01
	Buffer[1]=value;
    2f4a:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f4c:	42 e0       	ldi	r20, 0x02	; 2
    2f4e:	be 01       	movw	r22, r28
    2f50:	6f 5f       	subi	r22, 0xFF	; 255
    2f52:	7f 4f       	sbci	r23, 0xFF	; 255
    2f54:	89 e2       	ldi	r24, 0x29	; 41
    2f56:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f5a:	09 83       	std	Y+1, r16	; 0x01
	Buffer[1]=value;
    2f5c:	60 e2       	ldi	r22, 0x20	; 32
    2f5e:	d6 2e       	mov	r13, r22
    2f60:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f62:	42 e0       	ldi	r20, 0x02	; 2
    2f64:	be 01       	movw	r22, r28
    2f66:	6f 5f       	subi	r22, 0xFF	; 255
    2f68:	7f 4f       	sbci	r23, 0xFF	; 255
    2f6a:	89 e2       	ldi	r24, 0x29	; 41
    2f6c:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f70:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2f72:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f74:	42 e0       	ldi	r20, 0x02	; 2
    2f76:	be 01       	movw	r22, r28
    2f78:	6f 5f       	subi	r22, 0xFF	; 255
    2f7a:	7f 4f       	sbci	r23, 0xFF	; 255
    2f7c:	89 e2       	ldi	r24, 0x29	; 41
    2f7e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f82:	09 83       	std	Y+1, r16	; 0x01
	Buffer[1]=value;
    2f84:	ba 82       	std	Y+2, r11	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f86:	42 e0       	ldi	r20, 0x02	; 2
    2f88:	be 01       	movw	r22, r28
    2f8a:	6f 5f       	subi	r22, 0xFF	; 255
    2f8c:	7f 4f       	sbci	r23, 0xFF	; 255
    2f8e:	89 e2       	ldi	r24, 0x29	; 41
    2f90:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f94:	84 e5       	ldi	r24, 0x54	; 84
    2f96:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2f98:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f9a:	42 e0       	ldi	r20, 0x02	; 2
    2f9c:	be 01       	movw	r22, r28
    2f9e:	6f 5f       	subi	r22, 0xFF	; 255
    2fa0:	7f 4f       	sbci	r23, 0xFF	; 255
    2fa2:	89 e2       	ldi	r24, 0x29	; 41
    2fa4:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2fa8:	71 e3       	ldi	r23, 0x31	; 49
    2faa:	57 2e       	mov	r5, r23
    2fac:	59 82       	std	Y+1, r5	; 0x01
	Buffer[1]=value;
    2fae:	b4 e0       	ldi	r27, 0x04	; 4
    2fb0:	ba 83       	std	Y+2, r27	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2fb2:	42 e0       	ldi	r20, 0x02	; 2
    2fb4:	be 01       	movw	r22, r28
    2fb6:	6f 5f       	subi	r22, 0xFF	; 255
    2fb8:	7f 4f       	sbci	r23, 0xFF	; 255
    2fba:	89 e2       	ldi	r24, 0x29	; 41
    2fbc:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2fc0:	e2 e3       	ldi	r30, 0x32	; 50
    2fc2:	8e 2e       	mov	r8, r30
    2fc4:	89 82       	std	Y+1, r8	; 0x01
	Buffer[1]=value;
    2fc6:	f3 e0       	ldi	r31, 0x03	; 3
    2fc8:	4f 2e       	mov	r4, r31
    2fca:	4a 82       	std	Y+2, r4	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2fcc:	42 e0       	ldi	r20, 0x02	; 2
    2fce:	be 01       	movw	r22, r28
    2fd0:	6f 5f       	subi	r22, 0xFF	; 255
    2fd2:	7f 4f       	sbci	r23, 0xFF	; 255
    2fd4:	89 e2       	ldi	r24, 0x29	; 41
    2fd6:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2fda:	a0 e4       	ldi	r26, 0x40	; 64
    2fdc:	ea 2e       	mov	r14, r26
    2fde:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2fe0:	83 e8       	ldi	r24, 0x83	; 131
    2fe2:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2fe4:	42 e0       	ldi	r20, 0x02	; 2
    2fe6:	be 01       	movw	r22, r28
    2fe8:	6f 5f       	subi	r22, 0xFF	; 255
    2fea:	7f 4f       	sbci	r23, 0xFF	; 255
    2fec:	89 e2       	ldi	r24, 0x29	; 41
    2fee:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2ff2:	b6 e4       	ldi	r27, 0x46	; 70
    2ff4:	6b 2e       	mov	r6, r27
    2ff6:	69 82       	std	Y+1, r6	; 0x01
	Buffer[1]=value;
    2ff8:	9a 82       	std	Y+2, r9	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2ffa:	42 e0       	ldi	r20, 0x02	; 2
    2ffc:	be 01       	movw	r22, r28
    2ffe:	6f 5f       	subi	r22, 0xFF	; 255
    3000:	7f 4f       	sbci	r23, 0xFF	; 255
    3002:	89 e2       	ldi	r24, 0x29	; 41
    3004:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3008:	80 e6       	ldi	r24, 0x60	; 96
    300a:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    300c:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    300e:	42 e0       	ldi	r20, 0x02	; 2
    3010:	be 01       	movw	r22, r28
    3012:	6f 5f       	subi	r22, 0xFF	; 255
    3014:	7f 4f       	sbci	r23, 0xFF	; 255
    3016:	89 e2       	ldi	r24, 0x29	; 41
    3018:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    301c:	87 e2       	ldi	r24, 0x27	; 39
    301e:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3020:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3022:	42 e0       	ldi	r20, 0x02	; 2
    3024:	be 01       	movw	r22, r28
    3026:	6f 5f       	subi	r22, 0xFF	; 255
    3028:	7f 4f       	sbci	r23, 0xFF	; 255
    302a:	89 e2       	ldi	r24, 0x29	; 41
    302c:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3030:	80 e5       	ldi	r24, 0x50	; 80
    3032:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3034:	86 e0       	ldi	r24, 0x06	; 6
    3036:	28 2e       	mov	r2, r24
    3038:	2a 82       	std	Y+2, r2	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    303a:	42 e0       	ldi	r20, 0x02	; 2
    303c:	be 01       	movw	r22, r28
    303e:	6f 5f       	subi	r22, 0xFF	; 255
    3040:	7f 4f       	sbci	r23, 0xFF	; 255
    3042:	89 e2       	ldi	r24, 0x29	; 41
    3044:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3048:	81 e5       	ldi	r24, 0x51	; 81
    304a:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    304c:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    304e:	42 e0       	ldi	r20, 0x02	; 2
    3050:	be 01       	movw	r22, r28
    3052:	6f 5f       	subi	r22, 0xFF	; 255
    3054:	7f 4f       	sbci	r23, 0xFF	; 255
    3056:	89 e2       	ldi	r24, 0x29	; 41
    3058:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    305c:	82 e5       	ldi	r24, 0x52	; 82
    305e:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3060:	86 e9       	ldi	r24, 0x96	; 150
    3062:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3064:	42 e0       	ldi	r20, 0x02	; 2
    3066:	be 01       	movw	r22, r28
    3068:	6f 5f       	subi	r22, 0xFF	; 255
    306a:	7f 4f       	sbci	r23, 0xFF	; 255
    306c:	89 e2       	ldi	r24, 0x29	; 41
    306e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3072:	86 e5       	ldi	r24, 0x56	; 86
    3074:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3076:	98 e0       	ldi	r25, 0x08	; 8
    3078:	99 2e       	mov	r9, r25
    307a:	9a 82       	std	Y+2, r9	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    307c:	42 e0       	ldi	r20, 0x02	; 2
    307e:	be 01       	movw	r22, r28
    3080:	6f 5f       	subi	r22, 0xFF	; 255
    3082:	7f 4f       	sbci	r23, 0xFF	; 255
    3084:	89 e2       	ldi	r24, 0x29	; 41
    3086:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    308a:	87 e5       	ldi	r24, 0x57	; 87
    308c:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    308e:	0a 83       	std	Y+2, r16	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3090:	42 e0       	ldi	r20, 0x02	; 2
    3092:	be 01       	movw	r22, r28
    3094:	6f 5f       	subi	r22, 0xFF	; 255
    3096:	7f 4f       	sbci	r23, 0xFF	; 255
    3098:	89 e2       	ldi	r24, 0x29	; 41
    309a:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    309e:	81 e6       	ldi	r24, 0x61	; 97
    30a0:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    30a2:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    30a4:	42 e0       	ldi	r20, 0x02	; 2
    30a6:	be 01       	movw	r22, r28
    30a8:	6f 5f       	subi	r22, 0xFF	; 255
    30aa:	7f 4f       	sbci	r23, 0xFF	; 255
    30ac:	89 e2       	ldi	r24, 0x29	; 41
    30ae:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    30b2:	82 e6       	ldi	r24, 0x62	; 98
    30b4:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    30b6:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    30b8:	42 e0       	ldi	r20, 0x02	; 2
    30ba:	be 01       	movw	r22, r28
    30bc:	6f 5f       	subi	r22, 0xFF	; 255
    30be:	7f 4f       	sbci	r23, 0xFF	; 255
    30c0:	89 e2       	ldi	r24, 0x29	; 41
    30c2:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    30c6:	84 e6       	ldi	r24, 0x64	; 100
    30c8:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    30ca:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    30cc:	42 e0       	ldi	r20, 0x02	; 2
    30ce:	be 01       	movw	r22, r28
    30d0:	6f 5f       	subi	r22, 0xFF	; 255
    30d2:	7f 4f       	sbci	r23, 0xFF	; 255
    30d4:	89 e2       	ldi	r24, 0x29	; 41
    30d6:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    30da:	85 e6       	ldi	r24, 0x65	; 101
    30dc:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    30de:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    30e0:	42 e0       	ldi	r20, 0x02	; 2
    30e2:	be 01       	movw	r22, r28
    30e4:	6f 5f       	subi	r22, 0xFF	; 255
    30e6:	7f 4f       	sbci	r23, 0xFF	; 255
    30e8:	89 e2       	ldi	r24, 0x29	; 41
    30ea:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    30ee:	86 e6       	ldi	r24, 0x66	; 102
    30f0:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    30f2:	80 ea       	ldi	r24, 0xA0	; 160
    30f4:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    30f6:	42 e0       	ldi	r20, 0x02	; 2
    30f8:	be 01       	movw	r22, r28
    30fa:	6f 5f       	subi	r22, 0xFF	; 255
    30fc:	7f 4f       	sbci	r23, 0xFF	; 255
    30fe:	89 e2       	ldi	r24, 0x29	; 41
    3100:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3104:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    3106:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3108:	42 e0       	ldi	r20, 0x02	; 2
    310a:	be 01       	movw	r22, r28
    310c:	6f 5f       	subi	r22, 0xFF	; 255
    310e:	7f 4f       	sbci	r23, 0xFF	; 255
    3110:	89 e2       	ldi	r24, 0x29	; 41
    3112:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3116:	82 e2       	ldi	r24, 0x22	; 34
    3118:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    311a:	8a 82       	std	Y+2, r8	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    311c:	42 e0       	ldi	r20, 0x02	; 2
    311e:	be 01       	movw	r22, r28
    3120:	6f 5f       	subi	r22, 0xFF	; 255
    3122:	7f 4f       	sbci	r23, 0xFF	; 255
    3124:	89 e2       	ldi	r24, 0x29	; 41
    3126:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    312a:	27 e4       	ldi	r18, 0x47	; 71
    312c:	82 2e       	mov	r8, r18
    312e:	89 82       	std	Y+1, r8	; 0x01
	Buffer[1]=value;
    3130:	84 e1       	ldi	r24, 0x14	; 20
    3132:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3134:	42 e0       	ldi	r20, 0x02	; 2
    3136:	be 01       	movw	r22, r28
    3138:	6f 5f       	subi	r22, 0xFF	; 255
    313a:	7f 4f       	sbci	r23, 0xFF	; 255
    313c:	89 e2       	ldi	r24, 0x29	; 41
    313e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3142:	89 e4       	ldi	r24, 0x49	; 73
    3144:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3146:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3148:	42 e0       	ldi	r20, 0x02	; 2
    314a:	be 01       	movw	r22, r28
    314c:	6f 5f       	subi	r22, 0xFF	; 255
    314e:	7f 4f       	sbci	r23, 0xFF	; 255
    3150:	89 e2       	ldi	r24, 0x29	; 41
    3152:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3156:	8a e4       	ldi	r24, 0x4A	; 74
    3158:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    315a:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    315c:	42 e0       	ldi	r20, 0x02	; 2
    315e:	be 01       	movw	r22, r28
    3160:	6f 5f       	subi	r22, 0xFF	; 255
    3162:	7f 4f       	sbci	r23, 0xFF	; 255
    3164:	89 e2       	ldi	r24, 0x29	; 41
    3166:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    316a:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    316c:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    316e:	42 e0       	ldi	r20, 0x02	; 2
    3170:	be 01       	movw	r22, r28
    3172:	6f 5f       	subi	r22, 0xFF	; 255
    3174:	7f 4f       	sbci	r23, 0xFF	; 255
    3176:	89 e2       	ldi	r24, 0x29	; 41
    3178:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    317c:	8a e7       	ldi	r24, 0x7A	; 122
    317e:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3180:	2a e0       	ldi	r18, 0x0A	; 10
    3182:	2a 83       	std	Y+2, r18	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3184:	42 e0       	ldi	r20, 0x02	; 2
    3186:	be 01       	movw	r22, r28
    3188:	6f 5f       	subi	r22, 0xFF	; 255
    318a:	7f 4f       	sbci	r23, 0xFF	; 255
    318c:	89 e2       	ldi	r24, 0x29	; 41
    318e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3192:	8b e7       	ldi	r24, 0x7B	; 123
    3194:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3196:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3198:	42 e0       	ldi	r20, 0x02	; 2
    319a:	be 01       	movw	r22, r28
    319c:	6f 5f       	subi	r22, 0xFF	; 255
    319e:	7f 4f       	sbci	r23, 0xFF	; 255
    31a0:	89 e2       	ldi	r24, 0x29	; 41
    31a2:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    31a6:	88 e7       	ldi	r24, 0x78	; 120
    31a8:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    31aa:	81 e2       	ldi	r24, 0x21	; 33
    31ac:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    31ae:	42 e0       	ldi	r20, 0x02	; 2
    31b0:	be 01       	movw	r22, r28
    31b2:	6f 5f       	subi	r22, 0xFF	; 255
    31b4:	7f 4f       	sbci	r23, 0xFF	; 255
    31b6:	89 e2       	ldi	r24, 0x29	; 41
    31b8:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    31bc:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    31be:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    31c0:	42 e0       	ldi	r20, 0x02	; 2
    31c2:	be 01       	movw	r22, r28
    31c4:	6f 5f       	subi	r22, 0xFF	; 255
    31c6:	7f 4f       	sbci	r23, 0xFF	; 255
    31c8:	89 e2       	ldi	r24, 0x29	; 41
    31ca:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    31ce:	83 e2       	ldi	r24, 0x23	; 35
    31d0:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    31d2:	34 e3       	ldi	r19, 0x34	; 52
    31d4:	33 2e       	mov	r3, r19
    31d6:	3a 82       	std	Y+2, r3	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    31d8:	42 e0       	ldi	r20, 0x02	; 2
    31da:	be 01       	movw	r22, r28
    31dc:	6f 5f       	subi	r22, 0xFF	; 255
    31de:	7f 4f       	sbci	r23, 0xFF	; 255
    31e0:	89 e2       	ldi	r24, 0x29	; 41
    31e2:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    31e6:	82 e4       	ldi	r24, 0x42	; 66
    31e8:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    31ea:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    31ec:	42 e0       	ldi	r20, 0x02	; 2
    31ee:	be 01       	movw	r22, r28
    31f0:	6f 5f       	subi	r22, 0xFF	; 255
    31f2:	7f 4f       	sbci	r23, 0xFF	; 255
    31f4:	89 e2       	ldi	r24, 0x29	; 41
    31f6:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    31fa:	44 e4       	ldi	r20, 0x44	; 68
    31fc:	c4 2e       	mov	r12, r20
    31fe:	c9 82       	std	Y+1, r12	; 0x01
	Buffer[1]=value;
    3200:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3202:	42 e0       	ldi	r20, 0x02	; 2
    3204:	be 01       	movw	r22, r28
    3206:	6f 5f       	subi	r22, 0xFF	; 255
    3208:	7f 4f       	sbci	r23, 0xFF	; 255
    320a:	89 e2       	ldi	r24, 0x29	; 41
    320c:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3210:	55 e4       	ldi	r21, 0x45	; 69
    3212:	75 2e       	mov	r7, r21
    3214:	79 82       	std	Y+1, r7	; 0x01
	Buffer[1]=value;
    3216:	86 e2       	ldi	r24, 0x26	; 38
    3218:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    321a:	42 e0       	ldi	r20, 0x02	; 2
    321c:	be 01       	movw	r22, r28
    321e:	6f 5f       	subi	r22, 0xFF	; 255
    3220:	7f 4f       	sbci	r23, 0xFF	; 255
    3222:	89 e2       	ldi	r24, 0x29	; 41
    3224:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3228:	69 82       	std	Y+1, r6	; 0x01
	Buffer[1]=value;
    322a:	65 e0       	ldi	r22, 0x05	; 5
    322c:	66 2e       	mov	r6, r22
    322e:	6a 82       	std	Y+2, r6	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3230:	42 e0       	ldi	r20, 0x02	; 2
    3232:	be 01       	movw	r22, r28
    3234:	6f 5f       	subi	r22, 0xFF	; 255
    3236:	7f 4f       	sbci	r23, 0xFF	; 255
    3238:	89 e2       	ldi	r24, 0x29	; 41
    323a:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    323e:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    3240:	ea 82       	std	Y+2, r14	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3242:	42 e0       	ldi	r20, 0x02	; 2
    3244:	be 01       	movw	r22, r28
    3246:	6f 5f       	subi	r22, 0xFF	; 255
    3248:	7f 4f       	sbci	r23, 0xFF	; 255
    324a:	89 e2       	ldi	r24, 0x29	; 41
    324c:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3250:	8e e0       	ldi	r24, 0x0E	; 14
    3252:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3254:	2a 82       	std	Y+2, r2	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3256:	42 e0       	ldi	r20, 0x02	; 2
    3258:	be 01       	movw	r22, r28
    325a:	6f 5f       	subi	r22, 0xFF	; 255
    325c:	7f 4f       	sbci	r23, 0xFF	; 255
    325e:	89 e2       	ldi	r24, 0x29	; 41
    3260:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3264:	d9 82       	std	Y+1, r13	; 0x01
	Buffer[1]=value;
    3266:	8a e1       	ldi	r24, 0x1A	; 26
    3268:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    326a:	42 e0       	ldi	r20, 0x02	; 2
    326c:	be 01       	movw	r22, r28
    326e:	6f 5f       	subi	r22, 0xFF	; 255
    3270:	7f 4f       	sbci	r23, 0xFF	; 255
    3272:	89 e2       	ldi	r24, 0x29	; 41
    3274:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3278:	83 e4       	ldi	r24, 0x43	; 67
    327a:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    327c:	ea 82       	std	Y+2, r14	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    327e:	42 e0       	ldi	r20, 0x02	; 2
    3280:	be 01       	movw	r22, r28
    3282:	6f 5f       	subi	r22, 0xFF	; 255
    3284:	7f 4f       	sbci	r23, 0xFF	; 255
    3286:	89 e2       	ldi	r24, 0x29	; 41
    3288:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    328c:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    328e:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3290:	42 e0       	ldi	r20, 0x02	; 2
    3292:	be 01       	movw	r22, r28
    3294:	6f 5f       	subi	r22, 0xFF	; 255
    3296:	7f 4f       	sbci	r23, 0xFF	; 255
    3298:	89 e2       	ldi	r24, 0x29	; 41
    329a:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    329e:	39 82       	std	Y+1, r3	; 0x01
	Buffer[1]=value;
    32a0:	4a 82       	std	Y+2, r4	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    32a2:	42 e0       	ldi	r20, 0x02	; 2
    32a4:	be 01       	movw	r22, r28
    32a6:	6f 5f       	subi	r22, 0xFF	; 255
    32a8:	7f 4f       	sbci	r23, 0xFF	; 255
    32aa:	89 e2       	ldi	r24, 0x29	; 41
    32ac:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    32b0:	85 e3       	ldi	r24, 0x35	; 53
    32b2:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    32b4:	ca 82       	std	Y+2, r12	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    32b6:	42 e0       	ldi	r20, 0x02	; 2
    32b8:	be 01       	movw	r22, r28
    32ba:	6f 5f       	subi	r22, 0xFF	; 255
    32bc:	7f 4f       	sbci	r23, 0xFF	; 255
    32be:	89 e2       	ldi	r24, 0x29	; 41
    32c0:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    32c4:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    32c6:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    32c8:	42 e0       	ldi	r20, 0x02	; 2
    32ca:	be 01       	movw	r22, r28
    32cc:	6f 5f       	subi	r22, 0xFF	; 255
    32ce:	7f 4f       	sbci	r23, 0xFF	; 255
    32d0:	89 e2       	ldi	r24, 0x29	; 41
    32d2:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    32d6:	59 82       	std	Y+1, r5	; 0x01
	Buffer[1]=value;
    32d8:	84 e0       	ldi	r24, 0x04	; 4
    32da:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    32dc:	42 e0       	ldi	r20, 0x02	; 2
    32de:	be 01       	movw	r22, r28
    32e0:	6f 5f       	subi	r22, 0xFF	; 255
    32e2:	7f 4f       	sbci	r23, 0xFF	; 255
    32e4:	89 e2       	ldi	r24, 0x29	; 41
    32e6:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    32ea:	8b e4       	ldi	r24, 0x4B	; 75
    32ec:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    32ee:	ba 82       	std	Y+2, r11	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    32f0:	42 e0       	ldi	r20, 0x02	; 2
    32f2:	be 01       	movw	r22, r28
    32f4:	6f 5f       	subi	r22, 0xFF	; 255
    32f6:	7f 4f       	sbci	r23, 0xFF	; 255
    32f8:	89 e2       	ldi	r24, 0x29	; 41
    32fa:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    32fe:	8c e4       	ldi	r24, 0x4C	; 76
    3300:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3302:	6a 82       	std	Y+2, r6	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3304:	42 e0       	ldi	r20, 0x02	; 2
    3306:	be 01       	movw	r22, r28
    3308:	6f 5f       	subi	r22, 0xFF	; 255
    330a:	7f 4f       	sbci	r23, 0xFF	; 255
    330c:	89 e2       	ldi	r24, 0x29	; 41
    330e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3312:	8d e4       	ldi	r24, 0x4D	; 77
    3314:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3316:	a4 e0       	ldi	r26, 0x04	; 4
    3318:	aa 83       	std	Y+2, r26	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    331a:	42 e0       	ldi	r20, 0x02	; 2
    331c:	be 01       	movw	r22, r28
    331e:	6f 5f       	subi	r22, 0xFF	; 255
    3320:	7f 4f       	sbci	r23, 0xFF	; 255
    3322:	89 e2       	ldi	r24, 0x29	; 41
    3324:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3328:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    332a:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    332c:	42 e0       	ldi	r20, 0x02	; 2
    332e:	be 01       	movw	r22, r28
    3330:	6f 5f       	subi	r22, 0xFF	; 255
    3332:	7f 4f       	sbci	r23, 0xFF	; 255
    3334:	89 e2       	ldi	r24, 0x29	; 41
    3336:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    333a:	c9 82       	std	Y+1, r12	; 0x01
	Buffer[1]=value;
    333c:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    333e:	42 e0       	ldi	r20, 0x02	; 2
    3340:	be 01       	movw	r22, r28
    3342:	6f 5f       	subi	r22, 0xFF	; 255
    3344:	7f 4f       	sbci	r23, 0xFF	; 255
    3346:	89 e2       	ldi	r24, 0x29	; 41
    3348:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    334c:	79 82       	std	Y+1, r7	; 0x01
	Buffer[1]=value;
    334e:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3350:	42 e0       	ldi	r20, 0x02	; 2
    3352:	be 01       	movw	r22, r28
    3354:	6f 5f       	subi	r22, 0xFF	; 255
    3356:	7f 4f       	sbci	r23, 0xFF	; 255
    3358:	89 e2       	ldi	r24, 0x29	; 41
    335a:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    335e:	89 82       	std	Y+1, r8	; 0x01
	Buffer[1]=value;
    3360:	9a 82       	std	Y+2, r9	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3362:	42 e0       	ldi	r20, 0x02	; 2
    3364:	be 01       	movw	r22, r28
    3366:	6f 5f       	subi	r22, 0xFF	; 255
    3368:	7f 4f       	sbci	r23, 0xFF	; 255
    336a:	89 e2       	ldi	r24, 0x29	; 41
    336c:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3370:	a9 82       	std	Y+1, r10	; 0x01
	Buffer[1]=value;
    3372:	88 e2       	ldi	r24, 0x28	; 40
    3374:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3376:	42 e0       	ldi	r20, 0x02	; 2
    3378:	be 01       	movw	r22, r28
    337a:	6f 5f       	subi	r22, 0xFF	; 255
    337c:	7f 4f       	sbci	r23, 0xFF	; 255
    337e:	89 e2       	ldi	r24, 0x29	; 41
    3380:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3384:	87 e6       	ldi	r24, 0x67	; 103
    3386:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3388:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    338a:	42 e0       	ldi	r20, 0x02	; 2
    338c:	be 01       	movw	r22, r28
    338e:	6f 5f       	subi	r22, 0xFF	; 255
    3390:	7f 4f       	sbci	r23, 0xFF	; 255
    3392:	89 e2       	ldi	r24, 0x29	; 41
    3394:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3398:	80 e7       	ldi	r24, 0x70	; 112
    339a:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    339c:	b4 e0       	ldi	r27, 0x04	; 4
    339e:	ba 83       	std	Y+2, r27	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    33a0:	42 e0       	ldi	r20, 0x02	; 2
    33a2:	be 01       	movw	r22, r28
    33a4:	6f 5f       	subi	r22, 0xFF	; 255
    33a6:	7f 4f       	sbci	r23, 0xFF	; 255
    33a8:	89 e2       	ldi	r24, 0x29	; 41
    33aa:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    33ae:	81 e7       	ldi	r24, 0x71	; 113
    33b0:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    33b2:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    33b4:	42 e0       	ldi	r20, 0x02	; 2
    33b6:	be 01       	movw	r22, r28
    33b8:	6f 5f       	subi	r22, 0xFF	; 255
    33ba:	7f 4f       	sbci	r23, 0xFF	; 255
    33bc:	89 e2       	ldi	r24, 0x29	; 41
    33be:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    33c2:	82 e7       	ldi	r24, 0x72	; 114
    33c4:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    33c6:	8e ef       	ldi	r24, 0xFE	; 254
    33c8:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    33ca:	42 e0       	ldi	r20, 0x02	; 2
    33cc:	be 01       	movw	r22, r28
    33ce:	6f 5f       	subi	r22, 0xFF	; 255
    33d0:	7f 4f       	sbci	r23, 0xFF	; 255
    33d2:	89 e2       	ldi	r24, 0x29	; 41
    33d4:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    33d8:	86 e7       	ldi	r24, 0x76	; 118
    33da:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    33dc:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    33de:	42 e0       	ldi	r20, 0x02	; 2
    33e0:	be 01       	movw	r22, r28
    33e2:	6f 5f       	subi	r22, 0xFF	; 255
    33e4:	7f 4f       	sbci	r23, 0xFF	; 255
    33e6:	89 e2       	ldi	r24, 0x29	; 41
    33e8:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    33ec:	87 e7       	ldi	r24, 0x77	; 119
    33ee:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    33f0:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    33f2:	42 e0       	ldi	r20, 0x02	; 2
    33f4:	be 01       	movw	r22, r28
    33f6:	6f 5f       	subi	r22, 0xFF	; 255
    33f8:	7f 4f       	sbci	r23, 0xFF	; 255
    33fa:	89 e2       	ldi	r24, 0x29	; 41
    33fc:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3400:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    3402:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3404:	42 e0       	ldi	r20, 0x02	; 2
    3406:	be 01       	movw	r22, r28
    3408:	6f 5f       	subi	r22, 0xFF	; 255
    340a:	7f 4f       	sbci	r23, 0xFF	; 255
    340c:	89 e2       	ldi	r24, 0x29	; 41
    340e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3412:	8d e0       	ldi	r24, 0x0D	; 13
    3414:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3416:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3418:	42 e0       	ldi	r20, 0x02	; 2
    341a:	be 01       	movw	r22, r28
    341c:	6f 5f       	subi	r22, 0xFF	; 255
    341e:	7f 4f       	sbci	r23, 0xFF	; 255
    3420:	89 e2       	ldi	r24, 0x29	; 41
    3422:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3426:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    3428:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    342a:	42 e0       	ldi	r20, 0x02	; 2
    342c:	be 01       	movw	r22, r28
    342e:	6f 5f       	subi	r22, 0xFF	; 255
    3430:	7f 4f       	sbci	r23, 0xFF	; 255
    3432:	89 e2       	ldi	r24, 0x29	; 41
    3434:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3438:	70 e8       	ldi	r23, 0x80	; 128
    343a:	e7 2e       	mov	r14, r23
    343c:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    343e:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3440:	42 e0       	ldi	r20, 0x02	; 2
    3442:	be 01       	movw	r22, r28
    3444:	6f 5f       	subi	r22, 0xFF	; 255
    3446:	7f 4f       	sbci	r23, 0xFF	; 255
    3448:	89 e2       	ldi	r24, 0x29	; 41
    344a:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    344e:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    3450:	88 ef       	ldi	r24, 0xF8	; 248
    3452:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3454:	42 e0       	ldi	r20, 0x02	; 2
    3456:	be 01       	movw	r22, r28
    3458:	6f 5f       	subi	r22, 0xFF	; 255
    345a:	7f 4f       	sbci	r23, 0xFF	; 255
    345c:	89 e2       	ldi	r24, 0x29	; 41
    345e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3462:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    3464:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3466:	42 e0       	ldi	r20, 0x02	; 2
    3468:	be 01       	movw	r22, r28
    346a:	6f 5f       	subi	r22, 0xFF	; 255
    346c:	7f 4f       	sbci	r23, 0xFF	; 255
    346e:	89 e2       	ldi	r24, 0x29	; 41
    3470:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3474:	8e e8       	ldi	r24, 0x8E	; 142
    3476:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3478:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    347a:	42 e0       	ldi	r20, 0x02	; 2
    347c:	be 01       	movw	r22, r28
    347e:	6f 5f       	subi	r22, 0xFF	; 255
    3480:	7f 4f       	sbci	r23, 0xFF	; 255
    3482:	89 e2       	ldi	r24, 0x29	; 41
    3484:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3488:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    348a:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    348c:	42 e0       	ldi	r20, 0x02	; 2
    348e:	be 01       	movw	r22, r28
    3490:	6f 5f       	subi	r22, 0xFF	; 255
    3492:	7f 4f       	sbci	r23, 0xFF	; 255
    3494:	89 e2       	ldi	r24, 0x29	; 41
    3496:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    349a:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    349c:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    349e:	42 e0       	ldi	r20, 0x02	; 2
    34a0:	be 01       	movw	r22, r28
    34a2:	6f 5f       	subi	r22, 0xFF	; 255
    34a4:	7f 4f       	sbci	r23, 0xFF	; 255
    34a6:	89 e2       	ldi	r24, 0x29	; 41
    34a8:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    34ac:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    34ae:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    34b0:	42 e0       	ldi	r20, 0x02	; 2
    34b2:	be 01       	movw	r22, r28
    34b4:	6f 5f       	subi	r22, 0xFF	; 255
    34b6:	7f 4f       	sbci	r23, 0xFF	; 255
    34b8:	89 e2       	ldi	r24, 0x29	; 41
    34ba:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    34be:	2a e0       	ldi	r18, 0x0A	; 10
    34c0:	29 83       	std	Y+1, r18	; 0x01
	Buffer[1]=value;
    34c2:	84 e0       	ldi	r24, 0x04	; 4
    34c4:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    34c6:	42 e0       	ldi	r20, 0x02	; 2
    34c8:	be 01       	movw	r22, r28
    34ca:	6f 5f       	subi	r22, 0xFF	; 255
    34cc:	7f 4f       	sbci	r23, 0xFF	; 255
    34ce:	89 e2       	ldi	r24, 0x29	; 41
    34d0:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    34d4:	14 e8       	ldi	r17, 0x84	; 132
    34d6:	19 83       	std	Y+1, r17	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    34d8:	01 e0       	ldi	r16, 0x01	; 1
    34da:	9e 01       	movw	r18, r28
    34dc:	2f 5f       	subi	r18, 0xFF	; 255
    34de:	3f 4f       	sbci	r19, 0xFF	; 255
    34e0:	41 e0       	ldi	r20, 0x01	; 1
    34e2:	b9 01       	movw	r22, r18
    34e4:	89 e2       	ldi	r24, 0x29	; 41
    34e6:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    34ea:	89 81       	ldd	r24, Y+1	; 0x01
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    34ec:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    34ee:	8f 7e       	andi	r24, 0xEF	; 239
    34f0:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    34f2:	42 e0       	ldi	r20, 0x02	; 2
    34f4:	be 01       	movw	r22, r28
    34f6:	6f 5f       	subi	r22, 0xFF	; 255
    34f8:	7f 4f       	sbci	r23, 0xFF	; 255
    34fa:	89 e2       	ldi	r24, 0x29	; 41
    34fc:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3500:	8b e0       	ldi	r24, 0x0B	; 11
    3502:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3504:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3506:	42 e0       	ldi	r20, 0x02	; 2
    3508:	be 01       	movw	r22, r28
    350a:	6f 5f       	subi	r22, 0xFF	; 255
    350c:	7f 4f       	sbci	r23, 0xFF	; 255
    350e:	89 e2       	ldi	r24, 0x29	; 41
    3510:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
	uint16_t const PreRangeOverhead   = 660;
	uint16_t const FinalRangeOverhead = 550;

	// "Start and end overhead times always present"
	uint32_t budget_us = StartOverhead + EndOverhead;
	getSequenceStepEnables (&enables);
    3514:	ce 01       	movw	r24, r28
    3516:	4d 96       	adiw	r24, 0x1d	; 29
    3518:	0e 94 3e 12 	call	0x247c	; 0x247c <getSequenceStepEnables>
	getSequenceStepTimeouts(&enables, &timeouts);
    351c:	be 01       	movw	r22, r28
    351e:	6f 5f       	subi	r22, 0xFF	; 255
    3520:	7f 4f       	sbci	r23, 0xFF	; 255
    3522:	ce 01       	movw	r24, r28
    3524:	80 96       	adiw	r24, 0x20	; 32
    3526:	0e 94 f3 12 	call	0x25e6	; 0x25e6 <getSequenceStepTimeouts.isra.1>

	if (enables.tcc)
    352a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    352c:	88 23       	and	r24, r24
    352e:	09 f4       	brne	.+2      	; 0x3532 <DriverVL53L0XInit+0xb50>
    3530:	86 c0       	rjmp	.+268    	; 0x363e <DriverVL53L0XInit+0xc5c>
	{
		budget_us += (timeouts.msrc_dss_tcc_us + TccOverhead);
    3532:	8b 85       	ldd	r24, Y+11	; 0x0b
    3534:	9c 85       	ldd	r25, Y+12	; 0x0c
    3536:	ad 85       	ldd	r26, Y+13	; 0x0d
    3538:	be 85       	ldd	r27, Y+14	; 0x0e
    353a:	8c 57       	subi	r24, 0x7C	; 124
    353c:	92 4f       	sbci	r25, 0xF2	; 242
    353e:	af 4f       	sbci	r26, 0xFF	; 255
    3540:	bf 4f       	sbci	r27, 0xFF	; 255
	}

	if (enables.dss)
    3542:	2f 8d       	ldd	r18, Y+31	; 0x1f
    3544:	22 23       	and	r18, r18
    3546:	09 f4       	brne	.+2      	; 0x354a <DriverVL53L0XInit+0xb68>
    3548:	69 c0       	rjmp	.+210    	; 0x361c <DriverVL53L0XInit+0xc3a>
	{
		budget_us += 2 * (timeouts.msrc_dss_tcc_us + DssOverhead);
    354a:	4b 85       	ldd	r20, Y+11	; 0x0b
    354c:	5c 85       	ldd	r21, Y+12	; 0x0c
    354e:	6d 85       	ldd	r22, Y+13	; 0x0d
    3550:	7e 85       	ldd	r23, Y+14	; 0x0e
    3552:	4e 54       	subi	r20, 0x4E	; 78
    3554:	5d 4f       	sbci	r21, 0xFD	; 253
    3556:	6f 4f       	sbci	r22, 0xFF	; 255
    3558:	7f 4f       	sbci	r23, 0xFF	; 255
    355a:	44 0f       	add	r20, r20
    355c:	55 1f       	adc	r21, r21
    355e:	66 1f       	adc	r22, r22
    3560:	77 1f       	adc	r23, r23
    3562:	84 0f       	add	r24, r20
    3564:	95 1f       	adc	r25, r21
    3566:	a6 1f       	adc	r26, r22
    3568:	b7 1f       	adc	r27, r23
	else if (enables.msrc)
	{
		budget_us += (timeouts.msrc_dss_tcc_us + MsrcOverhead);
	}

	if (enables.pre_range)
    356a:	28 a1       	ldd	r18, Y+32	; 0x20
    356c:	22 23       	and	r18, r18
    356e:	61 f0       	breq	.+24     	; 0x3588 <DriverVL53L0XInit+0xba6>
	{
		budget_us += (timeouts.pre_range_us + PreRangeOverhead);
    3570:	4f 85       	ldd	r20, Y+15	; 0x0f
    3572:	58 89       	ldd	r21, Y+16	; 0x10
    3574:	69 89       	ldd	r22, Y+17	; 0x11
    3576:	7a 89       	ldd	r23, Y+18	; 0x12
    3578:	4c 56       	subi	r20, 0x6C	; 108
    357a:	5d 4f       	sbci	r21, 0xFD	; 253
    357c:	6f 4f       	sbci	r22, 0xFF	; 255
    357e:	7f 4f       	sbci	r23, 0xFF	; 255
    3580:	84 0f       	add	r24, r20
    3582:	95 1f       	adc	r25, r21
    3584:	a6 1f       	adc	r26, r22
    3586:	b7 1f       	adc	r27, r23
	}

	if (enables.final_range)
    3588:	29 a1       	ldd	r18, Y+33	; 0x21
    358a:	22 23       	and	r18, r18
    358c:	61 f0       	breq	.+24     	; 0x35a6 <DriverVL53L0XInit+0xbc4>
	{
		budget_us += (timeouts.final_range_us + FinalRangeOverhead);
    358e:	4b 89       	ldd	r20, Y+19	; 0x13
    3590:	5c 89       	ldd	r21, Y+20	; 0x14
    3592:	6d 89       	ldd	r22, Y+21	; 0x15
    3594:	7e 89       	ldd	r23, Y+22	; 0x16
    3596:	4a 5d       	subi	r20, 0xDA	; 218
    3598:	5d 4f       	sbci	r21, 0xFD	; 253
    359a:	6f 4f       	sbci	r22, 0xFF	; 255
    359c:	7f 4f       	sbci	r23, 0xFF	; 255
    359e:	84 0f       	add	r24, r20
    35a0:	95 1f       	adc	r25, r21
    35a2:	a6 1f       	adc	r26, r22
    35a4:	b7 1f       	adc	r27, r23
	}

	measurement_timing_budget_us = budget_us; // store for internal reuse
    35a6:	80 93 cb 2d 	sts	0x2DCB, r24	; 0x802dcb <measurement_timing_budget_us>
    35aa:	90 93 cc 2d 	sts	0x2DCC, r25	; 0x802dcc <measurement_timing_budget_us+0x1>
    35ae:	a0 93 cd 2d 	sts	0x2DCD, r26	; 0x802dcd <measurement_timing_budget_us+0x2>
    35b2:	b0 93 ce 2d 	sts	0x2DCE, r27	; 0x802dce <measurement_timing_budget_us+0x3>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    35b6:	81 e0       	ldi	r24, 0x01	; 1
    35b8:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    35ba:	88 ee       	ldi	r24, 0xE8	; 232
    35bc:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    35be:	42 e0       	ldi	r20, 0x02	; 2
    35c0:	be 01       	movw	r22, r28
    35c2:	6f 5f       	subi	r22, 0xFF	; 255
    35c4:	7f 4f       	sbci	r23, 0xFF	; 255
    35c6:	89 e2       	ldi	r24, 0x29	; 41
    35c8:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
	writeReg(SYSTEM_SEQUENCE_CONFIG, 0xE8);

	// -- VL53L0X_SetSequenceStepEnable() end

	// "Recalculate timing budget"
	setMeasurementTimingBudget(measurement_timing_budget_us);
    35cc:	60 91 cb 2d 	lds	r22, 0x2DCB	; 0x802dcb <measurement_timing_budget_us>
    35d0:	70 91 cc 2d 	lds	r23, 0x2DCC	; 0x802dcc <measurement_timing_budget_us+0x1>
    35d4:	80 91 cd 2d 	lds	r24, 0x2DCD	; 0x802dcd <measurement_timing_budget_us+0x2>
    35d8:	90 91 ce 2d 	lds	r25, 0x2DCE	; 0x802dce <measurement_timing_budget_us+0x3>
	uint16_t const PreRangeOverhead   = 660;
	uint16_t const FinalRangeOverhead = 550;

	uint32_t const MinTimingBudget = 20000;

	if (budget_us < MinTimingBudget) { return false; }
    35dc:	60 32       	cpi	r22, 0x20	; 32
    35de:	ae e4       	ldi	r26, 0x4E	; 78
    35e0:	7a 07       	cpc	r23, r26
    35e2:	81 05       	cpc	r24, r1
    35e4:	91 05       	cpc	r25, r1
    35e6:	08 f0       	brcs	.+2      	; 0x35ea <DriverVL53L0XInit+0xc08>
    35e8:	4a c0       	rjmp	.+148    	; 0x367e <DriverVL53L0XInit+0xc9c>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    35ea:	11 e0       	ldi	r17, 0x01	; 1
    35ec:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    35ee:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    35f0:	42 e0       	ldi	r20, 0x02	; 2
    35f2:	be 01       	movw	r22, r28
    35f4:	6f 5f       	subi	r22, 0xFF	; 255
    35f6:	7f 4f       	sbci	r23, 0xFF	; 255
    35f8:	89 e2       	ldi	r24, 0x29	; 41
    35fa:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
	// VL53L0X_PerformRefCalibration() begin (VL53L0X_perform_ref_calibration())

	// -- VL53L0X_perform_vhv_calibration() begin

	writeReg(SYSTEM_SEQUENCE_CONFIG, 0x01);
	if (!performSingleRefCalibration(0x40)) { return false; }
    35fe:	80 e4       	ldi	r24, 0x40	; 64
    3600:	0e 94 72 12 	call	0x24e4	; 0x24e4 <performSingleRefCalibration>
    3604:	81 11       	cpse	r24, r1
    3606:	20 c0       	rjmp	.+64     	; 0x3648 <DriverVL53L0XInit+0xc66>
    3608:	80 e0       	ldi	r24, 0x00	; 0
    360a:	18 ca       	rjmp	.-3024   	; 0x2a3c <DriverVL53L0XInit+0x5a>
	//Check Model ID
	res=readReg(IDENTIFICATION_MODEL_ID,&Data);
	if (!res)
	{
		#ifdef VL53L0X_DEBUG
			printf ("VL53L0X:Cannot access.\r\n");
    360c:	83 e9       	ldi	r24, 0x93	; 147
    360e:	93 e2       	ldi	r25, 0x23	; 35
    3610:	0e 94 9e 4e 	call	0x9d3c	; 0x9d3c <puts>
		#endif
		return false;
    3614:	80 e0       	ldi	r24, 0x00	; 0
    3616:	12 ca       	rjmp	.-3036   	; 0x2a3c <DriverVL53L0XInit+0x5a>
	writeReg(DYNAMIC_SPAD_REF_EN_START_OFFSET, 0x00);
	writeReg(DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);
	writeReg(0xFF, 0x00);
	writeReg(GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);

	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
    3618:	4c e0       	ldi	r20, 0x0C	; 12
    361a:	df cb       	rjmp	.-2114   	; 0x2dda <DriverVL53L0XInit+0x3f8>

	if (enables.dss)
	{
		budget_us += 2 * (timeouts.msrc_dss_tcc_us + DssOverhead);
	}
	else if (enables.msrc)
    361c:	2e 8d       	ldd	r18, Y+30	; 0x1e
    361e:	22 23       	and	r18, r18
    3620:	09 f4       	brne	.+2      	; 0x3624 <DriverVL53L0XInit+0xc42>
    3622:	a3 cf       	rjmp	.-186    	; 0x356a <DriverVL53L0XInit+0xb88>
	{
		budget_us += (timeouts.msrc_dss_tcc_us + MsrcOverhead);
    3624:	4b 85       	ldd	r20, Y+11	; 0x0b
    3626:	5c 85       	ldd	r21, Y+12	; 0x0c
    3628:	6d 85       	ldd	r22, Y+13	; 0x0d
    362a:	7e 85       	ldd	r23, Y+14	; 0x0e
    362c:	4c 56       	subi	r20, 0x6C	; 108
    362e:	5d 4f       	sbci	r21, 0xFD	; 253
    3630:	6f 4f       	sbci	r22, 0xFF	; 255
    3632:	7f 4f       	sbci	r23, 0xFF	; 255
    3634:	84 0f       	add	r24, r20
    3636:	95 1f       	adc	r25, r21
    3638:	a6 1f       	adc	r26, r22
    363a:	b7 1f       	adc	r27, r23
    363c:	96 cf       	rjmp	.-212    	; 0x356a <DriverVL53L0XInit+0xb88>
	uint16_t const DssOverhead        = 690;
	uint16_t const PreRangeOverhead   = 660;
	uint16_t const FinalRangeOverhead = 550;

	// "Start and end overhead times always present"
	uint32_t budget_us = StartOverhead + EndOverhead;
    363e:	86 e3       	ldi	r24, 0x36	; 54
    3640:	9b e0       	ldi	r25, 0x0B	; 11
    3642:	a0 e0       	ldi	r26, 0x00	; 0
    3644:	b0 e0       	ldi	r27, 0x00	; 0
    3646:	7d cf       	rjmp	.-262    	; 0x3542 <DriverVL53L0XInit+0xb60>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3648:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    364a:	82 e0       	ldi	r24, 0x02	; 2
    364c:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    364e:	42 e0       	ldi	r20, 0x02	; 2
    3650:	be 01       	movw	r22, r28
    3652:	6f 5f       	subi	r22, 0xFF	; 255
    3654:	7f 4f       	sbci	r23, 0xFF	; 255
    3656:	89 e2       	ldi	r24, 0x29	; 41
    3658:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
	// -- VL53L0X_perform_vhv_calibration() end

	// -- VL53L0X_perform_phase_calibration() begin

	writeReg(SYSTEM_SEQUENCE_CONFIG, 0x02);
	if (!performSingleRefCalibration(0x00)) { return false; }
    365c:	80 e0       	ldi	r24, 0x00	; 0
    365e:	0e 94 72 12 	call	0x24e4	; 0x24e4 <performSingleRefCalibration>
    3662:	88 23       	and	r24, r24
    3664:	89 f2       	breq	.-94     	; 0x3608 <DriverVL53L0XInit+0xc26>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3666:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    3668:	88 ee       	ldi	r24, 0xE8	; 232
    366a:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    366c:	42 e0       	ldi	r20, 0x02	; 2
    366e:	be 01       	movw	r22, r28
    3670:	6f 5f       	subi	r22, 0xFF	; 255
    3672:	7f 4f       	sbci	r23, 0xFF	; 255
    3674:	89 e2       	ldi	r24, 0x29	; 41
    3676:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
	// "restore the previous Sequence Config"
	writeReg(SYSTEM_SEQUENCE_CONFIG, 0xE8);

	// VL53L0X_PerformRefCalibration() end

	return true;
    367a:	81 e0       	ldi	r24, 0x01	; 1
    367c:	df c9       	rjmp	.-3138   	; 0x2a3c <DriverVL53L0XInit+0x5a>
    367e:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <setMeasurementTimingBudget.part.4>
    3682:	b3 cf       	rjmp	.-154    	; 0x35ea <DriverVL53L0XInit+0xc08>

00003684 <DriverVL53L0XReadContinuous>:

// Returns a range reading in millimeters when continuous mode is active
// (readRangeSingleMillimeters() also calls this function after starting a
// single-shot range measurement)
uint16_t DriverVL53L0XReadContinuous()
{
    3684:	0f 93       	push	r16
    3686:	1f 93       	push	r17
    3688:	cf 93       	push	r28
    368a:	df 93       	push	r29
    368c:	00 d0       	rcall	.+0      	; 0x368e <DriverVL53L0XReadContinuous+0xa>
    368e:	00 d0       	rcall	.+0      	; 0x3690 <DriverVL53L0XReadContinuous+0xc>
    3690:	cd b7       	in	r28, 0x3d	; 61
    3692:	de b7       	in	r29, 0x3e	; 62
	return true;
}

static void startTimeout(void)
{
	timeout_start_ticks=portGET_RUN_TIME_COUNTER_VALUE();
    3694:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3698:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    369c:	80 91 cf 2d 	lds	r24, 0x2DCF	; 0x802dcf <StatsTimer>
    36a0:	90 91 d0 2d 	lds	r25, 0x2DD0	; 0x802dd0 <StatsTimer+0x1>
    36a4:	a0 91 d1 2d 	lds	r26, 0x2DD1	; 0x802dd1 <StatsTimer+0x2>
    36a8:	b0 91 d2 2d 	lds	r27, 0x2DD2	; 0x802dd2 <StatsTimer+0x3>
    36ac:	82 0f       	add	r24, r18
    36ae:	93 1f       	adc	r25, r19
    36b0:	a1 1d       	adc	r26, r1
    36b2:	b1 1d       	adc	r27, r1
    36b4:	80 93 df 2c 	sts	0x2CDF, r24	; 0x802cdf <timeout_start_ticks>
    36b8:	90 93 e0 2c 	sts	0x2CE0, r25	; 0x802ce0 <timeout_start_ticks+0x1>
    36bc:	a0 93 e1 2c 	sts	0x2CE1, r26	; 0x802ce1 <timeout_start_ticks+0x2>
    36c0:	b0 93 e2 2c 	sts	0x2CE2, r27	; 0x802ce2 <timeout_start_ticks+0x3>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    36c4:	13 e1       	ldi	r17, 0x13	; 19
    36c6:	19 83       	std	Y+1, r17	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    36c8:	01 e0       	ldi	r16, 0x01	; 1
    36ca:	9e 01       	movw	r18, r28
    36cc:	2f 5f       	subi	r18, 0xFF	; 255
    36ce:	3f 4f       	sbci	r19, 0xFF	; 255
    36d0:	41 e0       	ldi	r20, 0x01	; 1
    36d2:	b9 01       	movw	r22, r18
    36d4:	89 e2       	ldi	r24, 0x29	; 41
    36d6:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    36da:	89 81       	ldd	r24, Y+1	; 0x01
	
	
	while (1)
	{
		readReg(RESULT_INTERRUPT_STATUS,&Data);
		if ((Data & 0x07)!=0) break;
    36dc:	87 70       	andi	r24, 0x07	; 7
    36de:	99 f3       	breq	.-26     	; 0x36c6 <DriverVL53L0XReadContinuous+0x42>
			return 65535;
		}		
	}
	// assumptions: Linearity Corrective Gain is 1000 (default);
	// fractional ranging is not enabled
	readReg16Bit(RESULT_RANGE_STATUS+10,&Data16);
    36e0:	be 01       	movw	r22, r28
    36e2:	6b 5f       	subi	r22, 0xFB	; 251
    36e4:	7f 4f       	sbci	r23, 0xFF	; 255
    36e6:	8e e1       	ldi	r24, 0x1E	; 30
    36e8:	0e 94 c7 12 	call	0x258e	; 0x258e <readReg16Bit>
	uint16_t range = Data16;
    36ec:	0d 81       	ldd	r16, Y+5	; 0x05
    36ee:	1e 81       	ldd	r17, Y+6	; 0x06
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    36f0:	8b e0       	ldi	r24, 0x0B	; 11
    36f2:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    36f4:	81 e0       	ldi	r24, 0x01	; 1
    36f6:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    36f8:	42 e0       	ldi	r20, 0x02	; 2
    36fa:	be 01       	movw	r22, r28
    36fc:	6f 5f       	subi	r22, 0xFF	; 255
    36fe:	7f 4f       	sbci	r23, 0xFF	; 255
    3700:	89 e2       	ldi	r24, 0x29	; 41
    3702:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
	uint16_t range = Data16;

	writeReg(SYSTEM_INTERRUPT_CLEAR, 0x01);

	return range;
}
    3706:	c8 01       	movw	r24, r16
    3708:	26 96       	adiw	r28, 0x06	; 6
    370a:	cd bf       	out	0x3d, r28	; 61
    370c:	de bf       	out	0x3e, r29	; 62
    370e:	df 91       	pop	r29
    3710:	cf 91       	pop	r28
    3712:	1f 91       	pop	r17
    3714:	0f 91       	pop	r16
    3716:	08 95       	ret

00003718 <DriverVL53L0XReadSingle>:

// Performs a single-shot range measurement and returns the reading in
// millimeters
// based on VL53L0X_PerformSingleRangingMeasurement()
uint16_t DriverVL53L0XReadSingle()
{
    3718:	ff 92       	push	r15
    371a:	0f 93       	push	r16
    371c:	1f 93       	push	r17
    371e:	cf 93       	push	r28
    3720:	df 93       	push	r29
    3722:	00 d0       	rcall	.+0      	; 0x3724 <DriverVL53L0XReadSingle+0xc>
    3724:	1f 92       	push	r1
    3726:	cd b7       	in	r28, 0x3d	; 61
    3728:	de b7       	in	r29, 0x3e	; 62
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    372a:	00 e8       	ldi	r16, 0x80	; 128
    372c:	09 83       	std	Y+1, r16	; 0x01
	Buffer[1]=value;
    372e:	11 e0       	ldi	r17, 0x01	; 1
    3730:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3732:	42 e0       	ldi	r20, 0x02	; 2
    3734:	be 01       	movw	r22, r28
    3736:	6f 5f       	subi	r22, 0xFF	; 255
    3738:	7f 4f       	sbci	r23, 0xFF	; 255
    373a:	89 e2       	ldi	r24, 0x29	; 41
    373c:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3740:	ff 24       	eor	r15, r15
    3742:	fa 94       	dec	r15
    3744:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    3746:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3748:	42 e0       	ldi	r20, 0x02	; 2
    374a:	be 01       	movw	r22, r28
    374c:	6f 5f       	subi	r22, 0xFF	; 255
    374e:	7f 4f       	sbci	r23, 0xFF	; 255
    3750:	89 e2       	ldi	r24, 0x29	; 41
    3752:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3756:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    3758:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    375a:	42 e0       	ldi	r20, 0x02	; 2
    375c:	be 01       	movw	r22, r28
    375e:	6f 5f       	subi	r22, 0xFF	; 255
    3760:	7f 4f       	sbci	r23, 0xFF	; 255
    3762:	89 e2       	ldi	r24, 0x29	; 41
    3764:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
	uint8_t Data;
	
	writeReg(0x80, 0x01);
	writeReg(0xFF, 0x01);
	writeReg(0x00, 0x00);
	writeReg(0x91, stop_variable);
    3768:	80 91 e3 2c 	lds	r24, 0x2CE3	; 0x802ce3 <stop_variable>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    376c:	91 e9       	ldi	r25, 0x91	; 145
    376e:	99 83       	std	Y+1, r25	; 0x01
	Buffer[1]=value;
    3770:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3772:	42 e0       	ldi	r20, 0x02	; 2
    3774:	be 01       	movw	r22, r28
    3776:	6f 5f       	subi	r22, 0xFF	; 255
    3778:	7f 4f       	sbci	r23, 0xFF	; 255
    377a:	89 e2       	ldi	r24, 0x29	; 41
    377c:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3780:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    3782:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3784:	42 e0       	ldi	r20, 0x02	; 2
    3786:	be 01       	movw	r22, r28
    3788:	6f 5f       	subi	r22, 0xFF	; 255
    378a:	7f 4f       	sbci	r23, 0xFF	; 255
    378c:	89 e2       	ldi	r24, 0x29	; 41
    378e:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3792:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    3794:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3796:	42 e0       	ldi	r20, 0x02	; 2
    3798:	be 01       	movw	r22, r28
    379a:	6f 5f       	subi	r22, 0xFF	; 255
    379c:	7f 4f       	sbci	r23, 0xFF	; 255
    379e:	89 e2       	ldi	r24, 0x29	; 41
    37a0:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    37a4:	09 83       	std	Y+1, r16	; 0x01
	Buffer[1]=value;
    37a6:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    37a8:	42 e0       	ldi	r20, 0x02	; 2
    37aa:	be 01       	movw	r22, r28
    37ac:	6f 5f       	subi	r22, 0xFF	; 255
    37ae:	7f 4f       	sbci	r23, 0xFF	; 255
    37b0:	89 e2       	ldi	r24, 0x29	; 41
    37b2:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    37b6:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    37b8:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    37ba:	42 e0       	ldi	r20, 0x02	; 2
    37bc:	be 01       	movw	r22, r28
    37be:	6f 5f       	subi	r22, 0xFF	; 255
    37c0:	7f 4f       	sbci	r23, 0xFF	; 255
    37c2:	89 e2       	ldi	r24, 0x29	; 41
    37c4:	0e 94 63 10 	call	0x20c6	; 0x20c6 <TWIMWrite>
	return true;
}

static void startTimeout(void)
{
	timeout_start_ticks=portGET_RUN_TIME_COUNTER_VALUE();
    37c8:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    37cc:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    37d0:	80 91 cf 2d 	lds	r24, 0x2DCF	; 0x802dcf <StatsTimer>
    37d4:	90 91 d0 2d 	lds	r25, 0x2DD0	; 0x802dd0 <StatsTimer+0x1>
    37d8:	a0 91 d1 2d 	lds	r26, 0x2DD1	; 0x802dd1 <StatsTimer+0x2>
    37dc:	b0 91 d2 2d 	lds	r27, 0x2DD2	; 0x802dd2 <StatsTimer+0x3>
    37e0:	82 0f       	add	r24, r18
    37e2:	93 1f       	adc	r25, r19
    37e4:	a1 1d       	adc	r26, r1
    37e6:	b1 1d       	adc	r27, r1
    37e8:	80 93 df 2c 	sts	0x2CDF, r24	; 0x802cdf <timeout_start_ticks>
    37ec:	90 93 e0 2c 	sts	0x2CE0, r25	; 0x802ce0 <timeout_start_ticks+0x1>
    37f0:	a0 93 e1 2c 	sts	0x2CE1, r26	; 0x802ce1 <timeout_start_ticks+0x2>
    37f4:	b0 93 e2 2c 	sts	0x2CE2, r27	; 0x802ce2 <timeout_start_ticks+0x3>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    37f8:	19 82       	std	Y+1, r1	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    37fa:	01 e0       	ldi	r16, 0x01	; 1
    37fc:	9e 01       	movw	r18, r28
    37fe:	2f 5f       	subi	r18, 0xFF	; 255
    3800:	3f 4f       	sbci	r19, 0xFF	; 255
    3802:	41 e0       	ldi	r20, 0x01	; 1
    3804:	b9 01       	movw	r22, r18
    3806:	89 e2       	ldi	r24, 0x29	; 41
    3808:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    380c:	89 81       	ldd	r24, Y+1	; 0x01
	startTimeout();
	
	while (1)
	{
		readReg(SYSRANGE_START,&Data);
		if (! (Data & 0x01)) break;
    380e:	80 fd       	sbrc	r24, 0
    3810:	f3 cf       	rjmp	.-26     	; 0x37f8 <DriverVL53L0XReadSingle+0xe0>
			did_timeout = true;
			return 65535;
		}
	}

	return DriverVL53L0XReadContinuous();
    3812:	0e 94 42 1b 	call	0x3684	; 0x3684 <DriverVL53L0XReadContinuous>
}
    3816:	24 96       	adiw	r28, 0x04	; 4
    3818:	cd bf       	out	0x3d, r28	; 61
    381a:	de bf       	out	0x3e, r29	; 62
    381c:	df 91       	pop	r29
    381e:	cf 91       	pop	r28
    3820:	1f 91       	pop	r17
    3822:	0f 91       	pop	r16
    3824:	ff 90       	pop	r15
    3826:	08 95       	ret

00003828 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    3828:	0f 93       	push	r16
    382a:	1f 93       	push	r17
    382c:	cf 93       	push	r28
    382e:	df 93       	push	r29
    3830:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    3832:	0e 94 4e 29 	call	0x529c	; 0x529c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    3836:	80 91 e4 2c 	lds	r24, 0x2CE4	; 0x802ce4 <xHeapHasBeenInitialised.4135>
    383a:	81 11       	cpse	r24, r1
    383c:	21 c0       	rjmp	.+66     	; 0x3880 <pvPortMalloc+0x58>
{
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    383e:	e0 91 d3 2d 	lds	r30, 0x2DD3	; 0x802dd3 <ucHeap>
    3842:	f0 91 d4 2d 	lds	r31, 0x2DD4	; 0x802dd4 <ucHeap+0x1>

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    3846:	cf 01       	movw	r24, r30
    3848:	01 96       	adiw	r24, 0x01	; 1
    384a:	80 93 e9 2c 	sts	0x2CE9, r24	; 0x802ce9 <xStart>
    384e:	90 93 ea 2c 	sts	0x2CEA, r25	; 0x802cea <xStart+0x1>
	xStart.xBlockSize = ( size_t ) 0;
    3852:	10 92 eb 2c 	sts	0x2CEB, r1	; 0x802ceb <xStart+0x2>
    3856:	10 92 ec 2c 	sts	0x2CEC, r1	; 0x802cec <xStart+0x3>

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    385a:	8f ef       	ldi	r24, 0xFF	; 255
    385c:	9f e3       	ldi	r25, 0x3F	; 63
    385e:	80 93 e7 2c 	sts	0x2CE7, r24	; 0x802ce7 <xEnd+0x2>
    3862:	90 93 e8 2c 	sts	0x2CE8, r25	; 0x802ce8 <xEnd+0x3>
	xEnd.pxNextFreeBlock = NULL;
    3866:	10 92 e5 2c 	sts	0x2CE5, r1	; 0x802ce5 <xEnd>
    386a:	10 92 e6 2c 	sts	0x2CE6, r1	; 0x802ce6 <xEnd+0x1>

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
    386e:	83 83       	std	Z+3, r24	; 0x03
    3870:	94 83       	std	Z+4, r25	; 0x04
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    3872:	85 ee       	ldi	r24, 0xE5	; 229
    3874:	9c e2       	ldi	r25, 0x2C	; 44
    3876:	81 83       	std	Z+1, r24	; 0x01
    3878:	92 83       	std	Z+2, r25	; 0x02
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
    387a:	81 e0       	ldi	r24, 0x01	; 1
    387c:	80 93 e4 2c 	sts	0x2CE4, r24	; 0x802ce4 <xHeapHasBeenInitialised.4135>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    3880:	20 97       	sbiw	r28, 0x00	; 0
    3882:	09 f4       	brne	.+2      	; 0x3886 <pvPortMalloc+0x5e>
    3884:	64 c0       	rjmp	.+200    	; 0x394e <pvPortMalloc+0x126>
		{
			xWantedSize += heapSTRUCT_SIZE;
    3886:	ae 01       	movw	r20, r28
    3888:	4c 5f       	subi	r20, 0xFC	; 252
    388a:	5f 4f       	sbci	r21, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
    388c:	23 96       	adiw	r28, 0x03	; 3
    388e:	ce 3f       	cpi	r28, 0xFE	; 254
    3890:	df 43       	sbci	r29, 0x3F	; 63
    3892:	08 f0       	brcs	.+2      	; 0x3896 <pvPortMalloc+0x6e>
    3894:	5c c0       	rjmp	.+184    	; 0x394e <pvPortMalloc+0x126>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    3896:	e0 91 e9 2c 	lds	r30, 0x2CE9	; 0x802ce9 <xStart>
    389a:	f0 91 ea 2c 	lds	r31, 0x2CEA	; 0x802cea <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    389e:	a9 ee       	ldi	r26, 0xE9	; 233
    38a0:	bc e2       	ldi	r27, 0x2C	; 44
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    38a2:	06 c0       	rjmp	.+12     	; 0x38b0 <pvPortMalloc+0x88>
    38a4:	80 81       	ld	r24, Z
    38a6:	91 81       	ldd	r25, Z+1	; 0x01
    38a8:	00 97       	sbiw	r24, 0x00	; 0
    38aa:	39 f0       	breq	.+14     	; 0x38ba <pvPortMalloc+0x92>
    38ac:	df 01       	movw	r26, r30
    38ae:	fc 01       	movw	r30, r24
    38b0:	22 81       	ldd	r18, Z+2	; 0x02
    38b2:	33 81       	ldd	r19, Z+3	; 0x03
    38b4:	24 17       	cp	r18, r20
    38b6:	35 07       	cpc	r19, r21
    38b8:	a8 f3       	brcs	.-22     	; 0x38a4 <pvPortMalloc+0x7c>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    38ba:	cc e2       	ldi	r28, 0x2C	; 44
    38bc:	e5 3e       	cpi	r30, 0xE5	; 229
    38be:	fc 07       	cpc	r31, r28
    38c0:	09 f4       	brne	.+2      	; 0x38c4 <pvPortMalloc+0x9c>
    38c2:	45 c0       	rjmp	.+138    	; 0x394e <pvPortMalloc+0x126>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    38c4:	cd 91       	ld	r28, X+
    38c6:	dc 91       	ld	r29, X
    38c8:	11 97       	sbiw	r26, 0x01	; 1
    38ca:	8e 01       	movw	r16, r28
    38cc:	0c 5f       	subi	r16, 0xFC	; 252
    38ce:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    38d0:	80 81       	ld	r24, Z
    38d2:	91 81       	ldd	r25, Z+1	; 0x01
    38d4:	8d 93       	st	X+, r24
    38d6:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    38d8:	c9 01       	movw	r24, r18
    38da:	84 1b       	sub	r24, r20
    38dc:	95 0b       	sbc	r25, r21
    38de:	89 30       	cpi	r24, 0x09	; 9
    38e0:	91 05       	cpc	r25, r1
    38e2:	00 f1       	brcs	.+64     	; 0x3924 <pvPortMalloc+0xfc>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    38e4:	bf 01       	movw	r22, r30
    38e6:	64 0f       	add	r22, r20
    38e8:	75 1f       	adc	r23, r21

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    38ea:	db 01       	movw	r26, r22
    38ec:	12 96       	adiw	r26, 0x02	; 2
    38ee:	8d 93       	st	X+, r24
    38f0:	9c 93       	st	X, r25
    38f2:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    38f4:	42 83       	std	Z+2, r20	; 0x02
    38f6:	53 83       	std	Z+3, r21	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    38f8:	12 96       	adiw	r26, 0x02	; 2
    38fa:	2d 91       	ld	r18, X+
    38fc:	3c 91       	ld	r19, X
    38fe:	13 97       	sbiw	r26, 0x03	; 3
    3900:	a9 ee       	ldi	r26, 0xE9	; 233
    3902:	bc e2       	ldi	r27, 0x2C	; 44
    3904:	01 c0       	rjmp	.+2      	; 0x3908 <pvPortMalloc+0xe0>
    3906:	df 01       	movw	r26, r30
    3908:	ed 91       	ld	r30, X+
    390a:	fc 91       	ld	r31, X
    390c:	11 97       	sbiw	r26, 0x01	; 1
    390e:	82 81       	ldd	r24, Z+2	; 0x02
    3910:	93 81       	ldd	r25, Z+3	; 0x03
    3912:	82 17       	cp	r24, r18
    3914:	93 07       	cpc	r25, r19
    3916:	b8 f3       	brcs	.-18     	; 0x3906 <pvPortMalloc+0xde>
    3918:	eb 01       	movw	r28, r22
    391a:	e8 83       	st	Y, r30
    391c:	f9 83       	std	Y+1, r31	; 0x01
    391e:	6d 93       	st	X+, r22
    3920:	7c 93       	st	X, r23

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
		{
			xWantedSize += heapSTRUCT_SIZE;
    3922:	9a 01       	movw	r18, r20

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
    3924:	80 91 14 20 	lds	r24, 0x2014	; 0x802014 <xFreeBytesRemaining>
    3928:	90 91 15 20 	lds	r25, 0x2015	; 0x802015 <xFreeBytesRemaining+0x1>
    392c:	82 1b       	sub	r24, r18
    392e:	93 0b       	sbc	r25, r19
    3930:	80 93 14 20 	sts	0x2014, r24	; 0x802014 <xFreeBytesRemaining>
    3934:	90 93 15 20 	sts	0x2015, r25	; 0x802015 <xFreeBytesRemaining+0x1>
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    3938:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
    393c:	01 15       	cp	r16, r1
    393e:	11 05       	cpc	r17, r1
    3940:	41 f0       	breq	.+16     	; 0x3952 <pvPortMalloc+0x12a>
		}
	}
	#endif

	return pvReturn;
}
    3942:	c8 01       	movw	r24, r16
    3944:	df 91       	pop	r29
    3946:	cf 91       	pop	r28
    3948:	1f 91       	pop	r17
    394a:	0f 91       	pop	r16
    394c:	08 95       	ret
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    394e:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>
	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
    3952:	0e 94 d7 2f 	call	0x5fae	; 0x5fae <vApplicationMallocFailedHook>
    3956:	00 e0       	ldi	r16, 0x00	; 0
    3958:	10 e0       	ldi	r17, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
}
    395a:	c8 01       	movw	r24, r16
    395c:	df 91       	pop	r29
    395e:	cf 91       	pop	r28
    3960:	1f 91       	pop	r17
    3962:	0f 91       	pop	r16
    3964:	08 95       	ret

00003966 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    3966:	cf 93       	push	r28
    3968:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    396a:	00 97       	sbiw	r24, 0x00	; 0
    396c:	21 f1       	breq	.+72     	; 0x39b6 <vPortFree+0x50>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    396e:	ec 01       	movw	r28, r24
    3970:	24 97       	sbiw	r28, 0x04	; 4

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    3972:	0e 94 4e 29 	call	0x529c	; 0x529c <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    3976:	4a 81       	ldd	r20, Y+2	; 0x02
    3978:	5b 81       	ldd	r21, Y+3	; 0x03
    397a:	a9 ee       	ldi	r26, 0xE9	; 233
    397c:	bc e2       	ldi	r27, 0x2C	; 44
    397e:	01 c0       	rjmp	.+2      	; 0x3982 <vPortFree+0x1c>
    3980:	df 01       	movw	r26, r30
    3982:	ed 91       	ld	r30, X+
    3984:	fc 91       	ld	r31, X
    3986:	11 97       	sbiw	r26, 0x01	; 1
    3988:	22 81       	ldd	r18, Z+2	; 0x02
    398a:	33 81       	ldd	r19, Z+3	; 0x03
    398c:	24 17       	cp	r18, r20
    398e:	35 07       	cpc	r19, r21
    3990:	b8 f3       	brcs	.-18     	; 0x3980 <vPortFree+0x1a>
    3992:	e8 83       	st	Y, r30
    3994:	f9 83       	std	Y+1, r31	; 0x01
    3996:	cd 93       	st	X+, r28
    3998:	dc 93       	st	X, r29
			xFreeBytesRemaining += pxLink->xBlockSize;
    399a:	80 91 14 20 	lds	r24, 0x2014	; 0x802014 <xFreeBytesRemaining>
    399e:	90 91 15 20 	lds	r25, 0x2015	; 0x802015 <xFreeBytesRemaining+0x1>
    39a2:	48 0f       	add	r20, r24
    39a4:	59 1f       	adc	r21, r25
    39a6:	40 93 14 20 	sts	0x2014, r20	; 0x802014 <xFreeBytesRemaining>
    39aa:	50 93 15 20 	sts	0x2015, r21	; 0x802015 <xFreeBytesRemaining+0x1>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
	}
}
    39ae:	df 91       	pop	r29
    39b0:	cf 91       	pop	r28
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
			xFreeBytesRemaining += pxLink->xBlockSize;
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
    39b2:	0c 94 4a 2a 	jmp	0x5494	; 0x5494 <xTaskResumeAll>
	}
}
    39b6:	df 91       	pop	r29
    39b8:	cf 91       	pop	r28
    39ba:	08 95       	ret

000039bc <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    39bc:	80 91 14 20 	lds	r24, 0x2014	; 0x802014 <xFreeBytesRemaining>
    39c0:	90 91 15 20 	lds	r25, 0x2015	; 0x802015 <xFreeBytesRemaining+0x1>
    39c4:	08 95       	ret

000039c6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    39c6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    39c8:	03 96       	adiw	r24, 0x03	; 3
    39ca:	81 83       	std	Z+1, r24	; 0x01
    39cc:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    39ce:	2f ef       	ldi	r18, 0xFF	; 255
    39d0:	3f ef       	ldi	r19, 0xFF	; 255
    39d2:	23 83       	std	Z+3, r18	; 0x03
    39d4:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    39d6:	85 83       	std	Z+5, r24	; 0x05
    39d8:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    39da:	87 83       	std	Z+7, r24	; 0x07
    39dc:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    39de:	10 82       	st	Z, r1
    39e0:	08 95       	ret

000039e2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    39e2:	fc 01       	movw	r30, r24
    39e4:	10 86       	std	Z+8, r1	; 0x08
    39e6:	11 86       	std	Z+9, r1	; 0x09
    39e8:	08 95       	ret

000039ea <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    39ea:	cf 93       	push	r28
    39ec:	df 93       	push	r29
    39ee:	9c 01       	movw	r18, r24
    39f0:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    39f2:	dc 01       	movw	r26, r24
    39f4:	11 96       	adiw	r26, 0x01	; 1
    39f6:	cd 91       	ld	r28, X+
    39f8:	dc 91       	ld	r29, X
    39fa:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    39fc:	c2 83       	std	Z+2, r28	; 0x02
    39fe:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    3a00:	8c 81       	ldd	r24, Y+4	; 0x04
    3a02:	9d 81       	ldd	r25, Y+5	; 0x05
    3a04:	84 83       	std	Z+4, r24	; 0x04
    3a06:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    3a08:	8c 81       	ldd	r24, Y+4	; 0x04
    3a0a:	9d 81       	ldd	r25, Y+5	; 0x05
    3a0c:	dc 01       	movw	r26, r24
    3a0e:	12 96       	adiw	r26, 0x02	; 2
    3a10:	6d 93       	st	X+, r22
    3a12:	7c 93       	st	X, r23
    3a14:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    3a16:	6c 83       	std	Y+4, r22	; 0x04
    3a18:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    3a1a:	20 87       	std	Z+8, r18	; 0x08
    3a1c:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    3a1e:	f9 01       	movw	r30, r18
    3a20:	80 81       	ld	r24, Z
    3a22:	8f 5f       	subi	r24, 0xFF	; 255
    3a24:	80 83       	st	Z, r24
}
    3a26:	df 91       	pop	r29
    3a28:	cf 91       	pop	r28
    3a2a:	08 95       	ret

00003a2c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    3a2c:	cf 93       	push	r28
    3a2e:	df 93       	push	r29
    3a30:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    3a32:	48 81       	ld	r20, Y
    3a34:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    3a36:	4f 3f       	cpi	r20, 0xFF	; 255
    3a38:	2f ef       	ldi	r18, 0xFF	; 255
    3a3a:	52 07       	cpc	r21, r18
    3a3c:	01 f1       	breq	.+64     	; 0x3a7e <vListInsert+0x52>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    3a3e:	dc 01       	movw	r26, r24
    3a40:	13 96       	adiw	r26, 0x03	; 3
    3a42:	01 c0       	rjmp	.+2      	; 0x3a46 <vListInsert+0x1a>
    3a44:	df 01       	movw	r26, r30
    3a46:	12 96       	adiw	r26, 0x02	; 2
    3a48:	ed 91       	ld	r30, X+
    3a4a:	fc 91       	ld	r31, X
    3a4c:	13 97       	sbiw	r26, 0x03	; 3
    3a4e:	20 81       	ld	r18, Z
    3a50:	31 81       	ldd	r19, Z+1	; 0x01
    3a52:	42 17       	cp	r20, r18
    3a54:	53 07       	cpc	r21, r19
    3a56:	b0 f7       	brcc	.-20     	; 0x3a44 <vListInsert+0x18>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    3a58:	ea 83       	std	Y+2, r30	; 0x02
    3a5a:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3a5c:	c4 83       	std	Z+4, r28	; 0x04
    3a5e:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    3a60:	ac 83       	std	Y+4, r26	; 0x04
    3a62:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    3a64:	12 96       	adiw	r26, 0x02	; 2
    3a66:	cd 93       	st	X+, r28
    3a68:	dc 93       	st	X, r29
    3a6a:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    3a6c:	88 87       	std	Y+8, r24	; 0x08
    3a6e:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    3a70:	fc 01       	movw	r30, r24
    3a72:	20 81       	ld	r18, Z
    3a74:	2f 5f       	subi	r18, 0xFF	; 255
    3a76:	20 83       	st	Z, r18
}
    3a78:	df 91       	pop	r29
    3a7a:	cf 91       	pop	r28
    3a7c:	08 95       	ret
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    3a7e:	fc 01       	movw	r30, r24
    3a80:	a7 81       	ldd	r26, Z+7	; 0x07
    3a82:	b0 85       	ldd	r27, Z+8	; 0x08
    3a84:	12 96       	adiw	r26, 0x02	; 2
    3a86:	ed 91       	ld	r30, X+
    3a88:	fc 91       	ld	r31, X
    3a8a:	13 97       	sbiw	r26, 0x03	; 3
    3a8c:	e5 cf       	rjmp	.-54     	; 0x3a58 <vListInsert+0x2c>

00003a8e <uxListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    3a8e:	cf 93       	push	r28
    3a90:	df 93       	push	r29
    3a92:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    3a94:	a0 85       	ldd	r26, Z+8	; 0x08
    3a96:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3a98:	22 81       	ldd	r18, Z+2	; 0x02
    3a9a:	33 81       	ldd	r19, Z+3	; 0x03
    3a9c:	84 81       	ldd	r24, Z+4	; 0x04
    3a9e:	95 81       	ldd	r25, Z+5	; 0x05
    3aa0:	e9 01       	movw	r28, r18
    3aa2:	8c 83       	std	Y+4, r24	; 0x04
    3aa4:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3aa6:	84 81       	ldd	r24, Z+4	; 0x04
    3aa8:	95 81       	ldd	r25, Z+5	; 0x05
    3aaa:	ec 01       	movw	r28, r24
    3aac:	2a 83       	std	Y+2, r18	; 0x02
    3aae:	3b 83       	std	Y+3, r19	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    3ab0:	11 96       	adiw	r26, 0x01	; 1
    3ab2:	2d 91       	ld	r18, X+
    3ab4:	3c 91       	ld	r19, X
    3ab6:	12 97       	sbiw	r26, 0x02	; 2
    3ab8:	e2 17       	cp	r30, r18
    3aba:	f3 07       	cpc	r31, r19
    3abc:	49 f0       	breq	.+18     	; 0x3ad0 <uxListRemove+0x42>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    3abe:	10 86       	std	Z+8, r1	; 0x08
    3ac0:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    3ac2:	8c 91       	ld	r24, X
    3ac4:	81 50       	subi	r24, 0x01	; 1
    3ac6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    3ac8:	8c 91       	ld	r24, X
}
    3aca:	df 91       	pop	r29
    3acc:	cf 91       	pop	r28
    3ace:	08 95       	ret
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    3ad0:	11 96       	adiw	r26, 0x01	; 1
    3ad2:	8d 93       	st	X+, r24
    3ad4:	9c 93       	st	X, r25
    3ad6:	12 97       	sbiw	r26, 0x02	; 2
    3ad8:	f2 cf       	rjmp	.-28     	; 0x3abe <uxListRemove+0x30>

00003ada <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    3ada:	31 e1       	ldi	r19, 0x11	; 17
    3adc:	fc 01       	movw	r30, r24
    3ade:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    3ae0:	31 97       	sbiw	r30, 0x01	; 1
    3ae2:	22 e2       	ldi	r18, 0x22	; 34
    3ae4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    3ae6:	31 97       	sbiw	r30, 0x01	; 1
    3ae8:	a3 e3       	ldi	r26, 0x33	; 51
    3aea:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3aec:	31 97       	sbiw	r30, 0x01	; 1
    3aee:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3af0:	31 97       	sbiw	r30, 0x01	; 1
    3af2:	70 83       	st	Z, r23
	pxTopOfStack--;

#if defined(__AVR_3_BYTE_PC__) && __AVR_3_BYTE_PC__   //MCU's with more than 128kB of program memory: PC is 3 bytes
	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3af4:	31 97       	sbiw	r30, 0x01	; 1
    3af6:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    3af8:	31 97       	sbiw	r30, 0x01	; 1
    3afa:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    3afc:	31 97       	sbiw	r30, 0x01	; 1
    3afe:	60 e8       	ldi	r22, 0x80	; 128
    3b00:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    3b02:	31 97       	sbiw	r30, 0x01	; 1
    3b04:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    3b06:	31 97       	sbiw	r30, 0x01	; 1
    3b08:	62 e0       	ldi	r22, 0x02	; 2
    3b0a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    3b0c:	31 97       	sbiw	r30, 0x01	; 1
    3b0e:	63 e0       	ldi	r22, 0x03	; 3
    3b10:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    3b12:	31 97       	sbiw	r30, 0x01	; 1
    3b14:	64 e0       	ldi	r22, 0x04	; 4
    3b16:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    3b18:	31 97       	sbiw	r30, 0x01	; 1
    3b1a:	65 e0       	ldi	r22, 0x05	; 5
    3b1c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    3b1e:	31 97       	sbiw	r30, 0x01	; 1
    3b20:	66 e0       	ldi	r22, 0x06	; 6
    3b22:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    3b24:	31 97       	sbiw	r30, 0x01	; 1
    3b26:	67 e0       	ldi	r22, 0x07	; 7
    3b28:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    3b2a:	31 97       	sbiw	r30, 0x01	; 1
    3b2c:	68 e0       	ldi	r22, 0x08	; 8
    3b2e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    3b30:	31 97       	sbiw	r30, 0x01	; 1
    3b32:	69 e0       	ldi	r22, 0x09	; 9
    3b34:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    3b36:	31 97       	sbiw	r30, 0x01	; 1
    3b38:	60 e1       	ldi	r22, 0x10	; 16
    3b3a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    3b3c:	31 97       	sbiw	r30, 0x01	; 1
    3b3e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    3b40:	31 97       	sbiw	r30, 0x01	; 1
    3b42:	32 e1       	ldi	r19, 0x12	; 18
    3b44:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    3b46:	31 97       	sbiw	r30, 0x01	; 1
    3b48:	33 e1       	ldi	r19, 0x13	; 19
    3b4a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    3b4c:	31 97       	sbiw	r30, 0x01	; 1
    3b4e:	34 e1       	ldi	r19, 0x14	; 20
    3b50:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    3b52:	31 97       	sbiw	r30, 0x01	; 1
    3b54:	35 e1       	ldi	r19, 0x15	; 21
    3b56:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    3b58:	31 97       	sbiw	r30, 0x01	; 1
    3b5a:	36 e1       	ldi	r19, 0x16	; 22
    3b5c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    3b5e:	31 97       	sbiw	r30, 0x01	; 1
    3b60:	37 e1       	ldi	r19, 0x17	; 23
    3b62:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    3b64:	31 97       	sbiw	r30, 0x01	; 1
    3b66:	38 e1       	ldi	r19, 0x18	; 24
    3b68:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    3b6a:	31 97       	sbiw	r30, 0x01	; 1
    3b6c:	39 e1       	ldi	r19, 0x19	; 25
    3b6e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    3b70:	31 97       	sbiw	r30, 0x01	; 1
    3b72:	30 e2       	ldi	r19, 0x20	; 32
    3b74:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    3b76:	31 97       	sbiw	r30, 0x01	; 1
    3b78:	31 e2       	ldi	r19, 0x21	; 33
    3b7a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    3b7c:	31 97       	sbiw	r30, 0x01	; 1
    3b7e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    3b80:	31 97       	sbiw	r30, 0x01	; 1
    3b82:	23 e2       	ldi	r18, 0x23	; 35
    3b84:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3b86:	31 97       	sbiw	r30, 0x01	; 1
    3b88:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3b8a:	31 97       	sbiw	r30, 0x01	; 1
    3b8c:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    3b8e:	31 97       	sbiw	r30, 0x01	; 1
    3b90:	26 e2       	ldi	r18, 0x26	; 38
    3b92:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    3b94:	31 97       	sbiw	r30, 0x01	; 1
    3b96:	27 e2       	ldi	r18, 0x27	; 39
    3b98:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    3b9a:	31 97       	sbiw	r30, 0x01	; 1
    3b9c:	28 e2       	ldi	r18, 0x28	; 40
    3b9e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    3ba0:	31 97       	sbiw	r30, 0x01	; 1
    3ba2:	29 e2       	ldi	r18, 0x29	; 41
    3ba4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    3ba6:	31 97       	sbiw	r30, 0x01	; 1
    3ba8:	20 e3       	ldi	r18, 0x30	; 48
    3baa:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    3bac:	31 97       	sbiw	r30, 0x01	; 1
    3bae:	21 e3       	ldi	r18, 0x31	; 49
    3bb0:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    3bb2:	87 97       	sbiw	r24, 0x27	; 39
    3bb4:	08 95       	ret

00003bb6 <xPortStartScheduler>:
 */

static void prvSetupTimerInterrupt( void )
{
	//TCC0 is used as tick timer
	TCC0.CCA=65535;
    3bb6:	e0 e0       	ldi	r30, 0x00	; 0
    3bb8:	f8 e0       	ldi	r31, 0x08	; 8
    3bba:	8f ef       	ldi	r24, 0xFF	; 255
    3bbc:	9f ef       	ldi	r25, 0xFF	; 255
    3bbe:	80 a7       	std	Z+40, r24	; 0x28
    3bc0:	91 a7       	std	Z+41, r25	; 0x29
	TCC0.CTRLA=0b00000001; //DIV1
    3bc2:	81 e0       	ldi	r24, 0x01	; 1
    3bc4:	80 83       	st	Z, r24
	TCC0.CTRLB=1<<6;
    3bc6:	90 e4       	ldi	r25, 0x40	; 64
    3bc8:	91 83       	std	Z+1, r25	; 0x01
	TCC0.INTCTRLA=0b00000001; //OVF priority LOW
    3bca:	86 83       	std	Z+6, r24	; 0x06
	TCC0.INTCTRLB=0b00000001; //CCA priority LOW
    3bcc:	87 83       	std	Z+7, r24	; 0x07
	TCC0.PER=configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3bce:	80 e0       	ldi	r24, 0x00	; 0
    3bd0:	9d e7       	ldi	r25, 0x7D	; 125
    3bd2:	86 a3       	std	Z+38, r24	; 0x26
    3bd4:	97 a3       	std	Z+39, r25	; 0x27
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3bd6:	a0 91 8b 2d 	lds	r26, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    3bda:	b0 91 8c 2d 	lds	r27, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    3bde:	cd 91       	ld	r28, X+
    3be0:	cd bf       	out	0x3d, r28	; 61
    3be2:	dd 91       	ld	r29, X+
    3be4:	de bf       	out	0x3e, r29	; 62
    3be6:	ff 91       	pop	r31
    3be8:	ef 91       	pop	r30
    3bea:	df 91       	pop	r29
    3bec:	cf 91       	pop	r28
    3bee:	bf 91       	pop	r27
    3bf0:	af 91       	pop	r26
    3bf2:	9f 91       	pop	r25
    3bf4:	8f 91       	pop	r24
    3bf6:	7f 91       	pop	r23
    3bf8:	6f 91       	pop	r22
    3bfa:	5f 91       	pop	r21
    3bfc:	4f 91       	pop	r20
    3bfe:	3f 91       	pop	r19
    3c00:	2f 91       	pop	r18
    3c02:	1f 91       	pop	r17
    3c04:	0f 91       	pop	r16
    3c06:	ff 90       	pop	r15
    3c08:	ef 90       	pop	r14
    3c0a:	df 90       	pop	r13
    3c0c:	cf 90       	pop	r12
    3c0e:	bf 90       	pop	r11
    3c10:	af 90       	pop	r10
    3c12:	9f 90       	pop	r9
    3c14:	8f 90       	pop	r8
    3c16:	7f 90       	pop	r7
    3c18:	6f 90       	pop	r6
    3c1a:	5f 90       	pop	r5
    3c1c:	4f 90       	pop	r4
    3c1e:	3f 90       	pop	r3
    3c20:	2f 90       	pop	r2
    3c22:	1f 90       	pop	r1
    3c24:	0f 90       	pop	r0
    3c26:	0f be       	out	0x3f, r0	; 63
    3c28:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3c2a:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    3c2c:	81 e0       	ldi	r24, 0x01	; 1
    3c2e:	08 95       	ret

00003c30 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3c30:	0f 92       	push	r0
    3c32:	0f b6       	in	r0, 0x3f	; 63
    3c34:	f8 94       	cli
    3c36:	0f 92       	push	r0
    3c38:	1f 92       	push	r1
    3c3a:	11 24       	eor	r1, r1
    3c3c:	2f 92       	push	r2
    3c3e:	3f 92       	push	r3
    3c40:	4f 92       	push	r4
    3c42:	5f 92       	push	r5
    3c44:	6f 92       	push	r6
    3c46:	7f 92       	push	r7
    3c48:	8f 92       	push	r8
    3c4a:	9f 92       	push	r9
    3c4c:	af 92       	push	r10
    3c4e:	bf 92       	push	r11
    3c50:	cf 92       	push	r12
    3c52:	df 92       	push	r13
    3c54:	ef 92       	push	r14
    3c56:	ff 92       	push	r15
    3c58:	0f 93       	push	r16
    3c5a:	1f 93       	push	r17
    3c5c:	2f 93       	push	r18
    3c5e:	3f 93       	push	r19
    3c60:	4f 93       	push	r20
    3c62:	5f 93       	push	r21
    3c64:	6f 93       	push	r22
    3c66:	7f 93       	push	r23
    3c68:	8f 93       	push	r24
    3c6a:	9f 93       	push	r25
    3c6c:	af 93       	push	r26
    3c6e:	bf 93       	push	r27
    3c70:	cf 93       	push	r28
    3c72:	df 93       	push	r29
    3c74:	ef 93       	push	r30
    3c76:	ff 93       	push	r31
    3c78:	a0 91 8b 2d 	lds	r26, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    3c7c:	b0 91 8c 2d 	lds	r27, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    3c80:	0d b6       	in	r0, 0x3d	; 61
    3c82:	0d 92       	st	X+, r0
    3c84:	0e b6       	in	r0, 0x3e	; 62
    3c86:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3c88:	0e 94 54 2b 	call	0x56a8	; 0x56a8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3c8c:	a0 91 8b 2d 	lds	r26, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    3c90:	b0 91 8c 2d 	lds	r27, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    3c94:	cd 91       	ld	r28, X+
    3c96:	cd bf       	out	0x3d, r28	; 61
    3c98:	dd 91       	ld	r29, X+
    3c9a:	de bf       	out	0x3e, r29	; 62
    3c9c:	ff 91       	pop	r31
    3c9e:	ef 91       	pop	r30
    3ca0:	df 91       	pop	r29
    3ca2:	cf 91       	pop	r28
    3ca4:	bf 91       	pop	r27
    3ca6:	af 91       	pop	r26
    3ca8:	9f 91       	pop	r25
    3caa:	8f 91       	pop	r24
    3cac:	7f 91       	pop	r23
    3cae:	6f 91       	pop	r22
    3cb0:	5f 91       	pop	r21
    3cb2:	4f 91       	pop	r20
    3cb4:	3f 91       	pop	r19
    3cb6:	2f 91       	pop	r18
    3cb8:	1f 91       	pop	r17
    3cba:	0f 91       	pop	r16
    3cbc:	ff 90       	pop	r15
    3cbe:	ef 90       	pop	r14
    3cc0:	df 90       	pop	r13
    3cc2:	cf 90       	pop	r12
    3cc4:	bf 90       	pop	r11
    3cc6:	af 90       	pop	r10
    3cc8:	9f 90       	pop	r9
    3cca:	8f 90       	pop	r8
    3ccc:	7f 90       	pop	r7
    3cce:	6f 90       	pop	r6
    3cd0:	5f 90       	pop	r5
    3cd2:	4f 90       	pop	r4
    3cd4:	3f 90       	pop	r3
    3cd6:	2f 90       	pop	r2
    3cd8:	1f 90       	pop	r1
    3cda:	0f 90       	pop	r0
    3cdc:	0f be       	out	0x3f, r0	; 63
    3cde:	0f 90       	pop	r0
	asm volatile ( "ret" );
    3ce0:	08 95       	ret

00003ce2 <vPortYieldISR>:
}*/

//void vPortYieldISR( void ) __attribute__ ( ( naked ) );
void vPortYieldISR( void )
{
	TCC0.CCA=TCC0.CNT+100;
    3ce2:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3ce6:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3cea:	8c 59       	subi	r24, 0x9C	; 156
    3cec:	9f 4f       	sbci	r25, 0xFF	; 255
    3cee:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    3cf2:	90 93 29 08 	sts	0x0829, r25	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
	if (TCC0.CCA>=TCC0.PER) TCC0.CCA-= TCC0.PER;
    3cf6:	20 91 28 08 	lds	r18, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    3cfa:	30 91 29 08 	lds	r19, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    3cfe:	80 91 26 08 	lds	r24, 0x0826	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
    3d02:	90 91 27 08 	lds	r25, 0x0827	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
    3d06:	28 17       	cp	r18, r24
    3d08:	39 07       	cpc	r19, r25
    3d0a:	70 f0       	brcs	.+28     	; 0x3d28 <vPortYieldISR+0x46>
    3d0c:	20 91 26 08 	lds	r18, 0x0826	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
    3d10:	30 91 27 08 	lds	r19, 0x0827	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
    3d14:	80 91 28 08 	lds	r24, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    3d18:	90 91 29 08 	lds	r25, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    3d1c:	82 1b       	sub	r24, r18
    3d1e:	93 0b       	sbc	r25, r19
    3d20:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    3d24:	90 93 29 08 	sts	0x0829, r25	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
	asm volatile ( "ret" );
    3d28:	08 95       	ret

00003d2a <__vector_14>:
	 * the context is saved at the start of the ISR.  The tick
	 * count is incremented after the context is saved.
	 */	
	ISR(TCC0_OVF_vect,ISR_NAKED)
	{
		portSAVE_CONTEXT();
    3d2a:	0f 92       	push	r0
    3d2c:	0f b6       	in	r0, 0x3f	; 63
    3d2e:	f8 94       	cli
    3d30:	0f 92       	push	r0
    3d32:	1f 92       	push	r1
    3d34:	11 24       	eor	r1, r1
    3d36:	2f 92       	push	r2
    3d38:	3f 92       	push	r3
    3d3a:	4f 92       	push	r4
    3d3c:	5f 92       	push	r5
    3d3e:	6f 92       	push	r6
    3d40:	7f 92       	push	r7
    3d42:	8f 92       	push	r8
    3d44:	9f 92       	push	r9
    3d46:	af 92       	push	r10
    3d48:	bf 92       	push	r11
    3d4a:	cf 92       	push	r12
    3d4c:	df 92       	push	r13
    3d4e:	ef 92       	push	r14
    3d50:	ff 92       	push	r15
    3d52:	0f 93       	push	r16
    3d54:	1f 93       	push	r17
    3d56:	2f 93       	push	r18
    3d58:	3f 93       	push	r19
    3d5a:	4f 93       	push	r20
    3d5c:	5f 93       	push	r21
    3d5e:	6f 93       	push	r22
    3d60:	7f 93       	push	r23
    3d62:	8f 93       	push	r24
    3d64:	9f 93       	push	r25
    3d66:	af 93       	push	r26
    3d68:	bf 93       	push	r27
    3d6a:	cf 93       	push	r28
    3d6c:	df 93       	push	r29
    3d6e:	ef 93       	push	r30
    3d70:	ff 93       	push	r31
    3d72:	a0 91 8b 2d 	lds	r26, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    3d76:	b0 91 8c 2d 	lds	r27, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    3d7a:	0d b6       	in	r0, 0x3d	; 61
    3d7c:	0d 92       	st	X+, r0
    3d7e:	0e b6       	in	r0, 0x3e	; 62
    3d80:	0d 92       	st	X+, r0
		StatsTimer+=TCC0.PER;
    3d82:	20 91 26 08 	lds	r18, 0x0826	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
    3d86:	30 91 27 08 	lds	r19, 0x0827	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
    3d8a:	80 91 cf 2d 	lds	r24, 0x2DCF	; 0x802dcf <StatsTimer>
    3d8e:	90 91 d0 2d 	lds	r25, 0x2DD0	; 0x802dd0 <StatsTimer+0x1>
    3d92:	a0 91 d1 2d 	lds	r26, 0x2DD1	; 0x802dd1 <StatsTimer+0x2>
    3d96:	b0 91 d2 2d 	lds	r27, 0x2DD2	; 0x802dd2 <StatsTimer+0x3>
    3d9a:	82 0f       	add	r24, r18
    3d9c:	93 1f       	adc	r25, r19
    3d9e:	a1 1d       	adc	r26, r1
    3da0:	b1 1d       	adc	r27, r1
    3da2:	80 93 cf 2d 	sts	0x2DCF, r24	; 0x802dcf <StatsTimer>
    3da6:	90 93 d0 2d 	sts	0x2DD0, r25	; 0x802dd0 <StatsTimer+0x1>
    3daa:	a0 93 d1 2d 	sts	0x2DD1, r26	; 0x802dd1 <StatsTimer+0x2>
    3dae:	b0 93 d2 2d 	sts	0x2DD2, r27	; 0x802dd2 <StatsTimer+0x3>
		xTaskIncrementTick();
    3db2:	0e 94 70 29 	call	0x52e0	; 0x52e0 <xTaskIncrementTick>
		vTaskSwitchContext();
    3db6:	0e 94 54 2b 	call	0x56a8	; 0x56a8 <vTaskSwitchContext>
		portRESTORE_CONTEXT();
    3dba:	a0 91 8b 2d 	lds	r26, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    3dbe:	b0 91 8c 2d 	lds	r27, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    3dc2:	cd 91       	ld	r28, X+
    3dc4:	cd bf       	out	0x3d, r28	; 61
    3dc6:	dd 91       	ld	r29, X+
    3dc8:	de bf       	out	0x3e, r29	; 62
    3dca:	ff 91       	pop	r31
    3dcc:	ef 91       	pop	r30
    3dce:	df 91       	pop	r29
    3dd0:	cf 91       	pop	r28
    3dd2:	bf 91       	pop	r27
    3dd4:	af 91       	pop	r26
    3dd6:	9f 91       	pop	r25
    3dd8:	8f 91       	pop	r24
    3dda:	7f 91       	pop	r23
    3ddc:	6f 91       	pop	r22
    3dde:	5f 91       	pop	r21
    3de0:	4f 91       	pop	r20
    3de2:	3f 91       	pop	r19
    3de4:	2f 91       	pop	r18
    3de6:	1f 91       	pop	r17
    3de8:	0f 91       	pop	r16
    3dea:	ff 90       	pop	r15
    3dec:	ef 90       	pop	r14
    3dee:	df 90       	pop	r13
    3df0:	cf 90       	pop	r12
    3df2:	bf 90       	pop	r11
    3df4:	af 90       	pop	r10
    3df6:	9f 90       	pop	r9
    3df8:	8f 90       	pop	r8
    3dfa:	7f 90       	pop	r7
    3dfc:	6f 90       	pop	r6
    3dfe:	5f 90       	pop	r5
    3e00:	4f 90       	pop	r4
    3e02:	3f 90       	pop	r3
    3e04:	2f 90       	pop	r2
    3e06:	1f 90       	pop	r1
    3e08:	0f 90       	pop	r0
    3e0a:	0f be       	out	0x3f, r0	; 63
    3e0c:	0f 90       	pop	r0

		asm volatile ( "reti" );
    3e0e:	18 95       	reti

00003e10 <vConfigureTimerForRunTimeStats>:
 */

volatile uint32_t StatsTimer;

void vConfigureTimerForRunTimeStats(void)
{
    3e10:	08 95       	ret

00003e12 <__vector_16>:
	//TCC1.INTCTRLA=0b00000001; //OVF priority LOW
}

ISR(TCC0_CCA_vect,ISR_NAKED)
	{
	portSAVE_CONTEXT();
    3e12:	0f 92       	push	r0
    3e14:	0f b6       	in	r0, 0x3f	; 63
    3e16:	f8 94       	cli
    3e18:	0f 92       	push	r0
    3e1a:	1f 92       	push	r1
    3e1c:	11 24       	eor	r1, r1
    3e1e:	2f 92       	push	r2
    3e20:	3f 92       	push	r3
    3e22:	4f 92       	push	r4
    3e24:	5f 92       	push	r5
    3e26:	6f 92       	push	r6
    3e28:	7f 92       	push	r7
    3e2a:	8f 92       	push	r8
    3e2c:	9f 92       	push	r9
    3e2e:	af 92       	push	r10
    3e30:	bf 92       	push	r11
    3e32:	cf 92       	push	r12
    3e34:	df 92       	push	r13
    3e36:	ef 92       	push	r14
    3e38:	ff 92       	push	r15
    3e3a:	0f 93       	push	r16
    3e3c:	1f 93       	push	r17
    3e3e:	2f 93       	push	r18
    3e40:	3f 93       	push	r19
    3e42:	4f 93       	push	r20
    3e44:	5f 93       	push	r21
    3e46:	6f 93       	push	r22
    3e48:	7f 93       	push	r23
    3e4a:	8f 93       	push	r24
    3e4c:	9f 93       	push	r25
    3e4e:	af 93       	push	r26
    3e50:	bf 93       	push	r27
    3e52:	cf 93       	push	r28
    3e54:	df 93       	push	r29
    3e56:	ef 93       	push	r30
    3e58:	ff 93       	push	r31
    3e5a:	a0 91 8b 2d 	lds	r26, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    3e5e:	b0 91 8c 2d 	lds	r27, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    3e62:	0d b6       	in	r0, 0x3d	; 61
    3e64:	0d 92       	st	X+, r0
    3e66:	0e b6       	in	r0, 0x3e	; 62
    3e68:	0d 92       	st	X+, r0
	TCC0.CCA=65535;
    3e6a:	8f ef       	ldi	r24, 0xFF	; 255
    3e6c:	9f ef       	ldi	r25, 0xFF	; 255
    3e6e:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    3e72:	90 93 29 08 	sts	0x0829, r25	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
	vTaskSwitchContext();
    3e76:	0e 94 54 2b 	call	0x56a8	; 0x56a8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3e7a:	a0 91 8b 2d 	lds	r26, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    3e7e:	b0 91 8c 2d 	lds	r27, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    3e82:	cd 91       	ld	r28, X+
    3e84:	cd bf       	out	0x3d, r28	; 61
    3e86:	dd 91       	ld	r29, X+
    3e88:	de bf       	out	0x3e, r29	; 62
    3e8a:	ff 91       	pop	r31
    3e8c:	ef 91       	pop	r30
    3e8e:	df 91       	pop	r29
    3e90:	cf 91       	pop	r28
    3e92:	bf 91       	pop	r27
    3e94:	af 91       	pop	r26
    3e96:	9f 91       	pop	r25
    3e98:	8f 91       	pop	r24
    3e9a:	7f 91       	pop	r23
    3e9c:	6f 91       	pop	r22
    3e9e:	5f 91       	pop	r21
    3ea0:	4f 91       	pop	r20
    3ea2:	3f 91       	pop	r19
    3ea4:	2f 91       	pop	r18
    3ea6:	1f 91       	pop	r17
    3ea8:	0f 91       	pop	r16
    3eaa:	ff 90       	pop	r15
    3eac:	ef 90       	pop	r14
    3eae:	df 90       	pop	r13
    3eb0:	cf 90       	pop	r12
    3eb2:	bf 90       	pop	r11
    3eb4:	af 90       	pop	r10
    3eb6:	9f 90       	pop	r9
    3eb8:	8f 90       	pop	r8
    3eba:	7f 90       	pop	r7
    3ebc:	6f 90       	pop	r6
    3ebe:	5f 90       	pop	r5
    3ec0:	4f 90       	pop	r4
    3ec2:	3f 90       	pop	r3
    3ec4:	2f 90       	pop	r2
    3ec6:	1f 90       	pop	r1
    3ec8:	0f 90       	pop	r0
    3eca:	0f be       	out	0x3f, r0	; 63
    3ecc:	0f 90       	pop	r0
	asm volatile ( "reti" );
    3ece:	18 95       	reti

00003ed0 <prvCopyDataToQueue>:
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
    3ed0:	0f 93       	push	r16
    3ed2:	1f 93       	push	r17
    3ed4:	cf 93       	push	r28
    3ed6:	df 93       	push	r29
    3ed8:	ec 01       	movw	r28, r24
    3eda:	04 2f       	mov	r16, r20
    3edc:	1a 8d       	ldd	r17, Y+26	; 0x1a
    3ede:	4c 8d       	ldd	r20, Y+28	; 0x1c
    3ee0:	41 11       	cpse	r20, r1
    3ee2:	0d c0       	rjmp	.+26     	; 0x3efe <prvCopyDataToQueue+0x2e>
    3ee4:	88 81       	ld	r24, Y
    3ee6:	99 81       	ldd	r25, Y+1	; 0x01
    3ee8:	89 2b       	or	r24, r25
    3eea:	09 f4       	brne	.+2      	; 0x3eee <prvCopyDataToQueue+0x1e>
    3eec:	43 c0       	rjmp	.+134    	; 0x3f74 <prvCopyDataToQueue+0xa4>
    3eee:	1f 5f       	subi	r17, 0xFF	; 255
    3ef0:	80 e0       	ldi	r24, 0x00	; 0
    3ef2:	1a 8f       	std	Y+26, r17	; 0x1a
    3ef4:	df 91       	pop	r29
    3ef6:	cf 91       	pop	r28
    3ef8:	1f 91       	pop	r17
    3efa:	0f 91       	pop	r16
    3efc:	08 95       	ret
    3efe:	50 e0       	ldi	r21, 0x00	; 0
    3f00:	01 11       	cpse	r16, r1
    3f02:	15 c0       	rjmp	.+42     	; 0x3f2e <prvCopyDataToQueue+0x5e>
    3f04:	8a 81       	ldd	r24, Y+2	; 0x02
    3f06:	9b 81       	ldd	r25, Y+3	; 0x03
    3f08:	0e 94 91 4d 	call	0x9b22	; 0x9b22 <memcpy>
    3f0c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3f0e:	8a 81       	ldd	r24, Y+2	; 0x02
    3f10:	9b 81       	ldd	r25, Y+3	; 0x03
    3f12:	82 0f       	add	r24, r18
    3f14:	91 1d       	adc	r25, r1
    3f16:	8a 83       	std	Y+2, r24	; 0x02
    3f18:	9b 83       	std	Y+3, r25	; 0x03
    3f1a:	2c 81       	ldd	r18, Y+4	; 0x04
    3f1c:	3d 81       	ldd	r19, Y+5	; 0x05
    3f1e:	82 17       	cp	r24, r18
    3f20:	93 07       	cpc	r25, r19
    3f22:	28 f3       	brcs	.-54     	; 0x3eee <prvCopyDataToQueue+0x1e>
    3f24:	88 81       	ld	r24, Y
    3f26:	99 81       	ldd	r25, Y+1	; 0x01
    3f28:	8a 83       	std	Y+2, r24	; 0x02
    3f2a:	9b 83       	std	Y+3, r25	; 0x03
    3f2c:	e0 cf       	rjmp	.-64     	; 0x3eee <prvCopyDataToQueue+0x1e>
    3f2e:	8e 81       	ldd	r24, Y+6	; 0x06
    3f30:	9f 81       	ldd	r25, Y+7	; 0x07
    3f32:	0e 94 91 4d 	call	0x9b22	; 0x9b22 <memcpy>
    3f36:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3f38:	90 e0       	ldi	r25, 0x00	; 0
    3f3a:	91 95       	neg	r25
    3f3c:	81 95       	neg	r24
    3f3e:	91 09       	sbc	r25, r1
    3f40:	2e 81       	ldd	r18, Y+6	; 0x06
    3f42:	3f 81       	ldd	r19, Y+7	; 0x07
    3f44:	28 0f       	add	r18, r24
    3f46:	39 1f       	adc	r19, r25
    3f48:	2e 83       	std	Y+6, r18	; 0x06
    3f4a:	3f 83       	std	Y+7, r19	; 0x07
    3f4c:	48 81       	ld	r20, Y
    3f4e:	59 81       	ldd	r21, Y+1	; 0x01
    3f50:	24 17       	cp	r18, r20
    3f52:	35 07       	cpc	r19, r21
    3f54:	30 f4       	brcc	.+12     	; 0x3f62 <prvCopyDataToQueue+0x92>
    3f56:	2c 81       	ldd	r18, Y+4	; 0x04
    3f58:	3d 81       	ldd	r19, Y+5	; 0x05
    3f5a:	82 0f       	add	r24, r18
    3f5c:	93 1f       	adc	r25, r19
    3f5e:	8e 83       	std	Y+6, r24	; 0x06
    3f60:	9f 83       	std	Y+7, r25	; 0x07
    3f62:	02 30       	cpi	r16, 0x02	; 2
    3f64:	21 f6       	brne	.-120    	; 0x3eee <prvCopyDataToQueue+0x1e>
    3f66:	11 23       	and	r17, r17
    3f68:	11 f0       	breq	.+4      	; 0x3f6e <prvCopyDataToQueue+0x9e>
    3f6a:	80 e0       	ldi	r24, 0x00	; 0
    3f6c:	c2 cf       	rjmp	.-124    	; 0x3ef2 <prvCopyDataToQueue+0x22>
    3f6e:	11 e0       	ldi	r17, 0x01	; 1
    3f70:	80 e0       	ldi	r24, 0x00	; 0
    3f72:	bf cf       	rjmp	.-130    	; 0x3ef2 <prvCopyDataToQueue+0x22>
    3f74:	8c 81       	ldd	r24, Y+4	; 0x04
    3f76:	9d 81       	ldd	r25, Y+5	; 0x05
    3f78:	0e 94 48 2e 	call	0x5c90	; 0x5c90 <xTaskPriorityDisinherit>
    3f7c:	1c 82       	std	Y+4, r1	; 0x04
    3f7e:	1d 82       	std	Y+5, r1	; 0x05
    3f80:	1f 5f       	subi	r17, 0xFF	; 255
    3f82:	b7 cf       	rjmp	.-146    	; 0x3ef2 <prvCopyDataToQueue+0x22>

00003f84 <prvCopyDataFromQueue>:
    3f84:	fc 01       	movw	r30, r24
    3f86:	cb 01       	movw	r24, r22
    3f88:	44 8d       	ldd	r20, Z+28	; 0x1c
    3f8a:	44 23       	and	r20, r20
    3f8c:	91 f0       	breq	.+36     	; 0x3fb2 <prvCopyDataFromQueue+0x2e>
    3f8e:	50 e0       	ldi	r21, 0x00	; 0
    3f90:	66 81       	ldd	r22, Z+6	; 0x06
    3f92:	77 81       	ldd	r23, Z+7	; 0x07
    3f94:	64 0f       	add	r22, r20
    3f96:	75 1f       	adc	r23, r21
    3f98:	66 83       	std	Z+6, r22	; 0x06
    3f9a:	77 83       	std	Z+7, r23	; 0x07
    3f9c:	24 81       	ldd	r18, Z+4	; 0x04
    3f9e:	35 81       	ldd	r19, Z+5	; 0x05
    3fa0:	62 17       	cp	r22, r18
    3fa2:	73 07       	cpc	r23, r19
    3fa4:	20 f0       	brcs	.+8      	; 0x3fae <prvCopyDataFromQueue+0x2a>
    3fa6:	60 81       	ld	r22, Z
    3fa8:	71 81       	ldd	r23, Z+1	; 0x01
    3faa:	66 83       	std	Z+6, r22	; 0x06
    3fac:	77 83       	std	Z+7, r23	; 0x07
    3fae:	0c 94 91 4d 	jmp	0x9b22	; 0x9b22 <memcpy>
    3fb2:	08 95       	ret

00003fb4 <prvUnlockQueue>:
    3fb4:	ef 92       	push	r14
    3fb6:	ff 92       	push	r15
    3fb8:	0f 93       	push	r16
    3fba:	1f 93       	push	r17
    3fbc:	cf 93       	push	r28
    3fbe:	8c 01       	movw	r16, r24
    3fc0:	0f b6       	in	r0, 0x3f	; 63
    3fc2:	f8 94       	cli
    3fc4:	0f 92       	push	r0
    3fc6:	fc 01       	movw	r30, r24
    3fc8:	c6 8d       	ldd	r28, Z+30	; 0x1e
    3fca:	1c 16       	cp	r1, r28
    3fcc:	c4 f4       	brge	.+48     	; 0x3ffe <prvUnlockQueue+0x4a>
    3fce:	fc 01       	movw	r30, r24
    3fd0:	81 89       	ldd	r24, Z+17	; 0x11
    3fd2:	88 23       	and	r24, r24
    3fd4:	a1 f0       	breq	.+40     	; 0x3ffe <prvUnlockQueue+0x4a>
    3fd6:	78 01       	movw	r14, r16
    3fd8:	f1 e1       	ldi	r31, 0x11	; 17
    3fda:	ef 0e       	add	r14, r31
    3fdc:	f1 1c       	adc	r15, r1
    3fde:	06 c0       	rjmp	.+12     	; 0x3fec <prvUnlockQueue+0x38>
    3fe0:	c1 50       	subi	r28, 0x01	; 1
    3fe2:	69 f0       	breq	.+26     	; 0x3ffe <prvUnlockQueue+0x4a>
    3fe4:	f8 01       	movw	r30, r16
    3fe6:	81 89       	ldd	r24, Z+17	; 0x11
    3fe8:	88 23       	and	r24, r24
    3fea:	49 f0       	breq	.+18     	; 0x3ffe <prvUnlockQueue+0x4a>
    3fec:	c7 01       	movw	r24, r14
    3fee:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <xTaskRemoveFromEventList>
    3ff2:	88 23       	and	r24, r24
    3ff4:	a9 f3       	breq	.-22     	; 0x3fe0 <prvUnlockQueue+0x2c>
    3ff6:	0e 94 37 2c 	call	0x586e	; 0x586e <vTaskMissedYield>
    3ffa:	c1 50       	subi	r28, 0x01	; 1
    3ffc:	99 f7       	brne	.-26     	; 0x3fe4 <prvUnlockQueue+0x30>
    3ffe:	8f ef       	ldi	r24, 0xFF	; 255
    4000:	f8 01       	movw	r30, r16
    4002:	86 8f       	std	Z+30, r24	; 0x1e
    4004:	0f 90       	pop	r0
    4006:	0f be       	out	0x3f, r0	; 63
    4008:	0f b6       	in	r0, 0x3f	; 63
    400a:	f8 94       	cli
    400c:	0f 92       	push	r0
    400e:	c5 8d       	ldd	r28, Z+29	; 0x1d
    4010:	1c 16       	cp	r1, r28
    4012:	c4 f4       	brge	.+48     	; 0x4044 <prvUnlockQueue+0x90>
    4014:	f8 01       	movw	r30, r16
    4016:	80 85       	ldd	r24, Z+8	; 0x08
    4018:	88 23       	and	r24, r24
    401a:	a1 f0       	breq	.+40     	; 0x4044 <prvUnlockQueue+0x90>
    401c:	78 01       	movw	r14, r16
    401e:	f8 e0       	ldi	r31, 0x08	; 8
    4020:	ef 0e       	add	r14, r31
    4022:	f1 1c       	adc	r15, r1
    4024:	06 c0       	rjmp	.+12     	; 0x4032 <prvUnlockQueue+0x7e>
    4026:	c1 50       	subi	r28, 0x01	; 1
    4028:	69 f0       	breq	.+26     	; 0x4044 <prvUnlockQueue+0x90>
    402a:	f8 01       	movw	r30, r16
    402c:	80 85       	ldd	r24, Z+8	; 0x08
    402e:	88 23       	and	r24, r24
    4030:	49 f0       	breq	.+18     	; 0x4044 <prvUnlockQueue+0x90>
    4032:	c7 01       	movw	r24, r14
    4034:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <xTaskRemoveFromEventList>
    4038:	88 23       	and	r24, r24
    403a:	a9 f3       	breq	.-22     	; 0x4026 <prvUnlockQueue+0x72>
    403c:	0e 94 37 2c 	call	0x586e	; 0x586e <vTaskMissedYield>
    4040:	c1 50       	subi	r28, 0x01	; 1
    4042:	99 f7       	brne	.-26     	; 0x402a <prvUnlockQueue+0x76>
    4044:	8f ef       	ldi	r24, 0xFF	; 255
    4046:	f8 01       	movw	r30, r16
    4048:	85 8f       	std	Z+29, r24	; 0x1d
    404a:	0f 90       	pop	r0
    404c:	0f be       	out	0x3f, r0	; 63
    404e:	cf 91       	pop	r28
    4050:	1f 91       	pop	r17
    4052:	0f 91       	pop	r16
    4054:	ff 90       	pop	r15
    4056:	ef 90       	pop	r14
    4058:	08 95       	ret

0000405a <xQueueGenericReset>:
    405a:	1f 93       	push	r17
    405c:	cf 93       	push	r28
    405e:	df 93       	push	r29
    4060:	ec 01       	movw	r28, r24
    4062:	16 2f       	mov	r17, r22
    4064:	89 2b       	or	r24, r25
    4066:	09 f4       	brne	.+2      	; 0x406a <xQueueGenericReset+0x10>
    4068:	3e c0       	rjmp	.+124    	; 0x40e6 <xQueueGenericReset+0x8c>
    406a:	0f b6       	in	r0, 0x3f	; 63
    406c:	f8 94       	cli
    406e:	0f 92       	push	r0
    4070:	48 81       	ld	r20, Y
    4072:	59 81       	ldd	r21, Y+1	; 0x01
    4074:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4076:	6c 8d       	ldd	r22, Y+28	; 0x1c
    4078:	9a 01       	movw	r18, r20
    407a:	86 9f       	mul	r24, r22
    407c:	20 0d       	add	r18, r0
    407e:	31 1d       	adc	r19, r1
    4080:	11 24       	eor	r1, r1
    4082:	2c 83       	std	Y+4, r18	; 0x04
    4084:	3d 83       	std	Y+5, r19	; 0x05
    4086:	1a 8e       	std	Y+26, r1	; 0x1a
    4088:	4a 83       	std	Y+2, r20	; 0x02
    408a:	5b 83       	std	Y+3, r21	; 0x03
    408c:	90 e0       	ldi	r25, 0x00	; 0
    408e:	01 97       	sbiw	r24, 0x01	; 1
    4090:	68 9f       	mul	r22, r24
    4092:	90 01       	movw	r18, r0
    4094:	69 9f       	mul	r22, r25
    4096:	30 0d       	add	r19, r0
    4098:	11 24       	eor	r1, r1
    409a:	ca 01       	movw	r24, r20
    409c:	82 0f       	add	r24, r18
    409e:	93 1f       	adc	r25, r19
    40a0:	8e 83       	std	Y+6, r24	; 0x06
    40a2:	9f 83       	std	Y+7, r25	; 0x07
    40a4:	8f ef       	ldi	r24, 0xFF	; 255
    40a6:	8d 8f       	std	Y+29, r24	; 0x1d
    40a8:	8e 8f       	std	Y+30, r24	; 0x1e
    40aa:	11 11       	cpse	r17, r1
    40ac:	13 c0       	rjmp	.+38     	; 0x40d4 <xQueueGenericReset+0x7a>
    40ae:	88 85       	ldd	r24, Y+8	; 0x08
    40b0:	81 11       	cpse	r24, r1
    40b2:	07 c0       	rjmp	.+14     	; 0x40c2 <xQueueGenericReset+0x68>
    40b4:	0f 90       	pop	r0
    40b6:	0f be       	out	0x3f, r0	; 63
    40b8:	81 e0       	ldi	r24, 0x01	; 1
    40ba:	df 91       	pop	r29
    40bc:	cf 91       	pop	r28
    40be:	1f 91       	pop	r17
    40c0:	08 95       	ret
    40c2:	ce 01       	movw	r24, r28
    40c4:	08 96       	adiw	r24, 0x08	; 8
    40c6:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <xTaskRemoveFromEventList>
    40ca:	88 23       	and	r24, r24
    40cc:	99 f3       	breq	.-26     	; 0x40b4 <xQueueGenericReset+0x5a>
    40ce:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vPortYield>
    40d2:	f0 cf       	rjmp	.-32     	; 0x40b4 <xQueueGenericReset+0x5a>
    40d4:	ce 01       	movw	r24, r28
    40d6:	08 96       	adiw	r24, 0x08	; 8
    40d8:	0e 94 e3 1c 	call	0x39c6	; 0x39c6 <vListInitialise>
    40dc:	ce 01       	movw	r24, r28
    40de:	41 96       	adiw	r24, 0x11	; 17
    40e0:	0e 94 e3 1c 	call	0x39c6	; 0x39c6 <vListInitialise>
    40e4:	e7 cf       	rjmp	.-50     	; 0x40b4 <xQueueGenericReset+0x5a>
    40e6:	63 e0       	ldi	r22, 0x03	; 3
    40e8:	71 e0       	ldi	r23, 0x01	; 1
    40ea:	8a ec       	ldi	r24, 0xCA	; 202
    40ec:	93 e2       	ldi	r25, 0x23	; 35
    40ee:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    40f2:	bb cf       	rjmp	.-138    	; 0x406a <xQueueGenericReset+0x10>

000040f4 <xQueueGenericCreate>:
    40f4:	ff 92       	push	r15
    40f6:	0f 93       	push	r16
    40f8:	1f 93       	push	r17
    40fa:	cf 93       	push	r28
    40fc:	df 93       	push	r29
    40fe:	18 2f       	mov	r17, r24
    4100:	06 2f       	mov	r16, r22
    4102:	f4 2e       	mov	r15, r20
    4104:	88 23       	and	r24, r24
    4106:	99 f1       	breq	.+102    	; 0x416e <xQueueGenericCreate+0x7a>
    4108:	00 23       	and	r16, r16
    410a:	d1 f0       	breq	.+52     	; 0x4140 <xQueueGenericCreate+0x4c>
    410c:	10 9f       	mul	r17, r16
    410e:	c0 01       	movw	r24, r0
    4110:	11 24       	eor	r1, r1
    4112:	81 96       	adiw	r24, 0x21	; 33
    4114:	0e 94 14 1c 	call	0x3828	; 0x3828 <pvPortMalloc>
    4118:	ec 01       	movw	r28, r24
    411a:	00 97       	sbiw	r24, 0x00	; 0
    411c:	51 f0       	breq	.+20     	; 0x4132 <xQueueGenericCreate+0x3e>
    411e:	81 96       	adiw	r24, 0x21	; 33
    4120:	88 83       	st	Y, r24
    4122:	99 83       	std	Y+1, r25	; 0x01
    4124:	1b 8f       	std	Y+27, r17	; 0x1b
    4126:	0c 8f       	std	Y+28, r16	; 0x1c
    4128:	61 e0       	ldi	r22, 0x01	; 1
    412a:	ce 01       	movw	r24, r28
    412c:	0e 94 2d 20 	call	0x405a	; 0x405a <xQueueGenericReset>
    4130:	f8 a2       	std	Y+32, r15	; 0x20
    4132:	ce 01       	movw	r24, r28
    4134:	df 91       	pop	r29
    4136:	cf 91       	pop	r28
    4138:	1f 91       	pop	r17
    413a:	0f 91       	pop	r16
    413c:	ff 90       	pop	r15
    413e:	08 95       	ret
    4140:	81 e2       	ldi	r24, 0x21	; 33
    4142:	90 e0       	ldi	r25, 0x00	; 0
    4144:	0e 94 14 1c 	call	0x3828	; 0x3828 <pvPortMalloc>
    4148:	ec 01       	movw	r28, r24
    414a:	89 2b       	or	r24, r25
    414c:	91 f3       	breq	.-28     	; 0x4132 <xQueueGenericCreate+0x3e>
    414e:	c8 83       	st	Y, r28
    4150:	d9 83       	std	Y+1, r29	; 0x01
    4152:	1b 8f       	std	Y+27, r17	; 0x1b
    4154:	0c 8f       	std	Y+28, r16	; 0x1c
    4156:	61 e0       	ldi	r22, 0x01	; 1
    4158:	ce 01       	movw	r24, r28
    415a:	0e 94 2d 20 	call	0x405a	; 0x405a <xQueueGenericReset>
    415e:	f8 a2       	std	Y+32, r15	; 0x20
    4160:	ce 01       	movw	r24, r28
    4162:	df 91       	pop	r29
    4164:	cf 91       	pop	r28
    4166:	1f 91       	pop	r17
    4168:	0f 91       	pop	r16
    416a:	ff 90       	pop	r15
    416c:	08 95       	ret
    416e:	66 e7       	ldi	r22, 0x76	; 118
    4170:	71 e0       	ldi	r23, 0x01	; 1
    4172:	8a ec       	ldi	r24, 0xCA	; 202
    4174:	93 e2       	ldi	r25, 0x23	; 35
    4176:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    417a:	c6 cf       	rjmp	.-116    	; 0x4108 <xQueueGenericCreate+0x14>

0000417c <xQueueGenericSend>:
    417c:	bf 92       	push	r11
    417e:	cf 92       	push	r12
    4180:	df 92       	push	r13
    4182:	ef 92       	push	r14
    4184:	ff 92       	push	r15
    4186:	0f 93       	push	r16
    4188:	1f 93       	push	r17
    418a:	cf 93       	push	r28
    418c:	df 93       	push	r29
    418e:	cd b7       	in	r28, 0x3d	; 61
    4190:	de b7       	in	r29, 0x3e	; 62
    4192:	25 97       	sbiw	r28, 0x05	; 5
    4194:	cd bf       	out	0x3d, r28	; 61
    4196:	de bf       	out	0x3e, r29	; 62
    4198:	8c 01       	movw	r16, r24
    419a:	6b 01       	movw	r12, r22
    419c:	4c 83       	std	Y+4, r20	; 0x04
    419e:	5d 83       	std	Y+5, r21	; 0x05
    41a0:	b2 2e       	mov	r11, r18
    41a2:	89 2b       	or	r24, r25
    41a4:	09 f4       	brne	.+2      	; 0x41a8 <xQueueGenericSend+0x2c>
    41a6:	b2 c0       	rjmp	.+356    	; 0x430c <xQueueGenericSend+0x190>
    41a8:	c1 14       	cp	r12, r1
    41aa:	d1 04       	cpc	r13, r1
    41ac:	09 f4       	brne	.+2      	; 0x41b0 <xQueueGenericSend+0x34>
    41ae:	a2 c0       	rjmp	.+324    	; 0x42f4 <xQueueGenericSend+0x178>
    41b0:	f2 e0       	ldi	r31, 0x02	; 2
    41b2:	bf 16       	cp	r11, r31
    41b4:	09 f4       	brne	.+2      	; 0x41b8 <xQueueGenericSend+0x3c>
    41b6:	7d c0       	rjmp	.+250    	; 0x42b2 <xQueueGenericSend+0x136>
    41b8:	f8 01       	movw	r30, r16
    41ba:	83 8d       	ldd	r24, Z+27	; 0x1b
    41bc:	20 e0       	ldi	r18, 0x00	; 0
    41be:	78 01       	movw	r14, r16
    41c0:	f8 e0       	ldi	r31, 0x08	; 8
    41c2:	ef 0e       	add	r14, r31
    41c4:	f1 1c       	adc	r15, r1
    41c6:	10 c0       	rjmp	.+32     	; 0x41e8 <xQueueGenericSend+0x6c>
    41c8:	6c 81       	ldd	r22, Y+4	; 0x04
    41ca:	7d 81       	ldd	r23, Y+5	; 0x05
    41cc:	c7 01       	movw	r24, r14
    41ce:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <vTaskPlaceOnEventList>
    41d2:	c8 01       	movw	r24, r16
    41d4:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <prvUnlockQueue>
    41d8:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>
    41dc:	88 23       	and	r24, r24
    41de:	09 f4       	brne	.+2      	; 0x41e2 <xQueueGenericSend+0x66>
    41e0:	4a c0       	rjmp	.+148    	; 0x4276 <xQueueGenericSend+0xfa>
    41e2:	f8 01       	movw	r30, r16
    41e4:	83 8d       	ldd	r24, Z+27	; 0x1b
    41e6:	21 e0       	ldi	r18, 0x01	; 1
    41e8:	0f b6       	in	r0, 0x3f	; 63
    41ea:	f8 94       	cli
    41ec:	0f 92       	push	r0
    41ee:	f8 01       	movw	r30, r16
    41f0:	92 8d       	ldd	r25, Z+26	; 0x1a
    41f2:	98 17       	cp	r25, r24
    41f4:	08 f4       	brcc	.+2      	; 0x41f8 <xQueueGenericSend+0x7c>
    41f6:	42 c0       	rjmp	.+132    	; 0x427c <xQueueGenericSend+0x100>
    41f8:	f2 e0       	ldi	r31, 0x02	; 2
    41fa:	bf 16       	cp	r11, r31
    41fc:	09 f4       	brne	.+2      	; 0x4200 <xQueueGenericSend+0x84>
    41fe:	3e c0       	rjmp	.+124    	; 0x427c <xQueueGenericSend+0x100>
    4200:	8c 81       	ldd	r24, Y+4	; 0x04
    4202:	9d 81       	ldd	r25, Y+5	; 0x05
    4204:	89 2b       	or	r24, r25
    4206:	09 f4       	brne	.+2      	; 0x420a <xQueueGenericSend+0x8e>
    4208:	60 c0       	rjmp	.+192    	; 0x42ca <xQueueGenericSend+0x14e>
    420a:	22 23       	and	r18, r18
    420c:	59 f1       	breq	.+86     	; 0x4264 <xQueueGenericSend+0xe8>
    420e:	0f 90       	pop	r0
    4210:	0f be       	out	0x3f, r0	; 63
    4212:	0e 94 4e 29 	call	0x529c	; 0x529c <vTaskSuspendAll>
    4216:	0f b6       	in	r0, 0x3f	; 63
    4218:	f8 94       	cli
    421a:	0f 92       	push	r0
    421c:	f8 01       	movw	r30, r16
    421e:	85 8d       	ldd	r24, Z+29	; 0x1d
    4220:	8f 3f       	cpi	r24, 0xFF	; 255
    4222:	39 f1       	breq	.+78     	; 0x4272 <xQueueGenericSend+0xf6>
    4224:	f8 01       	movw	r30, r16
    4226:	86 8d       	ldd	r24, Z+30	; 0x1e
    4228:	8f 3f       	cpi	r24, 0xFF	; 255
    422a:	09 f1       	breq	.+66     	; 0x426e <xQueueGenericSend+0xf2>
    422c:	0f 90       	pop	r0
    422e:	0f be       	out	0x3f, r0	; 63
    4230:	be 01       	movw	r22, r28
    4232:	6c 5f       	subi	r22, 0xFC	; 252
    4234:	7f 4f       	sbci	r23, 0xFF	; 255
    4236:	ce 01       	movw	r24, r28
    4238:	01 96       	adiw	r24, 0x01	; 1
    423a:	0e 94 e0 2b 	call	0x57c0	; 0x57c0 <xTaskCheckForTimeOut>
    423e:	81 11       	cpse	r24, r1
    4240:	48 c0       	rjmp	.+144    	; 0x42d2 <xQueueGenericSend+0x156>
    4242:	0f b6       	in	r0, 0x3f	; 63
    4244:	f8 94       	cli
    4246:	0f 92       	push	r0
    4248:	f8 01       	movw	r30, r16
    424a:	92 8d       	ldd	r25, Z+26	; 0x1a
    424c:	0f 90       	pop	r0
    424e:	0f be       	out	0x3f, r0	; 63
    4250:	83 8d       	ldd	r24, Z+27	; 0x1b
    4252:	98 17       	cp	r25, r24
    4254:	09 f4       	brne	.+2      	; 0x4258 <xQueueGenericSend+0xdc>
    4256:	b8 cf       	rjmp	.-144    	; 0x41c8 <xQueueGenericSend+0x4c>
    4258:	c8 01       	movw	r24, r16
    425a:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <prvUnlockQueue>
    425e:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>
    4262:	bf cf       	rjmp	.-130    	; 0x41e2 <xQueueGenericSend+0x66>
    4264:	ce 01       	movw	r24, r28
    4266:	01 96       	adiw	r24, 0x01	; 1
    4268:	0e 94 d5 2b 	call	0x57aa	; 0x57aa <vTaskInternalSetTimeOutState>
    426c:	d0 cf       	rjmp	.-96     	; 0x420e <xQueueGenericSend+0x92>
    426e:	16 8e       	std	Z+30, r1	; 0x1e
    4270:	dd cf       	rjmp	.-70     	; 0x422c <xQueueGenericSend+0xb0>
    4272:	15 8e       	std	Z+29, r1	; 0x1d
    4274:	d7 cf       	rjmp	.-82     	; 0x4224 <xQueueGenericSend+0xa8>
    4276:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vPortYield>
    427a:	b3 cf       	rjmp	.-154    	; 0x41e2 <xQueueGenericSend+0x66>
    427c:	4b 2d       	mov	r20, r11
    427e:	b6 01       	movw	r22, r12
    4280:	c8 01       	movw	r24, r16
    4282:	0e 94 68 1f 	call	0x3ed0	; 0x3ed0 <prvCopyDataToQueue>
    4286:	f8 01       	movw	r30, r16
    4288:	91 89       	ldd	r25, Z+17	; 0x11
    428a:	91 11       	cpse	r25, r1
    428c:	2c c0       	rjmp	.+88     	; 0x42e6 <xQueueGenericSend+0x16a>
    428e:	81 11       	cpse	r24, r1
    4290:	27 c0       	rjmp	.+78     	; 0x42e0 <xQueueGenericSend+0x164>
    4292:	0f 90       	pop	r0
    4294:	0f be       	out	0x3f, r0	; 63
    4296:	81 e0       	ldi	r24, 0x01	; 1
    4298:	25 96       	adiw	r28, 0x05	; 5
    429a:	cd bf       	out	0x3d, r28	; 61
    429c:	de bf       	out	0x3e, r29	; 62
    429e:	df 91       	pop	r29
    42a0:	cf 91       	pop	r28
    42a2:	1f 91       	pop	r17
    42a4:	0f 91       	pop	r16
    42a6:	ff 90       	pop	r15
    42a8:	ef 90       	pop	r14
    42aa:	df 90       	pop	r13
    42ac:	cf 90       	pop	r12
    42ae:	bf 90       	pop	r11
    42b0:	08 95       	ret
    42b2:	f8 01       	movw	r30, r16
    42b4:	83 8d       	ldd	r24, Z+27	; 0x1b
    42b6:	81 30       	cpi	r24, 0x01	; 1
    42b8:	09 f4       	brne	.+2      	; 0x42bc <xQueueGenericSend+0x140>
    42ba:	80 cf       	rjmp	.-256    	; 0x41bc <xQueueGenericSend+0x40>
    42bc:	63 ef       	ldi	r22, 0xF3	; 243
    42be:	72 e0       	ldi	r23, 0x02	; 2
    42c0:	8a ec       	ldi	r24, 0xCA	; 202
    42c2:	93 e2       	ldi	r25, 0x23	; 35
    42c4:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    42c8:	77 cf       	rjmp	.-274    	; 0x41b8 <xQueueGenericSend+0x3c>
    42ca:	0f 90       	pop	r0
    42cc:	0f be       	out	0x3f, r0	; 63
    42ce:	80 e0       	ldi	r24, 0x00	; 0
    42d0:	e3 cf       	rjmp	.-58     	; 0x4298 <xQueueGenericSend+0x11c>
    42d2:	c8 01       	movw	r24, r16
    42d4:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <prvUnlockQueue>
    42d8:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>
    42dc:	80 e0       	ldi	r24, 0x00	; 0
    42de:	dc cf       	rjmp	.-72     	; 0x4298 <xQueueGenericSend+0x11c>
    42e0:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vPortYield>
    42e4:	d6 cf       	rjmp	.-84     	; 0x4292 <xQueueGenericSend+0x116>
    42e6:	c8 01       	movw	r24, r16
    42e8:	41 96       	adiw	r24, 0x11	; 17
    42ea:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <xTaskRemoveFromEventList>
    42ee:	88 23       	and	r24, r24
    42f0:	81 f2       	breq	.-96     	; 0x4292 <xQueueGenericSend+0x116>
    42f2:	f6 cf       	rjmp	.-20     	; 0x42e0 <xQueueGenericSend+0x164>
    42f4:	f8 01       	movw	r30, r16
    42f6:	84 8d       	ldd	r24, Z+28	; 0x1c
    42f8:	88 23       	and	r24, r24
    42fa:	09 f4       	brne	.+2      	; 0x42fe <xQueueGenericSend+0x182>
    42fc:	59 cf       	rjmp	.-334    	; 0x41b0 <xQueueGenericSend+0x34>
    42fe:	62 ef       	ldi	r22, 0xF2	; 242
    4300:	72 e0       	ldi	r23, 0x02	; 2
    4302:	8a ec       	ldi	r24, 0xCA	; 202
    4304:	93 e2       	ldi	r25, 0x23	; 35
    4306:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    430a:	52 cf       	rjmp	.-348    	; 0x41b0 <xQueueGenericSend+0x34>
    430c:	61 ef       	ldi	r22, 0xF1	; 241
    430e:	72 e0       	ldi	r23, 0x02	; 2
    4310:	8a ec       	ldi	r24, 0xCA	; 202
    4312:	93 e2       	ldi	r25, 0x23	; 35
    4314:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    4318:	47 cf       	rjmp	.-370    	; 0x41a8 <xQueueGenericSend+0x2c>

0000431a <xQueueCreateMutex>:
    431a:	cf 93       	push	r28
    431c:	df 93       	push	r29
    431e:	48 2f       	mov	r20, r24
    4320:	60 e0       	ldi	r22, 0x00	; 0
    4322:	81 e0       	ldi	r24, 0x01	; 1
    4324:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueGenericCreate>
    4328:	ec 01       	movw	r28, r24
    432a:	00 97       	sbiw	r24, 0x00	; 0
    432c:	61 f0       	breq	.+24     	; 0x4346 <xQueueCreateMutex+0x2c>
    432e:	1c 82       	std	Y+4, r1	; 0x04
    4330:	1d 82       	std	Y+5, r1	; 0x05
    4332:	18 82       	st	Y, r1
    4334:	19 82       	std	Y+1, r1	; 0x01
    4336:	1e 82       	std	Y+6, r1	; 0x06
    4338:	20 e0       	ldi	r18, 0x00	; 0
    433a:	40 e0       	ldi	r20, 0x00	; 0
    433c:	50 e0       	ldi	r21, 0x00	; 0
    433e:	60 e0       	ldi	r22, 0x00	; 0
    4340:	70 e0       	ldi	r23, 0x00	; 0
    4342:	0e 94 be 20 	call	0x417c	; 0x417c <xQueueGenericSend>
    4346:	ce 01       	movw	r24, r28
    4348:	df 91       	pop	r29
    434a:	cf 91       	pop	r28
    434c:	08 95       	ret

0000434e <xQueueGenericSendFromISR>:
    434e:	cf 92       	push	r12
    4350:	df 92       	push	r13
    4352:	ef 92       	push	r14
    4354:	ff 92       	push	r15
    4356:	0f 93       	push	r16
    4358:	1f 93       	push	r17
    435a:	cf 93       	push	r28
    435c:	df 93       	push	r29
    435e:	ec 01       	movw	r28, r24
    4360:	8b 01       	movw	r16, r22
    4362:	6a 01       	movw	r12, r20
    4364:	f2 2e       	mov	r15, r18
    4366:	89 2b       	or	r24, r25
    4368:	09 f4       	brne	.+2      	; 0x436c <xQueueGenericSendFromISR+0x1e>
    436a:	45 c0       	rjmp	.+138    	; 0x43f6 <xQueueGenericSendFromISR+0xa8>
    436c:	01 15       	cp	r16, r1
    436e:	11 05       	cpc	r17, r1
    4370:	c1 f1       	breq	.+112    	; 0x43e2 <xQueueGenericSendFromISR+0x94>
    4372:	82 e0       	ldi	r24, 0x02	; 2
    4374:	f8 16       	cp	r15, r24
    4376:	71 f0       	breq	.+28     	; 0x4394 <xQueueGenericSendFromISR+0x46>
    4378:	9a 8d       	ldd	r25, Y+26	; 0x1a
    437a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    437c:	98 17       	cp	r25, r24
    437e:	a0 f0       	brcs	.+40     	; 0x43a8 <xQueueGenericSendFromISR+0x5a>
    4380:	80 e0       	ldi	r24, 0x00	; 0
    4382:	df 91       	pop	r29
    4384:	cf 91       	pop	r28
    4386:	1f 91       	pop	r17
    4388:	0f 91       	pop	r16
    438a:	ff 90       	pop	r15
    438c:	ef 90       	pop	r14
    438e:	df 90       	pop	r13
    4390:	cf 90       	pop	r12
    4392:	08 95       	ret
    4394:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4396:	81 30       	cpi	r24, 0x01	; 1
    4398:	31 f0       	breq	.+12     	; 0x43a6 <xQueueGenericSendFromISR+0x58>
    439a:	65 ec       	ldi	r22, 0xC5	; 197
    439c:	73 e0       	ldi	r23, 0x03	; 3
    439e:	8a ec       	ldi	r24, 0xCA	; 202
    43a0:	93 e2       	ldi	r25, 0x23	; 35
    43a2:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    43a6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    43a8:	ee 8c       	ldd	r14, Y+30	; 0x1e
    43aa:	4f 2d       	mov	r20, r15
    43ac:	b8 01       	movw	r22, r16
    43ae:	ce 01       	movw	r24, r28
    43b0:	0e 94 68 1f 	call	0x3ed0	; 0x3ed0 <prvCopyDataToQueue>
    43b4:	ef ef       	ldi	r30, 0xFF	; 255
    43b6:	ee 16       	cp	r14, r30
    43b8:	21 f0       	breq	.+8      	; 0x43c2 <xQueueGenericSendFromISR+0x74>
    43ba:	e3 94       	inc	r14
    43bc:	ee 8e       	std	Y+30, r14	; 0x1e
    43be:	81 e0       	ldi	r24, 0x01	; 1
    43c0:	e0 cf       	rjmp	.-64     	; 0x4382 <xQueueGenericSendFromISR+0x34>
    43c2:	89 89       	ldd	r24, Y+17	; 0x11
    43c4:	88 23       	and	r24, r24
    43c6:	d9 f3       	breq	.-10     	; 0x43be <xQueueGenericSendFromISR+0x70>
    43c8:	ce 01       	movw	r24, r28
    43ca:	41 96       	adiw	r24, 0x11	; 17
    43cc:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <xTaskRemoveFromEventList>
    43d0:	88 23       	and	r24, r24
    43d2:	a9 f3       	breq	.-22     	; 0x43be <xQueueGenericSendFromISR+0x70>
    43d4:	c1 14       	cp	r12, r1
    43d6:	d1 04       	cpc	r13, r1
    43d8:	91 f3       	breq	.-28     	; 0x43be <xQueueGenericSendFromISR+0x70>
    43da:	81 e0       	ldi	r24, 0x01	; 1
    43dc:	f6 01       	movw	r30, r12
    43de:	80 83       	st	Z, r24
    43e0:	d0 cf       	rjmp	.-96     	; 0x4382 <xQueueGenericSendFromISR+0x34>
    43e2:	8c 8d       	ldd	r24, Y+28	; 0x1c
    43e4:	88 23       	and	r24, r24
    43e6:	29 f2       	breq	.-118    	; 0x4372 <xQueueGenericSendFromISR+0x24>
    43e8:	64 ec       	ldi	r22, 0xC4	; 196
    43ea:	73 e0       	ldi	r23, 0x03	; 3
    43ec:	8a ec       	ldi	r24, 0xCA	; 202
    43ee:	93 e2       	ldi	r25, 0x23	; 35
    43f0:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    43f4:	be cf       	rjmp	.-132    	; 0x4372 <xQueueGenericSendFromISR+0x24>
    43f6:	63 ec       	ldi	r22, 0xC3	; 195
    43f8:	73 e0       	ldi	r23, 0x03	; 3
    43fa:	8a ec       	ldi	r24, 0xCA	; 202
    43fc:	93 e2       	ldi	r25, 0x23	; 35
    43fe:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    4402:	b4 cf       	rjmp	.-152    	; 0x436c <xQueueGenericSendFromISR+0x1e>

00004404 <xQueueGiveFromISR>:
    4404:	0f 93       	push	r16
    4406:	1f 93       	push	r17
    4408:	cf 93       	push	r28
    440a:	df 93       	push	r29
    440c:	ec 01       	movw	r28, r24
    440e:	8b 01       	movw	r16, r22
    4410:	89 2b       	or	r24, r25
    4412:	09 f4       	brne	.+2      	; 0x4416 <xQueueGiveFromISR+0x12>
    4414:	43 c0       	rjmp	.+134    	; 0x449c <xQueueGiveFromISR+0x98>
    4416:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4418:	81 11       	cpse	r24, r1
    441a:	1b c0       	rjmp	.+54     	; 0x4452 <xQueueGiveFromISR+0x4e>
    441c:	88 81       	ld	r24, Y
    441e:	99 81       	ldd	r25, Y+1	; 0x01
    4420:	89 2b       	or	r24, r25
    4422:	09 f1       	breq	.+66     	; 0x4466 <xQueueGiveFromISR+0x62>
    4424:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4426:	9b 8d       	ldd	r25, Y+27	; 0x1b
    4428:	89 17       	cp	r24, r25
    442a:	68 f4       	brcc	.+26     	; 0x4446 <xQueueGiveFromISR+0x42>
    442c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    442e:	8f 5f       	subi	r24, 0xFF	; 255
    4430:	8a 8f       	std	Y+26, r24	; 0x1a
    4432:	9f 3f       	cpi	r25, 0xFF	; 255
    4434:	19 f1       	breq	.+70     	; 0x447c <xQueueGiveFromISR+0x78>
    4436:	9f 5f       	subi	r25, 0xFF	; 255
    4438:	9e 8f       	std	Y+30, r25	; 0x1e
    443a:	81 e0       	ldi	r24, 0x01	; 1
    443c:	df 91       	pop	r29
    443e:	cf 91       	pop	r28
    4440:	1f 91       	pop	r17
    4442:	0f 91       	pop	r16
    4444:	08 95       	ret
    4446:	80 e0       	ldi	r24, 0x00	; 0
    4448:	df 91       	pop	r29
    444a:	cf 91       	pop	r28
    444c:	1f 91       	pop	r17
    444e:	0f 91       	pop	r16
    4450:	08 95       	ret
    4452:	64 e6       	ldi	r22, 0x64	; 100
    4454:	74 e0       	ldi	r23, 0x04	; 4
    4456:	8a ec       	ldi	r24, 0xCA	; 202
    4458:	93 e2       	ldi	r25, 0x23	; 35
    445a:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    445e:	88 81       	ld	r24, Y
    4460:	99 81       	ldd	r25, Y+1	; 0x01
    4462:	89 2b       	or	r24, r25
    4464:	f9 f6       	brne	.-66     	; 0x4424 <xQueueGiveFromISR+0x20>
    4466:	8c 81       	ldd	r24, Y+4	; 0x04
    4468:	9d 81       	ldd	r25, Y+5	; 0x05
    446a:	89 2b       	or	r24, r25
    446c:	d9 f2       	breq	.-74     	; 0x4424 <xQueueGiveFromISR+0x20>
    446e:	69 e6       	ldi	r22, 0x69	; 105
    4470:	74 e0       	ldi	r23, 0x04	; 4
    4472:	8a ec       	ldi	r24, 0xCA	; 202
    4474:	93 e2       	ldi	r25, 0x23	; 35
    4476:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    447a:	d4 cf       	rjmp	.-88     	; 0x4424 <xQueueGiveFromISR+0x20>
    447c:	89 89       	ldd	r24, Y+17	; 0x11
    447e:	88 23       	and	r24, r24
    4480:	e1 f2       	breq	.-72     	; 0x443a <xQueueGiveFromISR+0x36>
    4482:	ce 01       	movw	r24, r28
    4484:	41 96       	adiw	r24, 0x11	; 17
    4486:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <xTaskRemoveFromEventList>
    448a:	88 23       	and	r24, r24
    448c:	b1 f2       	breq	.-84     	; 0x443a <xQueueGiveFromISR+0x36>
    448e:	01 15       	cp	r16, r1
    4490:	11 05       	cpc	r17, r1
    4492:	99 f2       	breq	.-90     	; 0x443a <xQueueGiveFromISR+0x36>
    4494:	81 e0       	ldi	r24, 0x01	; 1
    4496:	f8 01       	movw	r30, r16
    4498:	80 83       	st	Z, r24
    449a:	d0 cf       	rjmp	.-96     	; 0x443c <xQueueGiveFromISR+0x38>
    449c:	60 e6       	ldi	r22, 0x60	; 96
    449e:	74 e0       	ldi	r23, 0x04	; 4
    44a0:	8a ec       	ldi	r24, 0xCA	; 202
    44a2:	93 e2       	ldi	r25, 0x23	; 35
    44a4:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    44a8:	b6 cf       	rjmp	.-148    	; 0x4416 <xQueueGiveFromISR+0x12>

000044aa <xQueueReceive>:
    44aa:	af 92       	push	r10
    44ac:	bf 92       	push	r11
    44ae:	cf 92       	push	r12
    44b0:	df 92       	push	r13
    44b2:	ff 92       	push	r15
    44b4:	0f 93       	push	r16
    44b6:	1f 93       	push	r17
    44b8:	cf 93       	push	r28
    44ba:	df 93       	push	r29
    44bc:	cd b7       	in	r28, 0x3d	; 61
    44be:	de b7       	in	r29, 0x3e	; 62
    44c0:	25 97       	sbiw	r28, 0x05	; 5
    44c2:	cd bf       	out	0x3d, r28	; 61
    44c4:	de bf       	out	0x3e, r29	; 62
    44c6:	8c 01       	movw	r16, r24
    44c8:	5b 01       	movw	r10, r22
    44ca:	4c 83       	std	Y+4, r20	; 0x04
    44cc:	5d 83       	std	Y+5, r21	; 0x05
    44ce:	89 2b       	or	r24, r25
    44d0:	09 f4       	brne	.+2      	; 0x44d4 <xQueueReceive+0x2a>
    44d2:	a1 c0       	rjmp	.+322    	; 0x4616 <xQueueReceive+0x16c>
    44d4:	a1 14       	cp	r10, r1
    44d6:	b1 04       	cpc	r11, r1
    44d8:	09 f4       	brne	.+2      	; 0x44dc <xQueueReceive+0x32>
    44da:	91 c0       	rjmp	.+290    	; 0x45fe <xQueueReceive+0x154>
    44dc:	20 e0       	ldi	r18, 0x00	; 0
    44de:	68 01       	movw	r12, r16
    44e0:	f1 e1       	ldi	r31, 0x11	; 17
    44e2:	cf 0e       	add	r12, r31
    44e4:	d1 1c       	adc	r13, r1
    44e6:	0f b6       	in	r0, 0x3f	; 63
    44e8:	f8 94       	cli
    44ea:	0f 92       	push	r0
    44ec:	f8 01       	movw	r30, r16
    44ee:	f2 8c       	ldd	r15, Z+26	; 0x1a
    44f0:	f1 10       	cpse	r15, r1
    44f2:	6a c0       	rjmp	.+212    	; 0x45c8 <xQueueReceive+0x11e>
    44f4:	8c 81       	ldd	r24, Y+4	; 0x04
    44f6:	9d 81       	ldd	r25, Y+5	; 0x05
    44f8:	89 2b       	or	r24, r25
    44fa:	09 f4       	brne	.+2      	; 0x44fe <xQueueReceive+0x54>
    44fc:	73 c0       	rjmp	.+230    	; 0x45e4 <xQueueReceive+0x13a>
    44fe:	22 23       	and	r18, r18
    4500:	09 f4       	brne	.+2      	; 0x4504 <xQueueReceive+0x5a>
    4502:	59 c0       	rjmp	.+178    	; 0x45b6 <xQueueReceive+0x10c>
    4504:	0f 90       	pop	r0
    4506:	0f be       	out	0x3f, r0	; 63
    4508:	0e 94 4e 29 	call	0x529c	; 0x529c <vTaskSuspendAll>
    450c:	0f b6       	in	r0, 0x3f	; 63
    450e:	f8 94       	cli
    4510:	0f 92       	push	r0
    4512:	f8 01       	movw	r30, r16
    4514:	85 8d       	ldd	r24, Z+29	; 0x1d
    4516:	8f 3f       	cpi	r24, 0xFF	; 255
    4518:	09 f4       	brne	.+2      	; 0x451c <xQueueReceive+0x72>
    451a:	54 c0       	rjmp	.+168    	; 0x45c4 <xQueueReceive+0x11a>
    451c:	f8 01       	movw	r30, r16
    451e:	86 8d       	ldd	r24, Z+30	; 0x1e
    4520:	8f 3f       	cpi	r24, 0xFF	; 255
    4522:	09 f4       	brne	.+2      	; 0x4526 <xQueueReceive+0x7c>
    4524:	4d c0       	rjmp	.+154    	; 0x45c0 <xQueueReceive+0x116>
    4526:	0f 90       	pop	r0
    4528:	0f be       	out	0x3f, r0	; 63
    452a:	be 01       	movw	r22, r28
    452c:	6c 5f       	subi	r22, 0xFC	; 252
    452e:	7f 4f       	sbci	r23, 0xFF	; 255
    4530:	ce 01       	movw	r24, r28
    4532:	01 96       	adiw	r24, 0x01	; 1
    4534:	0e 94 e0 2b 	call	0x57c0	; 0x57c0 <xTaskCheckForTimeOut>
    4538:	81 11       	cpse	r24, r1
    453a:	22 c0       	rjmp	.+68     	; 0x4580 <xQueueReceive+0xd6>
    453c:	0f b6       	in	r0, 0x3f	; 63
    453e:	f8 94       	cli
    4540:	0f 92       	push	r0
    4542:	f8 01       	movw	r30, r16
    4544:	82 8d       	ldd	r24, Z+26	; 0x1a
    4546:	0f 90       	pop	r0
    4548:	0f be       	out	0x3f, r0	; 63
    454a:	81 11       	cpse	r24, r1
    454c:	12 c0       	rjmp	.+36     	; 0x4572 <xQueueReceive+0xc8>
    454e:	6c 81       	ldd	r22, Y+4	; 0x04
    4550:	7d 81       	ldd	r23, Y+5	; 0x05
    4552:	c6 01       	movw	r24, r12
    4554:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <vTaskPlaceOnEventList>
    4558:	c8 01       	movw	r24, r16
    455a:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <prvUnlockQueue>
    455e:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>
    4562:	88 23       	and	r24, r24
    4564:	11 f0       	breq	.+4      	; 0x456a <xQueueReceive+0xc0>
    4566:	21 e0       	ldi	r18, 0x01	; 1
    4568:	be cf       	rjmp	.-132    	; 0x44e6 <xQueueReceive+0x3c>
    456a:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vPortYield>
    456e:	21 e0       	ldi	r18, 0x01	; 1
    4570:	ba cf       	rjmp	.-140    	; 0x44e6 <xQueueReceive+0x3c>
    4572:	c8 01       	movw	r24, r16
    4574:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <prvUnlockQueue>
    4578:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>
    457c:	21 e0       	ldi	r18, 0x01	; 1
    457e:	b3 cf       	rjmp	.-154    	; 0x44e6 <xQueueReceive+0x3c>
    4580:	c8 01       	movw	r24, r16
    4582:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <prvUnlockQueue>
    4586:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>
    458a:	0f b6       	in	r0, 0x3f	; 63
    458c:	f8 94       	cli
    458e:	0f 92       	push	r0
    4590:	f8 01       	movw	r30, r16
    4592:	82 8d       	ldd	r24, Z+26	; 0x1a
    4594:	0f 90       	pop	r0
    4596:	0f be       	out	0x3f, r0	; 63
    4598:	81 11       	cpse	r24, r1
    459a:	e5 cf       	rjmp	.-54     	; 0x4566 <xQueueReceive+0xbc>
    459c:	25 96       	adiw	r28, 0x05	; 5
    459e:	cd bf       	out	0x3d, r28	; 61
    45a0:	de bf       	out	0x3e, r29	; 62
    45a2:	df 91       	pop	r29
    45a4:	cf 91       	pop	r28
    45a6:	1f 91       	pop	r17
    45a8:	0f 91       	pop	r16
    45aa:	ff 90       	pop	r15
    45ac:	df 90       	pop	r13
    45ae:	cf 90       	pop	r12
    45b0:	bf 90       	pop	r11
    45b2:	af 90       	pop	r10
    45b4:	08 95       	ret
    45b6:	ce 01       	movw	r24, r28
    45b8:	01 96       	adiw	r24, 0x01	; 1
    45ba:	0e 94 d5 2b 	call	0x57aa	; 0x57aa <vTaskInternalSetTimeOutState>
    45be:	a2 cf       	rjmp	.-188    	; 0x4504 <xQueueReceive+0x5a>
    45c0:	16 8e       	std	Z+30, r1	; 0x1e
    45c2:	b1 cf       	rjmp	.-158    	; 0x4526 <xQueueReceive+0x7c>
    45c4:	15 8e       	std	Z+29, r1	; 0x1d
    45c6:	aa cf       	rjmp	.-172    	; 0x451c <xQueueReceive+0x72>
    45c8:	b5 01       	movw	r22, r10
    45ca:	c8 01       	movw	r24, r16
    45cc:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <prvCopyDataFromQueue>
    45d0:	fa 94       	dec	r15
    45d2:	f8 01       	movw	r30, r16
    45d4:	f2 8e       	std	Z+26, r15	; 0x1a
    45d6:	80 85       	ldd	r24, Z+8	; 0x08
    45d8:	81 11       	cpse	r24, r1
    45da:	08 c0       	rjmp	.+16     	; 0x45ec <xQueueReceive+0x142>
    45dc:	0f 90       	pop	r0
    45de:	0f be       	out	0x3f, r0	; 63
    45e0:	81 e0       	ldi	r24, 0x01	; 1
    45e2:	dc cf       	rjmp	.-72     	; 0x459c <xQueueReceive+0xf2>
    45e4:	0f 90       	pop	r0
    45e6:	0f be       	out	0x3f, r0	; 63
    45e8:	80 e0       	ldi	r24, 0x00	; 0
    45ea:	d8 cf       	rjmp	.-80     	; 0x459c <xQueueReceive+0xf2>
    45ec:	c8 01       	movw	r24, r16
    45ee:	08 96       	adiw	r24, 0x08	; 8
    45f0:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <xTaskRemoveFromEventList>
    45f4:	88 23       	and	r24, r24
    45f6:	91 f3       	breq	.-28     	; 0x45dc <xQueueReceive+0x132>
    45f8:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vPortYield>
    45fc:	ef cf       	rjmp	.-34     	; 0x45dc <xQueueReceive+0x132>
    45fe:	f8 01       	movw	r30, r16
    4600:	84 8d       	ldd	r24, Z+28	; 0x1c
    4602:	88 23       	and	r24, r24
    4604:	09 f4       	brne	.+2      	; 0x4608 <xQueueReceive+0x15e>
    4606:	6a cf       	rjmp	.-300    	; 0x44dc <xQueueReceive+0x32>
    4608:	64 e0       	ldi	r22, 0x04	; 4
    460a:	75 e0       	ldi	r23, 0x05	; 5
    460c:	8a ec       	ldi	r24, 0xCA	; 202
    460e:	93 e2       	ldi	r25, 0x23	; 35
    4610:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    4614:	63 cf       	rjmp	.-314    	; 0x44dc <xQueueReceive+0x32>
    4616:	60 e0       	ldi	r22, 0x00	; 0
    4618:	75 e0       	ldi	r23, 0x05	; 5
    461a:	8a ec       	ldi	r24, 0xCA	; 202
    461c:	93 e2       	ldi	r25, 0x23	; 35
    461e:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    4622:	58 cf       	rjmp	.-336    	; 0x44d4 <xQueueReceive+0x2a>

00004624 <xQueueSemaphoreTake>:
    4624:	df 92       	push	r13
    4626:	ef 92       	push	r14
    4628:	ff 92       	push	r15
    462a:	0f 93       	push	r16
    462c:	1f 93       	push	r17
    462e:	cf 93       	push	r28
    4630:	df 93       	push	r29
    4632:	cd b7       	in	r28, 0x3d	; 61
    4634:	de b7       	in	r29, 0x3e	; 62
    4636:	25 97       	sbiw	r28, 0x05	; 5
    4638:	cd bf       	out	0x3d, r28	; 61
    463a:	de bf       	out	0x3e, r29	; 62
    463c:	8c 01       	movw	r16, r24
    463e:	6c 83       	std	Y+4, r22	; 0x04
    4640:	7d 83       	std	Y+5, r23	; 0x05
    4642:	89 2b       	or	r24, r25
    4644:	09 f4       	brne	.+2      	; 0x4648 <xQueueSemaphoreTake+0x24>
    4646:	d0 c0       	rjmp	.+416    	; 0x47e8 <xQueueSemaphoreTake+0x1c4>
    4648:	d8 01       	movw	r26, r16
    464a:	5c 96       	adiw	r26, 0x1c	; 28
    464c:	8c 91       	ld	r24, X
    464e:	81 11       	cpse	r24, r1
    4650:	bb c0       	rjmp	.+374    	; 0x47c8 <xQueueSemaphoreTake+0x1a4>
    4652:	d1 2c       	mov	r13, r1
    4654:	20 e0       	ldi	r18, 0x00	; 0
    4656:	78 01       	movw	r14, r16
    4658:	b1 e1       	ldi	r27, 0x11	; 17
    465a:	eb 0e       	add	r14, r27
    465c:	f1 1c       	adc	r15, r1
    465e:	0f b6       	in	r0, 0x3f	; 63
    4660:	f8 94       	cli
    4662:	0f 92       	push	r0
    4664:	f8 01       	movw	r30, r16
    4666:	82 8d       	ldd	r24, Z+26	; 0x1a
    4668:	81 11       	cpse	r24, r1
    466a:	89 c0       	rjmp	.+274    	; 0x477e <xQueueSemaphoreTake+0x15a>
    466c:	8c 81       	ldd	r24, Y+4	; 0x04
    466e:	9d 81       	ldd	r25, Y+5	; 0x05
    4670:	89 2b       	or	r24, r25
    4672:	09 f4       	brne	.+2      	; 0x4676 <xQueueSemaphoreTake+0x52>
    4674:	9d c0       	rjmp	.+314    	; 0x47b0 <xQueueSemaphoreTake+0x18c>
    4676:	22 23       	and	r18, r18
    4678:	09 f4       	brne	.+2      	; 0x467c <xQueueSemaphoreTake+0x58>
    467a:	5f c0       	rjmp	.+190    	; 0x473a <xQueueSemaphoreTake+0x116>
    467c:	0f 90       	pop	r0
    467e:	0f be       	out	0x3f, r0	; 63
    4680:	0e 94 4e 29 	call	0x529c	; 0x529c <vTaskSuspendAll>
    4684:	0f b6       	in	r0, 0x3f	; 63
    4686:	f8 94       	cli
    4688:	0f 92       	push	r0
    468a:	d8 01       	movw	r26, r16
    468c:	5d 96       	adiw	r26, 0x1d	; 29
    468e:	8c 91       	ld	r24, X
    4690:	5d 97       	sbiw	r26, 0x1d	; 29
    4692:	8f 3f       	cpi	r24, 0xFF	; 255
    4694:	09 f4       	brne	.+2      	; 0x4698 <xQueueSemaphoreTake+0x74>
    4696:	56 c0       	rjmp	.+172    	; 0x4744 <xQueueSemaphoreTake+0x120>
    4698:	f8 01       	movw	r30, r16
    469a:	86 8d       	ldd	r24, Z+30	; 0x1e
    469c:	8f 3f       	cpi	r24, 0xFF	; 255
    469e:	09 f4       	brne	.+2      	; 0x46a2 <xQueueSemaphoreTake+0x7e>
    46a0:	58 c0       	rjmp	.+176    	; 0x4752 <xQueueSemaphoreTake+0x12e>
    46a2:	0f 90       	pop	r0
    46a4:	0f be       	out	0x3f, r0	; 63
    46a6:	be 01       	movw	r22, r28
    46a8:	6c 5f       	subi	r22, 0xFC	; 252
    46aa:	7f 4f       	sbci	r23, 0xFF	; 255
    46ac:	ce 01       	movw	r24, r28
    46ae:	01 96       	adiw	r24, 0x01	; 1
    46b0:	0e 94 e0 2b 	call	0x57c0	; 0x57c0 <xTaskCheckForTimeOut>
    46b4:	81 11       	cpse	r24, r1
    46b6:	23 c0       	rjmp	.+70     	; 0x46fe <xQueueSemaphoreTake+0xda>
    46b8:	0f b6       	in	r0, 0x3f	; 63
    46ba:	f8 94       	cli
    46bc:	0f 92       	push	r0
    46be:	d8 01       	movw	r26, r16
    46c0:	5a 96       	adiw	r26, 0x1a	; 26
    46c2:	8c 91       	ld	r24, X
    46c4:	5a 97       	sbiw	r26, 0x1a	; 26
    46c6:	0f 90       	pop	r0
    46c8:	0f be       	out	0x3f, r0	; 63
    46ca:	81 11       	cpse	r24, r1
    46cc:	44 c0       	rjmp	.+136    	; 0x4756 <xQueueSemaphoreTake+0x132>
    46ce:	f8 01       	movw	r30, r16
    46d0:	80 81       	ld	r24, Z
    46d2:	91 81       	ldd	r25, Z+1	; 0x01
    46d4:	89 2b       	or	r24, r25
    46d6:	09 f4       	brne	.+2      	; 0x46da <xQueueSemaphoreTake+0xb6>
    46d8:	45 c0       	rjmp	.+138    	; 0x4764 <xQueueSemaphoreTake+0x140>
    46da:	6c 81       	ldd	r22, Y+4	; 0x04
    46dc:	7d 81       	ldd	r23, Y+5	; 0x05
    46de:	c7 01       	movw	r24, r14
    46e0:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <vTaskPlaceOnEventList>
    46e4:	c8 01       	movw	r24, r16
    46e6:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <prvUnlockQueue>
    46ea:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>
    46ee:	88 23       	and	r24, r24
    46f0:	11 f0       	breq	.+4      	; 0x46f6 <xQueueSemaphoreTake+0xd2>
    46f2:	21 e0       	ldi	r18, 0x01	; 1
    46f4:	b4 cf       	rjmp	.-152    	; 0x465e <xQueueSemaphoreTake+0x3a>
    46f6:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vPortYield>
    46fa:	21 e0       	ldi	r18, 0x01	; 1
    46fc:	b0 cf       	rjmp	.-160    	; 0x465e <xQueueSemaphoreTake+0x3a>
    46fe:	c8 01       	movw	r24, r16
    4700:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <prvUnlockQueue>
    4704:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>
    4708:	0f b6       	in	r0, 0x3f	; 63
    470a:	f8 94       	cli
    470c:	0f 92       	push	r0
    470e:	f8 01       	movw	r30, r16
    4710:	82 8d       	ldd	r24, Z+26	; 0x1a
    4712:	0f 90       	pop	r0
    4714:	0f be       	out	0x3f, r0	; 63
    4716:	81 11       	cpse	r24, r1
    4718:	ec cf       	rjmp	.-40     	; 0x46f2 <xQueueSemaphoreTake+0xce>
    471a:	dd 20       	and	r13, r13
    471c:	09 f4       	brne	.+2      	; 0x4720 <xQueueSemaphoreTake+0xfc>
    471e:	72 c0       	rjmp	.+228    	; 0x4804 <xQueueSemaphoreTake+0x1e0>
    4720:	0f b6       	in	r0, 0x3f	; 63
    4722:	f8 94       	cli
    4724:	0f 92       	push	r0
    4726:	81 89       	ldd	r24, Z+17	; 0x11
    4728:	81 11       	cpse	r24, r1
    472a:	65 c0       	rjmp	.+202    	; 0x47f6 <xQueueSemaphoreTake+0x1d2>
    472c:	60 e0       	ldi	r22, 0x00	; 0
    472e:	f8 01       	movw	r30, r16
    4730:	84 81       	ldd	r24, Z+4	; 0x04
    4732:	95 81       	ldd	r25, Z+5	; 0x05
    4734:	0e 94 9f 2e 	call	0x5d3e	; 0x5d3e <vTaskPriorityDisinheritAfterTimeout>
    4738:	43 c0       	rjmp	.+134    	; 0x47c0 <xQueueSemaphoreTake+0x19c>
    473a:	ce 01       	movw	r24, r28
    473c:	01 96       	adiw	r24, 0x01	; 1
    473e:	0e 94 d5 2b 	call	0x57aa	; 0x57aa <vTaskInternalSetTimeOutState>
    4742:	9c cf       	rjmp	.-200    	; 0x467c <xQueueSemaphoreTake+0x58>
    4744:	5d 96       	adiw	r26, 0x1d	; 29
    4746:	1c 92       	st	X, r1
    4748:	f8 01       	movw	r30, r16
    474a:	86 8d       	ldd	r24, Z+30	; 0x1e
    474c:	8f 3f       	cpi	r24, 0xFF	; 255
    474e:	09 f0       	breq	.+2      	; 0x4752 <xQueueSemaphoreTake+0x12e>
    4750:	a8 cf       	rjmp	.-176    	; 0x46a2 <xQueueSemaphoreTake+0x7e>
    4752:	16 8e       	std	Z+30, r1	; 0x1e
    4754:	a6 cf       	rjmp	.-180    	; 0x46a2 <xQueueSemaphoreTake+0x7e>
    4756:	c8 01       	movw	r24, r16
    4758:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <prvUnlockQueue>
    475c:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>
    4760:	21 e0       	ldi	r18, 0x01	; 1
    4762:	7d cf       	rjmp	.-262    	; 0x465e <xQueueSemaphoreTake+0x3a>
    4764:	0f b6       	in	r0, 0x3f	; 63
    4766:	f8 94       	cli
    4768:	0f 92       	push	r0
    476a:	14 96       	adiw	r26, 0x04	; 4
    476c:	8d 91       	ld	r24, X+
    476e:	9c 91       	ld	r25, X
    4770:	15 97       	sbiw	r26, 0x05	; 5
    4772:	0e 94 d5 2d 	call	0x5baa	; 0x5baa <xTaskPriorityInherit>
    4776:	d8 2e       	mov	r13, r24
    4778:	0f 90       	pop	r0
    477a:	0f be       	out	0x3f, r0	; 63
    477c:	ae cf       	rjmp	.-164    	; 0x46da <xQueueSemaphoreTake+0xb6>
    477e:	81 50       	subi	r24, 0x01	; 1
    4780:	82 8f       	std	Z+26, r24	; 0x1a
    4782:	80 81       	ld	r24, Z
    4784:	91 81       	ldd	r25, Z+1	; 0x01
    4786:	89 2b       	or	r24, r25
    4788:	09 f4       	brne	.+2      	; 0x478c <xQueueSemaphoreTake+0x168>
    478a:	3e c0       	rjmp	.+124    	; 0x4808 <xQueueSemaphoreTake+0x1e4>
    478c:	f8 01       	movw	r30, r16
    478e:	80 85       	ldd	r24, Z+8	; 0x08
    4790:	81 11       	cpse	r24, r1
    4792:	21 c0       	rjmp	.+66     	; 0x47d6 <xQueueSemaphoreTake+0x1b2>
    4794:	0f 90       	pop	r0
    4796:	0f be       	out	0x3f, r0	; 63
    4798:	81 e0       	ldi	r24, 0x01	; 1
    479a:	25 96       	adiw	r28, 0x05	; 5
    479c:	cd bf       	out	0x3d, r28	; 61
    479e:	de bf       	out	0x3e, r29	; 62
    47a0:	df 91       	pop	r29
    47a2:	cf 91       	pop	r28
    47a4:	1f 91       	pop	r17
    47a6:	0f 91       	pop	r16
    47a8:	ff 90       	pop	r15
    47aa:	ef 90       	pop	r14
    47ac:	df 90       	pop	r13
    47ae:	08 95       	ret
    47b0:	dd 20       	and	r13, r13
    47b2:	31 f0       	breq	.+12     	; 0x47c0 <xQueueSemaphoreTake+0x19c>
    47b4:	61 ee       	ldi	r22, 0xE1	; 225
    47b6:	75 e0       	ldi	r23, 0x05	; 5
    47b8:	8a ec       	ldi	r24, 0xCA	; 202
    47ba:	93 e2       	ldi	r25, 0x23	; 35
    47bc:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    47c0:	0f 90       	pop	r0
    47c2:	0f be       	out	0x3f, r0	; 63
    47c4:	80 e0       	ldi	r24, 0x00	; 0
    47c6:	e9 cf       	rjmp	.-46     	; 0x479a <xQueueSemaphoreTake+0x176>
    47c8:	65 e9       	ldi	r22, 0x95	; 149
    47ca:	75 e0       	ldi	r23, 0x05	; 5
    47cc:	8a ec       	ldi	r24, 0xCA	; 202
    47ce:	93 e2       	ldi	r25, 0x23	; 35
    47d0:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    47d4:	3e cf       	rjmp	.-388    	; 0x4652 <xQueueSemaphoreTake+0x2e>
    47d6:	c8 01       	movw	r24, r16
    47d8:	08 96       	adiw	r24, 0x08	; 8
    47da:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <xTaskRemoveFromEventList>
    47de:	88 23       	and	r24, r24
    47e0:	c9 f2       	breq	.-78     	; 0x4794 <xQueueSemaphoreTake+0x170>
    47e2:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vPortYield>
    47e6:	d6 cf       	rjmp	.-84     	; 0x4794 <xQueueSemaphoreTake+0x170>
    47e8:	61 e9       	ldi	r22, 0x91	; 145
    47ea:	75 e0       	ldi	r23, 0x05	; 5
    47ec:	8a ec       	ldi	r24, 0xCA	; 202
    47ee:	93 e2       	ldi	r25, 0x23	; 35
    47f0:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    47f4:	29 cf       	rjmp	.-430    	; 0x4648 <xQueueSemaphoreTake+0x24>
    47f6:	06 88       	ldd	r0, Z+22	; 0x16
    47f8:	f7 89       	ldd	r31, Z+23	; 0x17
    47fa:	e0 2d       	mov	r30, r0
    47fc:	80 81       	ld	r24, Z
    47fe:	6a e0       	ldi	r22, 0x0A	; 10
    4800:	68 1b       	sub	r22, r24
    4802:	95 cf       	rjmp	.-214    	; 0x472e <xQueueSemaphoreTake+0x10a>
    4804:	80 e0       	ldi	r24, 0x00	; 0
    4806:	c9 cf       	rjmp	.-110    	; 0x479a <xQueueSemaphoreTake+0x176>
    4808:	0e 94 c4 2f 	call	0x5f88	; 0x5f88 <pvTaskIncrementMutexHeldCount>
    480c:	d8 01       	movw	r26, r16
    480e:	14 96       	adiw	r26, 0x04	; 4
    4810:	8d 93       	st	X+, r24
    4812:	9c 93       	st	X, r25
    4814:	15 97       	sbiw	r26, 0x05	; 5
    4816:	ba cf       	rjmp	.-140    	; 0x478c <xQueueSemaphoreTake+0x168>

00004818 <xQueuePeek>:
    4818:	cf 92       	push	r12
    481a:	df 92       	push	r13
    481c:	ef 92       	push	r14
    481e:	ff 92       	push	r15
    4820:	0f 93       	push	r16
    4822:	1f 93       	push	r17
    4824:	cf 93       	push	r28
    4826:	df 93       	push	r29
    4828:	cd b7       	in	r28, 0x3d	; 61
    482a:	de b7       	in	r29, 0x3e	; 62
    482c:	25 97       	sbiw	r28, 0x05	; 5
    482e:	cd bf       	out	0x3d, r28	; 61
    4830:	de bf       	out	0x3e, r29	; 62
    4832:	8c 01       	movw	r16, r24
    4834:	6b 01       	movw	r12, r22
    4836:	4c 83       	std	Y+4, r20	; 0x04
    4838:	5d 83       	std	Y+5, r21	; 0x05
    483a:	89 2b       	or	r24, r25
    483c:	09 f4       	brne	.+2      	; 0x4840 <xQueuePeek+0x28>
    483e:	a2 c0       	rjmp	.+324    	; 0x4984 <xQueuePeek+0x16c>
    4840:	c1 14       	cp	r12, r1
    4842:	d1 04       	cpc	r13, r1
    4844:	09 f4       	brne	.+2      	; 0x4848 <xQueuePeek+0x30>
    4846:	92 c0       	rjmp	.+292    	; 0x496c <xQueuePeek+0x154>
    4848:	20 e0       	ldi	r18, 0x00	; 0
    484a:	78 01       	movw	r14, r16
    484c:	f1 e1       	ldi	r31, 0x11	; 17
    484e:	ef 0e       	add	r14, r31
    4850:	f1 1c       	adc	r15, r1
    4852:	0f b6       	in	r0, 0x3f	; 63
    4854:	f8 94       	cli
    4856:	0f 92       	push	r0
    4858:	f8 01       	movw	r30, r16
    485a:	82 8d       	ldd	r24, Z+26	; 0x1a
    485c:	81 11       	cpse	r24, r1
    485e:	69 c0       	rjmp	.+210    	; 0x4932 <xQueuePeek+0x11a>
    4860:	8c 81       	ldd	r24, Y+4	; 0x04
    4862:	9d 81       	ldd	r25, Y+5	; 0x05
    4864:	89 2b       	or	r24, r25
    4866:	09 f4       	brne	.+2      	; 0x486a <xQueuePeek+0x52>
    4868:	74 c0       	rjmp	.+232    	; 0x4952 <xQueuePeek+0x13a>
    486a:	22 23       	and	r18, r18
    486c:	09 f4       	brne	.+2      	; 0x4870 <xQueuePeek+0x58>
    486e:	58 c0       	rjmp	.+176    	; 0x4920 <xQueuePeek+0x108>
    4870:	0f 90       	pop	r0
    4872:	0f be       	out	0x3f, r0	; 63
    4874:	0e 94 4e 29 	call	0x529c	; 0x529c <vTaskSuspendAll>
    4878:	0f b6       	in	r0, 0x3f	; 63
    487a:	f8 94       	cli
    487c:	0f 92       	push	r0
    487e:	f8 01       	movw	r30, r16
    4880:	85 8d       	ldd	r24, Z+29	; 0x1d
    4882:	8f 3f       	cpi	r24, 0xFF	; 255
    4884:	09 f4       	brne	.+2      	; 0x4888 <xQueuePeek+0x70>
    4886:	53 c0       	rjmp	.+166    	; 0x492e <xQueuePeek+0x116>
    4888:	f8 01       	movw	r30, r16
    488a:	86 8d       	ldd	r24, Z+30	; 0x1e
    488c:	8f 3f       	cpi	r24, 0xFF	; 255
    488e:	09 f4       	brne	.+2      	; 0x4892 <xQueuePeek+0x7a>
    4890:	4c c0       	rjmp	.+152    	; 0x492a <xQueuePeek+0x112>
    4892:	0f 90       	pop	r0
    4894:	0f be       	out	0x3f, r0	; 63
    4896:	be 01       	movw	r22, r28
    4898:	6c 5f       	subi	r22, 0xFC	; 252
    489a:	7f 4f       	sbci	r23, 0xFF	; 255
    489c:	ce 01       	movw	r24, r28
    489e:	01 96       	adiw	r24, 0x01	; 1
    48a0:	0e 94 e0 2b 	call	0x57c0	; 0x57c0 <xTaskCheckForTimeOut>
    48a4:	81 11       	cpse	r24, r1
    48a6:	22 c0       	rjmp	.+68     	; 0x48ec <xQueuePeek+0xd4>
    48a8:	0f b6       	in	r0, 0x3f	; 63
    48aa:	f8 94       	cli
    48ac:	0f 92       	push	r0
    48ae:	f8 01       	movw	r30, r16
    48b0:	82 8d       	ldd	r24, Z+26	; 0x1a
    48b2:	0f 90       	pop	r0
    48b4:	0f be       	out	0x3f, r0	; 63
    48b6:	81 11       	cpse	r24, r1
    48b8:	12 c0       	rjmp	.+36     	; 0x48de <xQueuePeek+0xc6>
    48ba:	6c 81       	ldd	r22, Y+4	; 0x04
    48bc:	7d 81       	ldd	r23, Y+5	; 0x05
    48be:	c7 01       	movw	r24, r14
    48c0:	0e 94 5e 2b 	call	0x56bc	; 0x56bc <vTaskPlaceOnEventList>
    48c4:	c8 01       	movw	r24, r16
    48c6:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <prvUnlockQueue>
    48ca:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>
    48ce:	88 23       	and	r24, r24
    48d0:	11 f0       	breq	.+4      	; 0x48d6 <xQueuePeek+0xbe>
    48d2:	21 e0       	ldi	r18, 0x01	; 1
    48d4:	be cf       	rjmp	.-132    	; 0x4852 <xQueuePeek+0x3a>
    48d6:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vPortYield>
    48da:	21 e0       	ldi	r18, 0x01	; 1
    48dc:	ba cf       	rjmp	.-140    	; 0x4852 <xQueuePeek+0x3a>
    48de:	c8 01       	movw	r24, r16
    48e0:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <prvUnlockQueue>
    48e4:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>
    48e8:	21 e0       	ldi	r18, 0x01	; 1
    48ea:	b3 cf       	rjmp	.-154    	; 0x4852 <xQueuePeek+0x3a>
    48ec:	c8 01       	movw	r24, r16
    48ee:	0e 94 da 1f 	call	0x3fb4	; 0x3fb4 <prvUnlockQueue>
    48f2:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>
    48f6:	0f b6       	in	r0, 0x3f	; 63
    48f8:	f8 94       	cli
    48fa:	0f 92       	push	r0
    48fc:	f8 01       	movw	r30, r16
    48fe:	82 8d       	ldd	r24, Z+26	; 0x1a
    4900:	0f 90       	pop	r0
    4902:	0f be       	out	0x3f, r0	; 63
    4904:	81 11       	cpse	r24, r1
    4906:	e5 cf       	rjmp	.-54     	; 0x48d2 <xQueuePeek+0xba>
    4908:	25 96       	adiw	r28, 0x05	; 5
    490a:	cd bf       	out	0x3d, r28	; 61
    490c:	de bf       	out	0x3e, r29	; 62
    490e:	df 91       	pop	r29
    4910:	cf 91       	pop	r28
    4912:	1f 91       	pop	r17
    4914:	0f 91       	pop	r16
    4916:	ff 90       	pop	r15
    4918:	ef 90       	pop	r14
    491a:	df 90       	pop	r13
    491c:	cf 90       	pop	r12
    491e:	08 95       	ret
    4920:	ce 01       	movw	r24, r28
    4922:	01 96       	adiw	r24, 0x01	; 1
    4924:	0e 94 d5 2b 	call	0x57aa	; 0x57aa <vTaskInternalSetTimeOutState>
    4928:	a3 cf       	rjmp	.-186    	; 0x4870 <xQueuePeek+0x58>
    492a:	16 8e       	std	Z+30, r1	; 0x1e
    492c:	b2 cf       	rjmp	.-156    	; 0x4892 <xQueuePeek+0x7a>
    492e:	15 8e       	std	Z+29, r1	; 0x1d
    4930:	ab cf       	rjmp	.-170    	; 0x4888 <xQueuePeek+0x70>
    4932:	e6 80       	ldd	r14, Z+6	; 0x06
    4934:	f7 80       	ldd	r15, Z+7	; 0x07
    4936:	b6 01       	movw	r22, r12
    4938:	c8 01       	movw	r24, r16
    493a:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <prvCopyDataFromQueue>
    493e:	f8 01       	movw	r30, r16
    4940:	e6 82       	std	Z+6, r14	; 0x06
    4942:	f7 82       	std	Z+7, r15	; 0x07
    4944:	81 89       	ldd	r24, Z+17	; 0x11
    4946:	81 11       	cpse	r24, r1
    4948:	08 c0       	rjmp	.+16     	; 0x495a <xQueuePeek+0x142>
    494a:	0f 90       	pop	r0
    494c:	0f be       	out	0x3f, r0	; 63
    494e:	81 e0       	ldi	r24, 0x01	; 1
    4950:	db cf       	rjmp	.-74     	; 0x4908 <xQueuePeek+0xf0>
    4952:	0f 90       	pop	r0
    4954:	0f be       	out	0x3f, r0	; 63
    4956:	80 e0       	ldi	r24, 0x00	; 0
    4958:	d7 cf       	rjmp	.-82     	; 0x4908 <xQueuePeek+0xf0>
    495a:	c8 01       	movw	r24, r16
    495c:	41 96       	adiw	r24, 0x11	; 17
    495e:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <xTaskRemoveFromEventList>
    4962:	88 23       	and	r24, r24
    4964:	91 f3       	breq	.-28     	; 0x494a <xQueuePeek+0x132>
    4966:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vPortYield>
    496a:	ef cf       	rjmp	.-34     	; 0x494a <xQueuePeek+0x132>
    496c:	f8 01       	movw	r30, r16
    496e:	84 8d       	ldd	r24, Z+28	; 0x1c
    4970:	88 23       	and	r24, r24
    4972:	09 f4       	brne	.+2      	; 0x4976 <xQueuePeek+0x15e>
    4974:	69 cf       	rjmp	.-302    	; 0x4848 <xQueuePeek+0x30>
    4976:	6c e6       	ldi	r22, 0x6C	; 108
    4978:	76 e0       	ldi	r23, 0x06	; 6
    497a:	8a ec       	ldi	r24, 0xCA	; 202
    497c:	93 e2       	ldi	r25, 0x23	; 35
    497e:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    4982:	62 cf       	rjmp	.-316    	; 0x4848 <xQueuePeek+0x30>
    4984:	68 e6       	ldi	r22, 0x68	; 104
    4986:	76 e0       	ldi	r23, 0x06	; 6
    4988:	8a ec       	ldi	r24, 0xCA	; 202
    498a:	93 e2       	ldi	r25, 0x23	; 35
    498c:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    4990:	57 cf       	rjmp	.-338    	; 0x4840 <xQueuePeek+0x28>

00004992 <xQueueReceiveFromISR>:
    4992:	cf 92       	push	r12
    4994:	df 92       	push	r13
    4996:	ef 92       	push	r14
    4998:	ff 92       	push	r15
    499a:	0f 93       	push	r16
    499c:	1f 93       	push	r17
    499e:	cf 93       	push	r28
    49a0:	df 93       	push	r29
    49a2:	ec 01       	movw	r28, r24
    49a4:	7b 01       	movw	r14, r22
    49a6:	6a 01       	movw	r12, r20
    49a8:	89 2b       	or	r24, r25
    49aa:	b9 f1       	breq	.+110    	; 0x4a1a <xQueueReceiveFromISR+0x88>
    49ac:	e1 14       	cp	r14, r1
    49ae:	f1 04       	cpc	r15, r1
    49b0:	d1 f0       	breq	.+52     	; 0x49e6 <xQueueReceiveFromISR+0x54>
    49b2:	1a 8d       	ldd	r17, Y+26	; 0x1a
    49b4:	11 11       	cpse	r17, r1
    49b6:	0a c0       	rjmp	.+20     	; 0x49cc <xQueueReceiveFromISR+0x3a>
    49b8:	80 e0       	ldi	r24, 0x00	; 0
    49ba:	df 91       	pop	r29
    49bc:	cf 91       	pop	r28
    49be:	1f 91       	pop	r17
    49c0:	0f 91       	pop	r16
    49c2:	ff 90       	pop	r15
    49c4:	ef 90       	pop	r14
    49c6:	df 90       	pop	r13
    49c8:	cf 90       	pop	r12
    49ca:	08 95       	ret
    49cc:	0d 8d       	ldd	r16, Y+29	; 0x1d
    49ce:	b7 01       	movw	r22, r14
    49d0:	ce 01       	movw	r24, r28
    49d2:	0e 94 c2 1f 	call	0x3f84	; 0x3f84 <prvCopyDataFromQueue>
    49d6:	11 50       	subi	r17, 0x01	; 1
    49d8:	1a 8f       	std	Y+26, r17	; 0x1a
    49da:	0f 3f       	cpi	r16, 0xFF	; 255
    49dc:	71 f0       	breq	.+28     	; 0x49fa <xQueueReceiveFromISR+0x68>
    49de:	0f 5f       	subi	r16, 0xFF	; 255
    49e0:	0d 8f       	std	Y+29, r16	; 0x1d
    49e2:	81 e0       	ldi	r24, 0x01	; 1
    49e4:	ea cf       	rjmp	.-44     	; 0x49ba <xQueueReceiveFromISR+0x28>
    49e6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    49e8:	88 23       	and	r24, r24
    49ea:	19 f3       	breq	.-58     	; 0x49b2 <xQueueReceiveFromISR+0x20>
    49ec:	6c ef       	ldi	r22, 0xFC	; 252
    49ee:	76 e0       	ldi	r23, 0x06	; 6
    49f0:	8a ec       	ldi	r24, 0xCA	; 202
    49f2:	93 e2       	ldi	r25, 0x23	; 35
    49f4:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    49f8:	dc cf       	rjmp	.-72     	; 0x49b2 <xQueueReceiveFromISR+0x20>
    49fa:	88 85       	ldd	r24, Y+8	; 0x08
    49fc:	88 23       	and	r24, r24
    49fe:	89 f3       	breq	.-30     	; 0x49e2 <xQueueReceiveFromISR+0x50>
    4a00:	ce 01       	movw	r24, r28
    4a02:	08 96       	adiw	r24, 0x08	; 8
    4a04:	0e 94 7e 2b 	call	0x56fc	; 0x56fc <xTaskRemoveFromEventList>
    4a08:	88 23       	and	r24, r24
    4a0a:	59 f3       	breq	.-42     	; 0x49e2 <xQueueReceiveFromISR+0x50>
    4a0c:	c1 14       	cp	r12, r1
    4a0e:	d1 04       	cpc	r13, r1
    4a10:	41 f3       	breq	.-48     	; 0x49e2 <xQueueReceiveFromISR+0x50>
    4a12:	81 e0       	ldi	r24, 0x01	; 1
    4a14:	f6 01       	movw	r30, r12
    4a16:	80 83       	st	Z, r24
    4a18:	d0 cf       	rjmp	.-96     	; 0x49ba <xQueueReceiveFromISR+0x28>
    4a1a:	6b ef       	ldi	r22, 0xFB	; 251
    4a1c:	76 e0       	ldi	r23, 0x06	; 6
    4a1e:	8a ec       	ldi	r24, 0xCA	; 202
    4a20:	93 e2       	ldi	r25, 0x23	; 35
    4a22:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    4a26:	c2 cf       	rjmp	.-124    	; 0x49ac <xQueueReceiveFromISR+0x1a>

00004a28 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    4a28:	cf 93       	push	r28
    4a2a:	df 93       	push	r29
    4a2c:	ec 01       	movw	r28, r24
UBaseType_t uxReturn;

	configASSERT( xQueue );
    4a2e:	89 2b       	or	r24, r25
    4a30:	49 f0       	breq	.+18     	; 0x4a44 <uxQueueMessagesWaiting+0x1c>

	taskENTER_CRITICAL();
    4a32:	0f b6       	in	r0, 0x3f	; 63
    4a34:	f8 94       	cli
    4a36:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    4a38:	8a 8d       	ldd	r24, Y+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    4a3a:	0f 90       	pop	r0
    4a3c:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4a3e:	df 91       	pop	r29
    4a40:	cf 91       	pop	r28
    4a42:	08 95       	ret

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
UBaseType_t uxReturn;

	configASSERT( xQueue );
    4a44:	6a e8       	ldi	r22, 0x8A	; 138
    4a46:	77 e0       	ldi	r23, 0x07	; 7
    4a48:	8a ec       	ldi	r24, 0xCA	; 202
    4a4a:	93 e2       	ldi	r25, 0x23	; 35
    4a4c:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    4a50:	f0 cf       	rjmp	.-32     	; 0x4a32 <uxQueueMessagesWaiting+0xa>

00004a52 <prvIdleTask>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    4a52:	20 c0       	rjmp	.+64     	; 0x4a94 <prvIdleTask+0x42>
    4a54:	0f b6       	in	r0, 0x3f	; 63
    4a56:	f8 94       	cli
    4a58:	0f 92       	push	r0
    4a5a:	e0 91 0e 2d 	lds	r30, 0x2D0E	; 0x802d0e <xTasksWaitingTermination+0x5>
    4a5e:	f0 91 0f 2d 	lds	r31, 0x2D0F	; 0x802d0f <xTasksWaitingTermination+0x6>
    4a62:	c6 81       	ldd	r28, Z+6	; 0x06
    4a64:	d7 81       	ldd	r29, Z+7	; 0x07
    4a66:	ce 01       	movw	r24, r28
    4a68:	02 96       	adiw	r24, 0x02	; 2
    4a6a:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <uxListRemove>
    4a6e:	80 91 fe 2c 	lds	r24, 0x2CFE	; 0x802cfe <uxCurrentNumberOfTasks>
    4a72:	81 50       	subi	r24, 0x01	; 1
    4a74:	80 93 fe 2c 	sts	0x2CFE, r24	; 0x802cfe <uxCurrentNumberOfTasks>
    4a78:	80 91 08 2d 	lds	r24, 0x2D08	; 0x802d08 <uxDeletedTasksWaitingCleanUp>
    4a7c:	81 50       	subi	r24, 0x01	; 1
    4a7e:	80 93 08 2d 	sts	0x2D08, r24	; 0x802d08 <uxDeletedTasksWaitingCleanUp>
    4a82:	0f 90       	pop	r0
    4a84:	0f be       	out	0x3f, r0	; 63
    4a86:	8f 89       	ldd	r24, Y+23	; 0x17
    4a88:	98 8d       	ldd	r25, Y+24	; 0x18
    4a8a:	0e 94 b3 1c 	call	0x3966	; 0x3966 <vPortFree>
    4a8e:	ce 01       	movw	r24, r28
    4a90:	0e 94 b3 1c 	call	0x3966	; 0x3966 <vPortFree>
    4a94:	80 91 08 2d 	lds	r24, 0x2D08	; 0x802d08 <uxDeletedTasksWaitingCleanUp>
    4a98:	81 11       	cpse	r24, r1
    4a9a:	dc cf       	rjmp	.-72     	; 0x4a54 <prvIdleTask+0x2>
    4a9c:	80 91 31 2d 	lds	r24, 0x2D31	; 0x802d31 <pxReadyTasksLists>
    4aa0:	82 30       	cpi	r24, 0x02	; 2
    4aa2:	10 f0       	brcs	.+4      	; 0x4aa8 <prvIdleTask+0x56>
    4aa4:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vPortYield>
    4aa8:	0e 94 d6 2f 	call	0x5fac	; 0x5fac <vApplicationIdleHook>
    4aac:	f3 cf       	rjmp	.-26     	; 0x4a94 <prvIdleTask+0x42>

00004aae <prvWriteNameToBuffer>:
    4aae:	cf 93       	push	r28
    4ab0:	df 93       	push	r29
    4ab2:	ec 01       	movw	r28, r24
    4ab4:	0e 94 a1 4d 	call	0x9b42	; 0x9b42 <strcpy>
    4ab8:	fe 01       	movw	r30, r28
    4aba:	01 90       	ld	r0, Z+
    4abc:	00 20       	and	r0, r0
    4abe:	e9 f7       	brne	.-6      	; 0x4aba <prvWriteNameToBuffer+0xc>
    4ac0:	31 97       	sbiw	r30, 0x01	; 1
    4ac2:	ec 1b       	sub	r30, r28
    4ac4:	fd 0b       	sbc	r31, r29
    4ac6:	e7 30       	cpi	r30, 0x07	; 7
    4ac8:	f1 05       	cpc	r31, r1
    4aca:	60 f4       	brcc	.+24     	; 0x4ae4 <prvWriteNameToBuffer+0x36>
    4acc:	ec 0f       	add	r30, r28
    4ace:	fd 1f       	adc	r31, r29
    4ad0:	9e 01       	movw	r18, r28
    4ad2:	29 5f       	subi	r18, 0xF9	; 249
    4ad4:	3f 4f       	sbci	r19, 0xFF	; 255
    4ad6:	80 e2       	ldi	r24, 0x20	; 32
    4ad8:	81 93       	st	Z+, r24
    4ada:	e2 17       	cp	r30, r18
    4adc:	f3 07       	cpc	r31, r19
    4ade:	e1 f7       	brne	.-8      	; 0x4ad8 <prvWriteNameToBuffer+0x2a>
    4ae0:	e7 e0       	ldi	r30, 0x07	; 7
    4ae2:	f0 e0       	ldi	r31, 0x00	; 0
    4ae4:	ce 01       	movw	r24, r28
    4ae6:	8e 0f       	add	r24, r30
    4ae8:	9f 1f       	adc	r25, r31
    4aea:	fc 01       	movw	r30, r24
    4aec:	10 82       	st	Z, r1
    4aee:	df 91       	pop	r29
    4af0:	cf 91       	pop	r28
    4af2:	08 95       	ret

00004af4 <prvResetNextTaskUnblockTime.part.0>:
    4af4:	e0 91 1d 2d 	lds	r30, 0x2D1D	; 0x802d1d <pxDelayedTaskList>
    4af8:	f0 91 1e 2d 	lds	r31, 0x2D1E	; 0x802d1e <pxDelayedTaskList+0x1>
    4afc:	05 80       	ldd	r0, Z+5	; 0x05
    4afe:	f6 81       	ldd	r31, Z+6	; 0x06
    4b00:	e0 2d       	mov	r30, r0
    4b02:	06 80       	ldd	r0, Z+6	; 0x06
    4b04:	f7 81       	ldd	r31, Z+7	; 0x07
    4b06:	e0 2d       	mov	r30, r0
    4b08:	82 81       	ldd	r24, Z+2	; 0x02
    4b0a:	93 81       	ldd	r25, Z+3	; 0x03
    4b0c:	80 93 f4 2c 	sts	0x2CF4, r24	; 0x802cf4 <xNextTaskUnblockTime>
    4b10:	90 93 f5 2c 	sts	0x2CF5, r25	; 0x802cf5 <xNextTaskUnblockTime+0x1>
    4b14:	08 95       	ret

00004b16 <prvTaskIsTaskSuspended>:
    4b16:	cf 93       	push	r28
    4b18:	df 93       	push	r29
    4b1a:	ec 01       	movw	r28, r24
    4b1c:	89 2b       	or	r24, r25
    4b1e:	99 f0       	breq	.+38     	; 0x4b46 <prvTaskIsTaskSuspended+0x30>
    4b20:	8a 85       	ldd	r24, Y+10	; 0x0a
    4b22:	9b 85       	ldd	r25, Y+11	; 0x0b
    4b24:	8f 5f       	subi	r24, 0xFF	; 255
    4b26:	9c 42       	sbci	r25, 0x2C	; 44
    4b28:	21 f0       	breq	.+8      	; 0x4b32 <prvTaskIsTaskSuspended+0x1c>
    4b2a:	80 e0       	ldi	r24, 0x00	; 0
    4b2c:	df 91       	pop	r29
    4b2e:	cf 91       	pop	r28
    4b30:	08 95       	ret
    4b32:	2c 89       	ldd	r18, Y+20	; 0x14
    4b34:	3d 89       	ldd	r19, Y+21	; 0x15
    4b36:	8d e2       	ldi	r24, 0x2D	; 45
    4b38:	22 31       	cpi	r18, 0x12	; 18
    4b3a:	38 07       	cpc	r19, r24
    4b3c:	b1 f3       	breq	.-20     	; 0x4b2a <prvTaskIsTaskSuspended+0x14>
    4b3e:	81 e0       	ldi	r24, 0x01	; 1
    4b40:	23 2b       	or	r18, r19
    4b42:	99 f7       	brne	.-26     	; 0x4b2a <prvTaskIsTaskSuspended+0x14>
    4b44:	f3 cf       	rjmp	.-26     	; 0x4b2c <prvTaskIsTaskSuspended+0x16>
    4b46:	62 ef       	ldi	r22, 0xF2	; 242
    4b48:	76 e0       	ldi	r23, 0x06	; 6
    4b4a:	8e ed       	ldi	r24, 0xDE	; 222
    4b4c:	93 e2       	ldi	r25, 0x23	; 35
    4b4e:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    4b52:	e6 cf       	rjmp	.-52     	; 0x4b20 <prvTaskIsTaskSuspended+0xa>

00004b54 <prvAddCurrentTaskToDelayedList>:
    4b54:	ff 92       	push	r15
    4b56:	0f 93       	push	r16
    4b58:	1f 93       	push	r17
    4b5a:	cf 93       	push	r28
    4b5c:	df 93       	push	r29
    4b5e:	ec 01       	movw	r28, r24
    4b60:	f6 2e       	mov	r15, r22
    4b62:	00 91 fc 2c 	lds	r16, 0x2CFC	; 0x802cfc <xTickCount>
    4b66:	10 91 fd 2c 	lds	r17, 0x2CFD	; 0x802cfd <xTickCount+0x1>
    4b6a:	80 91 8b 2d 	lds	r24, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    4b6e:	90 91 8c 2d 	lds	r25, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    4b72:	02 96       	adiw	r24, 0x02	; 2
    4b74:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <uxListRemove>
    4b78:	cf 3f       	cpi	r28, 0xFF	; 255
    4b7a:	8f ef       	ldi	r24, 0xFF	; 255
    4b7c:	d8 07       	cpc	r29, r24
    4b7e:	a9 f1       	breq	.+106    	; 0x4bea <prvAddCurrentTaskToDelayedList+0x96>
    4b80:	c0 0f       	add	r28, r16
    4b82:	d1 1f       	adc	r29, r17
    4b84:	e0 91 8b 2d 	lds	r30, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    4b88:	f0 91 8c 2d 	lds	r31, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    4b8c:	c2 83       	std	Z+2, r28	; 0x02
    4b8e:	d3 83       	std	Z+3, r29	; 0x03
    4b90:	60 91 8b 2d 	lds	r22, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    4b94:	70 91 8c 2d 	lds	r23, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    4b98:	c0 17       	cp	r28, r16
    4b9a:	d1 07       	cpc	r29, r17
    4b9c:	c8 f0       	brcs	.+50     	; 0x4bd0 <prvAddCurrentTaskToDelayedList+0x7c>
    4b9e:	80 91 1d 2d 	lds	r24, 0x2D1D	; 0x802d1d <pxDelayedTaskList>
    4ba2:	90 91 1e 2d 	lds	r25, 0x2D1E	; 0x802d1e <pxDelayedTaskList+0x1>
    4ba6:	6e 5f       	subi	r22, 0xFE	; 254
    4ba8:	7f 4f       	sbci	r23, 0xFF	; 255
    4baa:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <vListInsert>
    4bae:	80 91 f4 2c 	lds	r24, 0x2CF4	; 0x802cf4 <xNextTaskUnblockTime>
    4bb2:	90 91 f5 2c 	lds	r25, 0x2CF5	; 0x802cf5 <xNextTaskUnblockTime+0x1>
    4bb6:	c8 17       	cp	r28, r24
    4bb8:	d9 07       	cpc	r29, r25
    4bba:	20 f4       	brcc	.+8      	; 0x4bc4 <prvAddCurrentTaskToDelayedList+0x70>
    4bbc:	c0 93 f4 2c 	sts	0x2CF4, r28	; 0x802cf4 <xNextTaskUnblockTime>
    4bc0:	d0 93 f5 2c 	sts	0x2CF5, r29	; 0x802cf5 <xNextTaskUnblockTime+0x1>
    4bc4:	df 91       	pop	r29
    4bc6:	cf 91       	pop	r28
    4bc8:	1f 91       	pop	r17
    4bca:	0f 91       	pop	r16
    4bcc:	ff 90       	pop	r15
    4bce:	08 95       	ret
    4bd0:	80 91 1b 2d 	lds	r24, 0x2D1B	; 0x802d1b <pxOverflowDelayedTaskList>
    4bd4:	90 91 1c 2d 	lds	r25, 0x2D1C	; 0x802d1c <pxOverflowDelayedTaskList+0x1>
    4bd8:	6e 5f       	subi	r22, 0xFE	; 254
    4bda:	7f 4f       	sbci	r23, 0xFF	; 255
    4bdc:	df 91       	pop	r29
    4bde:	cf 91       	pop	r28
    4be0:	1f 91       	pop	r17
    4be2:	0f 91       	pop	r16
    4be4:	ff 90       	pop	r15
    4be6:	0c 94 16 1d 	jmp	0x3a2c	; 0x3a2c <vListInsert>
    4bea:	ff 20       	and	r15, r15
    4bec:	49 f2       	breq	.-110    	; 0x4b80 <prvAddCurrentTaskToDelayedList+0x2c>
    4bee:	60 91 8b 2d 	lds	r22, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    4bf2:	70 91 8c 2d 	lds	r23, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    4bf6:	6e 5f       	subi	r22, 0xFE	; 254
    4bf8:	7f 4f       	sbci	r23, 0xFF	; 255
    4bfa:	8f ef       	ldi	r24, 0xFF	; 255
    4bfc:	9c e2       	ldi	r25, 0x2C	; 44
    4bfe:	df 91       	pop	r29
    4c00:	cf 91       	pop	r28
    4c02:	1f 91       	pop	r17
    4c04:	0f 91       	pop	r16
    4c06:	ff 90       	pop	r15
    4c08:	0c 94 f5 1c 	jmp	0x39ea	; 0x39ea <vListInsertEnd>

00004c0c <vTaskSwitchContext.part.5>:
    4c0c:	0f 93       	push	r16
    4c0e:	1f 93       	push	r17
    4c10:	cf 93       	push	r28
    4c12:	10 92 f8 2c 	sts	0x2CF8, r1	; 0x802cf8 <xYieldPending>
    4c16:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    4c1a:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    4c1e:	80 91 cf 2d 	lds	r24, 0x2DCF	; 0x802dcf <StatsTimer>
    4c22:	90 91 d0 2d 	lds	r25, 0x2DD0	; 0x802dd0 <StatsTimer+0x1>
    4c26:	a0 91 d1 2d 	lds	r26, 0x2DD1	; 0x802dd1 <StatsTimer+0x2>
    4c2a:	b0 91 d2 2d 	lds	r27, 0x2DD2	; 0x802dd2 <StatsTimer+0x3>
    4c2e:	82 0f       	add	r24, r18
    4c30:	93 1f       	adc	r25, r19
    4c32:	a1 1d       	adc	r26, r1
    4c34:	b1 1d       	adc	r27, r1
    4c36:	00 91 ed 2c 	lds	r16, 0x2CED	; 0x802ced <ulTaskSwitchedInTime>
    4c3a:	10 91 ee 2c 	lds	r17, 0x2CEE	; 0x802cee <ulTaskSwitchedInTime+0x1>
    4c3e:	20 91 ef 2c 	lds	r18, 0x2CEF	; 0x802cef <ulTaskSwitchedInTime+0x2>
    4c42:	30 91 f0 2c 	lds	r19, 0x2CF0	; 0x802cf0 <ulTaskSwitchedInTime+0x3>
    4c46:	08 17       	cp	r16, r24
    4c48:	19 07       	cpc	r17, r25
    4c4a:	2a 07       	cpc	r18, r26
    4c4c:	3b 07       	cpc	r19, r27
    4c4e:	a0 f4       	brcc	.+40     	; 0x4c78 <vTaskSwitchContext.part.5+0x6c>
    4c50:	e0 91 8b 2d 	lds	r30, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    4c54:	f0 91 8c 2d 	lds	r31, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    4c58:	47 a1       	ldd	r20, Z+39	; 0x27
    4c5a:	50 a5       	ldd	r21, Z+40	; 0x28
    4c5c:	61 a5       	ldd	r22, Z+41	; 0x29
    4c5e:	72 a5       	ldd	r23, Z+42	; 0x2a
    4c60:	40 1b       	sub	r20, r16
    4c62:	51 0b       	sbc	r21, r17
    4c64:	62 0b       	sbc	r22, r18
    4c66:	73 0b       	sbc	r23, r19
    4c68:	48 0f       	add	r20, r24
    4c6a:	59 1f       	adc	r21, r25
    4c6c:	6a 1f       	adc	r22, r26
    4c6e:	7b 1f       	adc	r23, r27
    4c70:	47 a3       	std	Z+39, r20	; 0x27
    4c72:	50 a7       	std	Z+40, r21	; 0x28
    4c74:	61 a7       	std	Z+41, r22	; 0x29
    4c76:	72 a7       	std	Z+42, r23	; 0x2a
    4c78:	80 93 ed 2c 	sts	0x2CED, r24	; 0x802ced <ulTaskSwitchedInTime>
    4c7c:	90 93 ee 2c 	sts	0x2CEE, r25	; 0x802cee <ulTaskSwitchedInTime+0x1>
    4c80:	a0 93 ef 2c 	sts	0x2CEF, r26	; 0x802cef <ulTaskSwitchedInTime+0x2>
    4c84:	b0 93 f0 2c 	sts	0x2CF0, r27	; 0x802cf0 <ulTaskSwitchedInTime+0x3>
    4c88:	e0 91 8b 2d 	lds	r30, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    4c8c:	f0 91 8c 2d 	lds	r31, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    4c90:	07 88       	ldd	r0, Z+23	; 0x17
    4c92:	f0 8d       	ldd	r31, Z+24	; 0x18
    4c94:	e0 2d       	mov	r30, r0
    4c96:	80 81       	ld	r24, Z
    4c98:	91 81       	ldd	r25, Z+1	; 0x01
    4c9a:	a2 81       	ldd	r26, Z+2	; 0x02
    4c9c:	b3 81       	ldd	r27, Z+3	; 0x03
    4c9e:	85 3a       	cpi	r24, 0xA5	; 165
    4ca0:	95 4a       	sbci	r25, 0xA5	; 165
    4ca2:	a5 4a       	sbci	r26, 0xA5	; 165
    4ca4:	b5 4a       	sbci	r27, 0xA5	; 165
    4ca6:	09 f4       	brne	.+2      	; 0x4caa <vTaskSwitchContext.part.5+0x9e>
    4ca8:	4c c0       	rjmp	.+152    	; 0x4d42 <vTaskSwitchContext.part.5+0x136>
    4caa:	60 91 8b 2d 	lds	r22, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    4cae:	70 91 8c 2d 	lds	r23, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    4cb2:	80 91 8b 2d 	lds	r24, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    4cb6:	90 91 8c 2d 	lds	r25, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    4cba:	67 5e       	subi	r22, 0xE7	; 231
    4cbc:	7f 4f       	sbci	r23, 0xFF	; 255
    4cbe:	0e 94 f6 2f 	call	0x5fec	; 0x5fec <vApplicationStackOverflowHook>
    4cc2:	c0 91 fb 2c 	lds	r28, 0x2CFB	; 0x802cfb <uxTopReadyPriority>
    4cc6:	8c 2f       	mov	r24, r28
    4cc8:	90 e0       	ldi	r25, 0x00	; 0
    4cca:	9c 01       	movw	r18, r24
    4ccc:	22 0f       	add	r18, r18
    4cce:	33 1f       	adc	r19, r19
    4cd0:	22 0f       	add	r18, r18
    4cd2:	33 1f       	adc	r19, r19
    4cd4:	22 0f       	add	r18, r18
    4cd6:	33 1f       	adc	r19, r19
    4cd8:	f9 01       	movw	r30, r18
    4cda:	e8 0f       	add	r30, r24
    4cdc:	f9 1f       	adc	r31, r25
    4cde:	ef 5c       	subi	r30, 0xCF	; 207
    4ce0:	f2 4d       	sbci	r31, 0xD2	; 210
    4ce2:	40 81       	ld	r20, Z
    4ce4:	41 11       	cpse	r20, r1
    4ce6:	0c c0       	rjmp	.+24     	; 0x4d00 <vTaskSwitchContext.part.5+0xf4>
    4ce8:	cc 23       	and	r28, r28
    4cea:	11 f0       	breq	.+4      	; 0x4cf0 <vTaskSwitchContext.part.5+0xe4>
    4cec:	c1 50       	subi	r28, 0x01	; 1
    4cee:	eb cf       	rjmp	.-42     	; 0x4cc6 <vTaskSwitchContext.part.5+0xba>
    4cf0:	6c e8       	ldi	r22, 0x8C	; 140
    4cf2:	7b e0       	ldi	r23, 0x0B	; 11
    4cf4:	8e ed       	ldi	r24, 0xDE	; 222
    4cf6:	93 e2       	ldi	r25, 0x23	; 35
    4cf8:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    4cfc:	c1 50       	subi	r28, 0x01	; 1
    4cfe:	e3 cf       	rjmp	.-58     	; 0x4cc6 <vTaskSwitchContext.part.5+0xba>
    4d00:	82 0f       	add	r24, r18
    4d02:	93 1f       	adc	r25, r19
    4d04:	dc 01       	movw	r26, r24
    4d06:	af 5c       	subi	r26, 0xCF	; 207
    4d08:	b2 4d       	sbci	r27, 0xD2	; 210
    4d0a:	11 96       	adiw	r26, 0x01	; 1
    4d0c:	ed 91       	ld	r30, X+
    4d0e:	fc 91       	ld	r31, X
    4d10:	12 97       	sbiw	r26, 0x02	; 2
    4d12:	02 80       	ldd	r0, Z+2	; 0x02
    4d14:	f3 81       	ldd	r31, Z+3	; 0x03
    4d16:	e0 2d       	mov	r30, r0
    4d18:	11 96       	adiw	r26, 0x01	; 1
    4d1a:	ed 93       	st	X+, r30
    4d1c:	fc 93       	st	X, r31
    4d1e:	12 97       	sbiw	r26, 0x02	; 2
    4d20:	8c 5c       	subi	r24, 0xCC	; 204
    4d22:	92 4d       	sbci	r25, 0xD2	; 210
    4d24:	e8 17       	cp	r30, r24
    4d26:	f9 07       	cpc	r31, r25
    4d28:	59 f1       	breq	.+86     	; 0x4d80 <vTaskSwitchContext.part.5+0x174>
    4d2a:	86 81       	ldd	r24, Z+6	; 0x06
    4d2c:	97 81       	ldd	r25, Z+7	; 0x07
    4d2e:	80 93 8b 2d 	sts	0x2D8B, r24	; 0x802d8b <pxCurrentTCB>
    4d32:	90 93 8c 2d 	sts	0x2D8C, r25	; 0x802d8c <pxCurrentTCB+0x1>
    4d36:	c0 93 fb 2c 	sts	0x2CFB, r28	; 0x802cfb <uxTopReadyPriority>
    4d3a:	cf 91       	pop	r28
    4d3c:	1f 91       	pop	r17
    4d3e:	0f 91       	pop	r16
    4d40:	08 95       	ret
    4d42:	84 81       	ldd	r24, Z+4	; 0x04
    4d44:	95 81       	ldd	r25, Z+5	; 0x05
    4d46:	a6 81       	ldd	r26, Z+6	; 0x06
    4d48:	b7 81       	ldd	r27, Z+7	; 0x07
    4d4a:	85 3a       	cpi	r24, 0xA5	; 165
    4d4c:	95 4a       	sbci	r25, 0xA5	; 165
    4d4e:	a5 4a       	sbci	r26, 0xA5	; 165
    4d50:	b5 4a       	sbci	r27, 0xA5	; 165
    4d52:	09 f0       	breq	.+2      	; 0x4d56 <vTaskSwitchContext.part.5+0x14a>
    4d54:	aa cf       	rjmp	.-172    	; 0x4caa <vTaskSwitchContext.part.5+0x9e>
    4d56:	80 85       	ldd	r24, Z+8	; 0x08
    4d58:	91 85       	ldd	r25, Z+9	; 0x09
    4d5a:	a2 85       	ldd	r26, Z+10	; 0x0a
    4d5c:	b3 85       	ldd	r27, Z+11	; 0x0b
    4d5e:	85 3a       	cpi	r24, 0xA5	; 165
    4d60:	95 4a       	sbci	r25, 0xA5	; 165
    4d62:	a5 4a       	sbci	r26, 0xA5	; 165
    4d64:	b5 4a       	sbci	r27, 0xA5	; 165
    4d66:	09 f0       	breq	.+2      	; 0x4d6a <vTaskSwitchContext.part.5+0x15e>
    4d68:	a0 cf       	rjmp	.-192    	; 0x4caa <vTaskSwitchContext.part.5+0x9e>
    4d6a:	84 85       	ldd	r24, Z+12	; 0x0c
    4d6c:	95 85       	ldd	r25, Z+13	; 0x0d
    4d6e:	a6 85       	ldd	r26, Z+14	; 0x0e
    4d70:	b7 85       	ldd	r27, Z+15	; 0x0f
    4d72:	85 3a       	cpi	r24, 0xA5	; 165
    4d74:	95 4a       	sbci	r25, 0xA5	; 165
    4d76:	a5 4a       	sbci	r26, 0xA5	; 165
    4d78:	b5 4a       	sbci	r27, 0xA5	; 165
    4d7a:	09 f0       	breq	.+2      	; 0x4d7e <vTaskSwitchContext.part.5+0x172>
    4d7c:	96 cf       	rjmp	.-212    	; 0x4caa <vTaskSwitchContext.part.5+0x9e>
    4d7e:	a1 cf       	rjmp	.-190    	; 0x4cc2 <vTaskSwitchContext.part.5+0xb6>
    4d80:	02 80       	ldd	r0, Z+2	; 0x02
    4d82:	f3 81       	ldd	r31, Z+3	; 0x03
    4d84:	e0 2d       	mov	r30, r0
    4d86:	11 96       	adiw	r26, 0x01	; 1
    4d88:	ed 93       	st	X+, r30
    4d8a:	fc 93       	st	X, r31
    4d8c:	12 97       	sbiw	r26, 0x02	; 2
    4d8e:	cd cf       	rjmp	.-102    	; 0x4d2a <vTaskSwitchContext.part.5+0x11e>

00004d90 <xTaskCreate>:
    4d90:	5f 92       	push	r5
    4d92:	6f 92       	push	r6
    4d94:	7f 92       	push	r7
    4d96:	8f 92       	push	r8
    4d98:	9f 92       	push	r9
    4d9a:	af 92       	push	r10
    4d9c:	bf 92       	push	r11
    4d9e:	cf 92       	push	r12
    4da0:	df 92       	push	r13
    4da2:	ef 92       	push	r14
    4da4:	ff 92       	push	r15
    4da6:	0f 93       	push	r16
    4da8:	1f 93       	push	r17
    4daa:	cf 93       	push	r28
    4dac:	df 93       	push	r29
    4dae:	4c 01       	movw	r8, r24
    4db0:	eb 01       	movw	r28, r22
    4db2:	5a 01       	movw	r10, r20
    4db4:	39 01       	movw	r6, r18
    4db6:	50 2e       	mov	r5, r16
    4db8:	ca 01       	movw	r24, r20
    4dba:	0e 94 14 1c 	call	0x3828	; 0x3828 <pvPortMalloc>
    4dbe:	8c 01       	movw	r16, r24
    4dc0:	89 2b       	or	r24, r25
    4dc2:	09 f4       	brne	.+2      	; 0x4dc6 <xTaskCreate+0x36>
    4dc4:	de c0       	rjmp	.+444    	; 0x4f82 <xTaskCreate+0x1f2>
    4dc6:	80 e3       	ldi	r24, 0x30	; 48
    4dc8:	90 e0       	ldi	r25, 0x00	; 0
    4dca:	0e 94 14 1c 	call	0x3828	; 0x3828 <pvPortMalloc>
    4dce:	6c 01       	movw	r12, r24
    4dd0:	00 97       	sbiw	r24, 0x00	; 0
    4dd2:	09 f4       	brne	.+2      	; 0x4dd6 <xTaskCreate+0x46>
    4dd4:	d3 c0       	rjmp	.+422    	; 0x4f7c <xTaskCreate+0x1ec>
    4dd6:	dc 01       	movw	r26, r24
    4dd8:	57 96       	adiw	r26, 0x17	; 23
    4dda:	0d 93       	st	X+, r16
    4ddc:	1c 93       	st	X, r17
    4dde:	58 97       	sbiw	r26, 0x18	; 24
    4de0:	20 97       	sbiw	r28, 0x00	; 0
    4de2:	09 f4       	brne	.+2      	; 0x4de6 <xTaskCreate+0x56>
    4de4:	d0 c0       	rjmp	.+416    	; 0x4f86 <xTaskCreate+0x1f6>
    4de6:	c8 01       	movw	r24, r16
    4de8:	a5 01       	movw	r20, r10
    4dea:	65 ea       	ldi	r22, 0xA5	; 165
    4dec:	70 e0       	ldi	r23, 0x00	; 0
    4dee:	0e 94 9a 4d 	call	0x9b34	; 0x9b34 <memset>
    4df2:	f1 e0       	ldi	r31, 0x01	; 1
    4df4:	af 1a       	sub	r10, r31
    4df6:	b1 08       	sbc	r11, r1
    4df8:	d6 01       	movw	r26, r12
    4dfa:	57 96       	adiw	r26, 0x17	; 23
    4dfc:	8d 91       	ld	r24, X+
    4dfe:	9c 91       	ld	r25, X
    4e00:	58 97       	sbiw	r26, 0x18	; 24
    4e02:	a8 0e       	add	r10, r24
    4e04:	b9 1e       	adc	r11, r25
    4e06:	f6 01       	movw	r30, r12
    4e08:	79 96       	adiw	r30, 0x19	; 25
    4e0a:	9e 01       	movw	r18, r28
    4e0c:	28 5f       	subi	r18, 0xF8	; 248
    4e0e:	3f 4f       	sbci	r19, 0xFF	; 255
    4e10:	de 01       	movw	r26, r28
    4e12:	89 91       	ld	r24, Y+
    4e14:	81 93       	st	Z+, r24
    4e16:	8c 91       	ld	r24, X
    4e18:	88 23       	and	r24, r24
    4e1a:	19 f0       	breq	.+6      	; 0x4e22 <xTaskCreate+0x92>
    4e1c:	c2 17       	cp	r28, r18
    4e1e:	d3 07       	cpc	r29, r19
    4e20:	b9 f7       	brne	.-18     	; 0x4e10 <xTaskCreate+0x80>
    4e22:	f6 01       	movw	r30, r12
    4e24:	10 a2       	std	Z+32, r1	; 0x20
    4e26:	05 2d       	mov	r16, r5
    4e28:	0a 30       	cpi	r16, 0x0A	; 10
    4e2a:	08 f0       	brcs	.+2      	; 0x4e2e <xTaskCreate+0x9e>
    4e2c:	a1 c0       	rjmp	.+322    	; 0x4f70 <xTaskCreate+0x1e0>
    4e2e:	d6 01       	movw	r26, r12
    4e30:	56 96       	adiw	r26, 0x16	; 22
    4e32:	0c 93       	st	X, r16
    4e34:	56 97       	sbiw	r26, 0x16	; 22
    4e36:	93 96       	adiw	r26, 0x23	; 35
    4e38:	0c 93       	st	X, r16
    4e3a:	93 97       	sbiw	r26, 0x23	; 35
    4e3c:	94 96       	adiw	r26, 0x24	; 36
    4e3e:	1c 92       	st	X, r1
    4e40:	e6 01       	movw	r28, r12
    4e42:	22 96       	adiw	r28, 0x02	; 2
    4e44:	ce 01       	movw	r24, r28
    4e46:	0e 94 f1 1c 	call	0x39e2	; 0x39e2 <vListInitialiseItem>
    4e4a:	c6 01       	movw	r24, r12
    4e4c:	0c 96       	adiw	r24, 0x0c	; 12
    4e4e:	0e 94 f1 1c 	call	0x39e2	; 0x39e2 <vListInitialiseItem>
    4e52:	f6 01       	movw	r30, r12
    4e54:	c0 86       	std	Z+8, r12	; 0x08
    4e56:	d1 86       	std	Z+9, r13	; 0x09
    4e58:	8a e0       	ldi	r24, 0x0A	; 10
    4e5a:	90 e0       	ldi	r25, 0x00	; 0
    4e5c:	80 1b       	sub	r24, r16
    4e5e:	91 09       	sbc	r25, r1
    4e60:	84 87       	std	Z+12, r24	; 0x0c
    4e62:	95 87       	std	Z+13, r25	; 0x0d
    4e64:	c2 8a       	std	Z+18, r12	; 0x12
    4e66:	d3 8a       	std	Z+19, r13	; 0x13
    4e68:	15 a2       	std	Z+37, r1	; 0x25
    4e6a:	16 a2       	std	Z+38, r1	; 0x26
    4e6c:	17 a2       	std	Z+39, r1	; 0x27
    4e6e:	10 a6       	std	Z+40, r1	; 0x28
    4e70:	11 a6       	std	Z+41, r1	; 0x29
    4e72:	12 a6       	std	Z+42, r1	; 0x2a
    4e74:	13 a6       	std	Z+43, r1	; 0x2b
    4e76:	14 a6       	std	Z+44, r1	; 0x2c
    4e78:	15 a6       	std	Z+45, r1	; 0x2d
    4e7a:	16 a6       	std	Z+46, r1	; 0x2e
    4e7c:	17 a6       	std	Z+47, r1	; 0x2f
    4e7e:	a3 01       	movw	r20, r6
    4e80:	b4 01       	movw	r22, r8
    4e82:	c5 01       	movw	r24, r10
    4e84:	0e 94 6d 1d 	call	0x3ada	; 0x3ada <pxPortInitialiseStack>
    4e88:	d6 01       	movw	r26, r12
    4e8a:	8d 93       	st	X+, r24
    4e8c:	9c 93       	st	X, r25
    4e8e:	e1 14       	cp	r14, r1
    4e90:	f1 04       	cpc	r15, r1
    4e92:	19 f0       	breq	.+6      	; 0x4e9a <xTaskCreate+0x10a>
    4e94:	f7 01       	movw	r30, r14
    4e96:	c0 82       	st	Z, r12
    4e98:	d1 82       	std	Z+1, r13	; 0x01
    4e9a:	0f b6       	in	r0, 0x3f	; 63
    4e9c:	f8 94       	cli
    4e9e:	0f 92       	push	r0
    4ea0:	80 91 fe 2c 	lds	r24, 0x2CFE	; 0x802cfe <uxCurrentNumberOfTasks>
    4ea4:	8f 5f       	subi	r24, 0xFF	; 255
    4ea6:	80 93 fe 2c 	sts	0x2CFE, r24	; 0x802cfe <uxCurrentNumberOfTasks>
    4eaa:	80 91 8b 2d 	lds	r24, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    4eae:	90 91 8c 2d 	lds	r25, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    4eb2:	89 2b       	or	r24, r25
    4eb4:	99 f0       	breq	.+38     	; 0x4edc <xTaskCreate+0x14c>
    4eb6:	80 91 fa 2c 	lds	r24, 0x2CFA	; 0x802cfa <xSchedulerRunning>
    4eba:	81 11       	cpse	r24, r1
    4ebc:	18 c0       	rjmp	.+48     	; 0x4eee <xTaskCreate+0x15e>
    4ebe:	e0 91 8b 2d 	lds	r30, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    4ec2:	f0 91 8c 2d 	lds	r31, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    4ec6:	d6 01       	movw	r26, r12
    4ec8:	56 96       	adiw	r26, 0x16	; 22
    4eca:	8c 91       	ld	r24, X
    4ecc:	96 89       	ldd	r25, Z+22	; 0x16
    4ece:	89 17       	cp	r24, r25
    4ed0:	88 f0       	brcs	.+34     	; 0x4ef4 <xTaskCreate+0x164>
    4ed2:	c0 92 8b 2d 	sts	0x2D8B, r12	; 0x802d8b <pxCurrentTCB>
    4ed6:	d0 92 8c 2d 	sts	0x2D8C, r13	; 0x802d8c <pxCurrentTCB+0x1>
    4eda:	0c c0       	rjmp	.+24     	; 0x4ef4 <xTaskCreate+0x164>
    4edc:	c0 92 8b 2d 	sts	0x2D8B, r12	; 0x802d8b <pxCurrentTCB>
    4ee0:	d0 92 8c 2d 	sts	0x2D8C, r13	; 0x802d8c <pxCurrentTCB+0x1>
    4ee4:	80 91 fe 2c 	lds	r24, 0x2CFE	; 0x802cfe <uxCurrentNumberOfTasks>
    4ee8:	81 30       	cpi	r24, 0x01	; 1
    4eea:	09 f4       	brne	.+2      	; 0x4eee <xTaskCreate+0x15e>
    4eec:	56 c0       	rjmp	.+172    	; 0x4f9a <xTaskCreate+0x20a>
    4eee:	d6 01       	movw	r26, r12
    4ef0:	56 96       	adiw	r26, 0x16	; 22
    4ef2:	8c 91       	ld	r24, X
    4ef4:	90 91 f6 2c 	lds	r25, 0x2CF6	; 0x802cf6 <uxTaskNumber>
    4ef8:	9f 5f       	subi	r25, 0xFF	; 255
    4efa:	90 93 f6 2c 	sts	0x2CF6, r25	; 0x802cf6 <uxTaskNumber>
    4efe:	f6 01       	movw	r30, r12
    4f00:	91 a3       	std	Z+33, r25	; 0x21
    4f02:	90 91 fb 2c 	lds	r25, 0x2CFB	; 0x802cfb <uxTopReadyPriority>
    4f06:	98 17       	cp	r25, r24
    4f08:	80 f1       	brcs	.+96     	; 0x4f6a <xTaskCreate+0x1da>
    4f0a:	90 e0       	ldi	r25, 0x00	; 0
    4f0c:	9c 01       	movw	r18, r24
    4f0e:	22 0f       	add	r18, r18
    4f10:	33 1f       	adc	r19, r19
    4f12:	22 0f       	add	r18, r18
    4f14:	33 1f       	adc	r19, r19
    4f16:	22 0f       	add	r18, r18
    4f18:	33 1f       	adc	r19, r19
    4f1a:	82 0f       	add	r24, r18
    4f1c:	93 1f       	adc	r25, r19
    4f1e:	be 01       	movw	r22, r28
    4f20:	8f 5c       	subi	r24, 0xCF	; 207
    4f22:	92 4d       	sbci	r25, 0xD2	; 210
    4f24:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vListInsertEnd>
    4f28:	0f 90       	pop	r0
    4f2a:	0f be       	out	0x3f, r0	; 63
    4f2c:	80 91 fa 2c 	lds	r24, 0x2CFA	; 0x802cfa <xSchedulerRunning>
    4f30:	88 23       	and	r24, r24
    4f32:	51 f0       	breq	.+20     	; 0x4f48 <xTaskCreate+0x1b8>
    4f34:	e0 91 8b 2d 	lds	r30, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    4f38:	f0 91 8c 2d 	lds	r31, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    4f3c:	96 89       	ldd	r25, Z+22	; 0x16
    4f3e:	d6 01       	movw	r26, r12
    4f40:	56 96       	adiw	r26, 0x16	; 22
    4f42:	8c 91       	ld	r24, X
    4f44:	98 17       	cp	r25, r24
    4f46:	b0 f0       	brcs	.+44     	; 0x4f74 <xTaskCreate+0x1e4>
    4f48:	81 e0       	ldi	r24, 0x01	; 1
    4f4a:	df 91       	pop	r29
    4f4c:	cf 91       	pop	r28
    4f4e:	1f 91       	pop	r17
    4f50:	0f 91       	pop	r16
    4f52:	ff 90       	pop	r15
    4f54:	ef 90       	pop	r14
    4f56:	df 90       	pop	r13
    4f58:	cf 90       	pop	r12
    4f5a:	bf 90       	pop	r11
    4f5c:	af 90       	pop	r10
    4f5e:	9f 90       	pop	r9
    4f60:	8f 90       	pop	r8
    4f62:	7f 90       	pop	r7
    4f64:	6f 90       	pop	r6
    4f66:	5f 90       	pop	r5
    4f68:	08 95       	ret
    4f6a:	80 93 fb 2c 	sts	0x2CFB, r24	; 0x802cfb <uxTopReadyPriority>
    4f6e:	cd cf       	rjmp	.-102    	; 0x4f0a <xTaskCreate+0x17a>
    4f70:	09 e0       	ldi	r16, 0x09	; 9
    4f72:	5d cf       	rjmp	.-326    	; 0x4e2e <xTaskCreate+0x9e>
    4f74:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vPortYield>
    4f78:	81 e0       	ldi	r24, 0x01	; 1
    4f7a:	e7 cf       	rjmp	.-50     	; 0x4f4a <xTaskCreate+0x1ba>
    4f7c:	c8 01       	movw	r24, r16
    4f7e:	0e 94 b3 1c 	call	0x3966	; 0x3966 <vPortFree>
    4f82:	8f ef       	ldi	r24, 0xFF	; 255
    4f84:	e2 cf       	rjmp	.-60     	; 0x4f4a <xTaskCreate+0x1ba>
    4f86:	60 e6       	ldi	r22, 0x60	; 96
    4f88:	73 e0       	ldi	r23, 0x03	; 3
    4f8a:	8e ed       	ldi	r24, 0xDE	; 222
    4f8c:	93 e2       	ldi	r25, 0x23	; 35
    4f8e:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    4f92:	f6 01       	movw	r30, r12
    4f94:	87 89       	ldd	r24, Z+23	; 0x17
    4f96:	90 8d       	ldd	r25, Z+24	; 0x18
    4f98:	27 cf       	rjmp	.-434    	; 0x4de8 <xTaskCreate+0x58>
    4f9a:	01 e3       	ldi	r16, 0x31	; 49
    4f9c:	1d e2       	ldi	r17, 0x2D	; 45
    4f9e:	5b e8       	ldi	r21, 0x8B	; 139
    4fa0:	e5 2e       	mov	r14, r21
    4fa2:	5d e2       	ldi	r21, 0x2D	; 45
    4fa4:	f5 2e       	mov	r15, r21
    4fa6:	c8 01       	movw	r24, r16
    4fa8:	0e 94 e3 1c 	call	0x39c6	; 0x39c6 <vListInitialise>
    4fac:	07 5f       	subi	r16, 0xF7	; 247
    4fae:	1f 4f       	sbci	r17, 0xFF	; 255
    4fb0:	e0 16       	cp	r14, r16
    4fb2:	f1 06       	cpc	r15, r17
    4fb4:	c1 f7       	brne	.-16     	; 0x4fa6 <xTaskCreate+0x216>
    4fb6:	88 e2       	ldi	r24, 0x28	; 40
    4fb8:	9d e2       	ldi	r25, 0x2D	; 45
    4fba:	0e 94 e3 1c 	call	0x39c6	; 0x39c6 <vListInitialise>
    4fbe:	8f e1       	ldi	r24, 0x1F	; 31
    4fc0:	9d e2       	ldi	r25, 0x2D	; 45
    4fc2:	0e 94 e3 1c 	call	0x39c6	; 0x39c6 <vListInitialise>
    4fc6:	82 e1       	ldi	r24, 0x12	; 18
    4fc8:	9d e2       	ldi	r25, 0x2D	; 45
    4fca:	0e 94 e3 1c 	call	0x39c6	; 0x39c6 <vListInitialise>
    4fce:	89 e0       	ldi	r24, 0x09	; 9
    4fd0:	9d e2       	ldi	r25, 0x2D	; 45
    4fd2:	0e 94 e3 1c 	call	0x39c6	; 0x39c6 <vListInitialise>
    4fd6:	8f ef       	ldi	r24, 0xFF	; 255
    4fd8:	9c e2       	ldi	r25, 0x2C	; 44
    4fda:	0e 94 e3 1c 	call	0x39c6	; 0x39c6 <vListInitialise>
    4fde:	88 e2       	ldi	r24, 0x28	; 40
    4fe0:	9d e2       	ldi	r25, 0x2D	; 45
    4fe2:	80 93 1d 2d 	sts	0x2D1D, r24	; 0x802d1d <pxDelayedTaskList>
    4fe6:	90 93 1e 2d 	sts	0x2D1E, r25	; 0x802d1e <pxDelayedTaskList+0x1>
    4fea:	8f e1       	ldi	r24, 0x1F	; 31
    4fec:	9d e2       	ldi	r25, 0x2D	; 45
    4fee:	80 93 1b 2d 	sts	0x2D1B, r24	; 0x802d1b <pxOverflowDelayedTaskList>
    4ff2:	90 93 1c 2d 	sts	0x2D1C, r25	; 0x802d1c <pxOverflowDelayedTaskList+0x1>
    4ff6:	f6 01       	movw	r30, r12
    4ff8:	86 89       	ldd	r24, Z+22	; 0x16
    4ffa:	7c cf       	rjmp	.-264    	; 0x4ef4 <xTaskCreate+0x164>

00004ffc <eTaskGetState>:
    4ffc:	cf 93       	push	r28
    4ffe:	df 93       	push	r29
    5000:	ec 01       	movw	r28, r24
    5002:	89 2b       	or	r24, r25
    5004:	09 f4       	brne	.+2      	; 0x5008 <eTaskGetState+0xc>
    5006:	3a c0       	rjmp	.+116    	; 0x507c <eTaskGetState+0x80>
    5008:	80 91 8b 2d 	lds	r24, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    500c:	90 91 8c 2d 	lds	r25, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    5010:	c8 17       	cp	r28, r24
    5012:	d9 07       	cpc	r29, r25
    5014:	79 f1       	breq	.+94     	; 0x5074 <eTaskGetState+0x78>
    5016:	0f b6       	in	r0, 0x3f	; 63
    5018:	f8 94       	cli
    501a:	0f 92       	push	r0
    501c:	8a 85       	ldd	r24, Y+10	; 0x0a
    501e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5020:	20 91 1d 2d 	lds	r18, 0x2D1D	; 0x802d1d <pxDelayedTaskList>
    5024:	30 91 1e 2d 	lds	r19, 0x2D1E	; 0x802d1e <pxDelayedTaskList+0x1>
    5028:	40 91 1b 2d 	lds	r20, 0x2D1B	; 0x802d1b <pxOverflowDelayedTaskList>
    502c:	50 91 1c 2d 	lds	r21, 0x2D1C	; 0x802d1c <pxOverflowDelayedTaskList+0x1>
    5030:	0f 90       	pop	r0
    5032:	0f be       	out	0x3f, r0	; 63
    5034:	82 17       	cp	r24, r18
    5036:	93 07       	cpc	r25, r19
    5038:	a9 f0       	breq	.+42     	; 0x5064 <eTaskGetState+0x68>
    503a:	84 17       	cp	r24, r20
    503c:	95 07       	cpc	r25, r21
    503e:	91 f0       	breq	.+36     	; 0x5064 <eTaskGetState+0x68>
    5040:	2c e2       	ldi	r18, 0x2C	; 44
    5042:	8f 3f       	cpi	r24, 0xFF	; 255
    5044:	92 07       	cpc	r25, r18
    5046:	51 f0       	breq	.+20     	; 0x505c <eTaskGetState+0x60>
    5048:	2d e2       	ldi	r18, 0x2D	; 45
    504a:	89 30       	cpi	r24, 0x09	; 9
    504c:	92 07       	cpc	r25, r18
    504e:	71 f0       	breq	.+28     	; 0x506c <eTaskGetState+0x70>
    5050:	89 2b       	or	r24, r25
    5052:	61 f0       	breq	.+24     	; 0x506c <eTaskGetState+0x70>
    5054:	81 e0       	ldi	r24, 0x01	; 1
    5056:	df 91       	pop	r29
    5058:	cf 91       	pop	r28
    505a:	08 95       	ret
    505c:	8c 89       	ldd	r24, Y+20	; 0x14
    505e:	9d 89       	ldd	r25, Y+21	; 0x15
    5060:	89 2b       	or	r24, r25
    5062:	99 f0       	breq	.+38     	; 0x508a <eTaskGetState+0x8e>
    5064:	82 e0       	ldi	r24, 0x02	; 2
    5066:	df 91       	pop	r29
    5068:	cf 91       	pop	r28
    506a:	08 95       	ret
    506c:	84 e0       	ldi	r24, 0x04	; 4
    506e:	df 91       	pop	r29
    5070:	cf 91       	pop	r28
    5072:	08 95       	ret
    5074:	80 e0       	ldi	r24, 0x00	; 0
    5076:	df 91       	pop	r29
    5078:	cf 91       	pop	r28
    507a:	08 95       	ret
    507c:	6c e4       	ldi	r22, 0x4C	; 76
    507e:	75 e0       	ldi	r23, 0x05	; 5
    5080:	8e ed       	ldi	r24, 0xDE	; 222
    5082:	93 e2       	ldi	r25, 0x23	; 35
    5084:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    5088:	bf cf       	rjmp	.-130    	; 0x5008 <eTaskGetState+0xc>
    508a:	8f a5       	ldd	r24, Y+47	; 0x2f
    508c:	81 30       	cpi	r24, 0x01	; 1
    508e:	51 f3       	breq	.-44     	; 0x5064 <eTaskGetState+0x68>
    5090:	83 e0       	ldi	r24, 0x03	; 3
    5092:	e1 cf       	rjmp	.-62     	; 0x5056 <eTaskGetState+0x5a>

00005094 <vTaskSuspend>:
    5094:	0f 93       	push	r16
    5096:	1f 93       	push	r17
    5098:	cf 93       	push	r28
    509a:	df 93       	push	r29
    509c:	ec 01       	movw	r28, r24
    509e:	0f b6       	in	r0, 0x3f	; 63
    50a0:	f8 94       	cli
    50a2:	0f 92       	push	r0
    50a4:	89 2b       	or	r24, r25
    50a6:	09 f4       	brne	.+2      	; 0x50aa <vTaskSuspend+0x16>
    50a8:	62 c0       	rjmp	.+196    	; 0x516e <vTaskSuspend+0xda>
    50aa:	8e 01       	movw	r16, r28
    50ac:	0e 5f       	subi	r16, 0xFE	; 254
    50ae:	1f 4f       	sbci	r17, 0xFF	; 255
    50b0:	c8 01       	movw	r24, r16
    50b2:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <uxListRemove>
    50b6:	8c 89       	ldd	r24, Y+20	; 0x14
    50b8:	9d 89       	ldd	r25, Y+21	; 0x15
    50ba:	89 2b       	or	r24, r25
    50bc:	21 f0       	breq	.+8      	; 0x50c6 <vTaskSuspend+0x32>
    50be:	ce 01       	movw	r24, r28
    50c0:	0c 96       	adiw	r24, 0x0c	; 12
    50c2:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <uxListRemove>
    50c6:	b8 01       	movw	r22, r16
    50c8:	8f ef       	ldi	r24, 0xFF	; 255
    50ca:	9c e2       	ldi	r25, 0x2C	; 44
    50cc:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vListInsertEnd>
    50d0:	8f a5       	ldd	r24, Y+47	; 0x2f
    50d2:	81 30       	cpi	r24, 0x01	; 1
    50d4:	21 f1       	breq	.+72     	; 0x511e <vTaskSuspend+0x8a>
    50d6:	0f 90       	pop	r0
    50d8:	0f be       	out	0x3f, r0	; 63
    50da:	80 91 fa 2c 	lds	r24, 0x2CFA	; 0x802cfa <xSchedulerRunning>
    50de:	88 23       	and	r24, r24
    50e0:	91 f0       	breq	.+36     	; 0x5106 <vTaskSuspend+0x72>
    50e2:	0f b6       	in	r0, 0x3f	; 63
    50e4:	f8 94       	cli
    50e6:	0f 92       	push	r0
    50e8:	e0 91 1d 2d 	lds	r30, 0x2D1D	; 0x802d1d <pxDelayedTaskList>
    50ec:	f0 91 1e 2d 	lds	r31, 0x2D1E	; 0x802d1e <pxDelayedTaskList+0x1>
    50f0:	80 81       	ld	r24, Z
    50f2:	81 11       	cpse	r24, r1
    50f4:	2b c0       	rjmp	.+86     	; 0x514c <vTaskSuspend+0xb8>
    50f6:	8f ef       	ldi	r24, 0xFF	; 255
    50f8:	9f ef       	ldi	r25, 0xFF	; 255
    50fa:	80 93 f4 2c 	sts	0x2CF4, r24	; 0x802cf4 <xNextTaskUnblockTime>
    50fe:	90 93 f5 2c 	sts	0x2CF5, r25	; 0x802cf5 <xNextTaskUnblockTime+0x1>
    5102:	0f 90       	pop	r0
    5104:	0f be       	out	0x3f, r0	; 63
    5106:	80 91 8b 2d 	lds	r24, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    510a:	90 91 8c 2d 	lds	r25, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    510e:	c8 17       	cp	r28, r24
    5110:	d9 07       	cpc	r29, r25
    5112:	39 f0       	breq	.+14     	; 0x5122 <vTaskSuspend+0x8e>
    5114:	df 91       	pop	r29
    5116:	cf 91       	pop	r28
    5118:	1f 91       	pop	r17
    511a:	0f 91       	pop	r16
    511c:	08 95       	ret
    511e:	1f a6       	std	Y+47, r1	; 0x2f
    5120:	da cf       	rjmp	.-76     	; 0x50d6 <vTaskSuspend+0x42>
    5122:	80 91 fa 2c 	lds	r24, 0x2CFA	; 0x802cfa <xSchedulerRunning>
    5126:	88 23       	and	r24, r24
    5128:	a1 f0       	breq	.+40     	; 0x5152 <vTaskSuspend+0xbe>
    512a:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <uxSchedulerSuspended>
    512e:	88 23       	and	r24, r24
    5130:	31 f0       	breq	.+12     	; 0x513e <vTaskSuspend+0xaa>
    5132:	68 ec       	ldi	r22, 0xC8	; 200
    5134:	76 e0       	ldi	r23, 0x06	; 6
    5136:	8e ed       	ldi	r24, 0xDE	; 222
    5138:	93 e2       	ldi	r25, 0x23	; 35
    513a:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    513e:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vPortYield>
    5142:	df 91       	pop	r29
    5144:	cf 91       	pop	r28
    5146:	1f 91       	pop	r17
    5148:	0f 91       	pop	r16
    514a:	08 95       	ret
    514c:	0e 94 7a 25 	call	0x4af4	; 0x4af4 <prvResetNextTaskUnblockTime.part.0>
    5150:	d8 cf       	rjmp	.-80     	; 0x5102 <vTaskSuspend+0x6e>
    5152:	90 91 ff 2c 	lds	r25, 0x2CFF	; 0x802cff <xSuspendedTaskList>
    5156:	80 91 fe 2c 	lds	r24, 0x2CFE	; 0x802cfe <uxCurrentNumberOfTasks>
    515a:	98 17       	cp	r25, r24
    515c:	99 f0       	breq	.+38     	; 0x5184 <vTaskSuspend+0xf0>
    515e:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <uxSchedulerSuspended>
    5162:	88 23       	and	r24, r24
    5164:	49 f0       	breq	.+18     	; 0x5178 <vTaskSuspend+0xe4>
    5166:	81 e0       	ldi	r24, 0x01	; 1
    5168:	80 93 f8 2c 	sts	0x2CF8, r24	; 0x802cf8 <xYieldPending>
    516c:	d3 cf       	rjmp	.-90     	; 0x5114 <vTaskSuspend+0x80>
    516e:	c0 91 8b 2d 	lds	r28, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    5172:	d0 91 8c 2d 	lds	r29, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    5176:	99 cf       	rjmp	.-206    	; 0x50aa <vTaskSuspend+0x16>
    5178:	df 91       	pop	r29
    517a:	cf 91       	pop	r28
    517c:	1f 91       	pop	r17
    517e:	0f 91       	pop	r16
    5180:	0c 94 06 26 	jmp	0x4c0c	; 0x4c0c <vTaskSwitchContext.part.5>
    5184:	10 92 8b 2d 	sts	0x2D8B, r1	; 0x802d8b <pxCurrentTCB>
    5188:	10 92 8c 2d 	sts	0x2D8C, r1	; 0x802d8c <pxCurrentTCB+0x1>
    518c:	c3 cf       	rjmp	.-122    	; 0x5114 <vTaskSuspend+0x80>

0000518e <vTaskResume>:
    518e:	0f 93       	push	r16
    5190:	1f 93       	push	r17
    5192:	cf 93       	push	r28
    5194:	df 93       	push	r29
    5196:	ec 01       	movw	r28, r24
    5198:	89 2b       	or	r24, r25
    519a:	09 f4       	brne	.+2      	; 0x519e <vTaskResume+0x10>
    519c:	3d c0       	rjmp	.+122    	; 0x5218 <vTaskResume+0x8a>
    519e:	80 91 8b 2d 	lds	r24, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    51a2:	90 91 8c 2d 	lds	r25, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    51a6:	c8 17       	cp	r28, r24
    51a8:	d9 07       	cpc	r29, r25
    51aa:	51 f0       	breq	.+20     	; 0x51c0 <vTaskResume+0x32>
    51ac:	0f b6       	in	r0, 0x3f	; 63
    51ae:	f8 94       	cli
    51b0:	0f 92       	push	r0
    51b2:	ce 01       	movw	r24, r28
    51b4:	0e 94 8b 25 	call	0x4b16	; 0x4b16 <prvTaskIsTaskSuspended>
    51b8:	81 11       	cpse	r24, r1
    51ba:	07 c0       	rjmp	.+14     	; 0x51ca <vTaskResume+0x3c>
    51bc:	0f 90       	pop	r0
    51be:	0f be       	out	0x3f, r0	; 63
    51c0:	df 91       	pop	r29
    51c2:	cf 91       	pop	r28
    51c4:	1f 91       	pop	r17
    51c6:	0f 91       	pop	r16
    51c8:	08 95       	ret
    51ca:	8e 01       	movw	r16, r28
    51cc:	0e 5f       	subi	r16, 0xFE	; 254
    51ce:	1f 4f       	sbci	r17, 0xFF	; 255
    51d0:	c8 01       	movw	r24, r16
    51d2:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <uxListRemove>
    51d6:	8e 89       	ldd	r24, Y+22	; 0x16
    51d8:	90 91 fb 2c 	lds	r25, 0x2CFB	; 0x802cfb <uxTopReadyPriority>
    51dc:	98 17       	cp	r25, r24
    51de:	10 f4       	brcc	.+4      	; 0x51e4 <vTaskResume+0x56>
    51e0:	80 93 fb 2c 	sts	0x2CFB, r24	; 0x802cfb <uxTopReadyPriority>
    51e4:	90 e0       	ldi	r25, 0x00	; 0
    51e6:	9c 01       	movw	r18, r24
    51e8:	22 0f       	add	r18, r18
    51ea:	33 1f       	adc	r19, r19
    51ec:	22 0f       	add	r18, r18
    51ee:	33 1f       	adc	r19, r19
    51f0:	22 0f       	add	r18, r18
    51f2:	33 1f       	adc	r19, r19
    51f4:	82 0f       	add	r24, r18
    51f6:	93 1f       	adc	r25, r19
    51f8:	b8 01       	movw	r22, r16
    51fa:	8f 5c       	subi	r24, 0xCF	; 207
    51fc:	92 4d       	sbci	r25, 0xD2	; 210
    51fe:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vListInsertEnd>
    5202:	e0 91 8b 2d 	lds	r30, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    5206:	f0 91 8c 2d 	lds	r31, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    520a:	9e 89       	ldd	r25, Y+22	; 0x16
    520c:	86 89       	ldd	r24, Z+22	; 0x16
    520e:	98 17       	cp	r25, r24
    5210:	a8 f2       	brcs	.-86     	; 0x51bc <vTaskResume+0x2e>
    5212:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vPortYield>
    5216:	d2 cf       	rjmp	.-92     	; 0x51bc <vTaskResume+0x2e>
    5218:	6c e1       	ldi	r22, 0x1C	; 28
    521a:	77 e0       	ldi	r23, 0x07	; 7
    521c:	8e ed       	ldi	r24, 0xDE	; 222
    521e:	93 e2       	ldi	r25, 0x23	; 35
    5220:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    5224:	80 91 8b 2d 	lds	r24, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    5228:	90 91 8c 2d 	lds	r25, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    522c:	c9 cf       	rjmp	.-110    	; 0x51c0 <vTaskResume+0x32>

0000522e <vTaskStartScheduler>:
    522e:	ef 92       	push	r14
    5230:	ff 92       	push	r15
    5232:	0f 93       	push	r16
    5234:	82 ef       	ldi	r24, 0xF2	; 242
    5236:	e8 2e       	mov	r14, r24
    5238:	8c e2       	ldi	r24, 0x2C	; 44
    523a:	f8 2e       	mov	r15, r24
    523c:	00 e0       	ldi	r16, 0x00	; 0
    523e:	20 e0       	ldi	r18, 0x00	; 0
    5240:	30 e0       	ldi	r19, 0x00	; 0
    5242:	40 e0       	ldi	r20, 0x00	; 0
    5244:	51 e0       	ldi	r21, 0x01	; 1
    5246:	62 ef       	ldi	r22, 0xF2	; 242
    5248:	73 e2       	ldi	r23, 0x23	; 35
    524a:	89 e2       	ldi	r24, 0x29	; 41
    524c:	95 e2       	ldi	r25, 0x25	; 37
    524e:	0e 94 c8 26 	call	0x4d90	; 0x4d90 <xTaskCreate>
    5252:	81 30       	cpi	r24, 0x01	; 1
    5254:	79 f0       	breq	.+30     	; 0x5274 <vTaskStartScheduler+0x46>
    5256:	8f 3f       	cpi	r24, 0xFF	; 255
    5258:	21 f0       	breq	.+8      	; 0x5262 <vTaskStartScheduler+0x34>
    525a:	0f 91       	pop	r16
    525c:	ff 90       	pop	r15
    525e:	ef 90       	pop	r14
    5260:	08 95       	ret
    5262:	67 e0       	ldi	r22, 0x07	; 7
    5264:	78 e0       	ldi	r23, 0x08	; 8
    5266:	8e ed       	ldi	r24, 0xDE	; 222
    5268:	93 e2       	ldi	r25, 0x23	; 35
    526a:	0f 91       	pop	r16
    526c:	ff 90       	pop	r15
    526e:	ef 90       	pop	r14
    5270:	0c 94 20 30 	jmp	0x6040	; 0x6040 <vAssertCalled>
    5274:	f8 94       	cli
    5276:	2f ef       	ldi	r18, 0xFF	; 255
    5278:	3f ef       	ldi	r19, 0xFF	; 255
    527a:	20 93 f4 2c 	sts	0x2CF4, r18	; 0x802cf4 <xNextTaskUnblockTime>
    527e:	30 93 f5 2c 	sts	0x2CF5, r19	; 0x802cf5 <xNextTaskUnblockTime+0x1>
    5282:	80 93 fa 2c 	sts	0x2CFA, r24	; 0x802cfa <xSchedulerRunning>
    5286:	10 92 fc 2c 	sts	0x2CFC, r1	; 0x802cfc <xTickCount>
    528a:	10 92 fd 2c 	sts	0x2CFD, r1	; 0x802cfd <xTickCount+0x1>
    528e:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <vConfigureTimerForRunTimeStats>
    5292:	0f 91       	pop	r16
    5294:	ff 90       	pop	r15
    5296:	ef 90       	pop	r14
    5298:	0c 94 db 1d 	jmp	0x3bb6	; 0x3bb6 <xPortStartScheduler>

0000529c <vTaskSuspendAll>:
    529c:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <uxSchedulerSuspended>
    52a0:	8f 5f       	subi	r24, 0xFF	; 255
    52a2:	80 93 f1 2c 	sts	0x2CF1, r24	; 0x802cf1 <uxSchedulerSuspended>
    52a6:	08 95       	ret

000052a8 <xTaskGetTickCount>:
    52a8:	0f b6       	in	r0, 0x3f	; 63
    52aa:	f8 94       	cli
    52ac:	0f 92       	push	r0
    52ae:	80 91 fc 2c 	lds	r24, 0x2CFC	; 0x802cfc <xTickCount>
    52b2:	90 91 fd 2c 	lds	r25, 0x2CFD	; 0x802cfd <xTickCount+0x1>
    52b6:	0f 90       	pop	r0
    52b8:	0f be       	out	0x3f, r0	; 63
    52ba:	08 95       	ret

000052bc <xTaskGetIdleTaskHandle>:
    52bc:	80 91 f2 2c 	lds	r24, 0x2CF2	; 0x802cf2 <xIdleTaskHandle>
    52c0:	90 91 f3 2c 	lds	r25, 0x2CF3	; 0x802cf3 <xIdleTaskHandle+0x1>
    52c4:	00 97       	sbiw	r24, 0x00	; 0
    52c6:	09 f0       	breq	.+2      	; 0x52ca <xTaskGetIdleTaskHandle+0xe>
    52c8:	08 95       	ret
    52ca:	6a ee       	ldi	r22, 0xEA	; 234
    52cc:	79 e0       	ldi	r23, 0x09	; 9
    52ce:	8e ed       	ldi	r24, 0xDE	; 222
    52d0:	93 e2       	ldi	r25, 0x23	; 35
    52d2:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    52d6:	80 91 f2 2c 	lds	r24, 0x2CF2	; 0x802cf2 <xIdleTaskHandle>
    52da:	90 91 f3 2c 	lds	r25, 0x2CF3	; 0x802cf3 <xIdleTaskHandle+0x1>
    52de:	08 95       	ret

000052e0 <xTaskIncrementTick>:
    52e0:	df 92       	push	r13
    52e2:	ef 92       	push	r14
    52e4:	ff 92       	push	r15
    52e6:	0f 93       	push	r16
    52e8:	1f 93       	push	r17
    52ea:	cf 93       	push	r28
    52ec:	df 93       	push	r29
    52ee:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <uxSchedulerSuspended>
    52f2:	81 11       	cpse	r24, r1
    52f4:	b9 c0       	rjmp	.+370    	; 0x5468 <xTaskIncrementTick+0x188>
    52f6:	e0 90 fc 2c 	lds	r14, 0x2CFC	; 0x802cfc <xTickCount>
    52fa:	f0 90 fd 2c 	lds	r15, 0x2CFD	; 0x802cfd <xTickCount+0x1>
    52fe:	8f ef       	ldi	r24, 0xFF	; 255
    5300:	e8 1a       	sub	r14, r24
    5302:	f8 0a       	sbc	r15, r24
    5304:	e0 92 fc 2c 	sts	0x2CFC, r14	; 0x802cfc <xTickCount>
    5308:	f0 92 fd 2c 	sts	0x2CFD, r15	; 0x802cfd <xTickCount+0x1>
    530c:	e1 14       	cp	r14, r1
    530e:	f1 04       	cpc	r15, r1
    5310:	49 f5       	brne	.+82     	; 0x5364 <xTaskIncrementTick+0x84>
    5312:	e0 91 1d 2d 	lds	r30, 0x2D1D	; 0x802d1d <pxDelayedTaskList>
    5316:	f0 91 1e 2d 	lds	r31, 0x2D1E	; 0x802d1e <pxDelayedTaskList+0x1>
    531a:	80 81       	ld	r24, Z
    531c:	81 11       	cpse	r24, r1
    531e:	ab c0       	rjmp	.+342    	; 0x5476 <xTaskIncrementTick+0x196>
    5320:	80 91 1d 2d 	lds	r24, 0x2D1D	; 0x802d1d <pxDelayedTaskList>
    5324:	90 91 1e 2d 	lds	r25, 0x2D1E	; 0x802d1e <pxDelayedTaskList+0x1>
    5328:	20 91 1b 2d 	lds	r18, 0x2D1B	; 0x802d1b <pxOverflowDelayedTaskList>
    532c:	30 91 1c 2d 	lds	r19, 0x2D1C	; 0x802d1c <pxOverflowDelayedTaskList+0x1>
    5330:	20 93 1d 2d 	sts	0x2D1D, r18	; 0x802d1d <pxDelayedTaskList>
    5334:	30 93 1e 2d 	sts	0x2D1E, r19	; 0x802d1e <pxDelayedTaskList+0x1>
    5338:	80 93 1b 2d 	sts	0x2D1B, r24	; 0x802d1b <pxOverflowDelayedTaskList>
    533c:	90 93 1c 2d 	sts	0x2D1C, r25	; 0x802d1c <pxOverflowDelayedTaskList+0x1>
    5340:	80 91 f7 2c 	lds	r24, 0x2CF7	; 0x802cf7 <xNumOfOverflows>
    5344:	8f 5f       	subi	r24, 0xFF	; 255
    5346:	80 93 f7 2c 	sts	0x2CF7, r24	; 0x802cf7 <xNumOfOverflows>
    534a:	e0 91 1d 2d 	lds	r30, 0x2D1D	; 0x802d1d <pxDelayedTaskList>
    534e:	f0 91 1e 2d 	lds	r31, 0x2D1E	; 0x802d1e <pxDelayedTaskList+0x1>
    5352:	80 81       	ld	r24, Z
    5354:	81 11       	cpse	r24, r1
    5356:	96 c0       	rjmp	.+300    	; 0x5484 <xTaskIncrementTick+0x1a4>
    5358:	8f ef       	ldi	r24, 0xFF	; 255
    535a:	9f ef       	ldi	r25, 0xFF	; 255
    535c:	80 93 f4 2c 	sts	0x2CF4, r24	; 0x802cf4 <xNextTaskUnblockTime>
    5360:	90 93 f5 2c 	sts	0x2CF5, r25	; 0x802cf5 <xNextTaskUnblockTime+0x1>
    5364:	80 91 f4 2c 	lds	r24, 0x2CF4	; 0x802cf4 <xNextTaskUnblockTime>
    5368:	90 91 f5 2c 	lds	r25, 0x2CF5	; 0x802cf5 <xNextTaskUnblockTime+0x1>
    536c:	d1 2c       	mov	r13, r1
    536e:	e8 16       	cp	r14, r24
    5370:	f9 06       	cpc	r15, r25
    5372:	08 f4       	brcc	.+2      	; 0x5376 <xTaskIncrementTick+0x96>
    5374:	53 c0       	rjmp	.+166    	; 0x541c <xTaskIncrementTick+0x13c>
    5376:	e0 91 1d 2d 	lds	r30, 0x2D1D	; 0x802d1d <pxDelayedTaskList>
    537a:	f0 91 1e 2d 	lds	r31, 0x2D1E	; 0x802d1e <pxDelayedTaskList+0x1>
    537e:	80 81       	ld	r24, Z
    5380:	88 23       	and	r24, r24
    5382:	09 f4       	brne	.+2      	; 0x5386 <xTaskIncrementTick+0xa6>
    5384:	45 c0       	rjmp	.+138    	; 0x5410 <xTaskIncrementTick+0x130>
    5386:	e0 91 1d 2d 	lds	r30, 0x2D1D	; 0x802d1d <pxDelayedTaskList>
    538a:	f0 91 1e 2d 	lds	r31, 0x2D1E	; 0x802d1e <pxDelayedTaskList+0x1>
    538e:	05 80       	ldd	r0, Z+5	; 0x05
    5390:	f6 81       	ldd	r31, Z+6	; 0x06
    5392:	e0 2d       	mov	r30, r0
    5394:	c6 81       	ldd	r28, Z+6	; 0x06
    5396:	d7 81       	ldd	r29, Z+7	; 0x07
    5398:	8a 81       	ldd	r24, Y+2	; 0x02
    539a:	9b 81       	ldd	r25, Y+3	; 0x03
    539c:	e8 16       	cp	r14, r24
    539e:	f9 06       	cpc	r15, r25
    53a0:	08 f4       	brcc	.+2      	; 0x53a4 <xTaskIncrementTick+0xc4>
    53a2:	73 c0       	rjmp	.+230    	; 0x548a <xTaskIncrementTick+0x1aa>
    53a4:	8e 01       	movw	r16, r28
    53a6:	0e 5f       	subi	r16, 0xFE	; 254
    53a8:	1f 4f       	sbci	r17, 0xFF	; 255
    53aa:	c8 01       	movw	r24, r16
    53ac:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <uxListRemove>
    53b0:	8c 89       	ldd	r24, Y+20	; 0x14
    53b2:	9d 89       	ldd	r25, Y+21	; 0x15
    53b4:	89 2b       	or	r24, r25
    53b6:	21 f0       	breq	.+8      	; 0x53c0 <xTaskIncrementTick+0xe0>
    53b8:	ce 01       	movw	r24, r28
    53ba:	0c 96       	adiw	r24, 0x0c	; 12
    53bc:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <uxListRemove>
    53c0:	8e 89       	ldd	r24, Y+22	; 0x16
    53c2:	90 91 fb 2c 	lds	r25, 0x2CFB	; 0x802cfb <uxTopReadyPriority>
    53c6:	98 17       	cp	r25, r24
    53c8:	10 f4       	brcc	.+4      	; 0x53ce <xTaskIncrementTick+0xee>
    53ca:	80 93 fb 2c 	sts	0x2CFB, r24	; 0x802cfb <uxTopReadyPriority>
    53ce:	90 e0       	ldi	r25, 0x00	; 0
    53d0:	9c 01       	movw	r18, r24
    53d2:	22 0f       	add	r18, r18
    53d4:	33 1f       	adc	r19, r19
    53d6:	22 0f       	add	r18, r18
    53d8:	33 1f       	adc	r19, r19
    53da:	22 0f       	add	r18, r18
    53dc:	33 1f       	adc	r19, r19
    53de:	82 0f       	add	r24, r18
    53e0:	93 1f       	adc	r25, r19
    53e2:	b8 01       	movw	r22, r16
    53e4:	8f 5c       	subi	r24, 0xCF	; 207
    53e6:	92 4d       	sbci	r25, 0xD2	; 210
    53e8:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vListInsertEnd>
    53ec:	e0 91 8b 2d 	lds	r30, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    53f0:	f0 91 8c 2d 	lds	r31, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    53f4:	9e 89       	ldd	r25, Y+22	; 0x16
    53f6:	86 89       	ldd	r24, Z+22	; 0x16
    53f8:	98 17       	cp	r25, r24
    53fa:	08 f4       	brcc	.+2      	; 0x53fe <xTaskIncrementTick+0x11e>
    53fc:	bc cf       	rjmp	.-136    	; 0x5376 <xTaskIncrementTick+0x96>
    53fe:	dd 24       	eor	r13, r13
    5400:	d3 94       	inc	r13
    5402:	e0 91 1d 2d 	lds	r30, 0x2D1D	; 0x802d1d <pxDelayedTaskList>
    5406:	f0 91 1e 2d 	lds	r31, 0x2D1E	; 0x802d1e <pxDelayedTaskList+0x1>
    540a:	80 81       	ld	r24, Z
    540c:	81 11       	cpse	r24, r1
    540e:	bb cf       	rjmp	.-138    	; 0x5386 <xTaskIncrementTick+0xa6>
    5410:	8f ef       	ldi	r24, 0xFF	; 255
    5412:	9f ef       	ldi	r25, 0xFF	; 255
    5414:	80 93 f4 2c 	sts	0x2CF4, r24	; 0x802cf4 <xNextTaskUnblockTime>
    5418:	90 93 f5 2c 	sts	0x2CF5, r25	; 0x802cf5 <xNextTaskUnblockTime+0x1>
    541c:	e0 91 8b 2d 	lds	r30, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    5420:	f0 91 8c 2d 	lds	r31, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    5424:	86 89       	ldd	r24, Z+22	; 0x16
    5426:	90 e0       	ldi	r25, 0x00	; 0
    5428:	fc 01       	movw	r30, r24
    542a:	ee 0f       	add	r30, r30
    542c:	ff 1f       	adc	r31, r31
    542e:	ee 0f       	add	r30, r30
    5430:	ff 1f       	adc	r31, r31
    5432:	ee 0f       	add	r30, r30
    5434:	ff 1f       	adc	r31, r31
    5436:	8e 0f       	add	r24, r30
    5438:	9f 1f       	adc	r25, r31
    543a:	fc 01       	movw	r30, r24
    543c:	ef 5c       	subi	r30, 0xCF	; 207
    543e:	f2 4d       	sbci	r31, 0xD2	; 210
    5440:	80 81       	ld	r24, Z
    5442:	82 30       	cpi	r24, 0x02	; 2
    5444:	10 f0       	brcs	.+4      	; 0x544a <xTaskIncrementTick+0x16a>
    5446:	dd 24       	eor	r13, r13
    5448:	d3 94       	inc	r13
    544a:	80 91 f8 2c 	lds	r24, 0x2CF8	; 0x802cf8 <xYieldPending>
    544e:	88 23       	and	r24, r24
    5450:	11 f0       	breq	.+4      	; 0x5456 <xTaskIncrementTick+0x176>
    5452:	dd 24       	eor	r13, r13
    5454:	d3 94       	inc	r13
    5456:	8d 2d       	mov	r24, r13
    5458:	df 91       	pop	r29
    545a:	cf 91       	pop	r28
    545c:	1f 91       	pop	r17
    545e:	0f 91       	pop	r16
    5460:	ff 90       	pop	r15
    5462:	ef 90       	pop	r14
    5464:	df 90       	pop	r13
    5466:	08 95       	ret
    5468:	80 91 f9 2c 	lds	r24, 0x2CF9	; 0x802cf9 <uxPendedTicks>
    546c:	8f 5f       	subi	r24, 0xFF	; 255
    546e:	80 93 f9 2c 	sts	0x2CF9, r24	; 0x802cf9 <uxPendedTicks>
    5472:	d1 2c       	mov	r13, r1
    5474:	ea cf       	rjmp	.-44     	; 0x544a <xTaskIncrementTick+0x16a>
    5476:	66 e6       	ldi	r22, 0x66	; 102
    5478:	7a e0       	ldi	r23, 0x0A	; 10
    547a:	8e ed       	ldi	r24, 0xDE	; 222
    547c:	93 e2       	ldi	r25, 0x23	; 35
    547e:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    5482:	4e cf       	rjmp	.-356    	; 0x5320 <xTaskIncrementTick+0x40>
    5484:	0e 94 7a 25 	call	0x4af4	; 0x4af4 <prvResetNextTaskUnblockTime.part.0>
    5488:	6d cf       	rjmp	.-294    	; 0x5364 <xTaskIncrementTick+0x84>
    548a:	80 93 f4 2c 	sts	0x2CF4, r24	; 0x802cf4 <xNextTaskUnblockTime>
    548e:	90 93 f5 2c 	sts	0x2CF5, r25	; 0x802cf5 <xNextTaskUnblockTime+0x1>
    5492:	c4 cf       	rjmp	.-120    	; 0x541c <xTaskIncrementTick+0x13c>

00005494 <xTaskResumeAll>:
    5494:	ff 92       	push	r15
    5496:	0f 93       	push	r16
    5498:	1f 93       	push	r17
    549a:	cf 93       	push	r28
    549c:	df 93       	push	r29
    549e:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <uxSchedulerSuspended>
    54a2:	88 23       	and	r24, r24
    54a4:	09 f4       	brne	.+2      	; 0x54a8 <xTaskResumeAll+0x14>
    54a6:	77 c0       	rjmp	.+238    	; 0x5596 <xTaskResumeAll+0x102>
    54a8:	0f b6       	in	r0, 0x3f	; 63
    54aa:	f8 94       	cli
    54ac:	0f 92       	push	r0
    54ae:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <uxSchedulerSuspended>
    54b2:	81 50       	subi	r24, 0x01	; 1
    54b4:	80 93 f1 2c 	sts	0x2CF1, r24	; 0x802cf1 <uxSchedulerSuspended>
    54b8:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <uxSchedulerSuspended>
    54bc:	81 11       	cpse	r24, r1
    54be:	62 c0       	rjmp	.+196    	; 0x5584 <xTaskResumeAll+0xf0>
    54c0:	80 91 fe 2c 	lds	r24, 0x2CFE	; 0x802cfe <uxCurrentNumberOfTasks>
    54c4:	88 23       	and	r24, r24
    54c6:	09 f4       	brne	.+2      	; 0x54ca <xTaskResumeAll+0x36>
    54c8:	5d c0       	rjmp	.+186    	; 0x5584 <xTaskResumeAll+0xf0>
    54ca:	c0 e0       	ldi	r28, 0x00	; 0
    54cc:	d0 e0       	ldi	r29, 0x00	; 0
    54ce:	ff 24       	eor	r15, r15
    54d0:	f3 94       	inc	r15
    54d2:	80 91 12 2d 	lds	r24, 0x2D12	; 0x802d12 <xPendingReadyList>
    54d6:	88 23       	and	r24, r24
    54d8:	a1 f1       	breq	.+104    	; 0x5542 <xTaskResumeAll+0xae>
    54da:	e0 91 17 2d 	lds	r30, 0x2D17	; 0x802d17 <xPendingReadyList+0x5>
    54de:	f0 91 18 2d 	lds	r31, 0x2D18	; 0x802d18 <xPendingReadyList+0x6>
    54e2:	c6 81       	ldd	r28, Z+6	; 0x06
    54e4:	d7 81       	ldd	r29, Z+7	; 0x07
    54e6:	ce 01       	movw	r24, r28
    54e8:	0c 96       	adiw	r24, 0x0c	; 12
    54ea:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <uxListRemove>
    54ee:	8e 01       	movw	r16, r28
    54f0:	0e 5f       	subi	r16, 0xFE	; 254
    54f2:	1f 4f       	sbci	r17, 0xFF	; 255
    54f4:	c8 01       	movw	r24, r16
    54f6:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <uxListRemove>
    54fa:	8e 89       	ldd	r24, Y+22	; 0x16
    54fc:	90 91 fb 2c 	lds	r25, 0x2CFB	; 0x802cfb <uxTopReadyPriority>
    5500:	98 17       	cp	r25, r24
    5502:	10 f4       	brcc	.+4      	; 0x5508 <xTaskResumeAll+0x74>
    5504:	80 93 fb 2c 	sts	0x2CFB, r24	; 0x802cfb <uxTopReadyPriority>
    5508:	90 e0       	ldi	r25, 0x00	; 0
    550a:	9c 01       	movw	r18, r24
    550c:	22 0f       	add	r18, r18
    550e:	33 1f       	adc	r19, r19
    5510:	22 0f       	add	r18, r18
    5512:	33 1f       	adc	r19, r19
    5514:	22 0f       	add	r18, r18
    5516:	33 1f       	adc	r19, r19
    5518:	82 0f       	add	r24, r18
    551a:	93 1f       	adc	r25, r19
    551c:	b8 01       	movw	r22, r16
    551e:	8f 5c       	subi	r24, 0xCF	; 207
    5520:	92 4d       	sbci	r25, 0xD2	; 210
    5522:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vListInsertEnd>
    5526:	e0 91 8b 2d 	lds	r30, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    552a:	f0 91 8c 2d 	lds	r31, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    552e:	9e 89       	ldd	r25, Y+22	; 0x16
    5530:	86 89       	ldd	r24, Z+22	; 0x16
    5532:	98 17       	cp	r25, r24
    5534:	70 f2       	brcs	.-100    	; 0x54d2 <xTaskResumeAll+0x3e>
    5536:	f0 92 f8 2c 	sts	0x2CF8, r15	; 0x802cf8 <xYieldPending>
    553a:	80 91 12 2d 	lds	r24, 0x2D12	; 0x802d12 <xPendingReadyList>
    553e:	81 11       	cpse	r24, r1
    5540:	cc cf       	rjmp	.-104    	; 0x54da <xTaskResumeAll+0x46>
    5542:	cd 2b       	or	r28, r29
    5544:	69 f0       	breq	.+26     	; 0x5560 <xTaskResumeAll+0xcc>
    5546:	e0 91 1d 2d 	lds	r30, 0x2D1D	; 0x802d1d <pxDelayedTaskList>
    554a:	f0 91 1e 2d 	lds	r31, 0x2D1E	; 0x802d1e <pxDelayedTaskList+0x1>
    554e:	80 81       	ld	r24, Z
    5550:	81 11       	cpse	r24, r1
    5552:	2c c0       	rjmp	.+88     	; 0x55ac <xTaskResumeAll+0x118>
    5554:	8f ef       	ldi	r24, 0xFF	; 255
    5556:	9f ef       	ldi	r25, 0xFF	; 255
    5558:	80 93 f4 2c 	sts	0x2CF4, r24	; 0x802cf4 <xNextTaskUnblockTime>
    555c:	90 93 f5 2c 	sts	0x2CF5, r25	; 0x802cf5 <xNextTaskUnblockTime+0x1>
    5560:	c0 91 f9 2c 	lds	r28, 0x2CF9	; 0x802cf9 <uxPendedTicks>
    5564:	cc 23       	and	r28, r28
    5566:	51 f0       	breq	.+20     	; 0x557c <xTaskResumeAll+0xe8>
    5568:	d1 e0       	ldi	r29, 0x01	; 1
    556a:	0e 94 70 29 	call	0x52e0	; 0x52e0 <xTaskIncrementTick>
    556e:	81 11       	cpse	r24, r1
    5570:	d0 93 f8 2c 	sts	0x2CF8, r29	; 0x802cf8 <xYieldPending>
    5574:	c1 50       	subi	r28, 0x01	; 1
    5576:	c9 f7       	brne	.-14     	; 0x556a <xTaskResumeAll+0xd6>
    5578:	10 92 f9 2c 	sts	0x2CF9, r1	; 0x802cf9 <uxPendedTicks>
    557c:	80 91 f8 2c 	lds	r24, 0x2CF8	; 0x802cf8 <xYieldPending>
    5580:	81 11       	cpse	r24, r1
    5582:	10 c0       	rjmp	.+32     	; 0x55a4 <xTaskResumeAll+0x110>
    5584:	80 e0       	ldi	r24, 0x00	; 0
    5586:	0f 90       	pop	r0
    5588:	0f be       	out	0x3f, r0	; 63
    558a:	df 91       	pop	r29
    558c:	cf 91       	pop	r28
    558e:	1f 91       	pop	r17
    5590:	0f 91       	pop	r16
    5592:	ff 90       	pop	r15
    5594:	08 95       	ret
    5596:	6c e6       	ldi	r22, 0x6C	; 108
    5598:	78 e0       	ldi	r23, 0x08	; 8
    559a:	8e ed       	ldi	r24, 0xDE	; 222
    559c:	93 e2       	ldi	r25, 0x23	; 35
    559e:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    55a2:	82 cf       	rjmp	.-252    	; 0x54a8 <xTaskResumeAll+0x14>
    55a4:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vPortYield>
    55a8:	81 e0       	ldi	r24, 0x01	; 1
    55aa:	ed cf       	rjmp	.-38     	; 0x5586 <xTaskResumeAll+0xf2>
    55ac:	0e 94 7a 25 	call	0x4af4	; 0x4af4 <prvResetNextTaskUnblockTime.part.0>
    55b0:	d7 cf       	rjmp	.-82     	; 0x5560 <xTaskResumeAll+0xcc>

000055b2 <vTaskDelayUntil>:
    55b2:	0f 93       	push	r16
    55b4:	1f 93       	push	r17
    55b6:	cf 93       	push	r28
    55b8:	df 93       	push	r29
    55ba:	8c 01       	movw	r16, r24
    55bc:	eb 01       	movw	r28, r22
    55be:	89 2b       	or	r24, r25
    55c0:	09 f4       	brne	.+2      	; 0x55c4 <vTaskDelayUntil+0x12>
    55c2:	46 c0       	rjmp	.+140    	; 0x5650 <vTaskDelayUntil+0x9e>
    55c4:	20 97       	sbiw	r28, 0x00	; 0
    55c6:	e9 f1       	breq	.+122    	; 0x5642 <vTaskDelayUntil+0x90>
    55c8:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <uxSchedulerSuspended>
    55cc:	81 11       	cpse	r24, r1
    55ce:	32 c0       	rjmp	.+100    	; 0x5634 <vTaskDelayUntil+0x82>
    55d0:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <uxSchedulerSuspended>
    55d4:	8f 5f       	subi	r24, 0xFF	; 255
    55d6:	80 93 f1 2c 	sts	0x2CF1, r24	; 0x802cf1 <uxSchedulerSuspended>
    55da:	40 91 fc 2c 	lds	r20, 0x2CFC	; 0x802cfc <xTickCount>
    55de:	50 91 fd 2c 	lds	r21, 0x2CFD	; 0x802cfd <xTickCount+0x1>
    55e2:	f8 01       	movw	r30, r16
    55e4:	20 81       	ld	r18, Z
    55e6:	31 81       	ldd	r19, Z+1	; 0x01
    55e8:	ce 01       	movw	r24, r28
    55ea:	82 0f       	add	r24, r18
    55ec:	93 1f       	adc	r25, r19
    55ee:	42 17       	cp	r20, r18
    55f0:	53 07       	cpc	r21, r19
    55f2:	88 f4       	brcc	.+34     	; 0x5616 <vTaskDelayUntil+0x64>
    55f4:	82 17       	cp	r24, r18
    55f6:	93 07       	cpc	r25, r19
    55f8:	88 f0       	brcs	.+34     	; 0x561c <vTaskDelayUntil+0x6a>
    55fa:	f8 01       	movw	r30, r16
    55fc:	80 83       	st	Z, r24
    55fe:	91 83       	std	Z+1, r25	; 0x01
    5600:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>
    5604:	81 11       	cpse	r24, r1
    5606:	02 c0       	rjmp	.+4      	; 0x560c <vTaskDelayUntil+0x5a>
    5608:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vPortYield>
    560c:	df 91       	pop	r29
    560e:	cf 91       	pop	r28
    5610:	1f 91       	pop	r17
    5612:	0f 91       	pop	r16
    5614:	08 95       	ret
    5616:	82 17       	cp	r24, r18
    5618:	93 07       	cpc	r25, r19
    561a:	18 f0       	brcs	.+6      	; 0x5622 <vTaskDelayUntil+0x70>
    561c:	48 17       	cp	r20, r24
    561e:	59 07       	cpc	r21, r25
    5620:	60 f7       	brcc	.-40     	; 0x55fa <vTaskDelayUntil+0x48>
    5622:	f8 01       	movw	r30, r16
    5624:	80 83       	st	Z, r24
    5626:	91 83       	std	Z+1, r25	; 0x01
    5628:	60 e0       	ldi	r22, 0x00	; 0
    562a:	84 1b       	sub	r24, r20
    562c:	95 0b       	sbc	r25, r21
    562e:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <prvAddCurrentTaskToDelayedList>
    5632:	e6 cf       	rjmp	.-52     	; 0x5600 <vTaskDelayUntil+0x4e>
    5634:	6c ec       	ldi	r22, 0xCC	; 204
    5636:	74 e0       	ldi	r23, 0x04	; 4
    5638:	8e ed       	ldi	r24, 0xDE	; 222
    563a:	93 e2       	ldi	r25, 0x23	; 35
    563c:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    5640:	c7 cf       	rjmp	.-114    	; 0x55d0 <vTaskDelayUntil+0x1e>
    5642:	6b ec       	ldi	r22, 0xCB	; 203
    5644:	74 e0       	ldi	r23, 0x04	; 4
    5646:	8e ed       	ldi	r24, 0xDE	; 222
    5648:	93 e2       	ldi	r25, 0x23	; 35
    564a:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    564e:	bc cf       	rjmp	.-136    	; 0x55c8 <vTaskDelayUntil+0x16>
    5650:	6a ec       	ldi	r22, 0xCA	; 202
    5652:	74 e0       	ldi	r23, 0x04	; 4
    5654:	8e ed       	ldi	r24, 0xDE	; 222
    5656:	93 e2       	ldi	r25, 0x23	; 35
    5658:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    565c:	b3 cf       	rjmp	.-154    	; 0x55c4 <vTaskDelayUntil+0x12>

0000565e <vTaskDelay>:
    565e:	cf 93       	push	r28
    5660:	df 93       	push	r29
    5662:	ec 01       	movw	r28, r24
    5664:	89 2b       	or	r24, r25
    5666:	29 f4       	brne	.+10     	; 0x5672 <vTaskDelay+0x14>
    5668:	0e 94 18 1e 	call	0x3c30	; 0x3c30 <vPortYield>
    566c:	df 91       	pop	r29
    566e:	cf 91       	pop	r28
    5670:	08 95       	ret
    5672:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <uxSchedulerSuspended>
    5676:	81 11       	cpse	r24, r1
    5678:	10 c0       	rjmp	.+32     	; 0x569a <vTaskDelay+0x3c>
    567a:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <uxSchedulerSuspended>
    567e:	8f 5f       	subi	r24, 0xFF	; 255
    5680:	80 93 f1 2c 	sts	0x2CF1, r24	; 0x802cf1 <uxSchedulerSuspended>
    5684:	60 e0       	ldi	r22, 0x00	; 0
    5686:	ce 01       	movw	r24, r28
    5688:	0e 94 aa 25 	call	0x4b54	; 0x4b54 <prvAddCurrentTaskToDelayedList>
    568c:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>
    5690:	88 23       	and	r24, r24
    5692:	51 f3       	breq	.-44     	; 0x5668 <vTaskDelay+0xa>
    5694:	df 91       	pop	r29
    5696:	cf 91       	pop	r28
    5698:	08 95       	ret
    569a:	60 e2       	ldi	r22, 0x20	; 32
    569c:	75 e0       	ldi	r23, 0x05	; 5
    569e:	8e ed       	ldi	r24, 0xDE	; 222
    56a0:	93 e2       	ldi	r25, 0x23	; 35
    56a2:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    56a6:	e9 cf       	rjmp	.-46     	; 0x567a <vTaskDelay+0x1c>

000056a8 <vTaskSwitchContext>:
    56a8:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <uxSchedulerSuspended>
    56ac:	81 11       	cpse	r24, r1
    56ae:	02 c0       	rjmp	.+4      	; 0x56b4 <vTaskSwitchContext+0xc>
    56b0:	0c 94 06 26 	jmp	0x4c0c	; 0x4c0c <vTaskSwitchContext.part.5>
    56b4:	81 e0       	ldi	r24, 0x01	; 1
    56b6:	80 93 f8 2c 	sts	0x2CF8, r24	; 0x802cf8 <xYieldPending>
    56ba:	08 95       	ret

000056bc <vTaskPlaceOnEventList>:
    56bc:	0f 93       	push	r16
    56be:	1f 93       	push	r17
    56c0:	cf 93       	push	r28
    56c2:	df 93       	push	r29
    56c4:	ec 01       	movw	r28, r24
    56c6:	8b 01       	movw	r16, r22
    56c8:	89 2b       	or	r24, r25
    56ca:	89 f0       	breq	.+34     	; 0x56ee <vTaskPlaceOnEventList+0x32>
    56cc:	60 91 8b 2d 	lds	r22, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    56d0:	70 91 8c 2d 	lds	r23, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    56d4:	64 5f       	subi	r22, 0xF4	; 244
    56d6:	7f 4f       	sbci	r23, 0xFF	; 255
    56d8:	ce 01       	movw	r24, r28
    56da:	0e 94 16 1d 	call	0x3a2c	; 0x3a2c <vListInsert>
    56de:	61 e0       	ldi	r22, 0x01	; 1
    56e0:	c8 01       	movw	r24, r16
    56e2:	df 91       	pop	r29
    56e4:	cf 91       	pop	r28
    56e6:	1f 91       	pop	r17
    56e8:	0f 91       	pop	r16
    56ea:	0c 94 aa 25 	jmp	0x4b54	; 0x4b54 <prvAddCurrentTaskToDelayedList>
    56ee:	63 ea       	ldi	r22, 0xA3	; 163
    56f0:	7b e0       	ldi	r23, 0x0B	; 11
    56f2:	8e ed       	ldi	r24, 0xDE	; 222
    56f4:	93 e2       	ldi	r25, 0x23	; 35
    56f6:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    56fa:	e8 cf       	rjmp	.-48     	; 0x56cc <vTaskPlaceOnEventList+0x10>

000056fc <xTaskRemoveFromEventList>:
    56fc:	0f 93       	push	r16
    56fe:	1f 93       	push	r17
    5700:	cf 93       	push	r28
    5702:	df 93       	push	r29
    5704:	dc 01       	movw	r26, r24
    5706:	15 96       	adiw	r26, 0x05	; 5
    5708:	ed 91       	ld	r30, X+
    570a:	fc 91       	ld	r31, X
    570c:	16 97       	sbiw	r26, 0x06	; 6
    570e:	c6 81       	ldd	r28, Z+6	; 0x06
    5710:	d7 81       	ldd	r29, Z+7	; 0x07
    5712:	20 97       	sbiw	r28, 0x00	; 0
    5714:	09 f4       	brne	.+2      	; 0x5718 <xTaskRemoveFromEventList+0x1c>
    5716:	42 c0       	rjmp	.+132    	; 0x579c <xTaskRemoveFromEventList+0xa0>
    5718:	8e 01       	movw	r16, r28
    571a:	04 5f       	subi	r16, 0xF4	; 244
    571c:	1f 4f       	sbci	r17, 0xFF	; 255
    571e:	c8 01       	movw	r24, r16
    5720:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <uxListRemove>
    5724:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <uxSchedulerSuspended>
    5728:	81 11       	cpse	r24, r1
    572a:	29 c0       	rjmp	.+82     	; 0x577e <xTaskRemoveFromEventList+0x82>
    572c:	0a 50       	subi	r16, 0x0A	; 10
    572e:	11 09       	sbc	r17, r1
    5730:	c8 01       	movw	r24, r16
    5732:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <uxListRemove>
    5736:	8e 89       	ldd	r24, Y+22	; 0x16
    5738:	90 91 fb 2c 	lds	r25, 0x2CFB	; 0x802cfb <uxTopReadyPriority>
    573c:	98 17       	cp	r25, r24
    573e:	28 f1       	brcs	.+74     	; 0x578a <xTaskRemoveFromEventList+0x8e>
    5740:	90 e0       	ldi	r25, 0x00	; 0
    5742:	9c 01       	movw	r18, r24
    5744:	22 0f       	add	r18, r18
    5746:	33 1f       	adc	r19, r19
    5748:	22 0f       	add	r18, r18
    574a:	33 1f       	adc	r19, r19
    574c:	22 0f       	add	r18, r18
    574e:	33 1f       	adc	r19, r19
    5750:	82 0f       	add	r24, r18
    5752:	93 1f       	adc	r25, r19
    5754:	b8 01       	movw	r22, r16
    5756:	8f 5c       	subi	r24, 0xCF	; 207
    5758:	92 4d       	sbci	r25, 0xD2	; 210
    575a:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vListInsertEnd>
    575e:	e0 91 8b 2d 	lds	r30, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    5762:	f0 91 8c 2d 	lds	r31, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    5766:	9e 89       	ldd	r25, Y+22	; 0x16
    5768:	86 89       	ldd	r24, Z+22	; 0x16
    576a:	89 17       	cp	r24, r25
    576c:	88 f4       	brcc	.+34     	; 0x5790 <xTaskRemoveFromEventList+0x94>
    576e:	81 e0       	ldi	r24, 0x01	; 1
    5770:	80 93 f8 2c 	sts	0x2CF8, r24	; 0x802cf8 <xYieldPending>
    5774:	df 91       	pop	r29
    5776:	cf 91       	pop	r28
    5778:	1f 91       	pop	r17
    577a:	0f 91       	pop	r16
    577c:	08 95       	ret
    577e:	b8 01       	movw	r22, r16
    5780:	82 e1       	ldi	r24, 0x12	; 18
    5782:	9d e2       	ldi	r25, 0x2D	; 45
    5784:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vListInsertEnd>
    5788:	ea cf       	rjmp	.-44     	; 0x575e <xTaskRemoveFromEventList+0x62>
    578a:	80 93 fb 2c 	sts	0x2CFB, r24	; 0x802cfb <uxTopReadyPriority>
    578e:	d8 cf       	rjmp	.-80     	; 0x5740 <xTaskRemoveFromEventList+0x44>
    5790:	80 e0       	ldi	r24, 0x00	; 0
    5792:	df 91       	pop	r29
    5794:	cf 91       	pop	r28
    5796:	1f 91       	pop	r17
    5798:	0f 91       	pop	r16
    579a:	08 95       	ret
    579c:	6e ef       	ldi	r22, 0xFE	; 254
    579e:	7b e0       	ldi	r23, 0x0B	; 11
    57a0:	8e ed       	ldi	r24, 0xDE	; 222
    57a2:	93 e2       	ldi	r25, 0x23	; 35
    57a4:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    57a8:	b7 cf       	rjmp	.-146    	; 0x5718 <xTaskRemoveFromEventList+0x1c>

000057aa <vTaskInternalSetTimeOutState>:
    57aa:	20 91 f7 2c 	lds	r18, 0x2CF7	; 0x802cf7 <xNumOfOverflows>
    57ae:	fc 01       	movw	r30, r24
    57b0:	20 83       	st	Z, r18
    57b2:	20 91 fc 2c 	lds	r18, 0x2CFC	; 0x802cfc <xTickCount>
    57b6:	30 91 fd 2c 	lds	r19, 0x2CFD	; 0x802cfd <xTickCount+0x1>
    57ba:	21 83       	std	Z+1, r18	; 0x01
    57bc:	32 83       	std	Z+2, r19	; 0x02
    57be:	08 95       	ret

000057c0 <xTaskCheckForTimeOut>:
    57c0:	0f 93       	push	r16
    57c2:	1f 93       	push	r17
    57c4:	cf 93       	push	r28
    57c6:	df 93       	push	r29
    57c8:	ec 01       	movw	r28, r24
    57ca:	8b 01       	movw	r16, r22
    57cc:	89 2b       	or	r24, r25
    57ce:	09 f4       	brne	.+2      	; 0x57d2 <xTaskCheckForTimeOut+0x12>
    57d0:	40 c0       	rjmp	.+128    	; 0x5852 <xTaskCheckForTimeOut+0x92>
    57d2:	01 15       	cp	r16, r1
    57d4:	11 05       	cpc	r17, r1
    57d6:	09 f4       	brne	.+2      	; 0x57da <xTaskCheckForTimeOut+0x1a>
    57d8:	43 c0       	rjmp	.+134    	; 0x5860 <xTaskCheckForTimeOut+0xa0>
    57da:	0f b6       	in	r0, 0x3f	; 63
    57dc:	f8 94       	cli
    57de:	0f 92       	push	r0
    57e0:	80 91 fc 2c 	lds	r24, 0x2CFC	; 0x802cfc <xTickCount>
    57e4:	90 91 fd 2c 	lds	r25, 0x2CFD	; 0x802cfd <xTickCount+0x1>
    57e8:	f8 01       	movw	r30, r16
    57ea:	20 81       	ld	r18, Z
    57ec:	31 81       	ldd	r19, Z+1	; 0x01
    57ee:	2f 3f       	cpi	r18, 0xFF	; 255
    57f0:	ff ef       	ldi	r31, 0xFF	; 255
    57f2:	3f 07       	cpc	r19, r31
    57f4:	61 f1       	breq	.+88     	; 0x584e <xTaskCheckForTimeOut+0x8e>
    57f6:	49 81       	ldd	r20, Y+1	; 0x01
    57f8:	5a 81       	ldd	r21, Y+2	; 0x02
    57fa:	60 91 f7 2c 	lds	r22, 0x2CF7	; 0x802cf7 <xNumOfOverflows>
    57fe:	78 81       	ld	r23, Y
    5800:	76 17       	cp	r23, r22
    5802:	19 f0       	breq	.+6      	; 0x580a <xTaskCheckForTimeOut+0x4a>
    5804:	84 17       	cp	r24, r20
    5806:	95 07       	cpc	r25, r21
    5808:	80 f4       	brcc	.+32     	; 0x582a <xTaskCheckForTimeOut+0x6a>
    580a:	84 1b       	sub	r24, r20
    580c:	95 0b       	sbc	r25, r21
    580e:	82 17       	cp	r24, r18
    5810:	93 07       	cpc	r25, r19
    5812:	68 f0       	brcs	.+26     	; 0x582e <xTaskCheckForTimeOut+0x6e>
    5814:	f8 01       	movw	r30, r16
    5816:	10 82       	st	Z, r1
    5818:	11 82       	std	Z+1, r1	; 0x01
    581a:	81 e0       	ldi	r24, 0x01	; 1
    581c:	0f 90       	pop	r0
    581e:	0f be       	out	0x3f, r0	; 63
    5820:	df 91       	pop	r29
    5822:	cf 91       	pop	r28
    5824:	1f 91       	pop	r17
    5826:	0f 91       	pop	r16
    5828:	08 95       	ret
    582a:	81 e0       	ldi	r24, 0x01	; 1
    582c:	f7 cf       	rjmp	.-18     	; 0x581c <xTaskCheckForTimeOut+0x5c>
    582e:	28 1b       	sub	r18, r24
    5830:	39 0b       	sbc	r19, r25
    5832:	f8 01       	movw	r30, r16
    5834:	20 83       	st	Z, r18
    5836:	31 83       	std	Z+1, r19	; 0x01
    5838:	80 91 f7 2c 	lds	r24, 0x2CF7	; 0x802cf7 <xNumOfOverflows>
    583c:	88 83       	st	Y, r24
    583e:	80 91 fc 2c 	lds	r24, 0x2CFC	; 0x802cfc <xTickCount>
    5842:	90 91 fd 2c 	lds	r25, 0x2CFD	; 0x802cfd <xTickCount+0x1>
    5846:	89 83       	std	Y+1, r24	; 0x01
    5848:	9a 83       	std	Y+2, r25	; 0x02
    584a:	80 e0       	ldi	r24, 0x00	; 0
    584c:	e7 cf       	rjmp	.-50     	; 0x581c <xTaskCheckForTimeOut+0x5c>
    584e:	80 e0       	ldi	r24, 0x00	; 0
    5850:	e5 cf       	rjmp	.-54     	; 0x581c <xTaskCheckForTimeOut+0x5c>
    5852:	69 e6       	ldi	r22, 0x69	; 105
    5854:	7c e0       	ldi	r23, 0x0C	; 12
    5856:	8e ed       	ldi	r24, 0xDE	; 222
    5858:	93 e2       	ldi	r25, 0x23	; 35
    585a:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    585e:	b9 cf       	rjmp	.-142    	; 0x57d2 <xTaskCheckForTimeOut+0x12>
    5860:	6a e6       	ldi	r22, 0x6A	; 106
    5862:	7c e0       	ldi	r23, 0x0C	; 12
    5864:	8e ed       	ldi	r24, 0xDE	; 222
    5866:	93 e2       	ldi	r25, 0x23	; 35
    5868:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    586c:	b6 cf       	rjmp	.-148    	; 0x57da <xTaskCheckForTimeOut+0x1a>

0000586e <vTaskMissedYield>:
    586e:	81 e0       	ldi	r24, 0x01	; 1
    5870:	80 93 f8 2c 	sts	0x2CF8, r24	; 0x802cf8 <xYieldPending>
    5874:	08 95       	ret

00005876 <vTaskGetInfo>:
    5876:	ff 92       	push	r15
    5878:	0f 93       	push	r16
    587a:	1f 93       	push	r17
    587c:	cf 93       	push	r28
    587e:	df 93       	push	r29
    5880:	8c 01       	movw	r16, r24
    5882:	eb 01       	movw	r28, r22
    5884:	f4 2e       	mov	r15, r20
    5886:	89 2b       	or	r24, r25
    5888:	09 f4       	brne	.+2      	; 0x588c <vTaskGetInfo+0x16>
    588a:	64 c0       	rjmp	.+200    	; 0x5954 <vTaskGetInfo+0xde>
    588c:	08 83       	st	Y, r16
    588e:	19 83       	std	Y+1, r17	; 0x01
    5890:	c8 01       	movw	r24, r16
    5892:	49 96       	adiw	r24, 0x19	; 25
    5894:	8a 83       	std	Y+2, r24	; 0x02
    5896:	9b 83       	std	Y+3, r25	; 0x03
    5898:	d8 01       	movw	r26, r16
    589a:	56 96       	adiw	r26, 0x16	; 22
    589c:	8c 91       	ld	r24, X
    589e:	56 97       	sbiw	r26, 0x16	; 22
    58a0:	8e 83       	std	Y+6, r24	; 0x06
    58a2:	57 96       	adiw	r26, 0x17	; 23
    58a4:	8d 91       	ld	r24, X+
    58a6:	9c 91       	ld	r25, X
    58a8:	58 97       	sbiw	r26, 0x18	; 24
    58aa:	8c 87       	std	Y+12, r24	; 0x0c
    58ac:	9d 87       	std	Y+13, r25	; 0x0d
    58ae:	91 96       	adiw	r26, 0x21	; 33
    58b0:	8c 91       	ld	r24, X
    58b2:	91 97       	sbiw	r26, 0x21	; 33
    58b4:	8c 83       	std	Y+4, r24	; 0x04
    58b6:	93 96       	adiw	r26, 0x23	; 35
    58b8:	8c 91       	ld	r24, X
    58ba:	93 97       	sbiw	r26, 0x23	; 35
    58bc:	8f 83       	std	Y+7, r24	; 0x07
    58be:	97 96       	adiw	r26, 0x27	; 39
    58c0:	8d 91       	ld	r24, X+
    58c2:	9d 91       	ld	r25, X+
    58c4:	0d 90       	ld	r0, X+
    58c6:	bc 91       	ld	r27, X
    58c8:	a0 2d       	mov	r26, r0
    58ca:	88 87       	std	Y+8, r24	; 0x08
    58cc:	99 87       	std	Y+9, r25	; 0x09
    58ce:	aa 87       	std	Y+10, r26	; 0x0a
    58d0:	bb 87       	std	Y+11, r27	; 0x0b
    58d2:	25 30       	cpi	r18, 0x05	; 5
    58d4:	09 f4       	brne	.+2      	; 0x58d8 <vTaskGetInfo+0x62>
    58d6:	43 c0       	rjmp	.+134    	; 0x595e <vTaskGetInfo+0xe8>
    58d8:	80 91 8b 2d 	lds	r24, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    58dc:	90 91 8c 2d 	lds	r25, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    58e0:	08 17       	cp	r16, r24
    58e2:	19 07       	cpc	r17, r25
    58e4:	09 f4       	brne	.+2      	; 0x58e8 <vTaskGetInfo+0x72>
    58e6:	40 c0       	rjmp	.+128    	; 0x5968 <vTaskGetInfo+0xf2>
    58e8:	2d 83       	std	Y+5, r18	; 0x05
    58ea:	23 30       	cpi	r18, 0x03	; 3
    58ec:	21 f1       	breq	.+72     	; 0x5936 <vTaskGetInfo+0xc0>
    58ee:	ff 20       	and	r15, r15
    58f0:	d1 f0       	breq	.+52     	; 0x5926 <vTaskGetInfo+0xb0>
    58f2:	d8 01       	movw	r26, r16
    58f4:	57 96       	adiw	r26, 0x17	; 23
    58f6:	ed 91       	ld	r30, X+
    58f8:	fc 91       	ld	r31, X
    58fa:	58 97       	sbiw	r26, 0x18	; 24
    58fc:	80 81       	ld	r24, Z
    58fe:	85 3a       	cpi	r24, 0xA5	; 165
    5900:	a9 f5       	brne	.+106    	; 0x596c <vTaskGetInfo+0xf6>
    5902:	31 96       	adiw	r30, 0x01	; 1
    5904:	80 e0       	ldi	r24, 0x00	; 0
    5906:	90 e0       	ldi	r25, 0x00	; 0
    5908:	dc 01       	movw	r26, r24
    590a:	01 96       	adiw	r24, 0x01	; 1
    590c:	a1 1d       	adc	r26, r1
    590e:	b1 1d       	adc	r27, r1
    5910:	21 91       	ld	r18, Z+
    5912:	25 3a       	cpi	r18, 0xA5	; 165
    5914:	d1 f3       	breq	.-12     	; 0x590a <vTaskGetInfo+0x94>
    5916:	8e 87       	std	Y+14, r24	; 0x0e
    5918:	9f 87       	std	Y+15, r25	; 0x0f
    591a:	df 91       	pop	r29
    591c:	cf 91       	pop	r28
    591e:	1f 91       	pop	r17
    5920:	0f 91       	pop	r16
    5922:	ff 90       	pop	r15
    5924:	08 95       	ret
    5926:	1e 86       	std	Y+14, r1	; 0x0e
    5928:	1f 86       	std	Y+15, r1	; 0x0f
    592a:	df 91       	pop	r29
    592c:	cf 91       	pop	r28
    592e:	1f 91       	pop	r17
    5930:	0f 91       	pop	r16
    5932:	ff 90       	pop	r15
    5934:	08 95       	ret
    5936:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <uxSchedulerSuspended>
    593a:	8f 5f       	subi	r24, 0xFF	; 255
    593c:	80 93 f1 2c 	sts	0x2CF1, r24	; 0x802cf1 <uxSchedulerSuspended>
    5940:	f8 01       	movw	r30, r16
    5942:	84 89       	ldd	r24, Z+20	; 0x14
    5944:	95 89       	ldd	r25, Z+21	; 0x15
    5946:	89 2b       	or	r24, r25
    5948:	11 f0       	breq	.+4      	; 0x594e <vTaskGetInfo+0xd8>
    594a:	82 e0       	ldi	r24, 0x02	; 2
    594c:	8d 83       	std	Y+5, r24	; 0x05
    594e:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>
    5952:	cd cf       	rjmp	.-102    	; 0x58ee <vTaskGetInfo+0x78>
    5954:	00 91 8b 2d 	lds	r16, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    5958:	10 91 8c 2d 	lds	r17, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    595c:	97 cf       	rjmp	.-210    	; 0x588c <vTaskGetInfo+0x16>
    595e:	c8 01       	movw	r24, r16
    5960:	0e 94 fe 27 	call	0x4ffc	; 0x4ffc <eTaskGetState>
    5964:	8d 83       	std	Y+5, r24	; 0x05
    5966:	c3 cf       	rjmp	.-122    	; 0x58ee <vTaskGetInfo+0x78>
    5968:	1d 82       	std	Y+5, r1	; 0x05
    596a:	c1 cf       	rjmp	.-126    	; 0x58ee <vTaskGetInfo+0x78>
    596c:	80 e0       	ldi	r24, 0x00	; 0
    596e:	90 e0       	ldi	r25, 0x00	; 0
    5970:	d2 cf       	rjmp	.-92     	; 0x5916 <vTaskGetInfo+0xa0>

00005972 <prvListTasksWithinSingleList.part.6>:
    5972:	8f 92       	push	r8
    5974:	9f 92       	push	r9
    5976:	af 92       	push	r10
    5978:	bf 92       	push	r11
    597a:	cf 92       	push	r12
    597c:	df 92       	push	r13
    597e:	ef 92       	push	r14
    5980:	ff 92       	push	r15
    5982:	0f 93       	push	r16
    5984:	1f 93       	push	r17
    5986:	cf 93       	push	r28
    5988:	df 93       	push	r29
    598a:	5c 01       	movw	r10, r24
    598c:	8b 01       	movw	r16, r22
    598e:	d4 2f       	mov	r29, r20
    5990:	db 01       	movw	r26, r22
    5992:	11 96       	adiw	r26, 0x01	; 1
    5994:	ed 91       	ld	r30, X+
    5996:	fc 91       	ld	r31, X
    5998:	12 97       	sbiw	r26, 0x02	; 2
    599a:	02 80       	ldd	r0, Z+2	; 0x02
    599c:	f3 81       	ldd	r31, Z+3	; 0x03
    599e:	e0 2d       	mov	r30, r0
    59a0:	11 96       	adiw	r26, 0x01	; 1
    59a2:	ed 93       	st	X+, r30
    59a4:	fc 93       	st	X, r31
    59a6:	12 97       	sbiw	r26, 0x02	; 2
    59a8:	7b 01       	movw	r14, r22
    59aa:	b3 e0       	ldi	r27, 0x03	; 3
    59ac:	eb 0e       	add	r14, r27
    59ae:	f1 1c       	adc	r15, r1
    59b0:	ee 15       	cp	r30, r14
    59b2:	ff 05       	cpc	r31, r15
    59b4:	e1 f1       	breq	.+120    	; 0x5a2e <prvListTasksWithinSingleList.part.6+0xbc>
    59b6:	c6 80       	ldd	r12, Z+6	; 0x06
    59b8:	d7 80       	ldd	r13, Z+7	; 0x07
    59ba:	c0 e0       	ldi	r28, 0x00	; 0
    59bc:	16 c0       	rjmp	.+44     	; 0x59ea <prvListTasksWithinSingleList.part.6+0x78>
    59be:	86 80       	ldd	r8, Z+6	; 0x06
    59c0:	97 80       	ldd	r9, Z+7	; 0x07
    59c2:	b5 01       	movw	r22, r10
    59c4:	b0 e1       	ldi	r27, 0x10	; 16
    59c6:	cb 9f       	mul	r28, r27
    59c8:	60 0d       	add	r22, r0
    59ca:	71 1d       	adc	r23, r1
    59cc:	11 24       	eor	r1, r1
    59ce:	2d 2f       	mov	r18, r29
    59d0:	41 e0       	ldi	r20, 0x01	; 1
    59d2:	c4 01       	movw	r24, r8
    59d4:	0e 94 3b 2c 	call	0x5876	; 0x5876 <vTaskGetInfo>
    59d8:	cf 5f       	subi	r28, 0xFF	; 255
    59da:	c8 14       	cp	r12, r8
    59dc:	d9 04       	cpc	r13, r9
    59de:	c9 f0       	breq	.+50     	; 0x5a12 <prvListTasksWithinSingleList.part.6+0xa0>
    59e0:	d8 01       	movw	r26, r16
    59e2:	11 96       	adiw	r26, 0x01	; 1
    59e4:	ed 91       	ld	r30, X+
    59e6:	fc 91       	ld	r31, X
    59e8:	12 97       	sbiw	r26, 0x02	; 2
    59ea:	02 80       	ldd	r0, Z+2	; 0x02
    59ec:	f3 81       	ldd	r31, Z+3	; 0x03
    59ee:	e0 2d       	mov	r30, r0
    59f0:	d8 01       	movw	r26, r16
    59f2:	11 96       	adiw	r26, 0x01	; 1
    59f4:	ed 93       	st	X+, r30
    59f6:	fc 93       	st	X, r31
    59f8:	12 97       	sbiw	r26, 0x02	; 2
    59fa:	ee 16       	cp	r14, r30
    59fc:	ff 06       	cpc	r15, r31
    59fe:	f9 f6       	brne	.-66     	; 0x59be <prvListTasksWithinSingleList.part.6+0x4c>
    5a00:	15 96       	adiw	r26, 0x05	; 5
    5a02:	ed 91       	ld	r30, X+
    5a04:	fc 91       	ld	r31, X
    5a06:	16 97       	sbiw	r26, 0x06	; 6
    5a08:	11 96       	adiw	r26, 0x01	; 1
    5a0a:	ed 93       	st	X+, r30
    5a0c:	fc 93       	st	X, r31
    5a0e:	12 97       	sbiw	r26, 0x02	; 2
    5a10:	d6 cf       	rjmp	.-84     	; 0x59be <prvListTasksWithinSingleList.part.6+0x4c>
    5a12:	8c 2f       	mov	r24, r28
    5a14:	df 91       	pop	r29
    5a16:	cf 91       	pop	r28
    5a18:	1f 91       	pop	r17
    5a1a:	0f 91       	pop	r16
    5a1c:	ff 90       	pop	r15
    5a1e:	ef 90       	pop	r14
    5a20:	df 90       	pop	r13
    5a22:	cf 90       	pop	r12
    5a24:	bf 90       	pop	r11
    5a26:	af 90       	pop	r10
    5a28:	9f 90       	pop	r9
    5a2a:	8f 90       	pop	r8
    5a2c:	08 95       	ret
    5a2e:	02 80       	ldd	r0, Z+2	; 0x02
    5a30:	f3 81       	ldd	r31, Z+3	; 0x03
    5a32:	e0 2d       	mov	r30, r0
    5a34:	c0 cf       	rjmp	.-128    	; 0x59b6 <prvListTasksWithinSingleList.part.6+0x44>

00005a36 <uxTaskGetSystemState>:
    5a36:	ef 92       	push	r14
    5a38:	ff 92       	push	r15
    5a3a:	0f 93       	push	r16
    5a3c:	1f 93       	push	r17
    5a3e:	cf 93       	push	r28
    5a40:	df 93       	push	r29
    5a42:	8c 01       	movw	r16, r24
    5a44:	7a 01       	movw	r14, r20
    5a46:	80 91 f1 2c 	lds	r24, 0x2CF1	; 0x802cf1 <uxSchedulerSuspended>
    5a4a:	8f 5f       	subi	r24, 0xFF	; 255
    5a4c:	80 93 f1 2c 	sts	0x2CF1, r24	; 0x802cf1 <uxSchedulerSuspended>
    5a50:	80 91 fe 2c 	lds	r24, 0x2CFE	; 0x802cfe <uxCurrentNumberOfTasks>
    5a54:	68 17       	cp	r22, r24
    5a56:	08 f4       	brcc	.+2      	; 0x5a5a <uxTaskGetSystemState+0x24>
    5a58:	66 c0       	rjmp	.+204    	; 0x5b26 <uxTaskGetSystemState+0xf0>
    5a5a:	ca e0       	ldi	r28, 0x0A	; 10
    5a5c:	d0 e0       	ldi	r29, 0x00	; 0
    5a5e:	04 c0       	rjmp	.+8      	; 0x5a68 <uxTaskGetSystemState+0x32>
    5a60:	80 e0       	ldi	r24, 0x00	; 0
    5a62:	d8 0f       	add	r29, r24
    5a64:	cc 23       	and	r28, r28
    5a66:	f9 f0       	breq	.+62     	; 0x5aa6 <uxTaskGetSystemState+0x70>
    5a68:	c1 50       	subi	r28, 0x01	; 1
    5a6a:	6c 2f       	mov	r22, r28
    5a6c:	70 e0       	ldi	r23, 0x00	; 0
    5a6e:	cb 01       	movw	r24, r22
    5a70:	88 0f       	add	r24, r24
    5a72:	99 1f       	adc	r25, r25
    5a74:	88 0f       	add	r24, r24
    5a76:	99 1f       	adc	r25, r25
    5a78:	88 0f       	add	r24, r24
    5a7a:	99 1f       	adc	r25, r25
    5a7c:	68 0f       	add	r22, r24
    5a7e:	79 1f       	adc	r23, r25
    5a80:	fb 01       	movw	r30, r22
    5a82:	ef 5c       	subi	r30, 0xCF	; 207
    5a84:	f2 4d       	sbci	r31, 0xD2	; 210
    5a86:	80 81       	ld	r24, Z
    5a88:	88 23       	and	r24, r24
    5a8a:	51 f3       	breq	.-44     	; 0x5a60 <uxTaskGetSystemState+0x2a>
    5a8c:	41 e0       	ldi	r20, 0x01	; 1
    5a8e:	bf 01       	movw	r22, r30
    5a90:	c8 01       	movw	r24, r16
    5a92:	20 e1       	ldi	r18, 0x10	; 16
    5a94:	d2 9f       	mul	r29, r18
    5a96:	80 0d       	add	r24, r0
    5a98:	91 1d       	adc	r25, r1
    5a9a:	11 24       	eor	r1, r1
    5a9c:	0e 94 b9 2c 	call	0x5972	; 0x5972 <prvListTasksWithinSingleList.part.6>
    5aa0:	d8 0f       	add	r29, r24
    5aa2:	c1 11       	cpse	r28, r1
    5aa4:	e1 cf       	rjmp	.-62     	; 0x5a68 <uxTaskGetSystemState+0x32>
    5aa6:	e0 91 1d 2d 	lds	r30, 0x2D1D	; 0x802d1d <pxDelayedTaskList>
    5aaa:	f0 91 1e 2d 	lds	r31, 0x2D1E	; 0x802d1e <pxDelayedTaskList+0x1>
    5aae:	80 81       	ld	r24, Z
    5ab0:	81 11       	cpse	r24, r1
    5ab2:	3b c0       	rjmp	.+118    	; 0x5b2a <uxTaskGetSystemState+0xf4>
    5ab4:	80 e0       	ldi	r24, 0x00	; 0
    5ab6:	d8 0f       	add	r29, r24
    5ab8:	e0 91 1b 2d 	lds	r30, 0x2D1B	; 0x802d1b <pxOverflowDelayedTaskList>
    5abc:	f0 91 1c 2d 	lds	r31, 0x2D1C	; 0x802d1c <pxOverflowDelayedTaskList+0x1>
    5ac0:	80 81       	ld	r24, Z
    5ac2:	81 11       	cpse	r24, r1
    5ac4:	45 c0       	rjmp	.+138    	; 0x5b50 <uxTaskGetSystemState+0x11a>
    5ac6:	80 e0       	ldi	r24, 0x00	; 0
    5ac8:	d8 0f       	add	r29, r24
    5aca:	80 91 09 2d 	lds	r24, 0x2D09	; 0x802d09 <xTasksWaitingTermination>
    5ace:	81 11       	cpse	r24, r1
    5ad0:	4f c0       	rjmp	.+158    	; 0x5b70 <uxTaskGetSystemState+0x13a>
    5ad2:	80 e0       	ldi	r24, 0x00	; 0
    5ad4:	d8 0f       	add	r29, r24
    5ad6:	80 91 ff 2c 	lds	r24, 0x2CFF	; 0x802cff <xSuspendedTaskList>
    5ada:	81 11       	cpse	r24, r1
    5adc:	5a c0       	rjmp	.+180    	; 0x5b92 <uxTaskGetSystemState+0x15c>
    5ade:	80 e0       	ldi	r24, 0x00	; 0
    5ae0:	d8 0f       	add	r29, r24
    5ae2:	e1 14       	cp	r14, r1
    5ae4:	f1 04       	cpc	r15, r1
    5ae6:	a9 f0       	breq	.+42     	; 0x5b12 <uxTaskGetSystemState+0xdc>
    5ae8:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    5aec:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    5af0:	80 91 cf 2d 	lds	r24, 0x2DCF	; 0x802dcf <StatsTimer>
    5af4:	90 91 d0 2d 	lds	r25, 0x2DD0	; 0x802dd0 <StatsTimer+0x1>
    5af8:	a0 91 d1 2d 	lds	r26, 0x2DD1	; 0x802dd1 <StatsTimer+0x2>
    5afc:	b0 91 d2 2d 	lds	r27, 0x2DD2	; 0x802dd2 <StatsTimer+0x3>
    5b00:	82 0f       	add	r24, r18
    5b02:	93 1f       	adc	r25, r19
    5b04:	a1 1d       	adc	r26, r1
    5b06:	b1 1d       	adc	r27, r1
    5b08:	f7 01       	movw	r30, r14
    5b0a:	80 83       	st	Z, r24
    5b0c:	91 83       	std	Z+1, r25	; 0x01
    5b0e:	a2 83       	std	Z+2, r26	; 0x02
    5b10:	b3 83       	std	Z+3, r27	; 0x03
    5b12:	0e 94 4a 2a 	call	0x5494	; 0x5494 <xTaskResumeAll>
    5b16:	8d 2f       	mov	r24, r29
    5b18:	df 91       	pop	r29
    5b1a:	cf 91       	pop	r28
    5b1c:	1f 91       	pop	r17
    5b1e:	0f 91       	pop	r16
    5b20:	ff 90       	pop	r15
    5b22:	ef 90       	pop	r14
    5b24:	08 95       	ret
    5b26:	d0 e0       	ldi	r29, 0x00	; 0
    5b28:	f4 cf       	rjmp	.-24     	; 0x5b12 <uxTaskGetSystemState+0xdc>
    5b2a:	42 e0       	ldi	r20, 0x02	; 2
    5b2c:	bf 01       	movw	r22, r30
    5b2e:	c8 01       	movw	r24, r16
    5b30:	e0 e1       	ldi	r30, 0x10	; 16
    5b32:	de 9f       	mul	r29, r30
    5b34:	80 0d       	add	r24, r0
    5b36:	91 1d       	adc	r25, r1
    5b38:	11 24       	eor	r1, r1
    5b3a:	0e 94 b9 2c 	call	0x5972	; 0x5972 <prvListTasksWithinSingleList.part.6>
    5b3e:	d8 0f       	add	r29, r24
    5b40:	e0 91 1b 2d 	lds	r30, 0x2D1B	; 0x802d1b <pxOverflowDelayedTaskList>
    5b44:	f0 91 1c 2d 	lds	r31, 0x2D1C	; 0x802d1c <pxOverflowDelayedTaskList+0x1>
    5b48:	80 81       	ld	r24, Z
    5b4a:	88 23       	and	r24, r24
    5b4c:	09 f4       	brne	.+2      	; 0x5b50 <uxTaskGetSystemState+0x11a>
    5b4e:	bb cf       	rjmp	.-138    	; 0x5ac6 <uxTaskGetSystemState+0x90>
    5b50:	42 e0       	ldi	r20, 0x02	; 2
    5b52:	bf 01       	movw	r22, r30
    5b54:	c8 01       	movw	r24, r16
    5b56:	f0 e1       	ldi	r31, 0x10	; 16
    5b58:	df 9f       	mul	r29, r31
    5b5a:	80 0d       	add	r24, r0
    5b5c:	91 1d       	adc	r25, r1
    5b5e:	11 24       	eor	r1, r1
    5b60:	0e 94 b9 2c 	call	0x5972	; 0x5972 <prvListTasksWithinSingleList.part.6>
    5b64:	d8 0f       	add	r29, r24
    5b66:	80 91 09 2d 	lds	r24, 0x2D09	; 0x802d09 <xTasksWaitingTermination>
    5b6a:	88 23       	and	r24, r24
    5b6c:	09 f4       	brne	.+2      	; 0x5b70 <uxTaskGetSystemState+0x13a>
    5b6e:	b1 cf       	rjmp	.-158    	; 0x5ad2 <uxTaskGetSystemState+0x9c>
    5b70:	44 e0       	ldi	r20, 0x04	; 4
    5b72:	69 e0       	ldi	r22, 0x09	; 9
    5b74:	7d e2       	ldi	r23, 0x2D	; 45
    5b76:	c8 01       	movw	r24, r16
    5b78:	20 e1       	ldi	r18, 0x10	; 16
    5b7a:	d2 9f       	mul	r29, r18
    5b7c:	80 0d       	add	r24, r0
    5b7e:	91 1d       	adc	r25, r1
    5b80:	11 24       	eor	r1, r1
    5b82:	0e 94 b9 2c 	call	0x5972	; 0x5972 <prvListTasksWithinSingleList.part.6>
    5b86:	d8 0f       	add	r29, r24
    5b88:	80 91 ff 2c 	lds	r24, 0x2CFF	; 0x802cff <xSuspendedTaskList>
    5b8c:	88 23       	and	r24, r24
    5b8e:	09 f4       	brne	.+2      	; 0x5b92 <uxTaskGetSystemState+0x15c>
    5b90:	a6 cf       	rjmp	.-180    	; 0x5ade <uxTaskGetSystemState+0xa8>
    5b92:	43 e0       	ldi	r20, 0x03	; 3
    5b94:	6f ef       	ldi	r22, 0xFF	; 255
    5b96:	7c e2       	ldi	r23, 0x2C	; 44
    5b98:	c8 01       	movw	r24, r16
    5b9a:	e0 e1       	ldi	r30, 0x10	; 16
    5b9c:	de 9f       	mul	r29, r30
    5b9e:	80 0d       	add	r24, r0
    5ba0:	91 1d       	adc	r25, r1
    5ba2:	11 24       	eor	r1, r1
    5ba4:	0e 94 b9 2c 	call	0x5972	; 0x5972 <prvListTasksWithinSingleList.part.6>
    5ba8:	9b cf       	rjmp	.-202    	; 0x5ae0 <uxTaskGetSystemState+0xaa>

00005baa <xTaskPriorityInherit>:
    5baa:	0f 93       	push	r16
    5bac:	1f 93       	push	r17
    5bae:	cf 93       	push	r28
    5bb0:	df 93       	push	r29
    5bb2:	fc 01       	movw	r30, r24
    5bb4:	89 2b       	or	r24, r25
    5bb6:	09 f4       	brne	.+2      	; 0x5bba <xTaskPriorityInherit+0x10>
    5bb8:	41 c0       	rjmp	.+130    	; 0x5c3c <xTaskPriorityInherit+0x92>
    5bba:	26 89       	ldd	r18, Z+22	; 0x16
    5bbc:	a0 91 8b 2d 	lds	r26, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    5bc0:	b0 91 8c 2d 	lds	r27, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    5bc4:	56 96       	adiw	r26, 0x16	; 22
    5bc6:	8c 91       	ld	r24, X
    5bc8:	28 17       	cp	r18, r24
    5bca:	70 f5       	brcc	.+92     	; 0x5c28 <xTaskPriorityInherit+0x7e>
    5bcc:	84 85       	ldd	r24, Z+12	; 0x0c
    5bce:	95 85       	ldd	r25, Z+13	; 0x0d
    5bd0:	97 fd       	sbrc	r25, 7
    5bd2:	0c c0       	rjmp	.+24     	; 0x5bec <xTaskPriorityInherit+0x42>
    5bd4:	a0 91 8b 2d 	lds	r26, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    5bd8:	b0 91 8c 2d 	lds	r27, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    5bdc:	56 96       	adiw	r26, 0x16	; 22
    5bde:	3c 91       	ld	r19, X
    5be0:	8a e0       	ldi	r24, 0x0A	; 10
    5be2:	90 e0       	ldi	r25, 0x00	; 0
    5be4:	83 1b       	sub	r24, r19
    5be6:	91 09       	sbc	r25, r1
    5be8:	84 87       	std	Z+12, r24	; 0x0c
    5bea:	95 87       	std	Z+13, r25	; 0x0d
    5bec:	30 e0       	ldi	r19, 0x00	; 0
    5bee:	c9 01       	movw	r24, r18
    5bf0:	88 0f       	add	r24, r24
    5bf2:	99 1f       	adc	r25, r25
    5bf4:	88 0f       	add	r24, r24
    5bf6:	99 1f       	adc	r25, r25
    5bf8:	88 0f       	add	r24, r24
    5bfa:	99 1f       	adc	r25, r25
    5bfc:	28 0f       	add	r18, r24
    5bfe:	39 1f       	adc	r19, r25
    5c00:	2f 5c       	subi	r18, 0xCF	; 207
    5c02:	32 4d       	sbci	r19, 0xD2	; 210
    5c04:	82 85       	ldd	r24, Z+10	; 0x0a
    5c06:	93 85       	ldd	r25, Z+11	; 0x0b
    5c08:	82 17       	cp	r24, r18
    5c0a:	93 07       	cpc	r25, r19
    5c0c:	e9 f0       	breq	.+58     	; 0x5c48 <xTaskPriorityInherit+0x9e>
    5c0e:	a0 91 8b 2d 	lds	r26, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    5c12:	b0 91 8c 2d 	lds	r27, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    5c16:	56 96       	adiw	r26, 0x16	; 22
    5c18:	8c 91       	ld	r24, X
    5c1a:	86 8b       	std	Z+22, r24	; 0x16
    5c1c:	81 e0       	ldi	r24, 0x01	; 1
    5c1e:	df 91       	pop	r29
    5c20:	cf 91       	pop	r28
    5c22:	1f 91       	pop	r17
    5c24:	0f 91       	pop	r16
    5c26:	08 95       	ret
    5c28:	a0 91 8b 2d 	lds	r26, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    5c2c:	b0 91 8c 2d 	lds	r27, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    5c30:	81 e0       	ldi	r24, 0x01	; 1
    5c32:	23 a1       	ldd	r18, Z+35	; 0x23
    5c34:	56 96       	adiw	r26, 0x16	; 22
    5c36:	9c 91       	ld	r25, X
    5c38:	29 17       	cp	r18, r25
    5c3a:	88 f3       	brcs	.-30     	; 0x5c1e <xTaskPriorityInherit+0x74>
    5c3c:	80 e0       	ldi	r24, 0x00	; 0
    5c3e:	df 91       	pop	r29
    5c40:	cf 91       	pop	r28
    5c42:	1f 91       	pop	r17
    5c44:	0f 91       	pop	r16
    5c46:	08 95       	ret
    5c48:	8f 01       	movw	r16, r30
    5c4a:	ef 01       	movw	r28, r30
    5c4c:	22 96       	adiw	r28, 0x02	; 2
    5c4e:	ce 01       	movw	r24, r28
    5c50:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <uxListRemove>
    5c54:	e0 91 8b 2d 	lds	r30, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    5c58:	f0 91 8c 2d 	lds	r31, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    5c5c:	86 89       	ldd	r24, Z+22	; 0x16
    5c5e:	f8 01       	movw	r30, r16
    5c60:	86 8b       	std	Z+22, r24	; 0x16
    5c62:	90 91 fb 2c 	lds	r25, 0x2CFB	; 0x802cfb <uxTopReadyPriority>
    5c66:	98 17       	cp	r25, r24
    5c68:	10 f4       	brcc	.+4      	; 0x5c6e <xTaskPriorityInherit+0xc4>
    5c6a:	80 93 fb 2c 	sts	0x2CFB, r24	; 0x802cfb <uxTopReadyPriority>
    5c6e:	90 e0       	ldi	r25, 0x00	; 0
    5c70:	9c 01       	movw	r18, r24
    5c72:	22 0f       	add	r18, r18
    5c74:	33 1f       	adc	r19, r19
    5c76:	22 0f       	add	r18, r18
    5c78:	33 1f       	adc	r19, r19
    5c7a:	22 0f       	add	r18, r18
    5c7c:	33 1f       	adc	r19, r19
    5c7e:	82 0f       	add	r24, r18
    5c80:	93 1f       	adc	r25, r19
    5c82:	be 01       	movw	r22, r28
    5c84:	8f 5c       	subi	r24, 0xCF	; 207
    5c86:	92 4d       	sbci	r25, 0xD2	; 210
    5c88:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vListInsertEnd>
    5c8c:	81 e0       	ldi	r24, 0x01	; 1
    5c8e:	c7 cf       	rjmp	.-114    	; 0x5c1e <xTaskPriorityInherit+0x74>

00005c90 <xTaskPriorityDisinherit>:
    5c90:	0f 93       	push	r16
    5c92:	1f 93       	push	r17
    5c94:	cf 93       	push	r28
    5c96:	df 93       	push	r29
    5c98:	00 97       	sbiw	r24, 0x00	; 0
    5c9a:	c9 f0       	breq	.+50     	; 0x5cce <xTaskPriorityDisinherit+0x3e>
    5c9c:	ec 01       	movw	r28, r24
    5c9e:	80 91 8b 2d 	lds	r24, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    5ca2:	90 91 8c 2d 	lds	r25, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    5ca6:	c8 17       	cp	r28, r24
    5ca8:	d9 07       	cpc	r29, r25
    5caa:	31 f0       	breq	.+12     	; 0x5cb8 <xTaskPriorityDisinherit+0x28>
    5cac:	6e e7       	ldi	r22, 0x7E	; 126
    5cae:	7f e0       	ldi	r23, 0x0F	; 15
    5cb0:	8e ed       	ldi	r24, 0xDE	; 222
    5cb2:	93 e2       	ldi	r25, 0x23	; 35
    5cb4:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    5cb8:	8c a1       	ldd	r24, Y+36	; 0x24
    5cba:	88 23       	and	r24, r24
    5cbc:	c1 f1       	breq	.+112    	; 0x5d2e <xTaskPriorityDisinherit+0x9e>
    5cbe:	81 50       	subi	r24, 0x01	; 1
    5cc0:	8c a3       	std	Y+36, r24	; 0x24
    5cc2:	2e 89       	ldd	r18, Y+22	; 0x16
    5cc4:	9b a1       	ldd	r25, Y+35	; 0x23
    5cc6:	29 17       	cp	r18, r25
    5cc8:	11 f0       	breq	.+4      	; 0x5cce <xTaskPriorityDisinherit+0x3e>
    5cca:	88 23       	and	r24, r24
    5ccc:	31 f0       	breq	.+12     	; 0x5cda <xTaskPriorityDisinherit+0x4a>
    5cce:	80 e0       	ldi	r24, 0x00	; 0
    5cd0:	df 91       	pop	r29
    5cd2:	cf 91       	pop	r28
    5cd4:	1f 91       	pop	r17
    5cd6:	0f 91       	pop	r16
    5cd8:	08 95       	ret
    5cda:	8e 01       	movw	r16, r28
    5cdc:	0e 5f       	subi	r16, 0xFE	; 254
    5cde:	1f 4f       	sbci	r17, 0xFF	; 255
    5ce0:	c8 01       	movw	r24, r16
    5ce2:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <uxListRemove>
    5ce6:	2b a1       	ldd	r18, Y+35	; 0x23
    5ce8:	2e 8b       	std	Y+22, r18	; 0x16
    5cea:	82 2f       	mov	r24, r18
    5cec:	90 e0       	ldi	r25, 0x00	; 0
    5cee:	4a e0       	ldi	r20, 0x0A	; 10
    5cf0:	50 e0       	ldi	r21, 0x00	; 0
    5cf2:	48 1b       	sub	r20, r24
    5cf4:	59 0b       	sbc	r21, r25
    5cf6:	4c 87       	std	Y+12, r20	; 0x0c
    5cf8:	5d 87       	std	Y+13, r21	; 0x0d
    5cfa:	30 91 fb 2c 	lds	r19, 0x2CFB	; 0x802cfb <uxTopReadyPriority>
    5cfe:	32 17       	cp	r19, r18
    5d00:	10 f4       	brcc	.+4      	; 0x5d06 <xTaskPriorityDisinherit+0x76>
    5d02:	20 93 fb 2c 	sts	0x2CFB, r18	; 0x802cfb <uxTopReadyPriority>
    5d06:	9c 01       	movw	r18, r24
    5d08:	22 0f       	add	r18, r18
    5d0a:	33 1f       	adc	r19, r19
    5d0c:	22 0f       	add	r18, r18
    5d0e:	33 1f       	adc	r19, r19
    5d10:	22 0f       	add	r18, r18
    5d12:	33 1f       	adc	r19, r19
    5d14:	82 0f       	add	r24, r18
    5d16:	93 1f       	adc	r25, r19
    5d18:	b8 01       	movw	r22, r16
    5d1a:	8f 5c       	subi	r24, 0xCF	; 207
    5d1c:	92 4d       	sbci	r25, 0xD2	; 210
    5d1e:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vListInsertEnd>
    5d22:	81 e0       	ldi	r24, 0x01	; 1
    5d24:	df 91       	pop	r29
    5d26:	cf 91       	pop	r28
    5d28:	1f 91       	pop	r17
    5d2a:	0f 91       	pop	r16
    5d2c:	08 95       	ret
    5d2e:	6f e7       	ldi	r22, 0x7F	; 127
    5d30:	7f e0       	ldi	r23, 0x0F	; 15
    5d32:	8e ed       	ldi	r24, 0xDE	; 222
    5d34:	93 e2       	ldi	r25, 0x23	; 35
    5d36:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    5d3a:	8c a1       	ldd	r24, Y+36	; 0x24
    5d3c:	c0 cf       	rjmp	.-128    	; 0x5cbe <xTaskPriorityDisinherit+0x2e>

00005d3e <vTaskPriorityDisinheritAfterTimeout>:
    5d3e:	0f 93       	push	r16
    5d40:	1f 93       	push	r17
    5d42:	cf 93       	push	r28
    5d44:	df 93       	push	r29
    5d46:	00 97       	sbiw	r24, 0x00	; 0
    5d48:	79 f0       	breq	.+30     	; 0x5d68 <vTaskPriorityDisinheritAfterTimeout+0x2a>
    5d4a:	16 2f       	mov	r17, r22
    5d4c:	ec 01       	movw	r28, r24
    5d4e:	8c a1       	ldd	r24, Y+36	; 0x24
    5d50:	88 23       	and	r24, r24
    5d52:	09 f4       	brne	.+2      	; 0x5d56 <vTaskPriorityDisinheritAfterTimeout+0x18>
    5d54:	54 c0       	rjmp	.+168    	; 0x5dfe <vTaskPriorityDisinheritAfterTimeout+0xc0>
    5d56:	0b a1       	ldd	r16, Y+35	; 0x23
    5d58:	01 17       	cp	r16, r17
    5d5a:	58 f0       	brcs	.+22     	; 0x5d72 <vTaskPriorityDisinheritAfterTimeout+0x34>
    5d5c:	8e 89       	ldd	r24, Y+22	; 0x16
    5d5e:	80 17       	cp	r24, r16
    5d60:	19 f0       	breq	.+6      	; 0x5d68 <vTaskPriorityDisinheritAfterTimeout+0x2a>
    5d62:	9c a1       	ldd	r25, Y+36	; 0x24
    5d64:	91 30       	cpi	r25, 0x01	; 1
    5d66:	39 f0       	breq	.+14     	; 0x5d76 <vTaskPriorityDisinheritAfterTimeout+0x38>
    5d68:	df 91       	pop	r29
    5d6a:	cf 91       	pop	r28
    5d6c:	1f 91       	pop	r17
    5d6e:	0f 91       	pop	r16
    5d70:	08 95       	ret
    5d72:	01 2f       	mov	r16, r17
    5d74:	f3 cf       	rjmp	.-26     	; 0x5d5c <vTaskPriorityDisinheritAfterTimeout+0x1e>
    5d76:	20 91 8b 2d 	lds	r18, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    5d7a:	30 91 8c 2d 	lds	r19, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    5d7e:	c2 17       	cp	r28, r18
    5d80:	d3 07       	cpc	r29, r19
    5d82:	09 f4       	brne	.+2      	; 0x5d86 <vTaskPriorityDisinheritAfterTimeout+0x48>
    5d84:	43 c0       	rjmp	.+134    	; 0x5e0c <vTaskPriorityDisinheritAfterTimeout+0xce>
    5d86:	0e 8b       	std	Y+22, r16	; 0x16
    5d88:	2c 85       	ldd	r18, Y+12	; 0x0c
    5d8a:	3d 85       	ldd	r19, Y+13	; 0x0d
    5d8c:	37 fd       	sbrc	r19, 7
    5d8e:	06 c0       	rjmp	.+12     	; 0x5d9c <vTaskPriorityDisinheritAfterTimeout+0x5e>
    5d90:	2a e0       	ldi	r18, 0x0A	; 10
    5d92:	30 e0       	ldi	r19, 0x00	; 0
    5d94:	20 1b       	sub	r18, r16
    5d96:	31 09       	sbc	r19, r1
    5d98:	2c 87       	std	Y+12, r18	; 0x0c
    5d9a:	3d 87       	std	Y+13, r19	; 0x0d
    5d9c:	90 e0       	ldi	r25, 0x00	; 0
    5d9e:	9c 01       	movw	r18, r24
    5da0:	22 0f       	add	r18, r18
    5da2:	33 1f       	adc	r19, r19
    5da4:	22 0f       	add	r18, r18
    5da6:	33 1f       	adc	r19, r19
    5da8:	22 0f       	add	r18, r18
    5daa:	33 1f       	adc	r19, r19
    5dac:	82 0f       	add	r24, r18
    5dae:	93 1f       	adc	r25, r19
    5db0:	8f 5c       	subi	r24, 0xCF	; 207
    5db2:	92 4d       	sbci	r25, 0xD2	; 210
    5db4:	2a 85       	ldd	r18, Y+10	; 0x0a
    5db6:	3b 85       	ldd	r19, Y+11	; 0x0b
    5db8:	28 17       	cp	r18, r24
    5dba:	39 07       	cpc	r19, r25
    5dbc:	a9 f6       	brne	.-86     	; 0x5d68 <vTaskPriorityDisinheritAfterTimeout+0x2a>
    5dbe:	8e 01       	movw	r16, r28
    5dc0:	0e 5f       	subi	r16, 0xFE	; 254
    5dc2:	1f 4f       	sbci	r17, 0xFF	; 255
    5dc4:	c8 01       	movw	r24, r16
    5dc6:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <uxListRemove>
    5dca:	8e 89       	ldd	r24, Y+22	; 0x16
    5dcc:	90 91 fb 2c 	lds	r25, 0x2CFB	; 0x802cfb <uxTopReadyPriority>
    5dd0:	98 17       	cp	r25, r24
    5dd2:	10 f4       	brcc	.+4      	; 0x5dd8 <vTaskPriorityDisinheritAfterTimeout+0x9a>
    5dd4:	80 93 fb 2c 	sts	0x2CFB, r24	; 0x802cfb <uxTopReadyPriority>
    5dd8:	90 e0       	ldi	r25, 0x00	; 0
    5dda:	9c 01       	movw	r18, r24
    5ddc:	22 0f       	add	r18, r18
    5dde:	33 1f       	adc	r19, r19
    5de0:	22 0f       	add	r18, r18
    5de2:	33 1f       	adc	r19, r19
    5de4:	22 0f       	add	r18, r18
    5de6:	33 1f       	adc	r19, r19
    5de8:	82 0f       	add	r24, r18
    5dea:	93 1f       	adc	r25, r19
    5dec:	b8 01       	movw	r22, r16
    5dee:	8f 5c       	subi	r24, 0xCF	; 207
    5df0:	92 4d       	sbci	r25, 0xD2	; 210
    5df2:	df 91       	pop	r29
    5df4:	cf 91       	pop	r28
    5df6:	1f 91       	pop	r17
    5df8:	0f 91       	pop	r16
    5dfa:	0c 94 f5 1c 	jmp	0x39ea	; 0x39ea <vListInsertEnd>
    5dfe:	6d ec       	ldi	r22, 0xCD	; 205
    5e00:	7f e0       	ldi	r23, 0x0F	; 15
    5e02:	8e ed       	ldi	r24, 0xDE	; 222
    5e04:	93 e2       	ldi	r25, 0x23	; 35
    5e06:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    5e0a:	a5 cf       	rjmp	.-182    	; 0x5d56 <vTaskPriorityDisinheritAfterTimeout+0x18>
    5e0c:	68 ee       	ldi	r22, 0xE8	; 232
    5e0e:	7f e0       	ldi	r23, 0x0F	; 15
    5e10:	8e ed       	ldi	r24, 0xDE	; 222
    5e12:	93 e2       	ldi	r25, 0x23	; 35
    5e14:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    5e18:	8e 89       	ldd	r24, Y+22	; 0x16
    5e1a:	b5 cf       	rjmp	.-150    	; 0x5d86 <vTaskPriorityDisinheritAfterTimeout+0x48>

00005e1c <vTaskGetRunTimeStats>:
    5e1c:	2f 92       	push	r2
    5e1e:	3f 92       	push	r3
    5e20:	4f 92       	push	r4
    5e22:	5f 92       	push	r5
    5e24:	6f 92       	push	r6
    5e26:	7f 92       	push	r7
    5e28:	8f 92       	push	r8
    5e2a:	9f 92       	push	r9
    5e2c:	af 92       	push	r10
    5e2e:	bf 92       	push	r11
    5e30:	cf 92       	push	r12
    5e32:	df 92       	push	r13
    5e34:	ef 92       	push	r14
    5e36:	ff 92       	push	r15
    5e38:	0f 93       	push	r16
    5e3a:	1f 93       	push	r17
    5e3c:	cf 93       	push	r28
    5e3e:	df 93       	push	r29
    5e40:	00 d0       	rcall	.+0      	; 0x5e42 <vTaskGetRunTimeStats+0x26>
    5e42:	1f 92       	push	r1
    5e44:	cd b7       	in	r28, 0x3d	; 61
    5e46:	de b7       	in	r29, 0x3e	; 62
    5e48:	8c 01       	movw	r16, r24
    5e4a:	fc 01       	movw	r30, r24
    5e4c:	10 82       	st	Z, r1
    5e4e:	f0 90 fe 2c 	lds	r15, 0x2CFE	; 0x802cfe <uxCurrentNumberOfTasks>
    5e52:	80 91 fe 2c 	lds	r24, 0x2CFE	; 0x802cfe <uxCurrentNumberOfTasks>
    5e56:	f0 e1       	ldi	r31, 0x10	; 16
    5e58:	8f 9f       	mul	r24, r31
    5e5a:	c0 01       	movw	r24, r0
    5e5c:	11 24       	eor	r1, r1
    5e5e:	0e 94 14 1c 	call	0x3828	; 0x3828 <pvPortMalloc>
    5e62:	5c 01       	movw	r10, r24
    5e64:	00 97       	sbiw	r24, 0x00	; 0
    5e66:	09 f4       	brne	.+2      	; 0x5e6a <vTaskGetRunTimeStats+0x4e>
    5e68:	79 c0       	rjmp	.+242    	; 0x5f5c <vTaskGetRunTimeStats+0x140>
    5e6a:	ae 01       	movw	r20, r28
    5e6c:	4f 5f       	subi	r20, 0xFF	; 255
    5e6e:	5f 4f       	sbci	r21, 0xFF	; 255
    5e70:	6f 2d       	mov	r22, r15
    5e72:	0e 94 1b 2d 	call	0x5a36	; 0x5a36 <uxTaskGetSystemState>
    5e76:	88 2e       	mov	r8, r24
    5e78:	69 81       	ldd	r22, Y+1	; 0x01
    5e7a:	7a 81       	ldd	r23, Y+2	; 0x02
    5e7c:	8b 81       	ldd	r24, Y+3	; 0x03
    5e7e:	9c 81       	ldd	r25, Y+4	; 0x04
    5e80:	24 e6       	ldi	r18, 0x64	; 100
    5e82:	30 e0       	ldi	r19, 0x00	; 0
    5e84:	40 e0       	ldi	r20, 0x00	; 0
    5e86:	50 e0       	ldi	r21, 0x00	; 0
    5e88:	0e 94 33 49 	call	0x9266	; 0x9266 <__udivmodsi4>
    5e8c:	29 83       	std	Y+1, r18	; 0x01
    5e8e:	3a 83       	std	Y+2, r19	; 0x02
    5e90:	4b 83       	std	Y+3, r20	; 0x03
    5e92:	5c 83       	std	Y+4, r21	; 0x04
    5e94:	21 15       	cp	r18, r1
    5e96:	31 05       	cpc	r19, r1
    5e98:	41 05       	cpc	r20, r1
    5e9a:	51 05       	cpc	r21, r1
    5e9c:	09 f4       	brne	.+2      	; 0x5ea0 <vTaskGetRunTimeStats+0x84>
    5e9e:	5b c0       	rjmp	.+182    	; 0x5f56 <vTaskGetRunTimeStats+0x13a>
    5ea0:	88 20       	and	r8, r8
    5ea2:	09 f4       	brne	.+2      	; 0x5ea6 <vTaskGetRunTimeStats+0x8a>
    5ea4:	58 c0       	rjmp	.+176    	; 0x5f56 <vTaskGetRunTimeStats+0x13a>
    5ea6:	75 01       	movw	r14, r10
    5ea8:	91 2c       	mov	r9, r1
    5eaa:	84 e1       	ldi	r24, 0x14	; 20
    5eac:	c8 2e       	mov	r12, r24
    5eae:	84 e2       	ldi	r24, 0x24	; 36
    5eb0:	d8 2e       	mov	r13, r24
    5eb2:	96 e0       	ldi	r25, 0x06	; 6
    5eb4:	29 2e       	mov	r2, r25
    5eb6:	94 e2       	ldi	r25, 0x24	; 36
    5eb8:	39 2e       	mov	r3, r25
    5eba:	26 c0       	rjmp	.+76     	; 0x5f08 <vTaskGetRunTimeStats+0xec>
    5ebc:	7f 92       	push	r7
    5ebe:	6f 92       	push	r6
    5ec0:	5f 92       	push	r5
    5ec2:	4f 92       	push	r4
    5ec4:	f7 01       	movw	r30, r14
    5ec6:	83 85       	ldd	r24, Z+11	; 0x0b
    5ec8:	8f 93       	push	r24
    5eca:	82 85       	ldd	r24, Z+10	; 0x0a
    5ecc:	8f 93       	push	r24
    5ece:	81 85       	ldd	r24, Z+9	; 0x09
    5ed0:	8f 93       	push	r24
    5ed2:	80 85       	ldd	r24, Z+8	; 0x08
    5ed4:	8f 93       	push	r24
    5ed6:	3f 92       	push	r3
    5ed8:	2f 92       	push	r2
    5eda:	1f 93       	push	r17
    5edc:	0f 93       	push	r16
    5ede:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
    5ee2:	cd bf       	out	0x3d, r28	; 61
    5ee4:	de bf       	out	0x3e, r29	; 62
    5ee6:	f8 01       	movw	r30, r16
    5ee8:	01 90       	ld	r0, Z+
    5eea:	00 20       	and	r0, r0
    5eec:	e9 f7       	brne	.-6      	; 0x5ee8 <vTaskGetRunTimeStats+0xcc>
    5eee:	8f 01       	movw	r16, r30
    5ef0:	01 50       	subi	r16, 0x01	; 1
    5ef2:	11 09       	sbc	r17, r1
    5ef4:	93 94       	inc	r9
    5ef6:	90 e1       	ldi	r25, 0x10	; 16
    5ef8:	e9 0e       	add	r14, r25
    5efa:	f1 1c       	adc	r15, r1
    5efc:	89 14       	cp	r8, r9
    5efe:	59 f1       	breq	.+86     	; 0x5f56 <vTaskGetRunTimeStats+0x13a>
    5f00:	29 81       	ldd	r18, Y+1	; 0x01
    5f02:	3a 81       	ldd	r19, Y+2	; 0x02
    5f04:	4b 81       	ldd	r20, Y+3	; 0x03
    5f06:	5c 81       	ldd	r21, Y+4	; 0x04
    5f08:	f7 01       	movw	r30, r14
    5f0a:	60 85       	ldd	r22, Z+8	; 0x08
    5f0c:	71 85       	ldd	r23, Z+9	; 0x09
    5f0e:	82 85       	ldd	r24, Z+10	; 0x0a
    5f10:	93 85       	ldd	r25, Z+11	; 0x0b
    5f12:	0e 94 33 49 	call	0x9266	; 0x9266 <__udivmodsi4>
    5f16:	29 01       	movw	r4, r18
    5f18:	3a 01       	movw	r6, r20
    5f1a:	f7 01       	movw	r30, r14
    5f1c:	62 81       	ldd	r22, Z+2	; 0x02
    5f1e:	73 81       	ldd	r23, Z+3	; 0x03
    5f20:	c8 01       	movw	r24, r16
    5f22:	0e 94 57 25 	call	0x4aae	; 0x4aae <prvWriteNameToBuffer>
    5f26:	8c 01       	movw	r16, r24
    5f28:	41 14       	cp	r4, r1
    5f2a:	51 04       	cpc	r5, r1
    5f2c:	61 04       	cpc	r6, r1
    5f2e:	71 04       	cpc	r7, r1
    5f30:	29 f6       	brne	.-118    	; 0x5ebc <vTaskGetRunTimeStats+0xa0>
    5f32:	f7 01       	movw	r30, r14
    5f34:	83 85       	ldd	r24, Z+11	; 0x0b
    5f36:	8f 93       	push	r24
    5f38:	82 85       	ldd	r24, Z+10	; 0x0a
    5f3a:	8f 93       	push	r24
    5f3c:	81 85       	ldd	r24, Z+9	; 0x09
    5f3e:	8f 93       	push	r24
    5f40:	80 85       	ldd	r24, Z+8	; 0x08
    5f42:	8f 93       	push	r24
    5f44:	df 92       	push	r13
    5f46:	cf 92       	push	r12
    5f48:	1f 93       	push	r17
    5f4a:	0f 93       	push	r16
    5f4c:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
    5f50:	cd bf       	out	0x3d, r28	; 61
    5f52:	de bf       	out	0x3e, r29	; 62
    5f54:	c8 cf       	rjmp	.-112    	; 0x5ee6 <vTaskGetRunTimeStats+0xca>
    5f56:	c5 01       	movw	r24, r10
    5f58:	0e 94 b3 1c 	call	0x3966	; 0x3966 <vPortFree>
    5f5c:	24 96       	adiw	r28, 0x04	; 4
    5f5e:	cd bf       	out	0x3d, r28	; 61
    5f60:	de bf       	out	0x3e, r29	; 62
    5f62:	df 91       	pop	r29
    5f64:	cf 91       	pop	r28
    5f66:	1f 91       	pop	r17
    5f68:	0f 91       	pop	r16
    5f6a:	ff 90       	pop	r15
    5f6c:	ef 90       	pop	r14
    5f6e:	df 90       	pop	r13
    5f70:	cf 90       	pop	r12
    5f72:	bf 90       	pop	r11
    5f74:	af 90       	pop	r10
    5f76:	9f 90       	pop	r9
    5f78:	8f 90       	pop	r8
    5f7a:	7f 90       	pop	r7
    5f7c:	6f 90       	pop	r6
    5f7e:	5f 90       	pop	r5
    5f80:	4f 90       	pop	r4
    5f82:	3f 90       	pop	r3
    5f84:	2f 90       	pop	r2
    5f86:	08 95       	ret

00005f88 <pvTaskIncrementMutexHeldCount>:

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    5f88:	80 91 8b 2d 	lds	r24, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    5f8c:	90 91 8c 2d 	lds	r25, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    5f90:	89 2b       	or	r24, r25
    5f92:	39 f0       	breq	.+14     	; 0x5fa2 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    5f94:	e0 91 8b 2d 	lds	r30, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    5f98:	f0 91 8c 2d 	lds	r31, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
    5f9c:	84 a1       	ldd	r24, Z+36	; 0x24
    5f9e:	8f 5f       	subi	r24, 0xFF	; 255
    5fa0:	84 a3       	std	Z+36, r24	; 0x24
		}

		return pxCurrentTCB;
    5fa2:	80 91 8b 2d 	lds	r24, 0x2D8B	; 0x802d8b <pxCurrentTCB>
    5fa6:	90 91 8c 2d 	lds	r25, 0x2D8C	; 0x802d8c <pxCurrentTCB+0x1>
	}
    5faa:	08 95       	ret

00005fac <vApplicationIdleHook>:
#define SET_ERR_LED() PORTA.OUTSET=1<<7
#define CLR_ERR_LED() PORTA.OUTCLR=1<<7


void vApplicationIdleHook( void )
{
    5fac:	08 95       	ret

00005fae <vApplicationMallocFailedHook>:
	
}

void vApplicationMallocFailedHook(void)
{
	taskDISABLE_INTERRUPTS();
    5fae:	f8 94       	cli
	DbgPrint ("ERROR: memory allocation failed\r\n");
    5fb0:	81 e2       	ldi	r24, 0x21	; 33
    5fb2:	94 e2       	ldi	r25, 0x24	; 36
    5fb4:	0e 94 d3 05 	call	0xba6	; 0xba6 <DbgPrint>
	CFG_ERR_LED();
    5fb8:	80 e8       	ldi	r24, 0x80	; 128
    5fba:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	while (1)
	{
		SET_ERR_LED();
    5fbe:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5fc2:	2f ef       	ldi	r18, 0xFF	; 255
    5fc4:	33 ec       	ldi	r19, 0xC3	; 195
    5fc6:	99 e0       	ldi	r25, 0x09	; 9
    5fc8:	21 50       	subi	r18, 0x01	; 1
    5fca:	30 40       	sbci	r19, 0x00	; 0
    5fcc:	90 40       	sbci	r25, 0x00	; 0
    5fce:	e1 f7       	brne	.-8      	; 0x5fc8 <vApplicationMallocFailedHook+0x1a>
    5fd0:	00 c0       	rjmp	.+0      	; 0x5fd2 <vApplicationMallocFailedHook+0x24>
    5fd2:	00 00       	nop
		_delay_ms(100);
		CLR_ERR_LED();
    5fd4:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    5fd8:	2f ef       	ldi	r18, 0xFF	; 255
    5fda:	33 ec       	ldi	r19, 0xC3	; 195
    5fdc:	99 e0       	ldi	r25, 0x09	; 9
    5fde:	21 50       	subi	r18, 0x01	; 1
    5fe0:	30 40       	sbci	r19, 0x00	; 0
    5fe2:	90 40       	sbci	r25, 0x00	; 0
    5fe4:	e1 f7       	brne	.-8      	; 0x5fde <vApplicationMallocFailedHook+0x30>
    5fe6:	00 c0       	rjmp	.+0      	; 0x5fe8 <vApplicationMallocFailedHook+0x3a>
    5fe8:	00 00       	nop
    5fea:	e9 cf       	rjmp	.-46     	; 0x5fbe <vApplicationMallocFailedHook+0x10>

00005fec <vApplicationStackOverflowHook>:
}



void vApplicationStackOverflowHook( TaskHandle_t xTask,signed char *pcTaskName )
{
    5fec:	eb 01       	movw	r28, r22
	taskDISABLE_INTERRUPTS();
    5fee:	f8 94       	cli
	CFG_ERR_LED();
    5ff0:	80 e8       	ldi	r24, 0x80	; 128
    5ff2:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	DbgPrint("STACK overflow in task ");
    5ff6:	83 e4       	ldi	r24, 0x43	; 67
    5ff8:	94 e2       	ldi	r25, 0x24	; 36
    5ffa:	0e 94 d3 05 	call	0xba6	; 0xba6 <DbgPrint>
	DbgPrintn(pcTaskName,10);
    5ffe:	6a e0       	ldi	r22, 0x0A	; 10
    6000:	70 e0       	ldi	r23, 0x00	; 0
    6002:	ce 01       	movw	r24, r28
    6004:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <DbgPrintn>
	DbgPrint("\r\n");
    6008:	8e e1       	ldi	r24, 0x1E	; 30
    600a:	94 e2       	ldi	r25, 0x24	; 36
    600c:	0e 94 d3 05 	call	0xba6	; 0xba6 <DbgPrint>
	while (1)
	{
		SET_ERR_LED();
    6010:	80 e8       	ldi	r24, 0x80	; 128
    6012:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
    6016:	2f ef       	ldi	r18, 0xFF	; 255
    6018:	33 ed       	ldi	r19, 0xD3	; 211
    601a:	90 e3       	ldi	r25, 0x30	; 48
    601c:	21 50       	subi	r18, 0x01	; 1
    601e:	30 40       	sbci	r19, 0x00	; 0
    6020:	90 40       	sbci	r25, 0x00	; 0
    6022:	e1 f7       	brne	.-8      	; 0x601c <vApplicationStackOverflowHook+0x30>
    6024:	00 c0       	rjmp	.+0      	; 0x6026 <vApplicationStackOverflowHook+0x3a>
    6026:	00 00       	nop
		_delay_ms(500);
		CLR_ERR_LED();
    6028:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    602c:	2f ef       	ldi	r18, 0xFF	; 255
    602e:	33 ed       	ldi	r19, 0xD3	; 211
    6030:	90 e3       	ldi	r25, 0x30	; 48
    6032:	21 50       	subi	r18, 0x01	; 1
    6034:	30 40       	sbci	r19, 0x00	; 0
    6036:	90 40       	sbci	r25, 0x00	; 0
    6038:	e1 f7       	brne	.-8      	; 0x6032 <vApplicationStackOverflowHook+0x46>
    603a:	00 c0       	rjmp	.+0      	; 0x603c <vApplicationStackOverflowHook+0x50>
    603c:	00 00       	nop
    603e:	e9 cf       	rjmp	.-46     	; 0x6012 <vApplicationStackOverflowHook+0x26>

00006040 <vAssertCalled>:
		_delay_ms(500);
	}
}

void vAssertCalled( char *File, int Line)
{
    6040:	8c 01       	movw	r16, r24
    6042:	eb 01       	movw	r28, r22
	taskDISABLE_INTERRUPTS();	
    6044:	f8 94       	cli
	CFG_ERR_LED();
    6046:	80 e8       	ldi	r24, 0x80	; 128
    6048:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	DbgPrint("Assert in file ");
    604c:	8b e5       	ldi	r24, 0x5B	; 91
    604e:	94 e2       	ldi	r25, 0x24	; 36
    6050:	0e 94 d3 05 	call	0xba6	; 0xba6 <DbgPrint>
	DbgPrintn(File,100);
    6054:	64 e6       	ldi	r22, 0x64	; 100
    6056:	70 e0       	ldi	r23, 0x00	; 0
    6058:	c8 01       	movw	r24, r16
    605a:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <DbgPrintn>
	DbgPrint(", line nr ");
    605e:	8b e6       	ldi	r24, 0x6B	; 107
    6060:	94 e2       	ldi	r25, 0x24	; 36
    6062:	0e 94 d3 05 	call	0xba6	; 0xba6 <DbgPrint>
	DbgPrintInt(Line);
    6066:	ce 01       	movw	r24, r28
    6068:	0e 94 17 06 	call	0xc2e	; 0xc2e <DbgPrintInt>
	DbgPrint("\r\n");
    606c:	8e e1       	ldi	r24, 0x1E	; 30
    606e:	94 e2       	ldi	r25, 0x24	; 36
    6070:	0e 94 d3 05 	call	0xba6	; 0xba6 <DbgPrint>

	while (1)
	{
		SET_ERR_LED();
    6074:	80 e8       	ldi	r24, 0x80	; 128
    6076:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
    607a:	2f ef       	ldi	r18, 0xFF	; 255
    607c:	33 ec       	ldi	r19, 0xC3	; 195
    607e:	99 e0       	ldi	r25, 0x09	; 9
    6080:	21 50       	subi	r18, 0x01	; 1
    6082:	30 40       	sbci	r19, 0x00	; 0
    6084:	90 40       	sbci	r25, 0x00	; 0
    6086:	e1 f7       	brne	.-8      	; 0x6080 <vAssertCalled+0x40>
    6088:	00 c0       	rjmp	.+0      	; 0x608a <vAssertCalled+0x4a>
    608a:	00 00       	nop
		_delay_ms(100);
		CLR_ERR_LED();
    608c:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    6090:	2f ef       	ldi	r18, 0xFF	; 255
    6092:	33 ed       	ldi	r19, 0xD3	; 211
    6094:	90 e3       	ldi	r25, 0x30	; 48
    6096:	21 50       	subi	r18, 0x01	; 1
    6098:	30 40       	sbci	r19, 0x00	; 0
    609a:	90 40       	sbci	r25, 0x00	; 0
    609c:	e1 f7       	brne	.-8      	; 0x6096 <vAssertCalled+0x56>
    609e:	00 c0       	rjmp	.+0      	; 0x60a0 <vAssertCalled+0x60>
    60a0:	00 00       	nop
    60a2:	e9 cf       	rjmp	.-46     	; 0x6076 <vAssertCalled+0x36>

000060a4 <main>:

uint8_t *ucHeap;

int main(void)
{
	DriverSysClkXtalInit();	//Clock init
    60a4:	0e 94 9a 0f 	call	0x1f34	; 0x1f34 <DriverSysClkXtalInit>
	//Allocate FreeRTOS heap
	ucHeap=malloc(configTOTAL_HEAP_SIZE);
    60a8:	80 e0       	ldi	r24, 0x00	; 0
    60aa:	90 e4       	ldi	r25, 0x40	; 64
    60ac:	0e 94 77 49 	call	0x92ee	; 0x92ee <malloc>
    60b0:	80 93 d3 2d 	sts	0x2DD3, r24	; 0x802dd3 <ucHeap>
    60b4:	90 93 d4 2d 	sts	0x2DD4, r25	; 0x802dd4 <ucHeap+0x1>
	if (ucHeap==NULL) while(1);
    60b8:	89 2b       	or	r24, r25
    60ba:	a9 f0       	breq	.+42     	; 0x60e6 <main+0x42>
	
	//Enable interrupts
	PMIC.CTRL=0b111;		
    60bc:	87 e0       	ldi	r24, 0x07	; 7
    60be:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    60c2:	78 94       	sei
	
	//Init startup task
	InitStartupTask();
    60c4:	0e 94 9c 40 	call	0x8138	; 0x8138 <InitStartupTask>
    MotorSpeedSet(100, 200); // Set initial speeds for the motors
    60c8:	68 ec       	ldi	r22, 0xC8	; 200
    60ca:	70 e0       	ldi	r23, 0x00	; 0
    60cc:	84 e6       	ldi	r24, 0x64	; 100
    60ce:	90 e0       	ldi	r25, 0x00	; 0
    60d0:	0e 94 be 39 	call	0x737c	; 0x737c <MotorSpeedSet>
    InitMotorSpeedTask();
    60d4:	0e 94 7c 39 	call	0x72f8	; 0x72f8 <InitMotorSpeedTask>
	EnableMotorSpeedTask();
    60d8:	0e 94 ac 39 	call	0x7358	; 0x7358 <EnableMotorSpeedTask>
	//Start scheduler loop
	vTaskStartScheduler();	
    60dc:	0e 94 17 29 	call	0x522e	; 0x522e <vTaskStartScheduler>
	
	


	return 0;
}
    60e0:	80 e0       	ldi	r24, 0x00	; 0
    60e2:	90 e0       	ldi	r25, 0x00	; 0
    60e4:	08 95       	ret
    60e6:	ff cf       	rjmp	.-2      	; 0x60e6 <main+0x42>

000060e8 <cmpfunc>:
int cmpfunc (const void * a, const void * b) {
	TaskStatus_t *TaskA, *TaskB;
	TaskA=(TaskStatus_t *) a;
	TaskB=(TaskStatus_t *) b;
	
	if (TaskA->pxStackBase<TaskB->pxStackBase) return -1;
    60e8:	fc 01       	movw	r30, r24
    60ea:	44 85       	ldd	r20, Z+12	; 0x0c
    60ec:	55 85       	ldd	r21, Z+13	; 0x0d
    60ee:	fb 01       	movw	r30, r22
    60f0:	24 85       	ldd	r18, Z+12	; 0x0c
    60f2:	35 85       	ldd	r19, Z+13	; 0x0d
    60f4:	42 17       	cp	r20, r18
    60f6:	53 07       	cpc	r21, r19
    60f8:	40 f0       	brcs	.+16     	; 0x610a <cmpfunc+0x22>
    60fa:	81 e0       	ldi	r24, 0x01	; 1
    60fc:	90 e0       	ldi	r25, 0x00	; 0
    60fe:	24 17       	cp	r18, r20
    6100:	35 07       	cpc	r19, r21
    6102:	08 f4       	brcc	.+2      	; 0x6106 <cmpfunc+0x1e>
	else if (TaskA->pxStackBase>TaskB->pxStackBase) return 1;
	else return 0;
	
}
    6104:	08 95       	ret
int cmpfunc (const void * a, const void * b) {
	TaskStatus_t *TaskA, *TaskB;
	TaskA=(TaskStatus_t *) a;
	TaskB=(TaskStatus_t *) b;
	
	if (TaskA->pxStackBase<TaskB->pxStackBase) return -1;
    6106:	80 e0       	ldi	r24, 0x00	; 0
    6108:	08 95       	ret
    610a:	8f ef       	ldi	r24, 0xFF	; 255
    610c:	9f ef       	ldi	r25, 0xFF	; 255
	else if (TaskA->pxStackBase>TaskB->pxStackBase) return 1;
	else return 0;
	
}
    610e:	08 95       	ret

00006110 <MemMap>:

void MemMap()
{
    6110:	5f 92       	push	r5
    6112:	6f 92       	push	r6
    6114:	7f 92       	push	r7
    6116:	8f 92       	push	r8
    6118:	9f 92       	push	r9
    611a:	af 92       	push	r10
    611c:	bf 92       	push	r11
    611e:	cf 92       	push	r12
    6120:	df 92       	push	r13
    6122:	ef 92       	push	r14
    6124:	ff 92       	push	r15
    6126:	0f 93       	push	r16
    6128:	1f 93       	push	r17
    612a:	cf 93       	push	r28
    612c:	df 93       	push	r29
    612e:	cd b7       	in	r28, 0x3d	; 61
    6130:	de b7       	in	r29, 0x3e	; 62
    6132:	c0 54       	subi	r28, 0x40	; 64
    6134:	d1 40       	sbci	r29, 0x01	; 1
    6136:	cd bf       	out	0x3d, r28	; 61
    6138:	de bf       	out	0x3e, r29	; 62
	uint8_t a;
	TaskStatus_t TaskStatusArray[MAX_TASKS];
	int TCBSize;
	
	
	NumTasks=uxTaskGetSystemState(TaskStatusArray,MAX_TASKS,NULL);
    613a:	40 e0       	ldi	r20, 0x00	; 0
    613c:	50 e0       	ldi	r21, 0x00	; 0
    613e:	64 e1       	ldi	r22, 0x14	; 20
    6140:	ce 01       	movw	r24, r28
    6142:	01 96       	adiw	r24, 0x01	; 1
    6144:	0e 94 1b 2d 	call	0x5a36	; 0x5a36 <uxTaskGetSystemState>
    6148:	88 2e       	mov	r8, r24
    614a:	91 2c       	mov	r9, r1
	qsort(TaskStatusArray, NumTasks, sizeof(TaskStatus_t), cmpfunc);
    614c:	24 e7       	ldi	r18, 0x74	; 116
    614e:	30 e3       	ldi	r19, 0x30	; 48
    6150:	40 e1       	ldi	r20, 0x10	; 16
    6152:	50 e0       	ldi	r21, 0x00	; 0
    6154:	b4 01       	movw	r22, r8
    6156:	ce 01       	movw	r24, r28
    6158:	01 96       	adiw	r24, 0x01	; 1
    615a:	0e 94 df 4a 	call	0x95be	; 0x95be <qsort>
	
	printf("MEMORY MAP:\r\n");
    615e:	86 e7       	ldi	r24, 0x76	; 118
    6160:	94 e2       	ldi	r25, 0x24	; 36
    6162:	0e 94 9e 4e 	call	0x9d3c	; 0x9d3c <puts>
	printf("-----------\r\n");
    6166:	83 e8       	ldi	r24, 0x83	; 131
    6168:	94 e2       	ldi	r25, 0x24	; 36
    616a:	0e 94 9e 4e 	call	0x9d3c	; 0x9d3c <puts>
	printf("IO registers start:\t\t\t0x%04x\r\n",MEM_IO_REGS_START);
    616e:	1f 92       	push	r1
    6170:	1f 92       	push	r1
    6172:	1f 92       	push	r1
    6174:	1f 92       	push	r1
    6176:	80 e9       	ldi	r24, 0x90	; 144
    6178:	94 e2       	ldi	r25, 0x24	; 36
    617a:	9f 93       	push	r25
    617c:	8f 93       	push	r24
    617e:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
	printf("IO registers end:\t\t\t0x%04x\r\n",MEM_IO_REGS_STOP);
    6182:	1f 92       	push	r1
    6184:	1f 92       	push	r1
    6186:	8f e0       	ldi	r24, 0x0F	; 15
    6188:	8f 93       	push	r24
    618a:	1f ef       	ldi	r17, 0xFF	; 255
    618c:	1f 93       	push	r17
    618e:	8f ea       	ldi	r24, 0xAF	; 175
    6190:	94 e2       	ldi	r25, 0x24	; 36
    6192:	9f 93       	push	r25
    6194:	8f 93       	push	r24
    6196:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
	printf("EEPROM start:\t\t\t\t0x%04x\r\n",MEM_EEPROM_START);
    619a:	1f 92       	push	r1
    619c:	1f 92       	push	r1
    619e:	80 e1       	ldi	r24, 0x10	; 16
    61a0:	8f 93       	push	r24
    61a2:	1f 92       	push	r1
    61a4:	8c ec       	ldi	r24, 0xCC	; 204
    61a6:	94 e2       	ldi	r25, 0x24	; 36
    61a8:	9f 93       	push	r25
    61aa:	8f 93       	push	r24
    61ac:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
	printf("EEPROM end:\t\t\t\t0x%04x\r\n",MEM_EEPROM_STOP);
    61b0:	1f 92       	push	r1
    61b2:	1f 92       	push	r1
    61b4:	8f e1       	ldi	r24, 0x1F	; 31
    61b6:	8f 93       	push	r24
    61b8:	1f 93       	push	r17
    61ba:	86 ee       	ldi	r24, 0xE6	; 230
    61bc:	94 e2       	ldi	r25, 0x24	; 36
    61be:	9f 93       	push	r25
    61c0:	8f 93       	push	r24
    61c2:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
	printf("SRAM start:\t\t\t\t0x%04x\r\n",MEM_SRAM_START);
    61c6:	1f 92       	push	r1
    61c8:	1f 92       	push	r1
    61ca:	80 e2       	ldi	r24, 0x20	; 32
    61cc:	8f 93       	push	r24
    61ce:	1f 92       	push	r1
    61d0:	8e ef       	ldi	r24, 0xFE	; 254
    61d2:	94 e2       	ldi	r25, 0x24	; 36
    61d4:	9f 93       	push	r25
    61d6:	8f 93       	push	r24
    61d8:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
	printf ("\t.DATA start:\t\t\t0x%04x\r\n",__data_start);
    61dc:	80 e0       	ldi	r24, 0x00	; 0
    61de:	90 e2       	ldi	r25, 0x20	; 32
    61e0:	9f 93       	push	r25
    61e2:	8f 93       	push	r24
    61e4:	86 e1       	ldi	r24, 0x16	; 22
    61e6:	95 e2       	ldi	r25, 0x25	; 37
    61e8:	9f 93       	push	r25
    61ea:	8f 93       	push	r24
    61ec:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
	printf ("\t.DATA end:\t\t\t0x%04x\r\n",__data_end-1);
    61f0:	cd bf       	out	0x3d, r28	; 61
    61f2:	de bf       	out	0x3e, r29	; 62
    61f4:	8f e6       	ldi	r24, 0x6F	; 111
    61f6:	98 e2       	ldi	r25, 0x28	; 40
    61f8:	9f 93       	push	r25
    61fa:	8f 93       	push	r24
    61fc:	8f e2       	ldi	r24, 0x2F	; 47
    61fe:	95 e2       	ldi	r25, 0x25	; 37
    6200:	9f 93       	push	r25
    6202:	8f 93       	push	r24
    6204:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
	printf ("\t.BSS start:\t\t\t0x%04x\r\n",__bss_start);
    6208:	80 e7       	ldi	r24, 0x70	; 112
    620a:	98 e2       	ldi	r25, 0x28	; 40
    620c:	9f 93       	push	r25
    620e:	8f 93       	push	r24
    6210:	86 e4       	ldi	r24, 0x46	; 70
    6212:	95 e2       	ldi	r25, 0x25	; 37
    6214:	9f 93       	push	r25
    6216:	8f 93       	push	r24
    6218:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
	printf ("\t.BSS end:\t\t\t0x%04x\r\n",__bss_end-1);
    621c:	84 ee       	ldi	r24, 0xE4	; 228
    621e:	9d e2       	ldi	r25, 0x2D	; 45
    6220:	9f 93       	push	r25
    6222:	8f 93       	push	r24
    6224:	8e e5       	ldi	r24, 0x5E	; 94
    6226:	95 e2       	ldi	r25, 0x25	; 37
    6228:	9f 93       	push	r25
    622a:	8f 93       	push	r24
    622c:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
	printf ("\t.HEAP start:\t\t\t0x%04x\r\n",ucHeap);
    6230:	80 91 d4 2d 	lds	r24, 0x2DD4	; 0x802dd4 <ucHeap+0x1>
    6234:	8f 93       	push	r24
    6236:	80 91 d3 2d 	lds	r24, 0x2DD3	; 0x802dd3 <ucHeap>
    623a:	8f 93       	push	r24
    623c:	84 e7       	ldi	r24, 0x74	; 116
    623e:	95 e2       	ldi	r25, 0x25	; 37
    6240:	9f 93       	push	r25
    6242:	8f 93       	push	r24
    6244:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
	
	for (a=0;a<NumTasks;a++)
    6248:	cd bf       	out	0x3d, r28	; 61
    624a:	de bf       	out	0x3e, r29	; 62
    624c:	81 14       	cp	r8, r1
    624e:	91 04       	cpc	r9, r1
    6250:	09 f4       	brne	.+2      	; 0x6254 <MemMap+0x144>
    6252:	52 c0       	rjmp	.+164    	; 0x62f8 <MemMap+0x1e8>
    6254:	00 e0       	ldi	r16, 0x00	; 0
    6256:	10 e0       	ldi	r17, 0x00	; 0
    6258:	51 2c       	mov	r5, r1
	{
		printf ("\tTask name: %s\r\n",TaskStatusArray[a].pcTaskName);
    625a:	90 e0       	ldi	r25, 0x00	; 0
    625c:	a9 2e       	mov	r10, r25
    625e:	96 e2       	ldi	r25, 0x26	; 38
    6260:	b9 2e       	mov	r11, r25
		printf ("\t\tSTACK end:\t\t0x%04x\r\n",TaskStatusArray[a].pxStackBase);
    6262:	21 e1       	ldi	r18, 0x11	; 17
    6264:	c2 2e       	mov	r12, r18
    6266:	26 e2       	ldi	r18, 0x26	; 38
    6268:	d2 2e       	mov	r13, r18
		printf ("\t\tTCB start:\t\t0x%04x\r\n",TaskStatusArray[a].xHandle);
    626a:	38 e2       	ldi	r19, 0x28	; 40
    626c:	e3 2e       	mov	r14, r19
    626e:	36 e2       	ldi	r19, 0x26	; 38
    6270:	f3 2e       	mov	r15, r19
		TCBSize=(*(uint16_t *) ((uint16_t) (TaskStatusArray[a].xHandle)-2))-4;
		printf ("\t\tTCB end:\t\t0x%04x\r\n",(uint16_t)(TaskStatusArray[a].xHandle)+TCBSize-1);
    6272:	4f e3       	ldi	r20, 0x3F	; 63
    6274:	64 2e       	mov	r6, r20
    6276:	46 e2       	ldi	r20, 0x26	; 38
    6278:	74 2e       	mov	r7, r20
	printf ("\t.BSS end:\t\t\t0x%04x\r\n",__bss_end-1);
	printf ("\t.HEAP start:\t\t\t0x%04x\r\n",ucHeap);
	
	for (a=0;a<NumTasks;a++)
	{
		printf ("\tTask name: %s\r\n",TaskStatusArray[a].pcTaskName);
    627a:	02 95       	swap	r16
    627c:	12 95       	swap	r17
    627e:	10 7f       	andi	r17, 0xF0	; 240
    6280:	10 27       	eor	r17, r16
    6282:	00 7f       	andi	r16, 0xF0	; 240
    6284:	10 27       	eor	r17, r16
    6286:	e1 e0       	ldi	r30, 0x01	; 1
    6288:	f0 e0       	ldi	r31, 0x00	; 0
    628a:	ec 0f       	add	r30, r28
    628c:	fd 1f       	adc	r31, r29
    628e:	0e 0f       	add	r16, r30
    6290:	1f 1f       	adc	r17, r31
    6292:	f8 01       	movw	r30, r16
    6294:	83 81       	ldd	r24, Z+3	; 0x03
    6296:	8f 93       	push	r24
    6298:	82 81       	ldd	r24, Z+2	; 0x02
    629a:	8f 93       	push	r24
    629c:	bf 92       	push	r11
    629e:	af 92       	push	r10
    62a0:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
		printf ("\t\tSTACK end:\t\t0x%04x\r\n",TaskStatusArray[a].pxStackBase);
    62a4:	f8 01       	movw	r30, r16
    62a6:	85 85       	ldd	r24, Z+13	; 0x0d
    62a8:	8f 93       	push	r24
    62aa:	84 85       	ldd	r24, Z+12	; 0x0c
    62ac:	8f 93       	push	r24
    62ae:	df 92       	push	r13
    62b0:	cf 92       	push	r12
    62b2:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
		printf ("\t\tTCB start:\t\t0x%04x\r\n",TaskStatusArray[a].xHandle);
    62b6:	f8 01       	movw	r30, r16
    62b8:	81 81       	ldd	r24, Z+1	; 0x01
    62ba:	8f 93       	push	r24
    62bc:	80 81       	ld	r24, Z
    62be:	8f 93       	push	r24
    62c0:	ff 92       	push	r15
    62c2:	ef 92       	push	r14
    62c4:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
		TCBSize=(*(uint16_t *) ((uint16_t) (TaskStatusArray[a].xHandle)-2))-4;
    62c8:	f8 01       	movw	r30, r16
    62ca:	80 81       	ld	r24, Z
    62cc:	91 81       	ldd	r25, Z+1	; 0x01
    62ce:	fc 01       	movw	r30, r24
    62d0:	32 97       	sbiw	r30, 0x02	; 2
		printf ("\t\tTCB end:\t\t0x%04x\r\n",(uint16_t)(TaskStatusArray[a].xHandle)+TCBSize-1);
    62d2:	05 97       	sbiw	r24, 0x05	; 5
    62d4:	20 81       	ld	r18, Z
    62d6:	31 81       	ldd	r19, Z+1	; 0x01
    62d8:	82 0f       	add	r24, r18
    62da:	93 1f       	adc	r25, r19
    62dc:	9f 93       	push	r25
    62de:	8f 93       	push	r24
    62e0:	7f 92       	push	r7
    62e2:	6f 92       	push	r6
    62e4:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
	printf ("\t.DATA end:\t\t\t0x%04x\r\n",__data_end-1);
	printf ("\t.BSS start:\t\t\t0x%04x\r\n",__bss_start);
	printf ("\t.BSS end:\t\t\t0x%04x\r\n",__bss_end-1);
	printf ("\t.HEAP start:\t\t\t0x%04x\r\n",ucHeap);
	
	for (a=0;a<NumTasks;a++)
    62e8:	53 94       	inc	r5
    62ea:	05 2d       	mov	r16, r5
    62ec:	10 e0       	ldi	r17, 0x00	; 0
    62ee:	cd bf       	out	0x3d, r28	; 61
    62f0:	de bf       	out	0x3e, r29	; 62
    62f2:	08 15       	cp	r16, r8
    62f4:	19 05       	cpc	r17, r9
    62f6:	0c f2       	brlt	.-126    	; 0x627a <MemMap+0x16a>
		TCBSize=(*(uint16_t *) ((uint16_t) (TaskStatusArray[a].xHandle)-2))-4;
		printf ("\t\tTCB end:\t\t0x%04x\r\n",(uint16_t)(TaskStatusArray[a].xHandle)+TCBSize-1);
	}
	
	
	printf ("\t.HEAP end:\t\t\t0x%04x\r\n",ucHeap+configTOTAL_HEAP_SIZE-1);
    62f8:	80 91 d3 2d 	lds	r24, 0x2DD3	; 0x802dd3 <ucHeap>
    62fc:	90 91 d4 2d 	lds	r25, 0x2DD4	; 0x802dd4 <ucHeap+0x1>
    6300:	81 50       	subi	r24, 0x01	; 1
    6302:	90 4c       	sbci	r25, 0xC0	; 192
    6304:	9f 93       	push	r25
    6306:	8f 93       	push	r24
    6308:	8d e8       	ldi	r24, 0x8D	; 141
    630a:	95 e2       	ldi	r25, 0x25	; 37
    630c:	9f 93       	push	r25
    630e:	8f 93       	push	r24
    6310:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
	printf ("\t.Bare metal STACK end:\t\t0x%04x\r\n",ucHeap+configTOTAL_HEAP_SIZE);
    6314:	80 91 d3 2d 	lds	r24, 0x2DD3	; 0x802dd3 <ucHeap>
    6318:	90 91 d4 2d 	lds	r25, 0x2DD4	; 0x802dd4 <ucHeap+0x1>
    631c:	90 5c       	subi	r25, 0xC0	; 192
    631e:	9f 93       	push	r25
    6320:	8f 93       	push	r24
    6322:	84 ea       	ldi	r24, 0xA4	; 164
    6324:	95 e2       	ldi	r25, 0x25	; 37
    6326:	9f 93       	push	r25
    6328:	8f 93       	push	r24
    632a:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
	printf ("\t.Bare metal STACK start:\t0x%04x\r\n",MEM_SRAM_STOP);
    632e:	1f 92       	push	r1
    6330:	1f 92       	push	r1
    6332:	0f e9       	ldi	r16, 0x9F	; 159
    6334:	0f 93       	push	r16
    6336:	1f ef       	ldi	r17, 0xFF	; 255
    6338:	1f 93       	push	r17
    633a:	86 ec       	ldi	r24, 0xC6	; 198
    633c:	95 e2       	ldi	r25, 0x25	; 37
    633e:	9f 93       	push	r25
    6340:	8f 93       	push	r24
    6342:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
	printf("SRAM stop:\t\t\t\t0x%04x\r\n",MEM_SRAM_STOP);
    6346:	1f 92       	push	r1
    6348:	1f 92       	push	r1
    634a:	0f 93       	push	r16
    634c:	1f 93       	push	r17
    634e:	89 ee       	ldi	r24, 0xE9	; 233
    6350:	95 e2       	ldi	r25, 0x25	; 37
    6352:	9f 93       	push	r25
    6354:	8f 93       	push	r24
    6356:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
	
	printf("-----------\r\n");
    635a:	83 e8       	ldi	r24, 0x83	; 131
    635c:	94 e2       	ldi	r25, 0x24	; 36
    635e:	0e 94 9e 4e 	call	0x9d3c	; 0x9d3c <puts>
}
    6362:	cd bf       	out	0x3d, r28	; 61
    6364:	de bf       	out	0x3e, r29	; 62
    6366:	c0 5c       	subi	r28, 0xC0	; 192
    6368:	de 4f       	sbci	r29, 0xFE	; 254
    636a:	cd bf       	out	0x3d, r28	; 61
    636c:	de bf       	out	0x3e, r29	; 62
    636e:	df 91       	pop	r29
    6370:	cf 91       	pop	r28
    6372:	1f 91       	pop	r17
    6374:	0f 91       	pop	r16
    6376:	ff 90       	pop	r15
    6378:	ef 90       	pop	r14
    637a:	df 90       	pop	r13
    637c:	cf 90       	pop	r12
    637e:	bf 90       	pop	r11
    6380:	af 90       	pop	r10
    6382:	9f 90       	pop	r9
    6384:	8f 90       	pop	r8
    6386:	7f 90       	pop	r7
    6388:	6f 90       	pop	r6
    638a:	5f 90       	pop	r5
    638c:	08 95       	ret

0000638e <WorkerADC>:
	ADCQueue=xQueueCreate(1,sizeof(ADCStruct));
	xTaskCreate( WorkerADC, "ADC", 512, NULL, tskIDLE_PRIORITY+2, NULL );
}

void WorkerADC(void *pvParameters)
{
    638e:	cf 93       	push	r28
    6390:	df 93       	push	r29
    6392:	cd b7       	in	r28, 0x3d	; 61
    6394:	de b7       	in	r29, 0x3e	; 62
    6396:	2a 97       	sbiw	r28, 0x0a	; 10
    6398:	cd bf       	out	0x3d, r28	; 61
    639a:	de bf       	out	0x3e, r29	; 62
	TickType_t xLastWakeTime;
	const TickType_t xPeriod = 10;
	ADCStruct ADCData;
	
	DriverLedSet(0b0111);
    639c:	87 e0       	ldi	r24, 0x07	; 7
    639e:	0e 94 83 06 	call	0xd06	; 0xd06 <DriverLedSet>
	
	xLastWakeTime=xTaskGetTickCount();
    63a2:	0e 94 54 29 	call	0x52a8	; 0x52a8 <xTaskGetTickCount>
    63a6:	89 87       	std	Y+9, r24	; 0x09
    63a8:	9a 87       	std	Y+10, r25	; 0x0a
	while(1)
	{
		ADCData.PhotoL=DriverAdcGetCh(0,4);
    63aa:	64 e0       	ldi	r22, 0x04	; 4
    63ac:	80 e0       	ldi	r24, 0x00	; 0
    63ae:	0e 94 ad 03 	call	0x75a	; 0x75a <DriverAdcGetCh>
    63b2:	89 83       	std	Y+1, r24	; 0x01
    63b4:	9a 83       	std	Y+2, r25	; 0x02
		ADCData.PhotoM=DriverAdcGetCh(1,4);
    63b6:	64 e0       	ldi	r22, 0x04	; 4
    63b8:	81 e0       	ldi	r24, 0x01	; 1
    63ba:	0e 94 ad 03 	call	0x75a	; 0x75a <DriverAdcGetCh>
    63be:	8b 83       	std	Y+3, r24	; 0x03
    63c0:	9c 83       	std	Y+4, r25	; 0x04
		ADCData.PhotoR=DriverAdcGetCh(2,4);
    63c2:	64 e0       	ldi	r22, 0x04	; 4
    63c4:	82 e0       	ldi	r24, 0x02	; 2
    63c6:	0e 94 ad 03 	call	0x75a	; 0x75a <DriverAdcGetCh>
    63ca:	8d 83       	std	Y+5, r24	; 0x05
    63cc:	9e 83       	std	Y+6, r25	; 0x06
		ADCData.Potmeter=DriverAdcGetCh(3,4);
    63ce:	64 e0       	ldi	r22, 0x04	; 4
    63d0:	83 e0       	ldi	r24, 0x03	; 3
    63d2:	0e 94 ad 03 	call	0x75a	; 0x75a <DriverAdcGetCh>
    63d6:	8f 83       	std	Y+7, r24	; 0x07
    63d8:	98 87       	std	Y+8, r25	; 0x08
		xQueueOverwrite(ADCQueue,&ADCData);
    63da:	22 e0       	ldi	r18, 0x02	; 2
    63dc:	40 e0       	ldi	r20, 0x00	; 0
    63de:	50 e0       	ldi	r21, 0x00	; 0
    63e0:	be 01       	movw	r22, r28
    63e2:	6f 5f       	subi	r22, 0xFF	; 255
    63e4:	7f 4f       	sbci	r23, 0xFF	; 255
    63e6:	80 91 d5 2d 	lds	r24, 0x2DD5	; 0x802dd5 <ADCQueue>
    63ea:	90 91 d6 2d 	lds	r25, 0x2DD6	; 0x802dd6 <ADCQueue+0x1>
    63ee:	0e 94 be 20 	call	0x417c	; 0x417c <xQueueGenericSend>
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    63f2:	6a e0       	ldi	r22, 0x0A	; 10
    63f4:	70 e0       	ldi	r23, 0x00	; 0
    63f6:	ce 01       	movw	r24, r28
    63f8:	09 96       	adiw	r24, 0x09	; 9
    63fa:	0e 94 d9 2a 	call	0x55b2	; 0x55b2 <vTaskDelayUntil>
    63fe:	d5 cf       	rjmp	.-86     	; 0x63aa <WorkerADC+0x1c>

00006400 <InitADCTask>:

void WorkerADC(void *pvParameters);

//Function definitions
void InitADCTask()
{
    6400:	ef 92       	push	r14
    6402:	ff 92       	push	r15
    6404:	0f 93       	push	r16
	ADCQueue=xQueueCreate(1,sizeof(ADCStruct));
    6406:	40 e0       	ldi	r20, 0x00	; 0
    6408:	68 e0       	ldi	r22, 0x08	; 8
    640a:	81 e0       	ldi	r24, 0x01	; 1
    640c:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueGenericCreate>
    6410:	80 93 d5 2d 	sts	0x2DD5, r24	; 0x802dd5 <ADCQueue>
    6414:	90 93 d6 2d 	sts	0x2DD6, r25	; 0x802dd6 <ADCQueue+0x1>
	xTaskCreate( WorkerADC, "ADC", 512, NULL, tskIDLE_PRIORITY+2, NULL );
    6418:	e1 2c       	mov	r14, r1
    641a:	f1 2c       	mov	r15, r1
    641c:	02 e0       	ldi	r16, 0x02	; 2
    641e:	20 e0       	ldi	r18, 0x00	; 0
    6420:	30 e0       	ldi	r19, 0x00	; 0
    6422:	40 e0       	ldi	r20, 0x00	; 0
    6424:	52 e0       	ldi	r21, 0x02	; 2
    6426:	64 e5       	ldi	r22, 0x54	; 84
    6428:	76 e2       	ldi	r23, 0x26	; 38
    642a:	87 ec       	ldi	r24, 0xC7	; 199
    642c:	91 e3       	ldi	r25, 0x31	; 49
    642e:	0e 94 c8 26 	call	0x4d90	; 0x4d90 <xTaskCreate>
}
    6432:	0f 91       	pop	r16
    6434:	ff 90       	pop	r15
    6436:	ef 90       	pop	r14
    6438:	08 95       	ret

0000643a <GetADCData>:
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
	}
}

ADCStruct GetADCData(void)
{
    643a:	cf 93       	push	r28
    643c:	df 93       	push	r29
    643e:	cd b7       	in	r28, 0x3d	; 61
    6440:	de b7       	in	r29, 0x3e	; 62
    6442:	60 97       	sbiw	r28, 0x10	; 16
    6444:	cd bf       	out	0x3d, r28	; 61
    6446:	de bf       	out	0x3e, r29	; 62
	ADCStruct ADCData;
	xQueuePeek(ADCQueue,&ADCData,portMAX_DELAY);
    6448:	4f ef       	ldi	r20, 0xFF	; 255
    644a:	5f ef       	ldi	r21, 0xFF	; 255
    644c:	be 01       	movw	r22, r28
    644e:	67 5f       	subi	r22, 0xF7	; 247
    6450:	7f 4f       	sbci	r23, 0xFF	; 255
    6452:	80 91 d5 2d 	lds	r24, 0x2DD5	; 0x802dd5 <ADCQueue>
    6456:	90 91 d6 2d 	lds	r25, 0x2DD6	; 0x802dd6 <ADCQueue+0x1>
    645a:	0e 94 0c 24 	call	0x4818	; 0x4818 <xQueuePeek>
	return ADCData;
    645e:	88 e0       	ldi	r24, 0x08	; 8
    6460:	fe 01       	movw	r30, r28
    6462:	39 96       	adiw	r30, 0x09	; 9
    6464:	de 01       	movw	r26, r28
    6466:	11 96       	adiw	r26, 0x01	; 1
    6468:	01 90       	ld	r0, Z+
    646a:	0d 92       	st	X+, r0
    646c:	8a 95       	dec	r24
    646e:	e1 f7       	brne	.-8      	; 0x6468 <GetADCData+0x2e>
    6470:	29 81       	ldd	r18, Y+1	; 0x01
    6472:	3a 81       	ldd	r19, Y+2	; 0x02
    6474:	4b 81       	ldd	r20, Y+3	; 0x03
    6476:	5c 81       	ldd	r21, Y+4	; 0x04
    6478:	6d 81       	ldd	r22, Y+5	; 0x05
    647a:	7e 81       	ldd	r23, Y+6	; 0x06
    647c:	8f 81       	ldd	r24, Y+7	; 0x07
    647e:	98 85       	ldd	r25, Y+8	; 0x08
    6480:	60 96       	adiw	r28, 0x10	; 16
    6482:	cd bf       	out	0x3d, r28	; 61
    6484:	de bf       	out	0x3e, r29	; 62
    6486:	df 91       	pop	r29
    6488:	cf 91       	pop	r28
    648a:	08 95       	ret

0000648c <WorkerGyro>:
	xTaskCreate( WorkerGyro, "gyro", 256, NULL, tskIDLE_PRIORITY+3, NULL );	
	GyroSema=xSemaphoreCreateMutex();
}

static void WorkerGyro(void *pvParameters)
{
    648c:	cf 93       	push	r28
    648e:	df 93       	push	r29
    6490:	00 d0       	rcall	.+0      	; 0x6492 <WorkerGyro+0x6>
    6492:	1f 92       	push	r1
    6494:	cd b7       	in	r28, 0x3d	; 61
    6496:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime;
	const TickType_t xPeriod = 10;
	float GyroYawOffset;
	float OldYawRate=0;
	
	DriverMPU6050Init();	//Initialize IMU
    6498:	0e 94 ba 09 	call	0x1374	; 0x1374 <DriverMPU6050Init>
	xLastWakeTime=xTaskGetTickCount();
    649c:	0e 94 54 29 	call	0x52a8	; 0x52a8 <xTaskGetTickCount>
    64a0:	89 83       	std	Y+1, r24	; 0x01
    64a2:	9a 83       	std	Y+2, r25	; 0x02
	
	vTaskDelay(200);
    64a4:	88 ec       	ldi	r24, 0xC8	; 200
    64a6:	90 e0       	ldi	r25, 0x00	; 0
    64a8:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
	DriverMPU6050GyroGet(NULL,NULL,&Gz);
    64ac:	ae 01       	movw	r20, r28
    64ae:	4d 5f       	subi	r20, 0xFD	; 253
    64b0:	5f 4f       	sbci	r21, 0xFF	; 255
    64b2:	60 e0       	ldi	r22, 0x00	; 0
    64b4:	70 e0       	ldi	r23, 0x00	; 0
    64b6:	80 e0       	ldi	r24, 0x00	; 0
    64b8:	90 e0       	ldi	r25, 0x00	; 0
    64ba:	0e 94 3a 0a 	call	0x1474	; 0x1474 <DriverMPU6050GyroGet>
	GyroYawOffset=(float) Gz*RATE_CST;
    64be:	6b 81       	ldd	r22, Y+3	; 0x03
    64c0:	7c 81       	ldd	r23, Y+4	; 0x04
    64c2:	07 2e       	mov	r0, r23
    64c4:	00 0c       	add	r0, r0
    64c6:	88 0b       	sbc	r24, r24
    64c8:	99 0b       	sbc	r25, r25
    64ca:	0e 94 49 44 	call	0x8892	; 0x8892 <__floatsisf>
    64ce:	2d e2       	ldi	r18, 0x2D	; 45
    64d0:	33 e2       	ldi	r19, 0x23	; 35
    64d2:	4a ef       	ldi	r20, 0xFA	; 250
    64d4:	5b e3       	ldi	r21, 0x3B	; 59
    64d6:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    64da:	4b 01       	movw	r8, r22
    64dc:	5c 01       	movw	r10, r24
{
	int16_t Gz;
	TickType_t xLastWakeTime;
	const TickType_t xPeriod = 10;
	float GyroYawOffset;
	float OldYawRate=0;
    64de:	61 2c       	mov	r6, r1
    64e0:	71 2c       	mov	r7, r1
    64e2:	c1 2c       	mov	r12, r1
    64e4:	d1 2c       	mov	r13, r1
    64e6:	0e c0       	rjmp	.+28     	; 0x6504 <WorkerGyro+0x78>
		
		OldYawRate=GlobYawRate;
		
		xSemaphoreGive(GyroSema);
		if (GlobYawRate>0) 
			GyroYawOffset+=0.001;
    64e8:	c5 01       	movw	r24, r10
    64ea:	b4 01       	movw	r22, r8
    64ec:	0e 94 2e 43 	call	0x865c	; 0x865c <__addsf3>
    64f0:	4b 01       	movw	r8, r22
    64f2:	5c 01       	movw	r10, r24
		else
			GyroYawOffset-=0.001;
		
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    64f4:	6a e0       	ldi	r22, 0x0A	; 10
    64f6:	70 e0       	ldi	r23, 0x00	; 0
    64f8:	ce 01       	movw	r24, r28
    64fa:	01 96       	adiw	r24, 0x01	; 1
    64fc:	0e 94 d9 2a 	call	0x55b2	; 0x55b2 <vTaskDelayUntil>
		GlobYawRate-=GyroYawOffset;
		
		//Integration to yaw angle
		GlobYaw+=((GlobYawRate/100)+(OldYawRate/100))/2;
		
		OldYawRate=GlobYawRate;
    6500:	37 01       	movw	r6, r14
    6502:	68 01       	movw	r12, r16
	GyroYawOffset=(float) Gz*RATE_CST;

	
	while (1)
	{		
		DriverMPU6050GyroGet(NULL,NULL,&Gz);
    6504:	ae 01       	movw	r20, r28
    6506:	4d 5f       	subi	r20, 0xFD	; 253
    6508:	5f 4f       	sbci	r21, 0xFF	; 255
    650a:	60 e0       	ldi	r22, 0x00	; 0
    650c:	70 e0       	ldi	r23, 0x00	; 0
    650e:	80 e0       	ldi	r24, 0x00	; 0
    6510:	90 e0       	ldi	r25, 0x00	; 0
    6512:	0e 94 3a 0a 	call	0x1474	; 0x1474 <DriverMPU6050GyroGet>
		xSemaphoreTake(GyroSema,portMAX_DELAY);
    6516:	6f ef       	ldi	r22, 0xFF	; 255
    6518:	7f ef       	ldi	r23, 0xFF	; 255
    651a:	80 91 95 2d 	lds	r24, 0x2D95	; 0x802d95 <GyroSema>
    651e:	90 91 96 2d 	lds	r25, 0x2D96	; 0x802d96 <GyroSema+0x1>
    6522:	0e 94 12 23 	call	0x4624	; 0x4624 <xQueueSemaphoreTake>
		GlobYawRate=(float) Gz*RATE_CST;
		GlobYawRate-=GyroYawOffset;
    6526:	6b 81       	ldd	r22, Y+3	; 0x03
    6528:	7c 81       	ldd	r23, Y+4	; 0x04
    652a:	07 2e       	mov	r0, r23
    652c:	00 0c       	add	r0, r0
    652e:	88 0b       	sbc	r24, r24
    6530:	99 0b       	sbc	r25, r25
    6532:	0e 94 49 44 	call	0x8892	; 0x8892 <__floatsisf>
    6536:	2d e2       	ldi	r18, 0x2D	; 45
    6538:	33 e2       	ldi	r19, 0x23	; 35
    653a:	4a ef       	ldi	r20, 0xFA	; 250
    653c:	5b e3       	ldi	r21, 0x3B	; 59
    653e:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    6542:	a5 01       	movw	r20, r10
    6544:	94 01       	movw	r18, r8
    6546:	0e 94 2d 43 	call	0x865a	; 0x865a <__subsf3>
    654a:	7b 01       	movw	r14, r22
    654c:	8c 01       	movw	r16, r24
    654e:	cb 01       	movw	r24, r22
    6550:	d8 01       	movw	r26, r16
    6552:	80 93 91 2d 	sts	0x2D91, r24	; 0x802d91 <GlobYawRate>
    6556:	90 93 92 2d 	sts	0x2D92, r25	; 0x802d92 <GlobYawRate+0x1>
    655a:	a0 93 93 2d 	sts	0x2D93, r26	; 0x802d93 <GlobYawRate+0x2>
    655e:	b0 93 94 2d 	sts	0x2D94, r27	; 0x802d94 <GlobYawRate+0x3>
		
		//Integration to yaw angle
		GlobYaw+=((GlobYawRate/100)+(OldYawRate/100))/2;
    6562:	20 e0       	ldi	r18, 0x00	; 0
    6564:	30 e0       	ldi	r19, 0x00	; 0
    6566:	48 ec       	ldi	r20, 0xC8	; 200
    6568:	52 e4       	ldi	r21, 0x42	; 66
    656a:	b7 01       	movw	r22, r14
    656c:	c8 01       	movw	r24, r16
    656e:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6572:	1b 01       	movw	r2, r22
    6574:	2c 01       	movw	r4, r24
    6576:	20 e0       	ldi	r18, 0x00	; 0
    6578:	30 e0       	ldi	r19, 0x00	; 0
    657a:	48 ec       	ldi	r20, 0xC8	; 200
    657c:	52 e4       	ldi	r21, 0x42	; 66
    657e:	b3 01       	movw	r22, r6
    6580:	c6 01       	movw	r24, r12
    6582:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6586:	9b 01       	movw	r18, r22
    6588:	ac 01       	movw	r20, r24
    658a:	c2 01       	movw	r24, r4
    658c:	b1 01       	movw	r22, r2
    658e:	0e 94 2e 43 	call	0x865c	; 0x865c <__addsf3>
    6592:	20 e0       	ldi	r18, 0x00	; 0
    6594:	30 e0       	ldi	r19, 0x00	; 0
    6596:	40 e0       	ldi	r20, 0x00	; 0
    6598:	5f e3       	ldi	r21, 0x3F	; 63
    659a:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    659e:	9b 01       	movw	r18, r22
    65a0:	ac 01       	movw	r20, r24
    65a2:	60 91 8d 2d 	lds	r22, 0x2D8D	; 0x802d8d <GlobYaw>
    65a6:	70 91 8e 2d 	lds	r23, 0x2D8E	; 0x802d8e <GlobYaw+0x1>
    65aa:	80 91 8f 2d 	lds	r24, 0x2D8F	; 0x802d8f <GlobYaw+0x2>
    65ae:	90 91 90 2d 	lds	r25, 0x2D90	; 0x802d90 <GlobYaw+0x3>
    65b2:	0e 94 2e 43 	call	0x865c	; 0x865c <__addsf3>
    65b6:	60 93 8d 2d 	sts	0x2D8D, r22	; 0x802d8d <GlobYaw>
    65ba:	70 93 8e 2d 	sts	0x2D8E, r23	; 0x802d8e <GlobYaw+0x1>
    65be:	80 93 8f 2d 	sts	0x2D8F, r24	; 0x802d8f <GlobYaw+0x2>
    65c2:	90 93 90 2d 	sts	0x2D90, r25	; 0x802d90 <GlobYaw+0x3>
		
		OldYawRate=GlobYawRate;
		
		xSemaphoreGive(GyroSema);
    65c6:	20 e0       	ldi	r18, 0x00	; 0
    65c8:	40 e0       	ldi	r20, 0x00	; 0
    65ca:	50 e0       	ldi	r21, 0x00	; 0
    65cc:	60 e0       	ldi	r22, 0x00	; 0
    65ce:	70 e0       	ldi	r23, 0x00	; 0
    65d0:	80 91 95 2d 	lds	r24, 0x2D95	; 0x802d95 <GyroSema>
    65d4:	90 91 96 2d 	lds	r25, 0x2D96	; 0x802d96 <GyroSema+0x1>
    65d8:	0e 94 be 20 	call	0x417c	; 0x417c <xQueueGenericSend>
		if (GlobYawRate>0) 
    65dc:	20 e0       	ldi	r18, 0x00	; 0
    65de:	30 e0       	ldi	r19, 0x00	; 0
    65e0:	a9 01       	movw	r20, r18
    65e2:	60 91 91 2d 	lds	r22, 0x2D91	; 0x802d91 <GlobYawRate>
    65e6:	70 91 92 2d 	lds	r23, 0x2D92	; 0x802d92 <GlobYawRate+0x1>
    65ea:	80 91 93 2d 	lds	r24, 0x2D93	; 0x802d93 <GlobYawRate+0x2>
    65ee:	90 91 94 2d 	lds	r25, 0x2D94	; 0x802d94 <GlobYawRate+0x3>
    65f2:	0e 94 f9 44 	call	0x89f2	; 0x89f2 <__gesf2>
			GyroYawOffset+=0.001;
    65f6:	2f e6       	ldi	r18, 0x6F	; 111
    65f8:	32 e1       	ldi	r19, 0x12	; 18
    65fa:	43 e8       	ldi	r20, 0x83	; 131
    65fc:	5a e3       	ldi	r21, 0x3A	; 58
		GlobYaw+=((GlobYawRate/100)+(OldYawRate/100))/2;
		
		OldYawRate=GlobYawRate;
		
		xSemaphoreGive(GyroSema);
		if (GlobYawRate>0) 
    65fe:	18 16       	cp	r1, r24
    6600:	0c f4       	brge	.+2      	; 0x6604 <WorkerGyro+0x178>
    6602:	72 cf       	rjmp	.-284    	; 0x64e8 <WorkerGyro+0x5c>
			GyroYawOffset+=0.001;
		else
			GyroYawOffset-=0.001;
    6604:	c5 01       	movw	r24, r10
    6606:	b4 01       	movw	r22, r8
    6608:	0e 94 2d 43 	call	0x865a	; 0x865a <__subsf3>
    660c:	4b 01       	movw	r8, r22
    660e:	5c 01       	movw	r10, r24
    6610:	71 cf       	rjmp	.-286    	; 0x64f4 <WorkerGyro+0x68>

00006612 <InitGyroTask>:
//Private function prototypes
static void WorkerGyro(void *pvParameters);

//Function definitions
void InitGyroTask()
{
    6612:	ef 92       	push	r14
    6614:	ff 92       	push	r15
    6616:	0f 93       	push	r16
	xTaskCreate( WorkerGyro, "gyro", 256, NULL, tskIDLE_PRIORITY+3, NULL );	
    6618:	e1 2c       	mov	r14, r1
    661a:	f1 2c       	mov	r15, r1
    661c:	03 e0       	ldi	r16, 0x03	; 3
    661e:	20 e0       	ldi	r18, 0x00	; 0
    6620:	30 e0       	ldi	r19, 0x00	; 0
    6622:	40 e0       	ldi	r20, 0x00	; 0
    6624:	51 e0       	ldi	r21, 0x01	; 1
    6626:	68 e5       	ldi	r22, 0x58	; 88
    6628:	76 e2       	ldi	r23, 0x26	; 38
    662a:	86 e4       	ldi	r24, 0x46	; 70
    662c:	92 e3       	ldi	r25, 0x32	; 50
    662e:	0e 94 c8 26 	call	0x4d90	; 0x4d90 <xTaskCreate>
	GyroSema=xSemaphoreCreateMutex();
    6632:	81 e0       	ldi	r24, 0x01	; 1
    6634:	0e 94 8d 21 	call	0x431a	; 0x431a <xQueueCreateMutex>
    6638:	80 93 95 2d 	sts	0x2D95, r24	; 0x802d95 <GyroSema>
    663c:	90 93 96 2d 	sts	0x2D96, r25	; 0x802d96 <GyroSema+0x1>
}
    6640:	0f 91       	pop	r16
    6642:	ff 90       	pop	r15
    6644:	ef 90       	pop	r14
    6646:	08 95       	ret

00006648 <GyroGet>:
	}

}

void GyroGet(float *YawRate, float *Yaw)
{
    6648:	0f 93       	push	r16
    664a:	1f 93       	push	r17
    664c:	cf 93       	push	r28
    664e:	df 93       	push	r29
    6650:	8c 01       	movw	r16, r24
    6652:	eb 01       	movw	r28, r22
		xSemaphoreTake(GyroSema,portMAX_DELAY);
    6654:	6f ef       	ldi	r22, 0xFF	; 255
    6656:	7f ef       	ldi	r23, 0xFF	; 255
    6658:	80 91 95 2d 	lds	r24, 0x2D95	; 0x802d95 <GyroSema>
    665c:	90 91 96 2d 	lds	r25, 0x2D96	; 0x802d96 <GyroSema+0x1>
    6660:	0e 94 12 23 	call	0x4624	; 0x4624 <xQueueSemaphoreTake>
		if (YawRate!=NULL) *YawRate=GlobYawRate;
    6664:	01 15       	cp	r16, r1
    6666:	11 05       	cpc	r17, r1
    6668:	69 f0       	breq	.+26     	; 0x6684 <GyroGet+0x3c>
    666a:	80 91 91 2d 	lds	r24, 0x2D91	; 0x802d91 <GlobYawRate>
    666e:	90 91 92 2d 	lds	r25, 0x2D92	; 0x802d92 <GlobYawRate+0x1>
    6672:	a0 91 93 2d 	lds	r26, 0x2D93	; 0x802d93 <GlobYawRate+0x2>
    6676:	b0 91 94 2d 	lds	r27, 0x2D94	; 0x802d94 <GlobYawRate+0x3>
    667a:	f8 01       	movw	r30, r16
    667c:	80 83       	st	Z, r24
    667e:	91 83       	std	Z+1, r25	; 0x01
    6680:	a2 83       	std	Z+2, r26	; 0x02
    6682:	b3 83       	std	Z+3, r27	; 0x03
		if (Yaw!=NULL) *Yaw=GlobYaw;
    6684:	20 97       	sbiw	r28, 0x00	; 0
    6686:	61 f0       	breq	.+24     	; 0x66a0 <GyroGet+0x58>
    6688:	80 91 8d 2d 	lds	r24, 0x2D8D	; 0x802d8d <GlobYaw>
    668c:	90 91 8e 2d 	lds	r25, 0x2D8E	; 0x802d8e <GlobYaw+0x1>
    6690:	a0 91 8f 2d 	lds	r26, 0x2D8F	; 0x802d8f <GlobYaw+0x2>
    6694:	b0 91 90 2d 	lds	r27, 0x2D90	; 0x802d90 <GlobYaw+0x3>
    6698:	88 83       	st	Y, r24
    669a:	99 83       	std	Y+1, r25	; 0x01
    669c:	aa 83       	std	Y+2, r26	; 0x02
    669e:	bb 83       	std	Y+3, r27	; 0x03
		xSemaphoreGive(GyroSema);
    66a0:	20 e0       	ldi	r18, 0x00	; 0
    66a2:	40 e0       	ldi	r20, 0x00	; 0
    66a4:	50 e0       	ldi	r21, 0x00	; 0
    66a6:	60 e0       	ldi	r22, 0x00	; 0
    66a8:	70 e0       	ldi	r23, 0x00	; 0
    66aa:	80 91 95 2d 	lds	r24, 0x2D95	; 0x802d95 <GyroSema>
    66ae:	90 91 96 2d 	lds	r25, 0x2D96	; 0x802d96 <GyroSema+0x1>
	
}
    66b2:	df 91       	pop	r29
    66b4:	cf 91       	pop	r28
    66b6:	1f 91       	pop	r17
    66b8:	0f 91       	pop	r16
void GyroGet(float *YawRate, float *Yaw)
{
		xSemaphoreTake(GyroSema,portMAX_DELAY);
		if (YawRate!=NULL) *YawRate=GlobYawRate;
		if (Yaw!=NULL) *Yaw=GlobYaw;
		xSemaphoreGive(GyroSema);
    66ba:	0c 94 be 20 	jmp	0x417c	; 0x417c <xQueueGenericSend>

000066be <WorkerLineFollowerDirect>:
{
	vTaskSuspend(LineFollowerDirectTaskHandle);
}

static void WorkerLineFollowerDirect(void *pvParameters)
{
    66be:	cf 93       	push	r28
    66c0:	df 93       	push	r29
    66c2:	cd b7       	in	r28, 0x3d	; 61
    66c4:	de b7       	in	r29, 0x3e	; 62
    66c6:	2a 97       	sbiw	r28, 0x0a	; 10
    66c8:	cd bf       	out	0x3d, r28	; 61
    66ca:	de bf       	out	0x3e, r29	; 62
	{
		xLastWakeTime=xTaskGetTickCount();

		ADCData=GetADCData();
		Diff=(float) (ADCData.PhotoL-ADCData.PhotoR+SensorOffset);
		printf ("Diff:%f\r\n",Diff);
    66cc:	0d e5       	ldi	r16, 0x5D	; 93
    66ce:	16 e2       	ldi	r17, 0x26	; 38
    66d0:	1b c0       	rjmp	.+54     	; 0x6708 <WorkerLineFollowerDirect+0x4a>
    66d2:	c3 01       	movw	r24, r6
    66d4:	b2 01       	movw	r22, r4
    66d6:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
    66da:	7b 01       	movw	r14, r22
		OutL=Speed+(Diff*LineFollowKp);
		OutR=Speed-(Diff*LineFollowKp);
		
		if (OutL<0) OutL=0;
		if (OutR<0) OutR=0;
    66dc:	20 e0       	ldi	r18, 0x00	; 0
    66de:	30 e0       	ldi	r19, 0x00	; 0
    66e0:	a9 01       	movw	r20, r18
    66e2:	c5 01       	movw	r24, r10
    66e4:	b4 01       	movw	r22, r8
    66e6:	0e 94 9a 43 	call	0x8734	; 0x8734 <__cmpsf2>
    66ea:	87 fd       	sbrc	r24, 7
    66ec:	5d c0       	rjmp	.+186    	; 0x67a8 <WorkerLineFollowerDirect+0xea>
    66ee:	c5 01       	movw	r24, r10
    66f0:	b4 01       	movw	r22, r8
    66f2:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
		DriverMotorSet((int16_t) OutL, (int16_t) OutR);
    66f6:	c7 01       	movw	r24, r14
    66f8:	0e 94 d6 06 	call	0xdac	; 0xdac <DriverMotorSet>
			

		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    66fc:	6a e0       	ldi	r22, 0x0A	; 10
    66fe:	70 e0       	ldi	r23, 0x00	; 0
    6700:	ce 01       	movw	r24, r28
    6702:	09 96       	adiw	r24, 0x09	; 9
    6704:	0e 94 d9 2a 	call	0x55b2	; 0x55b2 <vTaskDelayUntil>
	ADCStruct ADCData;

	
	while(1)
	{
		xLastWakeTime=xTaskGetTickCount();
    6708:	0e 94 54 29 	call	0x52a8	; 0x52a8 <xTaskGetTickCount>
    670c:	89 87       	std	Y+9, r24	; 0x09
    670e:	9a 87       	std	Y+10, r25	; 0x0a

		ADCData=GetADCData();
    6710:	0e 94 1d 32 	call	0x643a	; 0x643a <GetADCData>
    6714:	29 83       	std	Y+1, r18	; 0x01
    6716:	3a 83       	std	Y+2, r19	; 0x02
    6718:	6d 83       	std	Y+5, r22	; 0x05
    671a:	7e 83       	std	Y+6, r23	; 0x06
		Diff=(float) (ADCData.PhotoL-ADCData.PhotoR+SensorOffset);
    671c:	69 81       	ldd	r22, Y+1	; 0x01
    671e:	7a 81       	ldd	r23, Y+2	; 0x02
    6720:	8d 81       	ldd	r24, Y+5	; 0x05
    6722:	9e 81       	ldd	r25, Y+6	; 0x06
    6724:	68 1b       	sub	r22, r24
    6726:	79 0b       	sbc	r23, r25
    6728:	07 2e       	mov	r0, r23
    672a:	00 0c       	add	r0, r0
    672c:	88 0b       	sbc	r24, r24
    672e:	99 0b       	sbc	r25, r25
    6730:	0e 94 49 44 	call	0x8892	; 0x8892 <__floatsisf>
    6734:	6b 01       	movw	r12, r22
    6736:	7c 01       	movw	r14, r24
		printf ("Diff:%f\r\n",Diff);
    6738:	ff 92       	push	r15
    673a:	8f 93       	push	r24
    673c:	df 92       	push	r13
    673e:	6f 93       	push	r22
    6740:	1f 93       	push	r17
    6742:	0f 93       	push	r16
    6744:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
		OutL=Speed+(Diff*LineFollowKp);
    6748:	2d ec       	ldi	r18, 0xCD	; 205
    674a:	3c ec       	ldi	r19, 0xCC	; 204
    674c:	4c e4       	ldi	r20, 0x4C	; 76
    674e:	5e e3       	ldi	r21, 0x3E	; 62
    6750:	6c 2d       	mov	r22, r12
    6752:	7d 2d       	mov	r23, r13
    6754:	8e 2d       	mov	r24, r14
    6756:	9f 2d       	mov	r25, r15
    6758:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    675c:	6b 01       	movw	r12, r22
    675e:	7c 01       	movw	r14, r24
    6760:	20 e0       	ldi	r18, 0x00	; 0
    6762:	30 e0       	ldi	r19, 0x00	; 0
    6764:	48 e4       	ldi	r20, 0x48	; 72
    6766:	55 e4       	ldi	r21, 0x45	; 69
    6768:	0e 94 2e 43 	call	0x865c	; 0x865c <__addsf3>
    676c:	2b 01       	movw	r4, r22
    676e:	3c 01       	movw	r6, r24
		OutR=Speed-(Diff*LineFollowKp);
    6770:	a7 01       	movw	r20, r14
    6772:	96 01       	movw	r18, r12
    6774:	60 e0       	ldi	r22, 0x00	; 0
    6776:	70 e0       	ldi	r23, 0x00	; 0
    6778:	88 e4       	ldi	r24, 0x48	; 72
    677a:	95 e4       	ldi	r25, 0x45	; 69
    677c:	0e 94 2d 43 	call	0x865a	; 0x865a <__subsf3>
    6780:	4b 01       	movw	r8, r22
    6782:	5c 01       	movw	r10, r24
		
		if (OutL<0) OutL=0;
    6784:	0f 90       	pop	r0
    6786:	0f 90       	pop	r0
    6788:	0f 90       	pop	r0
    678a:	0f 90       	pop	r0
    678c:	0f 90       	pop	r0
    678e:	0f 90       	pop	r0
    6790:	20 e0       	ldi	r18, 0x00	; 0
    6792:	30 e0       	ldi	r19, 0x00	; 0
    6794:	a9 01       	movw	r20, r18
    6796:	c3 01       	movw	r24, r6
    6798:	b2 01       	movw	r22, r4
    679a:	0e 94 9a 43 	call	0x8734	; 0x8734 <__cmpsf2>
    679e:	87 ff       	sbrs	r24, 7
    67a0:	98 cf       	rjmp	.-208    	; 0x66d2 <WorkerLineFollowerDirect+0x14>
    67a2:	e1 2c       	mov	r14, r1
    67a4:	f1 2c       	mov	r15, r1
    67a6:	9a cf       	rjmp	.-204    	; 0x66dc <WorkerLineFollowerDirect+0x1e>
    67a8:	60 e0       	ldi	r22, 0x00	; 0
    67aa:	70 e0       	ldi	r23, 0x00	; 0
    67ac:	a4 cf       	rjmp	.-184    	; 0x66f6 <WorkerLineFollowerDirect+0x38>

000067ae <InitLineFollowerDirectTask>:
//Private function prototypes
static void WorkerLineFollowerDirect(void *pvParameters);

//Function definitions
void InitLineFollowerDirectTask()
{
    67ae:	ef 92       	push	r14
    67b0:	ff 92       	push	r15
    67b2:	0f 93       	push	r16
	xTaskCreate( WorkerLineFollowerDirect, "LFdirect", 256, NULL, tskIDLE_PRIORITY+3, &LineFollowerDirectTaskHandle );	
    67b4:	87 e9       	ldi	r24, 0x97	; 151
    67b6:	e8 2e       	mov	r14, r24
    67b8:	8d e2       	ldi	r24, 0x2D	; 45
    67ba:	f8 2e       	mov	r15, r24
    67bc:	03 e0       	ldi	r16, 0x03	; 3
    67be:	20 e0       	ldi	r18, 0x00	; 0
    67c0:	30 e0       	ldi	r19, 0x00	; 0
    67c2:	40 e0       	ldi	r20, 0x00	; 0
    67c4:	51 e0       	ldi	r21, 0x01	; 1
    67c6:	67 e6       	ldi	r22, 0x67	; 103
    67c8:	76 e2       	ldi	r23, 0x26	; 38
    67ca:	8f e5       	ldi	r24, 0x5F	; 95
    67cc:	93 e3       	ldi	r25, 0x33	; 51
    67ce:	0e 94 c8 26 	call	0x4d90	; 0x4d90 <xTaskCreate>
	vTaskResume(LineFollowerDirectTaskHandle);
}

void DisableLineFollowerDirectTask()
{
	vTaskSuspend(LineFollowerDirectTaskHandle);
    67d2:	80 91 97 2d 	lds	r24, 0x2D97	; 0x802d97 <LineFollowerDirectTaskHandle>
    67d6:	90 91 98 2d 	lds	r25, 0x2D98	; 0x802d98 <LineFollowerDirectTaskHandle+0x1>
//Function definitions
void InitLineFollowerDirectTask()
{
	xTaskCreate( WorkerLineFollowerDirect, "LFdirect", 256, NULL, tskIDLE_PRIORITY+3, &LineFollowerDirectTaskHandle );	
	DisableLineFollowerDirectTask();
}
    67da:	0f 91       	pop	r16
    67dc:	ff 90       	pop	r15
    67de:	ef 90       	pop	r14
	vTaskResume(LineFollowerDirectTaskHandle);
}

void DisableLineFollowerDirectTask()
{
	vTaskSuspend(LineFollowerDirectTaskHandle);
    67e0:	0c 94 4a 28 	jmp	0x5094	; 0x5094 <vTaskSuspend>

000067e4 <EnableLineFollowerDirectTask>:
	DisableLineFollowerDirectTask();
}

void EnableLineFollowerDirectTask()
{
	vTaskResume(LineFollowerDirectTaskHandle);
    67e4:	80 91 97 2d 	lds	r24, 0x2D97	; 0x802d97 <LineFollowerDirectTaskHandle>
    67e8:	90 91 98 2d 	lds	r25, 0x2D98	; 0x802d98 <LineFollowerDirectTaskHandle+0x1>
    67ec:	0c 94 c7 28 	jmp	0x518e	; 0x518e <vTaskResume>

000067f0 <DisableLineFollowerDirectTask>:
}

void DisableLineFollowerDirectTask()
{
	vTaskSuspend(LineFollowerDirectTaskHandle);
    67f0:	80 91 97 2d 	lds	r24, 0x2D97	; 0x802d97 <LineFollowerDirectTaskHandle>
    67f4:	90 91 98 2d 	lds	r25, 0x2D98	; 0x802d98 <LineFollowerDirectTaskHandle+0x1>
    67f8:	0c 94 4a 28 	jmp	0x5094	; 0x5094 <vTaskSuspend>

000067fc <WorkerLineFollowerSpeed>:
	StopSema=xSemaphoreCreateBinary();
	xTaskCreate( WorkerLineFollowerSpeed, "LFSpeed", 512, NULL, tskIDLE_PRIORITY+2, NULL );
}

void WorkerLineFollowerSpeed(void *pvParameters)
{
    67fc:	cf 93       	push	r28
    67fe:	df 93       	push	r29
    6800:	cd b7       	in	r28, 0x3d	; 61
    6802:	de b7       	in	r29, 0x3e	; 62
    6804:	2a 97       	sbiw	r28, 0x0a	; 10
    6806:	cd bf       	out	0x3d, r28	; 61
    6808:	de bf       	out	0x3e, r29	; 62
	float OutL,OutR;
	ADCStruct ADCData;
	
	while(1)
	{
		xSemaphoreTake(StartSema,portMAX_DELAY);
    680a:	6f ef       	ldi	r22, 0xFF	; 255
    680c:	7f ef       	ldi	r23, 0xFF	; 255
    680e:	80 91 9b 2d 	lds	r24, 0x2D9B	; 0x802d9b <StartSema>
    6812:	90 91 9c 2d 	lds	r25, 0x2D9C	; 0x802d9c <StartSema+0x1>
    6816:	0e 94 12 23 	call	0x4624	; 0x4624 <xQueueSemaphoreTake>
		Speed=ReqSpeed;
    681a:	80 91 a1 2d 	lds	r24, 0x2DA1	; 0x802da1 <ReqSpeed>
    681e:	90 91 a2 2d 	lds	r25, 0x2DA2	; 0x802da2 <ReqSpeed+0x1>
    6822:	a0 91 a3 2d 	lds	r26, 0x2DA3	; 0x802da3 <ReqSpeed+0x2>
    6826:	b0 91 a4 2d 	lds	r27, 0x2DA4	; 0x802da4 <ReqSpeed+0x3>
    682a:	80 93 9d 2d 	sts	0x2D9D, r24	; 0x802d9d <Speed>
    682e:	90 93 9e 2d 	sts	0x2D9E, r25	; 0x802d9e <Speed+0x1>
    6832:	a0 93 9f 2d 	sts	0x2D9F, r26	; 0x802d9f <Speed+0x2>
    6836:	b0 93 a0 2d 	sts	0x2DA0, r27	; 0x802da0 <Speed+0x3>
		xLastWakeTime=xTaskGetTickCount();
    683a:	0e 94 54 29 	call	0x52a8	; 0x52a8 <xTaskGetTickCount>
    683e:	89 87       	std	Y+9, r24	; 0x09
    6840:	9a 87       	std	Y+10, r25	; 0x0a
    6842:	18 c0       	rjmp	.+48     	; 0x6874 <WorkerLineFollowerSpeed+0x78>
    6844:	c5 01       	movw	r24, r10
    6846:	b4 01       	movw	r22, r8
    6848:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
			//printf ("Diff:%f\r\n",Diff);
			OutL=Speed+(Diff*(float) (LINEFOLLOW_SPEED_KP));
			OutR=Speed-(Diff*(float) (LINEFOLLOW_SPEED_KP));
			if (OutL<0) OutL=0;
			if (OutR<0) OutR=0;
			MotorSpeedSet((int16_t) OutL, (int16_t) OutR);	
    684c:	c7 01       	movw	r24, r14
    684e:	0e 94 be 39 	call	0x737c	; 0x737c <MotorSpeedSet>
			
			if (xSemaphoreTake(StopSema,0)==pdPASS)
    6852:	60 e0       	ldi	r22, 0x00	; 0
    6854:	70 e0       	ldi	r23, 0x00	; 0
    6856:	80 91 99 2d 	lds	r24, 0x2D99	; 0x802d99 <StopSema>
    685a:	90 91 9a 2d 	lds	r25, 0x2D9A	; 0x802d9a <StopSema+0x1>
    685e:	0e 94 12 23 	call	0x4624	; 0x4624 <xQueueSemaphoreTake>
    6862:	81 30       	cpi	r24, 0x01	; 1
    6864:	09 f4       	brne	.+2      	; 0x6868 <WorkerLineFollowerSpeed+0x6c>
    6866:	55 c0       	rjmp	.+170    	; 0x6912 <WorkerLineFollowerSpeed+0x116>
			{
				MotorSpeedSet(0,0);	
				break;
			}
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
    6868:	6a e0       	ldi	r22, 0x0A	; 10
    686a:	70 e0       	ldi	r23, 0x00	; 0
    686c:	ce 01       	movw	r24, r28
    686e:	09 96       	adiw	r24, 0x09	; 9
    6870:	0e 94 d9 2a 	call	0x55b2	; 0x55b2 <vTaskDelayUntil>
		Speed=ReqSpeed;
		xLastWakeTime=xTaskGetTickCount();
		while (1)
		{
			
			ADCData=GetADCData();
    6874:	0e 94 1d 32 	call	0x643a	; 0x643a <GetADCData>
    6878:	29 83       	std	Y+1, r18	; 0x01
    687a:	3a 83       	std	Y+2, r19	; 0x02
    687c:	6d 83       	std	Y+5, r22	; 0x05
    687e:	7e 83       	std	Y+6, r23	; 0x06
			Diff=(float) (ADCData.PhotoL-ADCData.PhotoR+SensorOffset);
			//printf ("Diff:%f\r\n",Diff);
			OutL=Speed+(Diff*(float) (LINEFOLLOW_SPEED_KP));
    6880:	69 81       	ldd	r22, Y+1	; 0x01
    6882:	7a 81       	ldd	r23, Y+2	; 0x02
    6884:	8d 81       	ldd	r24, Y+5	; 0x05
    6886:	9e 81       	ldd	r25, Y+6	; 0x06
    6888:	68 1b       	sub	r22, r24
    688a:	79 0b       	sbc	r23, r25
    688c:	64 56       	subi	r22, 0x64	; 100
    688e:	71 09       	sbc	r23, r1
    6890:	07 2e       	mov	r0, r23
    6892:	00 0c       	add	r0, r0
    6894:	88 0b       	sbc	r24, r24
    6896:	99 0b       	sbc	r25, r25
    6898:	0e 94 49 44 	call	0x8892	; 0x8892 <__floatsisf>
    689c:	2d ec       	ldi	r18, 0xCD	; 205
    689e:	3c ec       	ldi	r19, 0xCC	; 204
    68a0:	4c ec       	ldi	r20, 0xCC	; 204
    68a2:	5d e3       	ldi	r21, 0x3D	; 61
    68a4:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    68a8:	4b 01       	movw	r8, r22
    68aa:	5c 01       	movw	r10, r24
    68ac:	c0 90 9d 2d 	lds	r12, 0x2D9D	; 0x802d9d <Speed>
    68b0:	d0 90 9e 2d 	lds	r13, 0x2D9E	; 0x802d9e <Speed+0x1>
    68b4:	e0 90 9f 2d 	lds	r14, 0x2D9F	; 0x802d9f <Speed+0x2>
    68b8:	f0 90 a0 2d 	lds	r15, 0x2DA0	; 0x802da0 <Speed+0x3>
    68bc:	a7 01       	movw	r20, r14
    68be:	96 01       	movw	r18, r12
    68c0:	0e 94 2e 43 	call	0x865c	; 0x865c <__addsf3>
    68c4:	2b 01       	movw	r4, r22
    68c6:	3c 01       	movw	r6, r24
			OutR=Speed-(Diff*(float) (LINEFOLLOW_SPEED_KP));
    68c8:	a5 01       	movw	r20, r10
    68ca:	94 01       	movw	r18, r8
    68cc:	c7 01       	movw	r24, r14
    68ce:	b6 01       	movw	r22, r12
    68d0:	0e 94 2d 43 	call	0x865a	; 0x865a <__subsf3>
    68d4:	4b 01       	movw	r8, r22
    68d6:	5c 01       	movw	r10, r24
			if (OutL<0) OutL=0;
    68d8:	20 e0       	ldi	r18, 0x00	; 0
    68da:	30 e0       	ldi	r19, 0x00	; 0
    68dc:	a9 01       	movw	r20, r18
    68de:	c3 01       	movw	r24, r6
    68e0:	b2 01       	movw	r22, r4
    68e2:	0e 94 9a 43 	call	0x8734	; 0x8734 <__cmpsf2>
    68e6:	87 ff       	sbrs	r24, 7
    68e8:	0e c0       	rjmp	.+28     	; 0x6906 <WorkerLineFollowerSpeed+0x10a>
    68ea:	e1 2c       	mov	r14, r1
    68ec:	f1 2c       	mov	r15, r1
			if (OutR<0) OutR=0;
    68ee:	20 e0       	ldi	r18, 0x00	; 0
    68f0:	30 e0       	ldi	r19, 0x00	; 0
    68f2:	a9 01       	movw	r20, r18
    68f4:	c5 01       	movw	r24, r10
    68f6:	b4 01       	movw	r22, r8
    68f8:	0e 94 9a 43 	call	0x8734	; 0x8734 <__cmpsf2>
    68fc:	87 ff       	sbrs	r24, 7
    68fe:	a2 cf       	rjmp	.-188    	; 0x6844 <WorkerLineFollowerSpeed+0x48>
    6900:	60 e0       	ldi	r22, 0x00	; 0
    6902:	70 e0       	ldi	r23, 0x00	; 0
    6904:	a3 cf       	rjmp	.-186    	; 0x684c <WorkerLineFollowerSpeed+0x50>
    6906:	c3 01       	movw	r24, r6
    6908:	b2 01       	movw	r22, r4
    690a:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
    690e:	7b 01       	movw	r14, r22
    6910:	ee cf       	rjmp	.-36     	; 0x68ee <WorkerLineFollowerSpeed+0xf2>
			MotorSpeedSet((int16_t) OutL, (int16_t) OutR);	
			
			if (xSemaphoreTake(StopSema,0)==pdPASS)
			{
				MotorSpeedSet(0,0);	
    6912:	60 e0       	ldi	r22, 0x00	; 0
    6914:	70 e0       	ldi	r23, 0x00	; 0
    6916:	80 e0       	ldi	r24, 0x00	; 0
    6918:	90 e0       	ldi	r25, 0x00	; 0
    691a:	0e 94 be 39 	call	0x737c	; 0x737c <MotorSpeedSet>
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
		}

		
		
	}
    691e:	75 cf       	rjmp	.-278    	; 0x680a <WorkerLineFollowerSpeed+0xe>

00006920 <InitLineFollowerSpeedTask>:
void WorkerLineFollowerSpeed(void *pvParameters);


//Function definitions
void InitLineFollowerSpeedTask()
{
    6920:	ef 92       	push	r14
    6922:	ff 92       	push	r15
    6924:	0f 93       	push	r16
	StartSema=xSemaphoreCreateBinary();
    6926:	43 e0       	ldi	r20, 0x03	; 3
    6928:	60 e0       	ldi	r22, 0x00	; 0
    692a:	81 e0       	ldi	r24, 0x01	; 1
    692c:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueGenericCreate>
    6930:	80 93 9b 2d 	sts	0x2D9B, r24	; 0x802d9b <StartSema>
    6934:	90 93 9c 2d 	sts	0x2D9C, r25	; 0x802d9c <StartSema+0x1>
	StopSema=xSemaphoreCreateBinary();
    6938:	43 e0       	ldi	r20, 0x03	; 3
    693a:	60 e0       	ldi	r22, 0x00	; 0
    693c:	81 e0       	ldi	r24, 0x01	; 1
    693e:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueGenericCreate>
    6942:	80 93 99 2d 	sts	0x2D99, r24	; 0x802d99 <StopSema>
    6946:	90 93 9a 2d 	sts	0x2D9A, r25	; 0x802d9a <StopSema+0x1>
	xTaskCreate( WorkerLineFollowerSpeed, "LFSpeed", 512, NULL, tskIDLE_PRIORITY+2, NULL );
    694a:	e1 2c       	mov	r14, r1
    694c:	f1 2c       	mov	r15, r1
    694e:	02 e0       	ldi	r16, 0x02	; 2
    6950:	20 e0       	ldi	r18, 0x00	; 0
    6952:	30 e0       	ldi	r19, 0x00	; 0
    6954:	40 e0       	ldi	r20, 0x00	; 0
    6956:	52 e0       	ldi	r21, 0x02	; 2
    6958:	60 e7       	ldi	r22, 0x70	; 112
    695a:	76 e2       	ldi	r23, 0x26	; 38
    695c:	8e ef       	ldi	r24, 0xFE	; 254
    695e:	93 e3       	ldi	r25, 0x33	; 51
    6960:	0e 94 c8 26 	call	0x4d90	; 0x4d90 <xTaskCreate>
}
    6964:	0f 91       	pop	r16
    6966:	ff 90       	pop	r15
    6968:	ef 90       	pop	r14
    696a:	08 95       	ret

0000696c <StartLineFollower>:
	}
}

void StartLineFollower(float Speed)
{
	ReqSpeed=Speed;
    696c:	60 93 a1 2d 	sts	0x2DA1, r22	; 0x802da1 <ReqSpeed>
    6970:	70 93 a2 2d 	sts	0x2DA2, r23	; 0x802da2 <ReqSpeed+0x1>
    6974:	80 93 a3 2d 	sts	0x2DA3, r24	; 0x802da3 <ReqSpeed+0x2>
    6978:	90 93 a4 2d 	sts	0x2DA4, r25	; 0x802da4 <ReqSpeed+0x3>
	xSemaphoreGive(StartSema);
    697c:	20 e0       	ldi	r18, 0x00	; 0
    697e:	40 e0       	ldi	r20, 0x00	; 0
    6980:	50 e0       	ldi	r21, 0x00	; 0
    6982:	60 e0       	ldi	r22, 0x00	; 0
    6984:	70 e0       	ldi	r23, 0x00	; 0
    6986:	80 91 9b 2d 	lds	r24, 0x2D9B	; 0x802d9b <StartSema>
    698a:	90 91 9c 2d 	lds	r25, 0x2D9C	; 0x802d9c <StartSema+0x1>
    698e:	0c 94 be 20 	jmp	0x417c	; 0x417c <xQueueGenericSend>

00006992 <StopLineFollower>:
	
}
void StopLineFollower()
{
	xSemaphoreGive(StopSema);
    6992:	20 e0       	ldi	r18, 0x00	; 0
    6994:	40 e0       	ldi	r20, 0x00	; 0
    6996:	50 e0       	ldi	r21, 0x00	; 0
    6998:	60 e0       	ldi	r22, 0x00	; 0
    699a:	70 e0       	ldi	r23, 0x00	; 0
    699c:	80 91 99 2d 	lds	r24, 0x2D99	; 0x802d99 <StopSema>
    69a0:	90 91 9a 2d 	lds	r25, 0x2D9A	; 0x802d9a <StopSema+0x1>
    69a4:	0c 94 be 20 	jmp	0x417c	; 0x417c <xQueueGenericSend>

000069a8 <WorkerMotion>:
	DisableMotorSpeedTask();
	
}

static void WorkerMotion(void *pvParameters)
{
    69a8:	cf 93       	push	r28
    69aa:	df 93       	push	r29
    69ac:	cd b7       	in	r28, 0x3d	; 61
    69ae:	de b7       	in	r29, 0x3e	; 62
    69b0:	67 97       	sbiw	r28, 0x17	; 23
    69b2:	cd bf       	out	0x3d, r28	; 61
    69b4:	de bf       	out	0x3e, r29	; 62
    69b6:	0f c0       	rjmp	.+30     	; 0x69d6 <WorkerMotion+0x2e>

		if (MotionCmd.Cmd==CMD_DRIVE_STRAIGHT)
		{
			CmdDriveStraight(MotionCmd.Params[0],MotionCmd.Params[1]);
		}	
		else if (MotionCmd.Cmd==CMD_DRIVE_SEGMENT)
    69b8:	82 30       	cpi	r24, 0x02	; 2
    69ba:	09 f4       	brne	.+2      	; 0x69be <WorkerMotion+0x16>
    69bc:	ae c0       	rjmp	.+348    	; 0x6b1a <WorkerMotion+0x172>
		{
			CmdDriveSegment(MotionCmd.Params[0]);
		}
		else if (MotionCmd.Cmd==CMD_ROTATE_CENTER)
    69be:	83 30       	cpi	r24, 0x03	; 3
    69c0:	09 f4       	brne	.+2      	; 0x69c4 <WorkerMotion+0x1c>
    69c2:	fa c0       	rjmp	.+500    	; 0x6bb8 <WorkerMotion+0x210>
		{
			CmdRotateCenter(MotionCmd.Params[0],MotionCmd.Params[1]);	
		}			
		if (uxQueueMessagesWaiting(CmdQueue)==0) xSemaphoreGive(CmdCompleteSema);
    69c4:	80 91 a7 2d 	lds	r24, 0x2DA7	; 0x802da7 <CmdQueue>
    69c8:	90 91 a8 2d 	lds	r25, 0x2DA8	; 0x802da8 <CmdQueue+0x1>
    69cc:	0e 94 14 25 	call	0x4a28	; 0x4a28 <uxQueueMessagesWaiting>
    69d0:	88 23       	and	r24, r24
    69d2:	09 f4       	brne	.+2      	; 0x69d6 <WorkerMotion+0x2e>
    69d4:	96 c0       	rjmp	.+300    	; 0x6b02 <WorkerMotion+0x15a>
	
	float fa;
	
	while (1)
	{
		xQueueReceive(CmdQueue,&MotionCmd,portMAX_DELAY);
    69d6:	4f ef       	ldi	r20, 0xFF	; 255
    69d8:	5f ef       	ldi	r21, 0xFF	; 255
    69da:	be 01       	movw	r22, r28
    69dc:	6f 5f       	subi	r22, 0xFF	; 255
    69de:	7f 4f       	sbci	r23, 0xFF	; 255
    69e0:	80 91 a7 2d 	lds	r24, 0x2DA7	; 0x802da7 <CmdQueue>
    69e4:	90 91 a8 2d 	lds	r25, 0x2DA8	; 0x802da8 <CmdQueue+0x1>
    69e8:	0e 94 55 22 	call	0x44aa	; 0x44aa <xQueueReceive>

		if (MotionCmd.Cmd==CMD_DRIVE_STRAIGHT)
    69ec:	89 81       	ldd	r24, Y+1	; 0x01
    69ee:	81 30       	cpi	r24, 0x01	; 1
    69f0:	19 f7       	brne	.-58     	; 0x69b8 <WorkerMotion+0x10>
		{
			CmdDriveStraight(MotionCmd.Params[0],MotionCmd.Params[1]);
    69f2:	4e 80       	ldd	r4, Y+6	; 0x06
    69f4:	5f 80       	ldd	r5, Y+7	; 0x07
    69f6:	68 84       	ldd	r6, Y+8	; 0x08
    69f8:	79 84       	ldd	r7, Y+9	; 0x09
    69fa:	8a 80       	ldd	r8, Y+2	; 0x02
    69fc:	9b 80       	ldd	r9, Y+3	; 0x03
    69fe:	ac 80       	ldd	r10, Y+4	; 0x04
    6a00:	bd 80       	ldd	r11, Y+5	; 0x05
	ADCStruct ADCData;
	int Cnt;
		
	float fa;
		
	xLastWakeTime = xTaskGetTickCount();
    6a02:	0e 94 54 29 	call	0x52a8	; 0x52a8 <xTaskGetTickCount>
    6a06:	8a 87       	std	Y+10, r24	; 0x0a
    6a08:	9b 87       	std	Y+11, r25	; 0x0b
	EnableMotorPosTask();
    6a0a:	0e 94 df 38 	call	0x71be	; 0x71be <EnableMotorPosTask>
	EnableMotorSpeedTask();
    6a0e:	0e 94 ac 39 	call	0x7358	; 0x7358 <EnableMotorSpeedTask>
	Encoder=DriverMotorGetEncoder();
    6a12:	0e 94 41 07 	call	0xe82	; 0xe82 <DriverMotorGetEncoder>
    6a16:	6b 01       	movw	r12, r22
    6a18:	7c 01       	movw	r14, r24
	if (Distance>0)
    6a1a:	20 e0       	ldi	r18, 0x00	; 0
    6a1c:	30 e0       	ldi	r19, 0x00	; 0
    6a1e:	a9 01       	movw	r20, r18
    6a20:	c5 01       	movw	r24, r10
    6a22:	b4 01       	movw	r22, r8
    6a24:	0e 94 f9 44 	call	0x89f2	; 0x89f2 <__gesf2>
	{
		//Fwd
		EncoderTarget.Cnt1=Encoder.Cnt1+MM_TO_CNT(Distance);
    6a28:	2d ec       	ldi	r18, 0xCD	; 205
    6a2a:	3c e4       	ldi	r19, 0x4C	; 76
    6a2c:	4f e4       	ldi	r20, 0x4F	; 79
    6a2e:	53 e4       	ldi	r21, 0x43	; 67
		
	xLastWakeTime = xTaskGetTickCount();
	EnableMotorPosTask();
	EnableMotorSpeedTask();
	Encoder=DriverMotorGetEncoder();
	if (Distance>0)
    6a30:	18 16       	cp	r1, r24
    6a32:	0c f0       	brlt	.+2      	; 0x6a36 <WorkerMotion+0x8e>
    6a34:	50 c1       	rjmp	.+672    	; 0x6cd6 <WorkerMotion+0x32e>
	{
		//Fwd
		EncoderTarget.Cnt1=Encoder.Cnt1+MM_TO_CNT(Distance);
    6a36:	c5 01       	movw	r24, r10
    6a38:	b4 01       	movw	r22, r8
    6a3a:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6a3e:	20 e0       	ldi	r18, 0x00	; 0
    6a40:	30 e0       	ldi	r19, 0x00	; 0
    6a42:	44 eb       	ldi	r20, 0xB4	; 180
    6a44:	53 e4       	ldi	r21, 0x43	; 67
    6a46:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    6a4a:	20 e0       	ldi	r18, 0x00	; 0
    6a4c:	30 e0       	ldi	r19, 0x00	; 0
    6a4e:	40 e4       	ldi	r20, 0x40	; 64
    6a50:	50 e4       	ldi	r21, 0x40	; 64
    6a52:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6a56:	6c 8b       	std	Y+20, r22	; 0x14
    6a58:	7d 8b       	std	Y+21, r23	; 0x15
    6a5a:	8e 8b       	std	Y+22, r24	; 0x16
    6a5c:	9f 8b       	std	Y+23, r25	; 0x17
    6a5e:	b6 01       	movw	r22, r12
    6a60:	dd 0c       	add	r13, r13
    6a62:	88 0b       	sbc	r24, r24
    6a64:	99 0b       	sbc	r25, r25
    6a66:	0e 94 49 44 	call	0x8892	; 0x8892 <__floatsisf>
    6a6a:	9b 01       	movw	r18, r22
    6a6c:	ac 01       	movw	r20, r24
    6a6e:	6c 89       	ldd	r22, Y+20	; 0x14
    6a70:	7d 89       	ldd	r23, Y+21	; 0x15
    6a72:	8e 89       	ldd	r24, Y+22	; 0x16
    6a74:	9f 89       	ldd	r25, Y+23	; 0x17
    6a76:	0e 94 2e 43 	call	0x865c	; 0x865c <__addsf3>
    6a7a:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
    6a7e:	8b 01       	movw	r16, r22
				
		MotorSpeedSet(MM_TO_CNT(Speed),MM_TO_CNT(Speed));
    6a80:	2d ec       	ldi	r18, 0xCD	; 205
    6a82:	3c e4       	ldi	r19, 0x4C	; 76
    6a84:	4f e4       	ldi	r20, 0x4F	; 79
    6a86:	53 e4       	ldi	r21, 0x43	; 67
    6a88:	c3 01       	movw	r24, r6
    6a8a:	b2 01       	movw	r22, r4
    6a8c:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6a90:	20 e0       	ldi	r18, 0x00	; 0
    6a92:	30 e0       	ldi	r19, 0x00	; 0
    6a94:	44 eb       	ldi	r20, 0xB4	; 180
    6a96:	53 e4       	ldi	r21, 0x43	; 67
    6a98:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    6a9c:	20 e0       	ldi	r18, 0x00	; 0
    6a9e:	30 e0       	ldi	r19, 0x00	; 0
    6aa0:	40 e4       	ldi	r20, 0x40	; 64
    6aa2:	50 e4       	ldi	r21, 0x40	; 64
    6aa4:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6aa8:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
    6aac:	dc 01       	movw	r26, r24
    6aae:	cb 01       	movw	r24, r22
    6ab0:	bc 01       	movw	r22, r24
    6ab2:	0e 94 be 39 	call	0x737c	; 0x737c <MotorSpeedSet>
    6ab6:	09 c0       	rjmp	.+18     	; 0x6aca <WorkerMotion+0x122>
		Encoder=DriverMotorGetEncoder();
				
		//Stop if target distance is reached
		if (Distance>0)
		{//Fwd
			if (Encoder.Cnt1>EncoderTarget.Cnt1) break;
    6ab8:	0c 15       	cp	r16, r12
    6aba:	1d 05       	cpc	r17, r13
    6abc:	b4 f0       	brlt	.+44     	; 0x6aea <WorkerMotion+0x142>
		else
		{//Reverse
			if (Encoder.Cnt1<EncoderTarget.Cnt1) break;
		}
				
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    6abe:	6a e0       	ldi	r22, 0x0A	; 10
    6ac0:	70 e0       	ldi	r23, 0x00	; 0
    6ac2:	ce 01       	movw	r24, r28
    6ac4:	0a 96       	adiw	r24, 0x0a	; 10
    6ac6:	0e 94 d9 2a 	call	0x55b2	; 0x55b2 <vTaskDelayUntil>
		EncoderTarget.Cnt1=Encoder.Cnt1+MM_TO_CNT(Distance);
		MotorSpeedSet(-MM_TO_CNT(Speed),-MM_TO_CNT(Speed));
	}
	while (1)
	{
		Encoder=DriverMotorGetEncoder();
    6aca:	0e 94 41 07 	call	0xe82	; 0xe82 <DriverMotorGetEncoder>
    6ace:	6b 01       	movw	r12, r22
    6ad0:	7c 01       	movw	r14, r24
				
		//Stop if target distance is reached
		if (Distance>0)
    6ad2:	20 e0       	ldi	r18, 0x00	; 0
    6ad4:	30 e0       	ldi	r19, 0x00	; 0
    6ad6:	a9 01       	movw	r20, r18
    6ad8:	c5 01       	movw	r24, r10
    6ada:	b4 01       	movw	r22, r8
    6adc:	0e 94 f9 44 	call	0x89f2	; 0x89f2 <__gesf2>
    6ae0:	18 16       	cp	r1, r24
    6ae2:	54 f3       	brlt	.-44     	; 0x6ab8 <WorkerMotion+0x110>
		{//Fwd
			if (Encoder.Cnt1>EncoderTarget.Cnt1) break;
		}
		else
		{//Reverse
			if (Encoder.Cnt1<EncoderTarget.Cnt1) break;
    6ae4:	c0 16       	cp	r12, r16
    6ae6:	d1 06       	cpc	r13, r17
    6ae8:	54 f7       	brge	.-44     	; 0x6abe <WorkerMotion+0x116>
			if (Encoder.Cnt1>EncoderTarget.Cnt1) break;
		}
		
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
	}
	DisableMotorPosTask();
    6aea:	0e 94 f8 38 	call	0x71f0	; 0x71f0 <DisableMotorPosTask>
	DisableMotorSpeedTask();
    6aee:	0e 94 b8 39 	call	0x7370	; 0x7370 <DisableMotorSpeedTask>
		}
		else if (MotionCmd.Cmd==CMD_ROTATE_CENTER)
		{
			CmdRotateCenter(MotionCmd.Params[0],MotionCmd.Params[1]);	
		}			
		if (uxQueueMessagesWaiting(CmdQueue)==0) xSemaphoreGive(CmdCompleteSema);
    6af2:	80 91 a7 2d 	lds	r24, 0x2DA7	; 0x802da7 <CmdQueue>
    6af6:	90 91 a8 2d 	lds	r25, 0x2DA8	; 0x802da8 <CmdQueue+0x1>
    6afa:	0e 94 14 25 	call	0x4a28	; 0x4a28 <uxQueueMessagesWaiting>
    6afe:	81 11       	cpse	r24, r1
    6b00:	6a cf       	rjmp	.-300    	; 0x69d6 <WorkerMotion+0x2e>
    6b02:	20 e0       	ldi	r18, 0x00	; 0
    6b04:	40 e0       	ldi	r20, 0x00	; 0
    6b06:	50 e0       	ldi	r21, 0x00	; 0
    6b08:	60 e0       	ldi	r22, 0x00	; 0
    6b0a:	70 e0       	ldi	r23, 0x00	; 0
    6b0c:	80 91 a5 2d 	lds	r24, 0x2DA5	; 0x802da5 <CmdCompleteSema>
    6b10:	90 91 a6 2d 	lds	r25, 0x2DA6	; 0x802da6 <CmdCompleteSema+0x1>
    6b14:	0e 94 be 20 	call	0x417c	; 0x417c <xQueueGenericSend>
    6b18:	5e cf       	rjmp	.-324    	; 0x69d6 <WorkerMotion+0x2e>
		{
			CmdDriveStraight(MotionCmd.Params[0],MotionCmd.Params[1]);
		}	
		else if (MotionCmd.Cmd==CMD_DRIVE_SEGMENT)
		{
			CmdDriveSegment(MotionCmd.Params[0]);
    6b1a:	ca 80       	ldd	r12, Y+2	; 0x02
    6b1c:	db 80       	ldd	r13, Y+3	; 0x03
    6b1e:	ec 80       	ldd	r14, Y+4	; 0x04
    6b20:	fd 80       	ldd	r15, Y+5	; 0x05
	ADCStruct ADCData;
	int Cnt;
			
	float fa;
			
	xLastWakeTime = xTaskGetTickCount();
    6b22:	0e 94 54 29 	call	0x52a8	; 0x52a8 <xTaskGetTickCount>
    6b26:	8a 8b       	std	Y+18, r24	; 0x12
    6b28:	9b 8b       	std	Y+19, r25	; 0x13
	EnableMotorPosTask();
    6b2a:	0e 94 df 38 	call	0x71be	; 0x71be <EnableMotorPosTask>
	EnableMotorSpeedTask();
    6b2e:	0e 94 ac 39 	call	0x7358	; 0x7358 <EnableMotorSpeedTask>
	Encoder=DriverMotorGetEncoder();
    6b32:	0e 94 41 07 	call	0xe82	; 0xe82 <DriverMotorGetEncoder>
				
	StartLineFollower(MM_TO_CNT(Speed));
    6b36:	2d ec       	ldi	r18, 0xCD	; 205
    6b38:	3c e4       	ldi	r19, 0x4C	; 76
    6b3a:	4f e4       	ldi	r20, 0x4F	; 79
    6b3c:	53 e4       	ldi	r21, 0x43	; 67
    6b3e:	c7 01       	movw	r24, r14
    6b40:	b6 01       	movw	r22, r12
    6b42:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6b46:	20 e0       	ldi	r18, 0x00	; 0
    6b48:	30 e0       	ldi	r19, 0x00	; 0
    6b4a:	44 eb       	ldi	r20, 0xB4	; 180
    6b4c:	53 e4       	ldi	r21, 0x43	; 67
    6b4e:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    6b52:	20 e0       	ldi	r18, 0x00	; 0
    6b54:	30 e0       	ldi	r19, 0x00	; 0
    6b56:	40 e4       	ldi	r20, 0x40	; 64
    6b58:	50 e4       	ldi	r21, 0x40	; 64
    6b5a:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6b5e:	0e 94 b6 34 	call	0x696c	; 0x696c <StartLineFollower>

	Cnt=0;
    6b62:	00 e0       	ldi	r16, 0x00	; 0
    6b64:	10 e0       	ldi	r17, 0x00	; 0
    6b66:	0b c0       	rjmp	.+22     	; 0x6b7e <WorkerMotion+0x1d6>
	while (1)
	{
		ADCData=GetADCData();
		if ((ADCData.PhotoL+ADCData.PhotoR)/2>LINEFOLLOW_THRESHOLD)
		{
			Cnt++;
    6b68:	0f 5f       	subi	r16, 0xFF	; 255
    6b6a:	1f 4f       	sbci	r17, 0xFF	; 255
			if (Cnt>LINEFOLLOW_THRESHOLD_CNT) break;
    6b6c:	05 31       	cpi	r16, 0x15	; 21
    6b6e:	11 05       	cpc	r17, r1
    6b70:	e4 f4       	brge	.+56     	; 0x6baa <WorkerMotion+0x202>
		}
		else
		Cnt=0;
					
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    6b72:	6a e0       	ldi	r22, 0x0A	; 10
    6b74:	70 e0       	ldi	r23, 0x00	; 0
    6b76:	ce 01       	movw	r24, r28
    6b78:	42 96       	adiw	r24, 0x12	; 18
    6b7a:	0e 94 d9 2a 	call	0x55b2	; 0x55b2 <vTaskDelayUntil>
	StartLineFollower(MM_TO_CNT(Speed));

	Cnt=0;
	while (1)
	{
		ADCData=GetADCData();
    6b7e:	0e 94 1d 32 	call	0x643a	; 0x643a <GetADCData>
    6b82:	2a 87       	std	Y+10, r18	; 0x0a
    6b84:	3b 87       	std	Y+11, r19	; 0x0b
    6b86:	4c 87       	std	Y+12, r20	; 0x0c
    6b88:	5d 87       	std	Y+13, r21	; 0x0d
    6b8a:	6e 87       	std	Y+14, r22	; 0x0e
    6b8c:	7f 87       	std	Y+15, r23	; 0x0f
    6b8e:	88 8b       	std	Y+16, r24	; 0x10
    6b90:	99 8b       	std	Y+17, r25	; 0x11
		if ((ADCData.PhotoL+ADCData.PhotoR)/2>LINEFOLLOW_THRESHOLD)
    6b92:	2a 85       	ldd	r18, Y+10	; 0x0a
    6b94:	3b 85       	ldd	r19, Y+11	; 0x0b
    6b96:	8e 85       	ldd	r24, Y+14	; 0x0e
    6b98:	9f 85       	ldd	r25, Y+15	; 0x0f
    6b9a:	82 0f       	add	r24, r18
    6b9c:	93 1f       	adc	r25, r19
    6b9e:	8a 38       	cpi	r24, 0x8A	; 138
    6ba0:	93 41       	sbci	r25, 0x13	; 19
    6ba2:	14 f7       	brge	.-60     	; 0x6b68 <WorkerMotion+0x1c0>
		{
			Cnt++;
			if (Cnt>LINEFOLLOW_THRESHOLD_CNT) break;
		}
		else
		Cnt=0;
    6ba4:	00 e0       	ldi	r16, 0x00	; 0
    6ba6:	10 e0       	ldi	r17, 0x00	; 0
    6ba8:	e4 cf       	rjmp	.-56     	; 0x6b72 <WorkerMotion+0x1ca>
					
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
	}
	StopLineFollower();
    6baa:	0e 94 c9 34 	call	0x6992	; 0x6992 <StopLineFollower>
	DisableMotorPosTask();
    6bae:	0e 94 f8 38 	call	0x71f0	; 0x71f0 <DisableMotorPosTask>
	DisableMotorSpeedTask();
    6bb2:	0e 94 b8 39 	call	0x7370	; 0x7370 <DisableMotorSpeedTask>
    6bb6:	06 cf       	rjmp	.-500    	; 0x69c4 <WorkerMotion+0x1c>
		{
			CmdDriveSegment(MotionCmd.Params[0]);
		}
		else if (MotionCmd.Cmd==CMD_ROTATE_CENTER)
		{
			CmdRotateCenter(MotionCmd.Params[0],MotionCmd.Params[1]);	
    6bb8:	4e 80       	ldd	r4, Y+6	; 0x06
    6bba:	5f 80       	ldd	r5, Y+7	; 0x07
    6bbc:	68 84       	ldd	r6, Y+8	; 0x08
    6bbe:	79 84       	ldd	r7, Y+9	; 0x09
    6bc0:	8a 80       	ldd	r8, Y+2	; 0x02
    6bc2:	9b 80       	ldd	r9, Y+3	; 0x03
    6bc4:	ac 80       	ldd	r10, Y+4	; 0x04
    6bc6:	bd 80       	ldd	r11, Y+5	; 0x05
	ADCStruct ADCData;
	int Cnt;
		
	float fa;
	
	xLastWakeTime = xTaskGetTickCount();
    6bc8:	0e 94 54 29 	call	0x52a8	; 0x52a8 <xTaskGetTickCount>
    6bcc:	8a 87       	std	Y+10, r24	; 0x0a
    6bce:	9b 87       	std	Y+11, r25	; 0x0b
	EnableMotorPosTask();
    6bd0:	0e 94 df 38 	call	0x71be	; 0x71be <EnableMotorPosTask>
	EnableMotorSpeedTask();
    6bd4:	0e 94 ac 39 	call	0x7358	; 0x7358 <EnableMotorSpeedTask>
	Encoder=DriverMotorGetEncoder();
    6bd8:	0e 94 41 07 	call	0xe82	; 0xe82 <DriverMotorGetEncoder>
    6bdc:	6b 01       	movw	r12, r22
    6bde:	7c 01       	movw	r14, r24
	fa=WHEEL_DISTANCE*3.14/360*Angle; //Calculate wheel distance to travel
    6be0:	26 ec       	ldi	r18, 0xC6	; 198
    6be2:	39 ed       	ldi	r19, 0xD9	; 217
    6be4:	47 e7       	ldi	r20, 0x77	; 119
    6be6:	5f e3       	ldi	r21, 0x3F	; 63
    6be8:	c5 01       	movw	r24, r10
    6bea:	b4 01       	movw	r22, r8
    6bec:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    6bf0:	4b 01       	movw	r8, r22
    6bf2:	5c 01       	movw	r10, r24
	if (fa>0)
    6bf4:	20 e0       	ldi	r18, 0x00	; 0
    6bf6:	30 e0       	ldi	r19, 0x00	; 0
    6bf8:	a9 01       	movw	r20, r18
    6bfa:	0e 94 f9 44 	call	0x89f2	; 0x89f2 <__gesf2>
    6bfe:	18 16       	cp	r1, r24
    6c00:	0c f0       	brlt	.+2      	; 0x6c04 <WorkerMotion+0x25c>
    6c02:	ab c0       	rjmp	.+342    	; 0x6d5a <WorkerMotion+0x3b2>
	{
		//Fwd
		EncoderTarget.Cnt1=(float) Encoder.Cnt1-MM_TO_CNT(fa);
    6c04:	b6 01       	movw	r22, r12
    6c06:	dd 0c       	add	r13, r13
    6c08:	88 0b       	sbc	r24, r24
    6c0a:	99 0b       	sbc	r25, r25
    6c0c:	0e 94 49 44 	call	0x8892	; 0x8892 <__floatsisf>
    6c10:	6b 01       	movw	r12, r22
    6c12:	7c 01       	movw	r14, r24
    6c14:	2d ec       	ldi	r18, 0xCD	; 205
    6c16:	3c e4       	ldi	r19, 0x4C	; 76
    6c18:	4f e4       	ldi	r20, 0x4F	; 79
    6c1a:	53 e4       	ldi	r21, 0x43	; 67
    6c1c:	c5 01       	movw	r24, r10
    6c1e:	b4 01       	movw	r22, r8
    6c20:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6c24:	20 e0       	ldi	r18, 0x00	; 0
    6c26:	30 e0       	ldi	r19, 0x00	; 0
    6c28:	44 eb       	ldi	r20, 0xB4	; 180
    6c2a:	53 e4       	ldi	r21, 0x43	; 67
    6c2c:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    6c30:	20 e0       	ldi	r18, 0x00	; 0
    6c32:	30 e0       	ldi	r19, 0x00	; 0
    6c34:	40 e4       	ldi	r20, 0x40	; 64
    6c36:	50 e4       	ldi	r21, 0x40	; 64
    6c38:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6c3c:	9b 01       	movw	r18, r22
    6c3e:	ac 01       	movw	r20, r24
    6c40:	c7 01       	movw	r24, r14
    6c42:	b6 01       	movw	r22, r12
    6c44:	0e 94 2d 43 	call	0x865a	; 0x865a <__subsf3>
    6c48:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
    6c4c:	8b 01       	movw	r16, r22
		MotorSpeedSet(-MM_TO_CNT(Speed),MM_TO_CNT(Speed));
    6c4e:	2d ec       	ldi	r18, 0xCD	; 205
    6c50:	3c e4       	ldi	r19, 0x4C	; 76
    6c52:	4f e4       	ldi	r20, 0x4F	; 79
    6c54:	53 e4       	ldi	r21, 0x43	; 67
    6c56:	c3 01       	movw	r24, r6
    6c58:	b2 01       	movw	r22, r4
    6c5a:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6c5e:	20 e0       	ldi	r18, 0x00	; 0
    6c60:	30 e0       	ldi	r19, 0x00	; 0
    6c62:	44 eb       	ldi	r20, 0xB4	; 180
    6c64:	53 e4       	ldi	r21, 0x43	; 67
    6c66:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    6c6a:	20 e0       	ldi	r18, 0x00	; 0
    6c6c:	30 e0       	ldi	r19, 0x00	; 0
    6c6e:	40 e4       	ldi	r20, 0x40	; 64
    6c70:	50 e4       	ldi	r21, 0x40	; 64
    6c72:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6c76:	2b 01       	movw	r4, r22
    6c78:	3c 01       	movw	r6, r24
    6c7a:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
    6c7e:	6b 01       	movw	r12, r22
    6c80:	7c 01       	movw	r14, r24
    6c82:	c3 01       	movw	r24, r6
    6c84:	b2 01       	movw	r22, r4
    6c86:	90 58       	subi	r25, 0x80	; 128
    6c88:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
    6c8c:	dc 01       	movw	r26, r24
    6c8e:	cb 01       	movw	r24, r22
    6c90:	b6 01       	movw	r22, r12
    6c92:	0e 94 be 39 	call	0x737c	; 0x737c <MotorSpeedSet>
    6c96:	0a c0       	rjmp	.+20     	; 0x6cac <WorkerMotion+0x304>
		Encoder=DriverMotorGetEncoder();
		
		//Stop if target distance is reached
		if (fa>0)
		{//Fwd
			if (Encoder.Cnt1<EncoderTarget.Cnt1) break;
    6c98:	c0 16       	cp	r12, r16
    6c9a:	d1 06       	cpc	r13, r17
    6c9c:	0c f4       	brge	.+2      	; 0x6ca0 <WorkerMotion+0x2f8>
    6c9e:	25 cf       	rjmp	.-438    	; 0x6aea <WorkerMotion+0x142>
		else
		{//Reverse
			if (Encoder.Cnt1>EncoderTarget.Cnt1) break;
		}
		
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    6ca0:	6a e0       	ldi	r22, 0x0A	; 10
    6ca2:	70 e0       	ldi	r23, 0x00	; 0
    6ca4:	ce 01       	movw	r24, r28
    6ca6:	0a 96       	adiw	r24, 0x0a	; 10
    6ca8:	0e 94 d9 2a 	call	0x55b2	; 0x55b2 <vTaskDelayUntil>
		EncoderTarget.Cnt1=(float) Encoder.Cnt1-MM_TO_CNT(fa);
		MotorSpeedSet(MM_TO_CNT(Speed),-MM_TO_CNT(Speed));
	}
	while (1)
	{
		Encoder=DriverMotorGetEncoder();
    6cac:	0e 94 41 07 	call	0xe82	; 0xe82 <DriverMotorGetEncoder>
    6cb0:	6b 01       	movw	r12, r22
    6cb2:	7c 01       	movw	r14, r24
		
		//Stop if target distance is reached
		if (fa>0)
    6cb4:	20 e0       	ldi	r18, 0x00	; 0
    6cb6:	30 e0       	ldi	r19, 0x00	; 0
    6cb8:	a9 01       	movw	r20, r18
    6cba:	c5 01       	movw	r24, r10
    6cbc:	b4 01       	movw	r22, r8
    6cbe:	0e 94 f9 44 	call	0x89f2	; 0x89f2 <__gesf2>
    6cc2:	18 16       	cp	r1, r24
    6cc4:	4c f3       	brlt	.-46     	; 0x6c98 <WorkerMotion+0x2f0>
		{//Fwd
			if (Encoder.Cnt1<EncoderTarget.Cnt1) break;
		}
		else
		{//Reverse
			if (Encoder.Cnt1>EncoderTarget.Cnt1) break;
    6cc6:	0c 15       	cp	r16, r12
    6cc8:	1d 05       	cpc	r17, r13
    6cca:	54 f7       	brge	.-44     	; 0x6ca0 <WorkerMotion+0x2f8>
		}
		
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
	}
	DisableMotorPosTask();
    6ccc:	0e 94 f8 38 	call	0x71f0	; 0x71f0 <DisableMotorPosTask>
	DisableMotorSpeedTask();
    6cd0:	0e 94 b8 39 	call	0x7370	; 0x7370 <DisableMotorSpeedTask>
    6cd4:	0e cf       	rjmp	.-484    	; 0x6af2 <WorkerMotion+0x14a>
		MotorSpeedSet(MM_TO_CNT(Speed),MM_TO_CNT(Speed));
	}
	else
	{
		//Reverse
		EncoderTarget.Cnt1=Encoder.Cnt1+MM_TO_CNT(Distance);
    6cd6:	c5 01       	movw	r24, r10
    6cd8:	b4 01       	movw	r22, r8
    6cda:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6cde:	20 e0       	ldi	r18, 0x00	; 0
    6ce0:	30 e0       	ldi	r19, 0x00	; 0
    6ce2:	44 eb       	ldi	r20, 0xB4	; 180
    6ce4:	53 e4       	ldi	r21, 0x43	; 67
    6ce6:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    6cea:	20 e0       	ldi	r18, 0x00	; 0
    6cec:	30 e0       	ldi	r19, 0x00	; 0
    6cee:	40 e4       	ldi	r20, 0x40	; 64
    6cf0:	50 e4       	ldi	r21, 0x40	; 64
    6cf2:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6cf6:	6c 8b       	std	Y+20, r22	; 0x14
    6cf8:	7d 8b       	std	Y+21, r23	; 0x15
    6cfa:	8e 8b       	std	Y+22, r24	; 0x16
    6cfc:	9f 8b       	std	Y+23, r25	; 0x17
    6cfe:	b6 01       	movw	r22, r12
    6d00:	dd 0c       	add	r13, r13
    6d02:	88 0b       	sbc	r24, r24
    6d04:	99 0b       	sbc	r25, r25
    6d06:	0e 94 49 44 	call	0x8892	; 0x8892 <__floatsisf>
    6d0a:	9b 01       	movw	r18, r22
    6d0c:	ac 01       	movw	r20, r24
    6d0e:	6c 89       	ldd	r22, Y+20	; 0x14
    6d10:	7d 89       	ldd	r23, Y+21	; 0x15
    6d12:	8e 89       	ldd	r24, Y+22	; 0x16
    6d14:	9f 89       	ldd	r25, Y+23	; 0x17
    6d16:	0e 94 2e 43 	call	0x865c	; 0x865c <__addsf3>
    6d1a:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
    6d1e:	8b 01       	movw	r16, r22
		MotorSpeedSet(-MM_TO_CNT(Speed),-MM_TO_CNT(Speed));
    6d20:	2d ec       	ldi	r18, 0xCD	; 205
    6d22:	3c e4       	ldi	r19, 0x4C	; 76
    6d24:	4f e4       	ldi	r20, 0x4F	; 79
    6d26:	53 e4       	ldi	r21, 0x43	; 67
    6d28:	c3 01       	movw	r24, r6
    6d2a:	b2 01       	movw	r22, r4
    6d2c:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6d30:	20 e0       	ldi	r18, 0x00	; 0
    6d32:	30 e0       	ldi	r19, 0x00	; 0
    6d34:	44 eb       	ldi	r20, 0xB4	; 180
    6d36:	53 e4       	ldi	r21, 0x43	; 67
    6d38:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    6d3c:	20 e0       	ldi	r18, 0x00	; 0
    6d3e:	30 e0       	ldi	r19, 0x00	; 0
    6d40:	40 e4       	ldi	r20, 0x40	; 64
    6d42:	50 e4       	ldi	r21, 0x40	; 64
    6d44:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6d48:	90 58       	subi	r25, 0x80	; 128
    6d4a:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
    6d4e:	dc 01       	movw	r26, r24
    6d50:	cb 01       	movw	r24, r22
    6d52:	bc 01       	movw	r22, r24
    6d54:	0e 94 be 39 	call	0x737c	; 0x737c <MotorSpeedSet>
    6d58:	b8 ce       	rjmp	.-656    	; 0x6aca <WorkerMotion+0x122>
		MotorSpeedSet(-MM_TO_CNT(Speed),MM_TO_CNT(Speed));
	}
	else
	{
		//Reverse
		EncoderTarget.Cnt1=(float) Encoder.Cnt1-MM_TO_CNT(fa);
    6d5a:	b6 01       	movw	r22, r12
    6d5c:	dd 0c       	add	r13, r13
    6d5e:	88 0b       	sbc	r24, r24
    6d60:	99 0b       	sbc	r25, r25
    6d62:	0e 94 49 44 	call	0x8892	; 0x8892 <__floatsisf>
    6d66:	6b 01       	movw	r12, r22
    6d68:	7c 01       	movw	r14, r24
    6d6a:	2d ec       	ldi	r18, 0xCD	; 205
    6d6c:	3c e4       	ldi	r19, 0x4C	; 76
    6d6e:	4f e4       	ldi	r20, 0x4F	; 79
    6d70:	53 e4       	ldi	r21, 0x43	; 67
    6d72:	c5 01       	movw	r24, r10
    6d74:	b4 01       	movw	r22, r8
    6d76:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6d7a:	20 e0       	ldi	r18, 0x00	; 0
    6d7c:	30 e0       	ldi	r19, 0x00	; 0
    6d7e:	44 eb       	ldi	r20, 0xB4	; 180
    6d80:	53 e4       	ldi	r21, 0x43	; 67
    6d82:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    6d86:	20 e0       	ldi	r18, 0x00	; 0
    6d88:	30 e0       	ldi	r19, 0x00	; 0
    6d8a:	40 e4       	ldi	r20, 0x40	; 64
    6d8c:	50 e4       	ldi	r21, 0x40	; 64
    6d8e:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6d92:	9b 01       	movw	r18, r22
    6d94:	ac 01       	movw	r20, r24
    6d96:	c7 01       	movw	r24, r14
    6d98:	b6 01       	movw	r22, r12
    6d9a:	0e 94 2d 43 	call	0x865a	; 0x865a <__subsf3>
    6d9e:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
    6da2:	8b 01       	movw	r16, r22
		MotorSpeedSet(MM_TO_CNT(Speed),-MM_TO_CNT(Speed));
    6da4:	2d ec       	ldi	r18, 0xCD	; 205
    6da6:	3c e4       	ldi	r19, 0x4C	; 76
    6da8:	4f e4       	ldi	r20, 0x4F	; 79
    6daa:	53 e4       	ldi	r21, 0x43	; 67
    6dac:	c3 01       	movw	r24, r6
    6dae:	b2 01       	movw	r22, r4
    6db0:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6db4:	20 e0       	ldi	r18, 0x00	; 0
    6db6:	30 e0       	ldi	r19, 0x00	; 0
    6db8:	44 eb       	ldi	r20, 0xB4	; 180
    6dba:	53 e4       	ldi	r21, 0x43	; 67
    6dbc:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    6dc0:	20 e0       	ldi	r18, 0x00	; 0
    6dc2:	30 e0       	ldi	r19, 0x00	; 0
    6dc4:	40 e4       	ldi	r20, 0x40	; 64
    6dc6:	50 e4       	ldi	r21, 0x40	; 64
    6dc8:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    6dcc:	2b 01       	movw	r4, r22
    6dce:	3c 01       	movw	r6, r24
    6dd0:	90 58       	subi	r25, 0x80	; 128
    6dd2:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
    6dd6:	6b 01       	movw	r12, r22
    6dd8:	7c 01       	movw	r14, r24
    6dda:	c3 01       	movw	r24, r6
    6ddc:	b2 01       	movw	r22, r4
    6dde:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
    6de2:	dc 01       	movw	r26, r24
    6de4:	cb 01       	movw	r24, r22
    6de6:	b6 01       	movw	r22, r12
    6de8:	0e 94 be 39 	call	0x737c	; 0x737c <MotorSpeedSet>
    6dec:	5f cf       	rjmp	.-322    	; 0x6cac <WorkerMotion+0x304>

00006dee <InitMotionTask>:
static void CmdDriveStraight(float Distance, float Speed);
static void CmdDriveSegment(float Speed);

//Function definitions
void InitMotionTask()
{
    6dee:	ef 92       	push	r14
    6df0:	ff 92       	push	r15
    6df2:	0f 93       	push	r16
	xTaskCreate( WorkerMotion, "motion", 256, NULL, tskIDLE_PRIORITY+3, NULL );	
    6df4:	e1 2c       	mov	r14, r1
    6df6:	f1 2c       	mov	r15, r1
    6df8:	03 e0       	ldi	r16, 0x03	; 3
    6dfa:	20 e0       	ldi	r18, 0x00	; 0
    6dfc:	30 e0       	ldi	r19, 0x00	; 0
    6dfe:	40 e0       	ldi	r20, 0x00	; 0
    6e00:	51 e0       	ldi	r21, 0x01	; 1
    6e02:	68 e7       	ldi	r22, 0x78	; 120
    6e04:	76 e2       	ldi	r23, 0x26	; 38
    6e06:	84 ed       	ldi	r24, 0xD4	; 212
    6e08:	94 e3       	ldi	r25, 0x34	; 52
    6e0a:	0e 94 c8 26 	call	0x4d90	; 0x4d90 <xTaskCreate>
	CmdQueue=xQueueCreate(1,sizeof(MotionCmdStruct));
    6e0e:	40 e0       	ldi	r20, 0x00	; 0
    6e10:	69 e0       	ldi	r22, 0x09	; 9
    6e12:	81 e0       	ldi	r24, 0x01	; 1
    6e14:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueGenericCreate>
    6e18:	80 93 a7 2d 	sts	0x2DA7, r24	; 0x802da7 <CmdQueue>
    6e1c:	90 93 a8 2d 	sts	0x2DA8, r25	; 0x802da8 <CmdQueue+0x1>
	CmdCompleteSema=xSemaphoreCreateBinary();
    6e20:	43 e0       	ldi	r20, 0x03	; 3
    6e22:	60 e0       	ldi	r22, 0x00	; 0
    6e24:	81 e0       	ldi	r24, 0x01	; 1
    6e26:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueGenericCreate>
    6e2a:	80 93 a5 2d 	sts	0x2DA5, r24	; 0x802da5 <CmdCompleteSema>
    6e2e:	90 93 a6 2d 	sts	0x2DA6, r25	; 0x802da6 <CmdCompleteSema+0x1>
}
    6e32:	0f 91       	pop	r16
    6e34:	ff 90       	pop	r15
    6e36:	ef 90       	pop	r14
    6e38:	08 95       	ret

00006e3a <DriveStraight>:
		
	}
}

void DriveStraight(float Distance, float Speed)
{
    6e3a:	cf 93       	push	r28
    6e3c:	df 93       	push	r29
    6e3e:	cd b7       	in	r28, 0x3d	; 61
    6e40:	de b7       	in	r29, 0x3e	; 62
    6e42:	29 97       	sbiw	r28, 0x09	; 9
    6e44:	cd bf       	out	0x3d, r28	; 61
    6e46:	de bf       	out	0x3e, r29	; 62
	MotionCmdStruct MotionCmd;
	MotionCmd.Cmd=CMD_DRIVE_STRAIGHT;
    6e48:	e1 e0       	ldi	r30, 0x01	; 1
    6e4a:	e9 83       	std	Y+1, r30	; 0x01
	MotionCmd.Params[0]=Distance;
    6e4c:	6a 83       	std	Y+2, r22	; 0x02
    6e4e:	7b 83       	std	Y+3, r23	; 0x03
    6e50:	8c 83       	std	Y+4, r24	; 0x04
    6e52:	9d 83       	std	Y+5, r25	; 0x05
	MotionCmd.Params[1]=Speed;
    6e54:	2e 83       	std	Y+6, r18	; 0x06
    6e56:	3f 83       	std	Y+7, r19	; 0x07
    6e58:	48 87       	std	Y+8, r20	; 0x08
    6e5a:	59 87       	std	Y+9, r21	; 0x09
	xQueueSendToBack(CmdQueue,&MotionCmd,portMAX_DELAY);	//Issue command
    6e5c:	20 e0       	ldi	r18, 0x00	; 0
    6e5e:	4f ef       	ldi	r20, 0xFF	; 255
    6e60:	5f ef       	ldi	r21, 0xFF	; 255
    6e62:	be 01       	movw	r22, r28
    6e64:	6f 5f       	subi	r22, 0xFF	; 255
    6e66:	7f 4f       	sbci	r23, 0xFF	; 255
    6e68:	80 91 a7 2d 	lds	r24, 0x2DA7	; 0x802da7 <CmdQueue>
    6e6c:	90 91 a8 2d 	lds	r25, 0x2DA8	; 0x802da8 <CmdQueue+0x1>
    6e70:	0e 94 be 20 	call	0x417c	; 0x417c <xQueueGenericSend>
	xSemaphoreTake(CmdCompleteSema,portMAX_DELAY);			//Block until command has been executed
    6e74:	6f ef       	ldi	r22, 0xFF	; 255
    6e76:	7f ef       	ldi	r23, 0xFF	; 255
    6e78:	80 91 a5 2d 	lds	r24, 0x2DA5	; 0x802da5 <CmdCompleteSema>
    6e7c:	90 91 a6 2d 	lds	r25, 0x2DA6	; 0x802da6 <CmdCompleteSema+0x1>
    6e80:	0e 94 12 23 	call	0x4624	; 0x4624 <xQueueSemaphoreTake>
}
    6e84:	29 96       	adiw	r28, 0x09	; 9
    6e86:	cd bf       	out	0x3d, r28	; 61
    6e88:	de bf       	out	0x3e, r29	; 62
    6e8a:	df 91       	pop	r29
    6e8c:	cf 91       	pop	r28
    6e8e:	08 95       	ret

00006e90 <DriveSegment>:
void DriveSegment(float Speed)
{
    6e90:	cf 93       	push	r28
    6e92:	df 93       	push	r29
    6e94:	cd b7       	in	r28, 0x3d	; 61
    6e96:	de b7       	in	r29, 0x3e	; 62
    6e98:	29 97       	sbiw	r28, 0x09	; 9
    6e9a:	cd bf       	out	0x3d, r28	; 61
    6e9c:	de bf       	out	0x3e, r29	; 62
	MotionCmdStruct MotionCmd;
	MotionCmd.Cmd=CMD_DRIVE_SEGMENT;
    6e9e:	22 e0       	ldi	r18, 0x02	; 2
    6ea0:	29 83       	std	Y+1, r18	; 0x01
	MotionCmd.Params[0]=Speed;
    6ea2:	6a 83       	std	Y+2, r22	; 0x02
    6ea4:	7b 83       	std	Y+3, r23	; 0x03
    6ea6:	8c 83       	std	Y+4, r24	; 0x04
    6ea8:	9d 83       	std	Y+5, r25	; 0x05
	xQueueSendToBack(CmdQueue,&MotionCmd,portMAX_DELAY);	//Issue command
    6eaa:	20 e0       	ldi	r18, 0x00	; 0
    6eac:	4f ef       	ldi	r20, 0xFF	; 255
    6eae:	5f ef       	ldi	r21, 0xFF	; 255
    6eb0:	be 01       	movw	r22, r28
    6eb2:	6f 5f       	subi	r22, 0xFF	; 255
    6eb4:	7f 4f       	sbci	r23, 0xFF	; 255
    6eb6:	80 91 a7 2d 	lds	r24, 0x2DA7	; 0x802da7 <CmdQueue>
    6eba:	90 91 a8 2d 	lds	r25, 0x2DA8	; 0x802da8 <CmdQueue+0x1>
    6ebe:	0e 94 be 20 	call	0x417c	; 0x417c <xQueueGenericSend>
	xSemaphoreTake(CmdCompleteSema,portMAX_DELAY);			//Block until command has been executed
    6ec2:	6f ef       	ldi	r22, 0xFF	; 255
    6ec4:	7f ef       	ldi	r23, 0xFF	; 255
    6ec6:	80 91 a5 2d 	lds	r24, 0x2DA5	; 0x802da5 <CmdCompleteSema>
    6eca:	90 91 a6 2d 	lds	r25, 0x2DA6	; 0x802da6 <CmdCompleteSema+0x1>
    6ece:	0e 94 12 23 	call	0x4624	; 0x4624 <xQueueSemaphoreTake>
}
    6ed2:	29 96       	adiw	r28, 0x09	; 9
    6ed4:	cd bf       	out	0x3d, r28	; 61
    6ed6:	de bf       	out	0x3e, r29	; 62
    6ed8:	df 91       	pop	r29
    6eda:	cf 91       	pop	r28
    6edc:	08 95       	ret

00006ede <RotateCenter>:
void RotateCenter(float Angle, float Speed)
{
    6ede:	cf 93       	push	r28
    6ee0:	df 93       	push	r29
    6ee2:	cd b7       	in	r28, 0x3d	; 61
    6ee4:	de b7       	in	r29, 0x3e	; 62
    6ee6:	29 97       	sbiw	r28, 0x09	; 9
    6ee8:	cd bf       	out	0x3d, r28	; 61
    6eea:	de bf       	out	0x3e, r29	; 62
	MotionCmdStruct MotionCmd;
	MotionCmd.Cmd=CMD_ROTATE_CENTER;
    6eec:	e3 e0       	ldi	r30, 0x03	; 3
    6eee:	e9 83       	std	Y+1, r30	; 0x01
	MotionCmd.Params[0]=Angle;
    6ef0:	6a 83       	std	Y+2, r22	; 0x02
    6ef2:	7b 83       	std	Y+3, r23	; 0x03
    6ef4:	8c 83       	std	Y+4, r24	; 0x04
    6ef6:	9d 83       	std	Y+5, r25	; 0x05
	MotionCmd.Params[1]=Speed;
    6ef8:	2e 83       	std	Y+6, r18	; 0x06
    6efa:	3f 83       	std	Y+7, r19	; 0x07
    6efc:	48 87       	std	Y+8, r20	; 0x08
    6efe:	59 87       	std	Y+9, r21	; 0x09
	xQueueSendToBack(CmdQueue,&MotionCmd,portMAX_DELAY);	//Issue command
    6f00:	20 e0       	ldi	r18, 0x00	; 0
    6f02:	4f ef       	ldi	r20, 0xFF	; 255
    6f04:	5f ef       	ldi	r21, 0xFF	; 255
    6f06:	be 01       	movw	r22, r28
    6f08:	6f 5f       	subi	r22, 0xFF	; 255
    6f0a:	7f 4f       	sbci	r23, 0xFF	; 255
    6f0c:	80 91 a7 2d 	lds	r24, 0x2DA7	; 0x802da7 <CmdQueue>
    6f10:	90 91 a8 2d 	lds	r25, 0x2DA8	; 0x802da8 <CmdQueue+0x1>
    6f14:	0e 94 be 20 	call	0x417c	; 0x417c <xQueueGenericSend>
	xSemaphoreTake(CmdCompleteSema,portMAX_DELAY);			//Block until command has been executed
    6f18:	6f ef       	ldi	r22, 0xFF	; 255
    6f1a:	7f ef       	ldi	r23, 0xFF	; 255
    6f1c:	80 91 a5 2d 	lds	r24, 0x2DA5	; 0x802da5 <CmdCompleteSema>
    6f20:	90 91 a6 2d 	lds	r25, 0x2DA6	; 0x802da6 <CmdCompleteSema+0x1>
    6f24:	0e 94 12 23 	call	0x4624	; 0x4624 <xQueueSemaphoreTake>
    6f28:	29 96       	adiw	r28, 0x09	; 9
    6f2a:	cd bf       	out	0x3d, r28	; 61
    6f2c:	de bf       	out	0x3e, r29	; 62
    6f2e:	df 91       	pop	r29
    6f30:	cf 91       	pop	r28
    6f32:	08 95       	ret

00006f34 <WorkerMotorPos>:
	IncSet.IncSet2=IncSet2;
	xQueueSend(IncSetQueue,&IncSet,portMAX_DELAY);
}

void WorkerMotorPos(void *pvParameters)
{
    6f34:	cf 93       	push	r28
    6f36:	df 93       	push	r29
    6f38:	cd b7       	in	r28, 0x3d	; 61
    6f3a:	de b7       	in	r29, 0x3e	; 62
    6f3c:	2c 97       	sbiw	r28, 0x0c	; 12
    6f3e:	cd bf       	out	0x3d, r28	; 61
    6f40:	de bf       	out	0x3e, r29	; 62
	float Err1=0,Err2=0;
	
	IncSetStruct IncSet;
	EncoderStruct EncoderInfo;
	
	xLastWakeTime = xTaskGetTickCount();
    6f42:	0e 94 54 29 	call	0x52a8	; 0x52a8 <xTaskGetTickCount>
    6f46:	80 93 a9 2d 	sts	0x2DA9, r24	; 0x802da9 <xLastWakeTime>
    6f4a:	90 93 aa 2d 	sts	0x2DAA, r25	; 0x802daa <xLastWakeTime+0x1>
void WorkerMotorPos(void *pvParameters)
{
	
	const TickType_t xPeriod = 10;
	
	float Set1=0,Set2=0;
    6f4e:	19 86       	std	Y+9, r1	; 0x09
    6f50:	1a 86       	std	Y+10, r1	; 0x0a
    6f52:	1b 86       	std	Y+11, r1	; 0x0b
    6f54:	1c 86       	std	Y+12, r1	; 0x0c
    6f56:	1d 82       	std	Y+5, r1	; 0x05
    6f58:	1e 82       	std	Y+6, r1	; 0x06
    6f5a:	1f 82       	std	Y+7, r1	; 0x07
    6f5c:	18 86       	std	Y+8, r1	; 0x08
    6f5e:	77 c0       	rjmp	.+238    	; 0x704e <WorkerMotorPos+0x11a>
			//PID 1
			Err1=Set1-EncoderInfo.Cnt1;
			Out1=Err1*MOTPOS_KP;
			if (Out1>0) Out1+=MOTPOS_FF_OFFSET;
			if (Out1>4095) Out1=4095;
			if (Out1<0) Out1-=MOTPOS_FF_OFFSET;			
    6f60:	20 e0       	ldi	r18, 0x00	; 0
    6f62:	30 e0       	ldi	r19, 0x00	; 0
    6f64:	a9 01       	movw	r20, r18
    6f66:	c7 01       	movw	r24, r14
    6f68:	b6 01       	movw	r22, r12
    6f6a:	0e 94 9a 43 	call	0x8734	; 0x8734 <__cmpsf2>
    6f6e:	87 ff       	sbrs	r24, 7
    6f70:	0a c0       	rjmp	.+20     	; 0x6f86 <WorkerMotorPos+0x52>
    6f72:	20 e0       	ldi	r18, 0x00	; 0
    6f74:	30 e8       	ldi	r19, 0x80	; 128
    6f76:	4b eb       	ldi	r20, 0xBB	; 187
    6f78:	54 e4       	ldi	r21, 0x44	; 68
    6f7a:	c7 01       	movw	r24, r14
    6f7c:	b6 01       	movw	r22, r12
    6f7e:	0e 94 2d 43 	call	0x865a	; 0x865a <__subsf3>
    6f82:	6b 01       	movw	r12, r22
    6f84:	7c 01       	movw	r14, r24
			if (Out1<-4095) Out1=-4095;
    6f86:	20 e0       	ldi	r18, 0x00	; 0
    6f88:	30 ef       	ldi	r19, 0xF0	; 240
    6f8a:	4f e7       	ldi	r20, 0x7F	; 127
    6f8c:	55 ec       	ldi	r21, 0xC5	; 197
    6f8e:	c7 01       	movw	r24, r14
    6f90:	b6 01       	movw	r22, r12
    6f92:	0e 94 9a 43 	call	0x8734	; 0x8734 <__cmpsf2>
    6f96:	87 ff       	sbrs	r24, 7
    6f98:	b6 c0       	rjmp	.+364    	; 0x7106 <WorkerMotorPos+0x1d2>
    6f9a:	01 e0       	ldi	r16, 0x01	; 1
    6f9c:	10 ef       	ldi	r17, 0xF0	; 240

			//PID 2
			Err2=Set2-EncoderInfo.Cnt2;
			Out2=Err2*MOTPOS_KP;
    6f9e:	c5 01       	movw	r24, r10
    6fa0:	b4 01       	movw	r22, r8
    6fa2:	0e 94 49 44 	call	0x8892	; 0x8892 <__floatsisf>
    6fa6:	9b 01       	movw	r18, r22
    6fa8:	ac 01       	movw	r20, r24
    6faa:	69 85       	ldd	r22, Y+9	; 0x09
    6fac:	7a 85       	ldd	r23, Y+10	; 0x0a
    6fae:	8b 85       	ldd	r24, Y+11	; 0x0b
    6fb0:	9c 85       	ldd	r25, Y+12	; 0x0c
    6fb2:	0e 94 2d 43 	call	0x865a	; 0x865a <__subsf3>
    6fb6:	20 e0       	ldi	r18, 0x00	; 0
    6fb8:	30 e0       	ldi	r19, 0x00	; 0
    6fba:	46 e9       	ldi	r20, 0x96	; 150
    6fbc:	53 e4       	ldi	r21, 0x43	; 67
    6fbe:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    6fc2:	6b 01       	movw	r12, r22
    6fc4:	7c 01       	movw	r14, r24
			if (Out2>0) Out2+=MOTPOS_FF_OFFSET;
    6fc6:	20 e0       	ldi	r18, 0x00	; 0
    6fc8:	30 e0       	ldi	r19, 0x00	; 0
    6fca:	a9 01       	movw	r20, r18
    6fcc:	0e 94 f9 44 	call	0x89f2	; 0x89f2 <__gesf2>
    6fd0:	18 16       	cp	r1, r24
    6fd2:	54 f4       	brge	.+20     	; 0x6fe8 <WorkerMotorPos+0xb4>
    6fd4:	20 e0       	ldi	r18, 0x00	; 0
    6fd6:	30 e8       	ldi	r19, 0x80	; 128
    6fd8:	4b eb       	ldi	r20, 0xBB	; 187
    6fda:	54 e4       	ldi	r21, 0x44	; 68
    6fdc:	c7 01       	movw	r24, r14
    6fde:	b6 01       	movw	r22, r12
    6fe0:	0e 94 2e 43 	call	0x865c	; 0x865c <__addsf3>
    6fe4:	6b 01       	movw	r12, r22
    6fe6:	7c 01       	movw	r14, r24
			if (Out2>4095) Out2=4095;
    6fe8:	20 e0       	ldi	r18, 0x00	; 0
    6fea:	30 ef       	ldi	r19, 0xF0	; 240
    6fec:	4f e7       	ldi	r20, 0x7F	; 127
    6fee:	55 e4       	ldi	r21, 0x45	; 69
    6ff0:	c7 01       	movw	r24, r14
    6ff2:	b6 01       	movw	r22, r12
    6ff4:	0e 94 f9 44 	call	0x89f2	; 0x89f2 <__gesf2>
    6ff8:	18 16       	cp	r1, r24
    6ffa:	0c f4       	brge	.+2      	; 0x6ffe <WorkerMotorPos+0xca>
    6ffc:	8a c0       	rjmp	.+276    	; 0x7112 <WorkerMotorPos+0x1de>
			if (Out2<0) Out2-=MOTPOS_FF_OFFSET;
    6ffe:	20 e0       	ldi	r18, 0x00	; 0
    7000:	30 e0       	ldi	r19, 0x00	; 0
    7002:	a9 01       	movw	r20, r18
    7004:	c7 01       	movw	r24, r14
    7006:	b6 01       	movw	r22, r12
    7008:	0e 94 9a 43 	call	0x8734	; 0x8734 <__cmpsf2>
    700c:	87 ff       	sbrs	r24, 7
    700e:	0a c0       	rjmp	.+20     	; 0x7024 <WorkerMotorPos+0xf0>
    7010:	20 e0       	ldi	r18, 0x00	; 0
    7012:	30 e8       	ldi	r19, 0x80	; 128
    7014:	4b eb       	ldi	r20, 0xBB	; 187
    7016:	54 e4       	ldi	r21, 0x44	; 68
    7018:	c7 01       	movw	r24, r14
    701a:	b6 01       	movw	r22, r12
    701c:	0e 94 2d 43 	call	0x865a	; 0x865a <__subsf3>
    7020:	6b 01       	movw	r12, r22
    7022:	7c 01       	movw	r14, r24
			if (Out2<-4095) Out2=-4095;
    7024:	20 e0       	ldi	r18, 0x00	; 0
    7026:	30 ef       	ldi	r19, 0xF0	; 240
    7028:	4f e7       	ldi	r20, 0x7F	; 127
    702a:	55 ec       	ldi	r21, 0xC5	; 197
    702c:	c7 01       	movw	r24, r14
    702e:	b6 01       	movw	r22, r12
    7030:	0e 94 9a 43 	call	0x8734	; 0x8734 <__cmpsf2>
    7034:	87 ff       	sbrs	r24, 7
    7036:	74 c0       	rjmp	.+232    	; 0x7120 <WorkerMotorPos+0x1ec>
    7038:	61 e0       	ldi	r22, 0x01	; 1
    703a:	70 ef       	ldi	r23, 0xF0	; 240
			
			//printf ("Err:%f   Out:%f\r\n",Err2 ,Out2);			
			
			DriverMotorSet(Out1,Out2);
    703c:	c8 01       	movw	r24, r16
    703e:	0e 94 d6 06 	call	0xdac	; 0xdac <DriverMotorSet>
			
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
    7042:	6a e0       	ldi	r22, 0x0A	; 10
    7044:	70 e0       	ldi	r23, 0x00	; 0
    7046:	89 ea       	ldi	r24, 0xA9	; 169
    7048:	9d e2       	ldi	r25, 0x2D	; 45
    704a:	0e 94 d9 2a 	call	0x55b2	; 0x55b2 <vTaskDelayUntil>
	
	xLastWakeTime = xTaskGetTickCount();
	
	while (1)
	{		
			EncoderInfo=DriverMotorGetEncoder();
    704e:	0e 94 41 07 	call	0xe82	; 0xe82 <DriverMotorGetEncoder>
    7052:	6b 01       	movw	r12, r22
    7054:	7c 01       	movw	r14, r24

			//Process reset setpoint command
			if (xSemaphoreTake(ResetSetpointSema,0)==pdPASS)
    7056:	60 e0       	ldi	r22, 0x00	; 0
    7058:	70 e0       	ldi	r23, 0x00	; 0
    705a:	80 91 af 2d 	lds	r24, 0x2DAF	; 0x802daf <ResetSetpointSema>
    705e:	90 91 b0 2d 	lds	r25, 0x2DB0	; 0x802db0 <ResetSetpointSema+0x1>
    7062:	0e 94 12 23 	call	0x4624	; 0x4624 <xQueueSemaphoreTake>
			{
				Set1=EncoderInfo.Cnt1;
    7066:	26 01       	movw	r4, r12
    7068:	dd 0c       	add	r13, r13
    706a:	66 08       	sbc	r6, r6
    706c:	77 08       	sbc	r7, r7
	while (1)
	{		
			EncoderInfo=DriverMotorGetEncoder();

			//Process reset setpoint command
			if (xSemaphoreTake(ResetSetpointSema,0)==pdPASS)
    706e:	81 30       	cpi	r24, 0x01	; 1
    7070:	09 f4       	brne	.+2      	; 0x7074 <WorkerMotorPos+0x140>
    7072:	90 c0       	rjmp	.+288    	; 0x7194 <WorkerMotorPos+0x260>
    7074:	47 01       	movw	r8, r14
    7076:	ff 0c       	add	r15, r15
    7078:	aa 08       	sbc	r10, r10
    707a:	bb 08       	sbc	r11, r11
				Set1=EncoderInfo.Cnt1;
				Set2=EncoderInfo.Cnt2;
			}
			
			//Process setpoint increment data
			if (xQueueReceive(IncSetQueue,&IncSet,0)==pdPASS)
    707c:	40 e0       	ldi	r20, 0x00	; 0
    707e:	50 e0       	ldi	r21, 0x00	; 0
    7080:	be 01       	movw	r22, r28
    7082:	6f 5f       	subi	r22, 0xFF	; 255
    7084:	7f 4f       	sbci	r23, 0xFF	; 255
    7086:	80 91 ad 2d 	lds	r24, 0x2DAD	; 0x802dad <IncSetQueue>
    708a:	90 91 ae 2d 	lds	r25, 0x2DAE	; 0x802dae <IncSetQueue+0x1>
    708e:	0e 94 55 22 	call	0x44aa	; 0x44aa <xQueueReceive>
    7092:	81 30       	cpi	r24, 0x01	; 1
    7094:	09 f4       	brne	.+2      	; 0x7098 <WorkerMotorPos+0x164>
    7096:	49 c0       	rjmp	.+146    	; 0x712a <WorkerMotorPos+0x1f6>
				Set2+=((float) IncSet.IncSet2)/100;
			}
			
			//PID 1
			Err1=Set1-EncoderInfo.Cnt1;
			Out1=Err1*MOTPOS_KP;
    7098:	c3 01       	movw	r24, r6
    709a:	b2 01       	movw	r22, r4
    709c:	0e 94 49 44 	call	0x8892	; 0x8892 <__floatsisf>
    70a0:	9b 01       	movw	r18, r22
    70a2:	ac 01       	movw	r20, r24
    70a4:	6d 81       	ldd	r22, Y+5	; 0x05
    70a6:	7e 81       	ldd	r23, Y+6	; 0x06
    70a8:	8f 81       	ldd	r24, Y+7	; 0x07
    70aa:	98 85       	ldd	r25, Y+8	; 0x08
    70ac:	0e 94 2d 43 	call	0x865a	; 0x865a <__subsf3>
    70b0:	20 e0       	ldi	r18, 0x00	; 0
    70b2:	30 e0       	ldi	r19, 0x00	; 0
    70b4:	46 e9       	ldi	r20, 0x96	; 150
    70b6:	53 e4       	ldi	r21, 0x43	; 67
    70b8:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    70bc:	6b 01       	movw	r12, r22
    70be:	7c 01       	movw	r14, r24
			if (Out1>0) Out1+=MOTPOS_FF_OFFSET;
    70c0:	20 e0       	ldi	r18, 0x00	; 0
    70c2:	30 e0       	ldi	r19, 0x00	; 0
    70c4:	a9 01       	movw	r20, r18
    70c6:	0e 94 f9 44 	call	0x89f2	; 0x89f2 <__gesf2>
    70ca:	18 16       	cp	r1, r24
    70cc:	54 f4       	brge	.+20     	; 0x70e2 <WorkerMotorPos+0x1ae>
    70ce:	20 e0       	ldi	r18, 0x00	; 0
    70d0:	30 e8       	ldi	r19, 0x80	; 128
    70d2:	4b eb       	ldi	r20, 0xBB	; 187
    70d4:	54 e4       	ldi	r21, 0x44	; 68
    70d6:	c7 01       	movw	r24, r14
    70d8:	b6 01       	movw	r22, r12
    70da:	0e 94 2e 43 	call	0x865c	; 0x865c <__addsf3>
    70de:	6b 01       	movw	r12, r22
    70e0:	7c 01       	movw	r14, r24
			if (Out1>4095) Out1=4095;
    70e2:	20 e0       	ldi	r18, 0x00	; 0
    70e4:	30 ef       	ldi	r19, 0xF0	; 240
    70e6:	4f e7       	ldi	r20, 0x7F	; 127
    70e8:	55 e4       	ldi	r21, 0x45	; 69
    70ea:	c7 01       	movw	r24, r14
    70ec:	b6 01       	movw	r22, r12
    70ee:	0e 94 f9 44 	call	0x89f2	; 0x89f2 <__gesf2>
    70f2:	18 16       	cp	r1, r24
    70f4:	0c f0       	brlt	.+2      	; 0x70f8 <WorkerMotorPos+0x1c4>
    70f6:	34 cf       	rjmp	.-408    	; 0x6f60 <WorkerMotorPos+0x2c>
    70f8:	c1 2c       	mov	r12, r1
    70fa:	90 ef       	ldi	r25, 0xF0	; 240
    70fc:	d9 2e       	mov	r13, r25
    70fe:	9f e7       	ldi	r25, 0x7F	; 127
    7100:	e9 2e       	mov	r14, r25
    7102:	95 e4       	ldi	r25, 0x45	; 69
    7104:	f9 2e       	mov	r15, r25
    7106:	c7 01       	movw	r24, r14
    7108:	b6 01       	movw	r22, r12
    710a:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
    710e:	8b 01       	movw	r16, r22
    7110:	46 cf       	rjmp	.-372    	; 0x6f9e <WorkerMotorPos+0x6a>

			//PID 2
			Err2=Set2-EncoderInfo.Cnt2;
			Out2=Err2*MOTPOS_KP;
			if (Out2>0) Out2+=MOTPOS_FF_OFFSET;
			if (Out2>4095) Out2=4095;
    7112:	c1 2c       	mov	r12, r1
    7114:	80 ef       	ldi	r24, 0xF0	; 240
    7116:	d8 2e       	mov	r13, r24
    7118:	8f e7       	ldi	r24, 0x7F	; 127
    711a:	e8 2e       	mov	r14, r24
    711c:	85 e4       	ldi	r24, 0x45	; 69
    711e:	f8 2e       	mov	r15, r24
    7120:	c7 01       	movw	r24, r14
    7122:	b6 01       	movw	r22, r12
    7124:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
    7128:	89 cf       	rjmp	.-238    	; 0x703c <WorkerMotorPos+0x108>
			}
			
			//Process setpoint increment data
			if (xQueueReceive(IncSetQueue,&IncSet,0)==pdPASS)
			{
				Set1+=((float) IncSet.IncSet1)/100;
    712a:	69 81       	ldd	r22, Y+1	; 0x01
    712c:	7a 81       	ldd	r23, Y+2	; 0x02
    712e:	07 2e       	mov	r0, r23
    7130:	00 0c       	add	r0, r0
    7132:	88 0b       	sbc	r24, r24
    7134:	99 0b       	sbc	r25, r25
    7136:	0e 94 49 44 	call	0x8892	; 0x8892 <__floatsisf>
    713a:	20 e0       	ldi	r18, 0x00	; 0
    713c:	30 e0       	ldi	r19, 0x00	; 0
    713e:	48 ec       	ldi	r20, 0xC8	; 200
    7140:	52 e4       	ldi	r21, 0x42	; 66
    7142:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    7146:	9b 01       	movw	r18, r22
    7148:	ac 01       	movw	r20, r24
    714a:	6d 81       	ldd	r22, Y+5	; 0x05
    714c:	7e 81       	ldd	r23, Y+6	; 0x06
    714e:	8f 81       	ldd	r24, Y+7	; 0x07
    7150:	98 85       	ldd	r25, Y+8	; 0x08
    7152:	0e 94 2e 43 	call	0x865c	; 0x865c <__addsf3>
    7156:	6d 83       	std	Y+5, r22	; 0x05
    7158:	7e 83       	std	Y+6, r23	; 0x06
    715a:	8f 83       	std	Y+7, r24	; 0x07
    715c:	98 87       	std	Y+8, r25	; 0x08
				Set2+=((float) IncSet.IncSet2)/100;
    715e:	6b 81       	ldd	r22, Y+3	; 0x03
    7160:	7c 81       	ldd	r23, Y+4	; 0x04
    7162:	07 2e       	mov	r0, r23
    7164:	00 0c       	add	r0, r0
    7166:	88 0b       	sbc	r24, r24
    7168:	99 0b       	sbc	r25, r25
    716a:	0e 94 49 44 	call	0x8892	; 0x8892 <__floatsisf>
    716e:	20 e0       	ldi	r18, 0x00	; 0
    7170:	30 e0       	ldi	r19, 0x00	; 0
    7172:	48 ec       	ldi	r20, 0xC8	; 200
    7174:	52 e4       	ldi	r21, 0x42	; 66
    7176:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    717a:	9b 01       	movw	r18, r22
    717c:	ac 01       	movw	r20, r24
    717e:	69 85       	ldd	r22, Y+9	; 0x09
    7180:	7a 85       	ldd	r23, Y+10	; 0x0a
    7182:	8b 85       	ldd	r24, Y+11	; 0x0b
    7184:	9c 85       	ldd	r25, Y+12	; 0x0c
    7186:	0e 94 2e 43 	call	0x865c	; 0x865c <__addsf3>
    718a:	69 87       	std	Y+9, r22	; 0x09
    718c:	7a 87       	std	Y+10, r23	; 0x0a
    718e:	8b 87       	std	Y+11, r24	; 0x0b
    7190:	9c 87       	std	Y+12, r25	; 0x0c
    7192:	82 cf       	rjmp	.-252    	; 0x7098 <WorkerMotorPos+0x164>
			EncoderInfo=DriverMotorGetEncoder();

			//Process reset setpoint command
			if (xSemaphoreTake(ResetSetpointSema,0)==pdPASS)
			{
				Set1=EncoderInfo.Cnt1;
    7194:	c3 01       	movw	r24, r6
    7196:	b2 01       	movw	r22, r4
    7198:	0e 94 49 44 	call	0x8892	; 0x8892 <__floatsisf>
    719c:	6d 83       	std	Y+5, r22	; 0x05
    719e:	7e 83       	std	Y+6, r23	; 0x06
    71a0:	8f 83       	std	Y+7, r24	; 0x07
    71a2:	98 87       	std	Y+8, r25	; 0x08
				Set2=EncoderInfo.Cnt2;
    71a4:	47 01       	movw	r8, r14
    71a6:	ff 0c       	add	r15, r15
    71a8:	aa 08       	sbc	r10, r10
    71aa:	bb 08       	sbc	r11, r11
    71ac:	c5 01       	movw	r24, r10
    71ae:	b4 01       	movw	r22, r8
    71b0:	0e 94 49 44 	call	0x8892	; 0x8892 <__floatsisf>
    71b4:	69 87       	std	Y+9, r22	; 0x09
    71b6:	7a 87       	std	Y+10, r23	; 0x0a
    71b8:	8b 87       	std	Y+11, r24	; 0x0b
    71ba:	9c 87       	std	Y+12, r25	; 0x0c
    71bc:	5f cf       	rjmp	.-322    	; 0x707c <WorkerMotorPos+0x148>

000071be <EnableMotorPosTask>:
	vSemaphoreCreateBinary(ResetSetpointSema);
}

void EnableMotorPosTask()
{
	DriverMotorResetEncoder();
    71be:	0e 94 ac 09 	call	0x1358	; 0x1358 <DriverMotorResetEncoder>
	xSemaphoreGive(ResetSetpointSema);
    71c2:	20 e0       	ldi	r18, 0x00	; 0
    71c4:	40 e0       	ldi	r20, 0x00	; 0
    71c6:	50 e0       	ldi	r21, 0x00	; 0
    71c8:	60 e0       	ldi	r22, 0x00	; 0
    71ca:	70 e0       	ldi	r23, 0x00	; 0
    71cc:	80 91 af 2d 	lds	r24, 0x2DAF	; 0x802daf <ResetSetpointSema>
    71d0:	90 91 b0 2d 	lds	r25, 0x2DB0	; 0x802db0 <ResetSetpointSema+0x1>
    71d4:	0e 94 be 20 	call	0x417c	; 0x417c <xQueueGenericSend>
	xLastWakeTime = xTaskGetTickCount();
    71d8:	0e 94 54 29 	call	0x52a8	; 0x52a8 <xTaskGetTickCount>
    71dc:	80 93 a9 2d 	sts	0x2DA9, r24	; 0x802da9 <xLastWakeTime>
    71e0:	90 93 aa 2d 	sts	0x2DAA, r25	; 0x802daa <xLastWakeTime+0x1>
	vTaskResume(MotorPosTaskHandle);
    71e4:	80 91 ab 2d 	lds	r24, 0x2DAB	; 0x802dab <MotorPosTaskHandle>
    71e8:	90 91 ac 2d 	lds	r25, 0x2DAC	; 0x802dac <MotorPosTaskHandle+0x1>
    71ec:	0c 94 c7 28 	jmp	0x518e	; 0x518e <vTaskResume>

000071f0 <DisableMotorPosTask>:
}

void DisableMotorPosTask()
{
	vTaskSuspend(MotorPosTaskHandle);
    71f0:	80 91 ab 2d 	lds	r24, 0x2DAB	; 0x802dab <MotorPosTaskHandle>
    71f4:	90 91 ac 2d 	lds	r25, 0x2DAC	; 0x802dac <MotorPosTaskHandle+0x1>
    71f8:	0e 94 4a 28 	call	0x5094	; 0x5094 <vTaskSuspend>
	DriverMotorSet(0,0);
    71fc:	60 e0       	ldi	r22, 0x00	; 0
    71fe:	70 e0       	ldi	r23, 0x00	; 0
    7200:	80 e0       	ldi	r24, 0x00	; 0
    7202:	90 e0       	ldi	r25, 0x00	; 0
    7204:	0c 94 d6 06 	jmp	0xdac	; 0xdac <DriverMotorSet>

00007208 <InitMotorPosTask>:
//Private function prototypes
void WorkerMotorPos(void *pvParameters);

//Function definitions
void InitMotorPosTask()
{
    7208:	ef 92       	push	r14
    720a:	ff 92       	push	r15
    720c:	0f 93       	push	r16
	DriverMotorInit();
    720e:	0e 94 a5 06 	call	0xd4a	; 0xd4a <DriverMotorInit>
	xTaskCreate( WorkerMotorPos, "motpos", 256, NULL, tskIDLE_PRIORITY+3, &MotorPosTaskHandle );
    7212:	8b ea       	ldi	r24, 0xAB	; 171
    7214:	e8 2e       	mov	r14, r24
    7216:	8d e2       	ldi	r24, 0x2D	; 45
    7218:	f8 2e       	mov	r15, r24
    721a:	03 e0       	ldi	r16, 0x03	; 3
    721c:	20 e0       	ldi	r18, 0x00	; 0
    721e:	30 e0       	ldi	r19, 0x00	; 0
    7220:	40 e0       	ldi	r20, 0x00	; 0
    7222:	51 e0       	ldi	r21, 0x01	; 1
    7224:	6f e7       	ldi	r22, 0x7F	; 127
    7226:	76 e2       	ldi	r23, 0x26	; 38
    7228:	8a e9       	ldi	r24, 0x9A	; 154
    722a:	97 e3       	ldi	r25, 0x37	; 55
    722c:	0e 94 c8 26 	call	0x4d90	; 0x4d90 <xTaskCreate>
	DisableMotorPosTask(); 	
    7230:	0e 94 f8 38 	call	0x71f0	; 0x71f0 <DisableMotorPosTask>
	
	IncSetQueue=xQueueCreate(1,sizeof(IncSetStruct));
    7234:	40 e0       	ldi	r20, 0x00	; 0
    7236:	64 e0       	ldi	r22, 0x04	; 4
    7238:	81 e0       	ldi	r24, 0x01	; 1
    723a:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueGenericCreate>
    723e:	80 93 ad 2d 	sts	0x2DAD, r24	; 0x802dad <IncSetQueue>
    7242:	90 93 ae 2d 	sts	0x2DAE, r25	; 0x802dae <IncSetQueue+0x1>
	vSemaphoreCreateBinary(ResetSetpointSema);
    7246:	43 e0       	ldi	r20, 0x03	; 3
    7248:	60 e0       	ldi	r22, 0x00	; 0
    724a:	81 e0       	ldi	r24, 0x01	; 1
    724c:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueGenericCreate>
    7250:	80 93 af 2d 	sts	0x2DAF, r24	; 0x802daf <ResetSetpointSema>
    7254:	90 93 b0 2d 	sts	0x2DB0, r25	; 0x802db0 <ResetSetpointSema+0x1>
    7258:	00 97       	sbiw	r24, 0x00	; 0
    725a:	51 f0       	breq	.+20     	; 0x7270 <InitMotorPosTask+0x68>
    725c:	20 e0       	ldi	r18, 0x00	; 0
    725e:	40 e0       	ldi	r20, 0x00	; 0
    7260:	50 e0       	ldi	r21, 0x00	; 0
    7262:	60 e0       	ldi	r22, 0x00	; 0
    7264:	70 e0       	ldi	r23, 0x00	; 0
}
    7266:	0f 91       	pop	r16
    7268:	ff 90       	pop	r15
    726a:	ef 90       	pop	r14
	DriverMotorInit();
	xTaskCreate( WorkerMotorPos, "motpos", 256, NULL, tskIDLE_PRIORITY+3, &MotorPosTaskHandle );
	DisableMotorPosTask(); 	
	
	IncSetQueue=xQueueCreate(1,sizeof(IncSetStruct));
	vSemaphoreCreateBinary(ResetSetpointSema);
    726c:	0c 94 be 20 	jmp	0x417c	; 0x417c <xQueueGenericSend>
}
    7270:	0f 91       	pop	r16
    7272:	ff 90       	pop	r15
    7274:	ef 90       	pop	r14
    7276:	08 95       	ret

00007278 <MotorPosIncSet>:
	DriverMotorSet(0,0);
}


void MotorPosIncSet(int16_t IncSet1,int16_t IncSet2)
{
    7278:	cf 93       	push	r28
    727a:	df 93       	push	r29
    727c:	00 d0       	rcall	.+0      	; 0x727e <MotorPosIncSet+0x6>
    727e:	1f 92       	push	r1
    7280:	cd b7       	in	r28, 0x3d	; 61
    7282:	de b7       	in	r29, 0x3e	; 62
	IncSetStruct IncSet;
	IncSet.IncSet1=IncSet1;
    7284:	89 83       	std	Y+1, r24	; 0x01
    7286:	9a 83       	std	Y+2, r25	; 0x02
	IncSet.IncSet2=IncSet2;
    7288:	6b 83       	std	Y+3, r22	; 0x03
    728a:	7c 83       	std	Y+4, r23	; 0x04
	xQueueSend(IncSetQueue,&IncSet,portMAX_DELAY);
    728c:	20 e0       	ldi	r18, 0x00	; 0
    728e:	4f ef       	ldi	r20, 0xFF	; 255
    7290:	5f ef       	ldi	r21, 0xFF	; 255
    7292:	be 01       	movw	r22, r28
    7294:	6f 5f       	subi	r22, 0xFF	; 255
    7296:	7f 4f       	sbci	r23, 0xFF	; 255
    7298:	80 91 ad 2d 	lds	r24, 0x2DAD	; 0x802dad <IncSetQueue>
    729c:	90 91 ae 2d 	lds	r25, 0x2DAE	; 0x802dae <IncSetQueue+0x1>
    72a0:	0e 94 be 20 	call	0x417c	; 0x417c <xQueueGenericSend>
}
    72a4:	24 96       	adiw	r28, 0x04	; 4
    72a6:	cd bf       	out	0x3d, r28	; 61
    72a8:	de bf       	out	0x3e, r29	; 62
    72aa:	df 91       	pop	r29
    72ac:	cf 91       	pop	r28
    72ae:	08 95       	ret

000072b0 <WorkerMotorSpeed>:
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
	
}

void WorkerMotorSpeed(void *pvParameters)
{
    72b0:	cf 93       	push	r28
    72b2:	df 93       	push	r29
    72b4:	00 d0       	rcall	.+0      	; 0x72b6 <WorkerMotorSpeed+0x6>
    72b6:	1f 92       	push	r1
    72b8:	cd b7       	in	r28, 0x3d	; 61
    72ba:	de b7       	in	r29, 0x3e	; 62
	const TickType_t xPeriod = 10;
	MotorSpeedStruct MotorSpeed;

	xLastWakeTime = xTaskGetTickCount();
    72bc:	0e 94 54 29 	call	0x52a8	; 0x52a8 <xTaskGetTickCount>
    72c0:	80 93 b1 2d 	sts	0x2DB1, r24	; 0x802db1 <xLastWakeTime>
    72c4:	90 93 b2 2d 	sts	0x2DB2, r25	; 0x802db2 <xLastWakeTime+0x1>
	
	while (1)
	{
			xQueuePeek(MotorSpeedQueue,&MotorSpeed,portMAX_DELAY);
    72c8:	4f ef       	ldi	r20, 0xFF	; 255
    72ca:	5f ef       	ldi	r21, 0xFF	; 255
    72cc:	be 01       	movw	r22, r28
    72ce:	6f 5f       	subi	r22, 0xFF	; 255
    72d0:	7f 4f       	sbci	r23, 0xFF	; 255
    72d2:	80 91 b5 2d 	lds	r24, 0x2DB5	; 0x802db5 <MotorSpeedQueue>
    72d6:	90 91 b6 2d 	lds	r25, 0x2DB6	; 0x802db6 <MotorSpeedQueue+0x1>
    72da:	0e 94 0c 24 	call	0x4818	; 0x4818 <xQueuePeek>
			MotorPosIncSet(MotorSpeed.Speed1,MotorSpeed.Speed2);
    72de:	6b 81       	ldd	r22, Y+3	; 0x03
    72e0:	7c 81       	ldd	r23, Y+4	; 0x04
    72e2:	89 81       	ldd	r24, Y+1	; 0x01
    72e4:	9a 81       	ldd	r25, Y+2	; 0x02
    72e6:	0e 94 3c 39 	call	0x7278	; 0x7278 <MotorPosIncSet>
			
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
    72ea:	6a e0       	ldi	r22, 0x0A	; 10
    72ec:	70 e0       	ldi	r23, 0x00	; 0
    72ee:	81 eb       	ldi	r24, 0xB1	; 177
    72f0:	9d e2       	ldi	r25, 0x2D	; 45
    72f2:	0e 94 d9 2a 	call	0x55b2	; 0x55b2 <vTaskDelayUntil>
    72f6:	e8 cf       	rjmp	.-48     	; 0x72c8 <WorkerMotorSpeed+0x18>

000072f8 <InitMotorSpeedTask>:
//Private function prototypes
void WorkerMotorSpeed(void *pvParameters);

//Function definitions
void InitMotorSpeedTask()
{
    72f8:	ef 92       	push	r14
    72fa:	ff 92       	push	r15
    72fc:	0f 93       	push	r16
	xTaskCreate( WorkerMotorSpeed, "motspd", 256, NULL, tskIDLE_PRIORITY+3, &MotorSpeedTaskHandle );	
    72fe:	83 eb       	ldi	r24, 0xB3	; 179
    7300:	e8 2e       	mov	r14, r24
    7302:	8d e2       	ldi	r24, 0x2D	; 45
    7304:	f8 2e       	mov	r15, r24
    7306:	03 e0       	ldi	r16, 0x03	; 3
    7308:	20 e0       	ldi	r18, 0x00	; 0
    730a:	30 e0       	ldi	r19, 0x00	; 0
    730c:	40 e0       	ldi	r20, 0x00	; 0
    730e:	51 e0       	ldi	r21, 0x01	; 1
    7310:	66 e8       	ldi	r22, 0x86	; 134
    7312:	76 e2       	ldi	r23, 0x26	; 38
    7314:	88 e5       	ldi	r24, 0x58	; 88
    7316:	99 e3       	ldi	r25, 0x39	; 57
    7318:	0e 94 c8 26 	call	0x4d90	; 0x4d90 <xTaskCreate>
	vTaskResume(MotorSpeedTaskHandle);
}

void DisableMotorSpeedTask()
{
	vTaskSuspend(MotorSpeedTaskHandle);
    731c:	80 91 b3 2d 	lds	r24, 0x2DB3	; 0x802db3 <MotorSpeedTaskHandle>
    7320:	90 91 b4 2d 	lds	r25, 0x2DB4	; 0x802db4 <MotorSpeedTaskHandle+0x1>
    7324:	0e 94 4a 28 	call	0x5094	; 0x5094 <vTaskSuspend>
void InitMotorSpeedTask()
{
	xTaskCreate( WorkerMotorSpeed, "motspd", 256, NULL, tskIDLE_PRIORITY+3, &MotorSpeedTaskHandle );	
	DisableMotorSpeedTask();
	
	MotorSpeedQueue=xQueueCreate(1,sizeof(MotorSpeedStruct));
    7328:	40 e0       	ldi	r20, 0x00	; 0
    732a:	64 e0       	ldi	r22, 0x04	; 4
    732c:	81 e0       	ldi	r24, 0x01	; 1
    732e:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueGenericCreate>
    7332:	80 93 b5 2d 	sts	0x2DB5, r24	; 0x802db5 <MotorSpeedQueue>
    7336:	90 93 b6 2d 	sts	0x2DB6, r25	; 0x802db6 <MotorSpeedQueue+0x1>
}

void MotorSpeedSet(int16_t Speed1,int16_t Speed2)
{
	
	MotorSpeed.Speed1=Speed1;
    733a:	e7 eb       	ldi	r30, 0xB7	; 183
    733c:	fd e2       	ldi	r31, 0x2D	; 45
    733e:	10 82       	st	Z, r1
    7340:	11 82       	std	Z+1, r1	; 0x01
	MotorSpeed.Speed2=Speed2;
    7342:	12 82       	std	Z+2, r1	; 0x02
    7344:	13 82       	std	Z+3, r1	; 0x03
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
    7346:	22 e0       	ldi	r18, 0x02	; 2
    7348:	40 e0       	ldi	r20, 0x00	; 0
    734a:	50 e0       	ldi	r21, 0x00	; 0
    734c:	bf 01       	movw	r22, r30
	xTaskCreate( WorkerMotorSpeed, "motspd", 256, NULL, tskIDLE_PRIORITY+3, &MotorSpeedTaskHandle );	
	DisableMotorSpeedTask();
	
	MotorSpeedQueue=xQueueCreate(1,sizeof(MotorSpeedStruct));
	MotorSpeedSet(0,0);
}
    734e:	0f 91       	pop	r16
    7350:	ff 90       	pop	r15
    7352:	ef 90       	pop	r14
void MotorSpeedSet(int16_t Speed1,int16_t Speed2)
{
	
	MotorSpeed.Speed1=Speed1;
	MotorSpeed.Speed2=Speed2;
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
    7354:	0c 94 be 20 	jmp	0x417c	; 0x417c <xQueueGenericSend>

00007358 <EnableMotorSpeedTask>:
	MotorSpeedSet(0,0);
}

void EnableMotorSpeedTask()
{
	xLastWakeTime = xTaskGetTickCount();
    7358:	0e 94 54 29 	call	0x52a8	; 0x52a8 <xTaskGetTickCount>
    735c:	80 93 b1 2d 	sts	0x2DB1, r24	; 0x802db1 <xLastWakeTime>
    7360:	90 93 b2 2d 	sts	0x2DB2, r25	; 0x802db2 <xLastWakeTime+0x1>
	vTaskResume(MotorSpeedTaskHandle);
    7364:	80 91 b3 2d 	lds	r24, 0x2DB3	; 0x802db3 <MotorSpeedTaskHandle>
    7368:	90 91 b4 2d 	lds	r25, 0x2DB4	; 0x802db4 <MotorSpeedTaskHandle+0x1>
    736c:	0c 94 c7 28 	jmp	0x518e	; 0x518e <vTaskResume>

00007370 <DisableMotorSpeedTask>:
}

void DisableMotorSpeedTask()
{
	vTaskSuspend(MotorSpeedTaskHandle);
    7370:	80 91 b3 2d 	lds	r24, 0x2DB3	; 0x802db3 <MotorSpeedTaskHandle>
    7374:	90 91 b4 2d 	lds	r25, 0x2DB4	; 0x802db4 <MotorSpeedTaskHandle+0x1>
    7378:	0c 94 4a 28 	jmp	0x5094	; 0x5094 <vTaskSuspend>

0000737c <MotorSpeedSet>:
}

void MotorSpeedSet(int16_t Speed1,int16_t Speed2)
{
	
	MotorSpeed.Speed1=Speed1;
    737c:	e7 eb       	ldi	r30, 0xB7	; 183
    737e:	fd e2       	ldi	r31, 0x2D	; 45
    7380:	80 83       	st	Z, r24
    7382:	91 83       	std	Z+1, r25	; 0x01
	MotorSpeed.Speed2=Speed2;
    7384:	62 83       	std	Z+2, r22	; 0x02
    7386:	73 83       	std	Z+3, r23	; 0x03
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
    7388:	22 e0       	ldi	r18, 0x02	; 2
    738a:	40 e0       	ldi	r20, 0x00	; 0
    738c:	50 e0       	ldi	r21, 0x00	; 0
    738e:	bf 01       	movw	r22, r30
    7390:	80 91 b5 2d 	lds	r24, 0x2DB5	; 0x802db5 <MotorSpeedQueue>
    7394:	90 91 b6 2d 	lds	r25, 0x2DB6	; 0x802db6 <MotorSpeedQueue+0x1>
    7398:	0c 94 be 20 	jmp	0x417c	; 0x417c <xQueueGenericSend>

0000739c <InitOLEDMenuTask>:
}

void UpMenu()
{
	if (SelItem>0) SelItem--;
	if (SelItem<TopItem) TopItem=SelItem;
    739c:	ef 92       	push	r14
    739e:	ff 92       	push	r15
    73a0:	0f 93       	push	r16
    73a2:	e1 2c       	mov	r14, r1
    73a4:	f1 2c       	mov	r15, r1
    73a6:	02 e0       	ldi	r16, 0x02	; 2
    73a8:	20 e0       	ldi	r18, 0x00	; 0
    73aa:	30 e0       	ldi	r19, 0x00	; 0
    73ac:	40 e0       	ldi	r20, 0x00	; 0
    73ae:	54 e0       	ldi	r21, 0x04	; 4
    73b0:	6d e8       	ldi	r22, 0x8D	; 141
    73b2:	76 e2       	ldi	r23, 0x26	; 38
    73b4:	86 e3       	ldi	r24, 0x36	; 54
    73b6:	9f e3       	ldi	r25, 0x3F	; 63
    73b8:	0e 94 c8 26 	call	0x4d90	; 0x4d90 <xTaskCreate>
    73bc:	0f 91       	pop	r16
    73be:	ff 90       	pop	r15
    73c0:	ef 90       	pop	r14
    73c2:	08 95       	ret

000073c4 <DrawMenu>:
    73c4:	0f 93       	push	r16
    73c6:	1f 93       	push	r17
    73c8:	cf 93       	push	r28
    73ca:	df 93       	push	r29
    73cc:	d0 91 bc 2d 	lds	r29, 0x2DBC	; 0x802dbc <TopItem>
    73d0:	15 e0       	ldi	r17, 0x05	; 5
    73d2:	1d 0f       	add	r17, r29
    73d4:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <DriverOLEDClearScreen>
    73d8:	1d 17       	cp	r17, r29
    73da:	78 f0       	brcs	.+30     	; 0x73fa <DrawMenu+0x36>
    73dc:	cd 2f       	mov	r28, r29
    73de:	04 e1       	ldi	r16, 0x14	; 20
    73e0:	0c 9f       	mul	r16, r28
    73e2:	b0 01       	movw	r22, r0
    73e4:	11 24       	eor	r1, r1
    73e6:	6a 5e       	subi	r22, 0xEA	; 234
    73e8:	7f 4d       	sbci	r23, 0xDF	; 223
    73ea:	40 e0       	ldi	r20, 0x00	; 0
    73ec:	8c 2f       	mov	r24, r28
    73ee:	8d 1b       	sub	r24, r29
    73f0:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
    73f4:	cf 5f       	subi	r28, 0xFF	; 255
    73f6:	1c 17       	cp	r17, r28
    73f8:	98 f7       	brcc	.-26     	; 0x73e0 <DrawMenu+0x1c>
    73fa:	60 91 bb 2d 	lds	r22, 0x2DBB	; 0x802dbb <SelItem>
    73fe:	80 91 bc 2d 	lds	r24, 0x2DBC	; 0x802dbc <TopItem>
    7402:	68 1b       	sub	r22, r24
    7404:	20 e0       	ldi	r18, 0x00	; 0
    7406:	4a e2       	ldi	r20, 0x2A	; 42
    7408:	80 e0       	ldi	r24, 0x00	; 0
    740a:	0e 94 10 0d 	call	0x1a20	; 0x1a20 <DriverOLEDPrintSmChar>
    740e:	df 91       	pop	r29
    7410:	cf 91       	pop	r28
    7412:	1f 91       	pop	r17
    7414:	0f 91       	pop	r16
    7416:	0c 94 c5 0c 	jmp	0x198a	; 0x198a <DriverOLEDUpdate>

0000741a <PageCPUStatus>:
}

void PageCPUStatus()
{
    741a:	2f 92       	push	r2
    741c:	3f 92       	push	r3
    741e:	4f 92       	push	r4
    7420:	5f 92       	push	r5
    7422:	6f 92       	push	r6
    7424:	7f 92       	push	r7
    7426:	8f 92       	push	r8
    7428:	9f 92       	push	r9
    742a:	af 92       	push	r10
    742c:	bf 92       	push	r11
    742e:	cf 92       	push	r12
    7430:	df 92       	push	r13
    7432:	ef 92       	push	r14
    7434:	ff 92       	push	r15
    7436:	0f 93       	push	r16
    7438:	1f 93       	push	r17
    743a:	cf 93       	push	r28
    743c:	df 93       	push	r29
    743e:	cd b7       	in	r28, 0x3d	; 61
    7440:	de b7       	in	r29, 0x3e	; 62
    7442:	c4 57       	subi	r28, 0x74	; 116
    7444:	d1 40       	sbci	r29, 0x01	; 1
    7446:	cd bf       	out	0x3d, r28	; 61
    7448:	de bf       	out	0x3e, r29	; 62
	float Load;
	
	uint32_t IdleTime;
	uint32_t OldTotalRunTime=0,OldIdleTime=0;
	
	vTaskDelay(300);
    744a:	8c e2       	ldi	r24, 0x2C	; 44
    744c:	91 e0       	ldi	r25, 0x01	; 1
    744e:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
	uint32_t TotalRunTime;
	int NumTasks;
	float Load;
	
	uint32_t IdleTime;
	uint32_t OldTotalRunTime=0,OldIdleTime=0;
    7452:	41 2c       	mov	r4, r1
    7454:	51 2c       	mov	r5, r1
    7456:	32 01       	movw	r6, r4
    7458:	81 2c       	mov	r8, r1
    745a:	91 2c       	mov	r9, r1
    745c:	54 01       	movw	r10, r8
		
		
		DriverOLEDClearScreen();
		
		DriverOLEDPrintSmText(0,"Mem free:",0);
		sprintf (s,"%6u/%6u",xPortGetFreeHeapSize(),configTOTAL_HEAP_SIZE);
    745e:	8f e9       	ldi	r24, 0x9F	; 159
    7460:	28 2e       	mov	r2, r24
    7462:	86 e2       	ldi	r24, 0x26	; 38
    7464:	38 2e       	mov	r3, r24
    7466:	8e 01       	movw	r16, r28
    7468:	0f 5b       	subi	r16, 0xBF	; 191
    746a:	1e 4f       	sbci	r17, 0xFE	; 254
    746c:	8f c0       	rjmp	.+286    	; 0x758c <PageCPUStatus+0x172>
	{
		Stick=DriverCursorStickGetFifo(300);
		if (Stick & CURSOR_PRESS) break;
		
		
		DriverOLEDClearScreen();
    746e:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <DriverOLEDClearScreen>
		
		DriverOLEDPrintSmText(0,"Mem free:",0);
    7472:	40 e0       	ldi	r20, 0x00	; 0
    7474:	65 e9       	ldi	r22, 0x95	; 149
    7476:	76 e2       	ldi	r23, 0x26	; 38
    7478:	80 e0       	ldi	r24, 0x00	; 0
    747a:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		sprintf (s,"%6u/%6u",xPortGetFreeHeapSize(),configTOTAL_HEAP_SIZE);
    747e:	0e 94 de 1c 	call	0x39bc	; 0x39bc <xPortGetFreeHeapSize>
    7482:	20 e4       	ldi	r18, 0x40	; 64
    7484:	2f 93       	push	r18
    7486:	1f 92       	push	r1
    7488:	9f 93       	push	r25
    748a:	8f 93       	push	r24
    748c:	3f 92       	push	r3
    748e:	2f 92       	push	r2
    7490:	1f 93       	push	r17
    7492:	0f 93       	push	r16
    7494:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    7498:	40 e0       	ldi	r20, 0x00	; 0
    749a:	b8 01       	movw	r22, r16
    749c:	81 e0       	ldi	r24, 0x01	; 1
    749e:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		
		
		NumTasks=uxTaskGetSystemState(TaskStatusArray,MAX_TASKS,&TotalRunTime);
    74a2:	ae 01       	movw	r20, r28
    74a4:	4f 58       	subi	r20, 0x8F	; 143
    74a6:	5e 4f       	sbci	r21, 0xFE	; 254
    74a8:	64 e1       	ldi	r22, 0x14	; 20
    74aa:	ce 01       	movw	r24, r28
    74ac:	01 96       	adiw	r24, 0x01	; 1
    74ae:	0e 94 1b 2d 	call	0x5a36	; 0x5a36 <uxTaskGetSystemState>
		sprintf (s,"Number of tasks:%d",NumTasks);
    74b2:	1f 92       	push	r1
    74b4:	8f 93       	push	r24
    74b6:	87 ea       	ldi	r24, 0xA7	; 167
    74b8:	96 e2       	ldi	r25, 0x26	; 38
    74ba:	9f 93       	push	r25
    74bc:	8f 93       	push	r24
    74be:	1f 93       	push	r17
    74c0:	0f 93       	push	r16
    74c2:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(2,s,0);
    74c6:	40 e0       	ldi	r20, 0x00	; 0
    74c8:	b8 01       	movw	r22, r16
    74ca:	82 e0       	ldi	r24, 0x02	; 2
    74cc:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		
		//Calculate system load
		vTaskGetTaskInfo(xTaskGetIdleTaskHandle(),&IdleTaskStatus,pdFALSE,eInvalid);
    74d0:	0e 94 5e 29 	call	0x52bc	; 0x52bc <xTaskGetIdleTaskHandle>
    74d4:	25 e0       	ldi	r18, 0x05	; 5
    74d6:	40 e0       	ldi	r20, 0x00	; 0
    74d8:	be 01       	movw	r22, r28
    74da:	6f 59       	subi	r22, 0x9F	; 159
    74dc:	7e 4f       	sbci	r23, 0xFE	; 254
    74de:	0e 94 3b 2c 	call	0x5876	; 0x5876 <vTaskGetInfo>
		IdleTime=IdleTaskStatus.ulRunTimeCounter;
    74e2:	c7 59       	subi	r28, 0x97	; 151
    74e4:	de 4f       	sbci	r29, 0xFE	; 254
    74e6:	c8 80       	ld	r12, Y
    74e8:	d9 80       	ldd	r13, Y+1	; 0x01
    74ea:	ea 80       	ldd	r14, Y+2	; 0x02
    74ec:	fb 80       	ldd	r15, Y+3	; 0x03
    74ee:	c9 56       	subi	r28, 0x69	; 105
    74f0:	d1 40       	sbci	r29, 0x01	; 1
		Load=(1-((float) (IdleTime-OldIdleTime)/ (float)(TotalRunTime-OldTotalRunTime)))*100;
		sprintf(s,"CPU Load:%2.2f",Load);
    74f2:	c7 01       	movw	r24, r14
    74f4:	b6 01       	movw	r22, r12
    74f6:	64 19       	sub	r22, r4
    74f8:	75 09       	sbc	r23, r5
    74fa:	86 09       	sbc	r24, r6
    74fc:	97 09       	sbc	r25, r7
    74fe:	0e 94 47 44 	call	0x888e	; 0x888e <__floatunsisf>
    7502:	2b 01       	movw	r4, r22
    7504:	3c 01       	movw	r6, r24
    7506:	cf 58       	subi	r28, 0x8F	; 143
    7508:	de 4f       	sbci	r29, 0xFE	; 254
    750a:	88 81       	ld	r24, Y
    750c:	99 81       	ldd	r25, Y+1	; 0x01
    750e:	aa 81       	ldd	r26, Y+2	; 0x02
    7510:	bb 81       	ldd	r27, Y+3	; 0x03
    7512:	c1 57       	subi	r28, 0x71	; 113
    7514:	d1 40       	sbci	r29, 0x01	; 1
    7516:	bc 01       	movw	r22, r24
    7518:	cd 01       	movw	r24, r26
    751a:	68 19       	sub	r22, r8
    751c:	79 09       	sbc	r23, r9
    751e:	8a 09       	sbc	r24, r10
    7520:	9b 09       	sbc	r25, r11
    7522:	0e 94 47 44 	call	0x888e	; 0x888e <__floatunsisf>
    7526:	9b 01       	movw	r18, r22
    7528:	ac 01       	movw	r20, r24
    752a:	c3 01       	movw	r24, r6
    752c:	b2 01       	movw	r22, r4
    752e:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    7532:	9b 01       	movw	r18, r22
    7534:	ac 01       	movw	r20, r24
    7536:	60 e0       	ldi	r22, 0x00	; 0
    7538:	70 e0       	ldi	r23, 0x00	; 0
    753a:	80 e8       	ldi	r24, 0x80	; 128
    753c:	9f e3       	ldi	r25, 0x3F	; 63
    753e:	0e 94 2d 43 	call	0x865a	; 0x865a <__subsf3>
    7542:	20 e0       	ldi	r18, 0x00	; 0
    7544:	30 e0       	ldi	r19, 0x00	; 0
    7546:	48 ec       	ldi	r20, 0xC8	; 200
    7548:	52 e4       	ldi	r21, 0x42	; 66
    754a:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    754e:	9f 93       	push	r25
    7550:	8f 93       	push	r24
    7552:	7f 93       	push	r23
    7554:	6f 93       	push	r22
    7556:	8a eb       	ldi	r24, 0xBA	; 186
    7558:	96 e2       	ldi	r25, 0x26	; 38
    755a:	9f 93       	push	r25
    755c:	8f 93       	push	r24
    755e:	1f 93       	push	r17
    7560:	0f 93       	push	r16
    7562:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(3,s,0);
    7566:	40 e0       	ldi	r20, 0x00	; 0
    7568:	b8 01       	movw	r22, r16
    756a:	83 e0       	ldi	r24, 0x03	; 3
    756c:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		
		DriverOLEDUpdate();
    7570:	0e 94 c5 0c 	call	0x198a	; 0x198a <DriverOLEDUpdate>
		OldIdleTime=IdleTime;
		OldTotalRunTime=TotalRunTime;
    7574:	cf 58       	subi	r28, 0x8F	; 143
    7576:	de 4f       	sbci	r29, 0xFE	; 254
    7578:	88 80       	ld	r8, Y
    757a:	99 80       	ldd	r9, Y+1	; 0x01
    757c:	aa 80       	ldd	r10, Y+2	; 0x02
    757e:	bb 80       	ldd	r11, Y+3	; 0x03
    7580:	c1 57       	subi	r28, 0x71	; 113
    7582:	d1 40       	sbci	r29, 0x01	; 1
		
	}
    7584:	cd bf       	out	0x3d, r28	; 61
    7586:	de bf       	out	0x3e, r29	; 62
		Load=(1-((float) (IdleTime-OldIdleTime)/ (float)(TotalRunTime-OldTotalRunTime)))*100;
		sprintf(s,"CPU Load:%2.2f",Load);
		DriverOLEDPrintSmText(3,s,0);
		
		DriverOLEDUpdate();
		OldIdleTime=IdleTime;
    7588:	26 01       	movw	r4, r12
    758a:	37 01       	movw	r6, r14
	uint32_t OldTotalRunTime=0,OldIdleTime=0;
	
	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    758c:	8c e2       	ldi	r24, 0x2C	; 44
    758e:	91 e0       	ldi	r25, 0x01	; 1
    7590:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
		if (Stick & CURSOR_PRESS) break;
    7594:	80 ff       	sbrs	r24, 0
    7596:	6b cf       	rjmp	.-298    	; 0x746e <PageCPUStatus+0x54>
		OldIdleTime=IdleTime;
		OldTotalRunTime=TotalRunTime;
		
	}
	
}
    7598:	cc 58       	subi	r28, 0x8C	; 140
    759a:	de 4f       	sbci	r29, 0xFE	; 254
    759c:	cd bf       	out	0x3d, r28	; 61
    759e:	de bf       	out	0x3e, r29	; 62
    75a0:	df 91       	pop	r29
    75a2:	cf 91       	pop	r28
    75a4:	1f 91       	pop	r17
    75a6:	0f 91       	pop	r16
    75a8:	ff 90       	pop	r15
    75aa:	ef 90       	pop	r14
    75ac:	df 90       	pop	r13
    75ae:	cf 90       	pop	r12
    75b0:	bf 90       	pop	r11
    75b2:	af 90       	pop	r10
    75b4:	9f 90       	pop	r9
    75b6:	8f 90       	pop	r8
    75b8:	7f 90       	pop	r7
    75ba:	6f 90       	pop	r6
    75bc:	5f 90       	pop	r5
    75be:	4f 90       	pop	r4
    75c0:	3f 90       	pop	r3
    75c2:	2f 90       	pop	r2
    75c4:	08 95       	ret

000075c6 <PageMotorSpeed>:

void PageMotorSpeed()
{
    75c6:	2f 92       	push	r2
    75c8:	3f 92       	push	r3
    75ca:	4f 92       	push	r4
    75cc:	5f 92       	push	r5
    75ce:	6f 92       	push	r6
    75d0:	7f 92       	push	r7
    75d2:	8f 92       	push	r8
    75d4:	9f 92       	push	r9
    75d6:	af 92       	push	r10
    75d8:	bf 92       	push	r11
    75da:	cf 92       	push	r12
    75dc:	df 92       	push	r13
    75de:	ef 92       	push	r14
    75e0:	ff 92       	push	r15
    75e2:	0f 93       	push	r16
    75e4:	1f 93       	push	r17
    75e6:	cf 93       	push	r28
    75e8:	df 93       	push	r29
    75ea:	cd b7       	in	r28, 0x3d	; 61
    75ec:	de b7       	in	r29, 0x3e	; 62
    75ee:	c7 54       	subi	r28, 0x47	; 71
    75f0:	d1 09       	sbc	r29, r1
    75f2:	cd bf       	out	0x3d, r28	; 61
    75f4:	de bf       	out	0x3e, r29	; 62
	float Phase2;
	
	EncoderStruct EncoderInfo;
	EncoderEventStruct Event;
			
	EnableMotorPosTask();	
    75f6:	0e 94 df 38 	call	0x71be	; 0x71be <EnableMotorPosTask>
	EnableMotorSpeedTask();	
    75fa:	0e 94 ac 39 	call	0x7358	; 0x7358 <EnableMotorSpeedTask>
}

void PageMotorSpeed()
{
	uint8_t Stick;
	int16_t Speed1=50,Speed2=50;
    75fe:	82 e3       	ldi	r24, 0x32	; 50
    7600:	a8 2e       	mov	r10, r24
    7602:	b1 2c       	mov	r11, r1
    7604:	92 e3       	ldi	r25, 0x32	; 50
    7606:	c9 2e       	mov	r12, r25
    7608:	d1 2c       	mov	r13, r1
    760a:	9e 01       	movw	r18, r28
    760c:	2f 5f       	subi	r18, 0xFF	; 255
    760e:	3f 4f       	sbci	r19, 0xFF	; 255
    7610:	79 01       	movw	r14, r18
		sprintf(s,"  A2:%d",EncoderInfo.Cnt2);
		DriverOLEDPrintSmText(3,s,0);
		
		sprintf(s,"  P1:%f",Phase1);
		DriverOLEDPrintSmText(4,s,0);
		sprintf(s,"  P2:%f",Phase2);
    7612:	6a a6       	std	Y+42, r6	; 0x2a
    7614:	32 01       	movw	r6, r4
    7616:	21 01       	movw	r4, r2
			
	EnableMotorPosTask();	
	EnableMotorSpeedTask();	
	while (1)
	{
		EncoderInfo=DriverMotorGetEncoder();
    7618:	0e 94 41 07 	call	0xe82	; 0xe82 <DriverMotorGetEncoder>
    761c:	86 2e       	mov	r8, r22
    761e:	37 2e       	mov	r3, r23
    7620:	28 2e       	mov	r2, r24
    7622:	99 2e       	mov	r9, r25

		EdgeIdx1=0; EdgeIdx2=0;
    7624:	10 e0       	ldi	r17, 0x00	; 0
    7626:	00 e0       	ldi	r16, 0x00	; 0
		while(1) 
		{
			Event=DriverMotorGetEncoderEvent();
    7628:	0e 94 51 07 	call	0xea2	; 0xea2 <DriverMotorGetEncoderEvent>
    762c:	29 a3       	std	Y+33, r18	; 0x21
    762e:	3a a3       	std	Y+34, r19	; 0x22
    7630:	4b a3       	std	Y+35, r20	; 0x23
    7632:	5c a3       	std	Y+36, r21	; 0x24
    7634:	89 a1       	ldd	r24, Y+33	; 0x21
    7636:	9a a1       	ldd	r25, Y+34	; 0x22
    7638:	ab a1       	ldd	r26, Y+35	; 0x23
    763a:	bc a1       	ldd	r27, Y+36	; 0x24
			if (Event.Time==0) break; //No more events
    763c:	00 97       	sbiw	r24, 0x00	; 0
    763e:	a1 05       	cpc	r26, r1
    7640:	b1 05       	cpc	r27, r1
    7642:	09 f4       	brne	.+2      	; 0x7646 <PageMotorSpeed+0x80>
    7644:	40 c0       	rjmp	.+128    	; 0x76c6 <PageMotorSpeed+0x100>
			
			//Parse events for encoder 1
			if (EdgeIdx1==0)
    7646:	01 11       	cpse	r16, r1
    7648:	0c c0       	rjmp	.+24     	; 0x7662 <PageMotorSpeed+0x9c>
			{
				if (Event.Event==RISING_1A)
    764a:	61 30       	cpi	r22, 0x01	; 1
    764c:	c1 f1       	breq	.+112    	; 0x76be <PageMotorSpeed+0xf8>
					EdgeIdx1++;
				}
			}

			//Parse events for encoder 2
			if (EdgeIdx2==0)
    764e:	11 11       	cpse	r17, r1
    7650:	17 c0       	rjmp	.+46     	; 0x7680 <PageMotorSpeed+0xba>
			{
				if (Event.Event==RISING_2A)
    7652:	63 30       	cpi	r22, 0x03	; 3
    7654:	49 f7       	brne	.-46     	; 0x7628 <PageMotorSpeed+0x62>
    7656:	8e a3       	std	Y+38, r24	; 0x26
    7658:	9f a3       	std	Y+39, r25	; 0x27
    765a:	a8 a7       	std	Y+40, r26	; 0x28
    765c:	b9 a7       	std	Y+41, r27	; 0x29
				{
					EdgeList2[0]=Event.Time;
					EdgeIdx2++;
    765e:	11 e0       	ldi	r17, 0x01	; 1
    7660:	e3 cf       	rjmp	.-58     	; 0x7628 <PageMotorSpeed+0x62>
				{
					EdgeList1[0]=Event.Time;
					EdgeIdx1++;
				}
			}
			else if (EdgeIdx1==1)
    7662:	01 30       	cpi	r16, 0x01	; 1
    7664:	d9 f0       	breq	.+54     	; 0x769c <PageMotorSpeed+0xd6>
				{
					EdgeList1[1]=Event.Time;
					EdgeIdx1++;
				}
			}
			else if (EdgeIdx1==2)
    7666:	02 30       	cpi	r16, 0x02	; 2
    7668:	91 f7       	brne	.-28     	; 0x764e <PageMotorSpeed+0x88>
			{
				if (Event.Event==RISING_1A)
    766a:	61 30       	cpi	r22, 0x01	; 1
    766c:	81 f7       	brne	.-32     	; 0x764e <PageMotorSpeed+0x88>
    766e:	24 96       	adiw	r28, 0x04	; 4
    7670:	8c af       	std	Y+60, r24	; 0x3c
    7672:	9d af       	std	Y+61, r25	; 0x3d
    7674:	ae af       	std	Y+62, r26	; 0x3e
    7676:	bf af       	std	Y+63, r27	; 0x3f
    7678:	24 97       	sbiw	r28, 0x04	; 4
				{
					EdgeList1[2]=Event.Time;
					EdgeIdx1++;
    767a:	03 e0       	ldi	r16, 0x03	; 3
				}
			}

			//Parse events for encoder 2
			if (EdgeIdx2==0)
    767c:	11 23       	and	r17, r17
    767e:	a1 f2       	breq	.-88     	; 0x7628 <PageMotorSpeed+0x62>
				{
					EdgeList2[0]=Event.Time;
					EdgeIdx2++;
				}
			}
			else if (EdgeIdx2==1)
    7680:	11 30       	cpi	r17, 0x01	; 1
    7682:	a1 f0       	breq	.+40     	; 0x76ac <PageMotorSpeed+0xe6>
				{
					EdgeList2[1]=Event.Time;
					EdgeIdx2++;
				}
			}
			else if (EdgeIdx2==2)
    7684:	12 30       	cpi	r17, 0x02	; 2
    7686:	81 f6       	brne	.-96     	; 0x7628 <PageMotorSpeed+0x62>
			{
				if (Event.Event==RISING_2A)
    7688:	63 30       	cpi	r22, 0x03	; 3
    768a:	71 f6       	brne	.-100    	; 0x7628 <PageMotorSpeed+0x62>
    768c:	28 96       	adiw	r28, 0x08	; 8
    768e:	8c af       	std	Y+60, r24	; 0x3c
    7690:	9d af       	std	Y+61, r25	; 0x3d
    7692:	ae af       	std	Y+62, r26	; 0x3e
    7694:	bf af       	std	Y+63, r27	; 0x3f
    7696:	28 97       	sbiw	r28, 0x08	; 8
				{
					EdgeList2[2]=Event.Time;
					EdgeIdx2++;
    7698:	13 e0       	ldi	r17, 0x03	; 3
    769a:	c6 cf       	rjmp	.-116    	; 0x7628 <PageMotorSpeed+0x62>
					EdgeIdx1++;
				}
			}
			else if (EdgeIdx1==1)
			{
				if (Event.Event==RISING_1B)
    769c:	62 30       	cpi	r22, 0x02	; 2
    769e:	b9 f6       	brne	.-82     	; 0x764e <PageMotorSpeed+0x88>
    76a0:	8c af       	std	Y+60, r24	; 0x3c
    76a2:	9d af       	std	Y+61, r25	; 0x3d
    76a4:	ae af       	std	Y+62, r26	; 0x3e
    76a6:	bf af       	std	Y+63, r27	; 0x3f
				{
					EdgeList1[1]=Event.Time;
					EdgeIdx1++;
    76a8:	02 e0       	ldi	r16, 0x02	; 2
    76aa:	e8 cf       	rjmp	.-48     	; 0x767c <PageMotorSpeed+0xb6>
					EdgeIdx2++;
				}
			}
			else if (EdgeIdx2==1)
			{
				if (Event.Event==RISING_2B)
    76ac:	64 30       	cpi	r22, 0x04	; 4
    76ae:	09 f0       	breq	.+2      	; 0x76b2 <PageMotorSpeed+0xec>
    76b0:	bb cf       	rjmp	.-138    	; 0x7628 <PageMotorSpeed+0x62>
    76b2:	88 af       	std	Y+56, r24	; 0x38
    76b4:	99 af       	std	Y+57, r25	; 0x39
    76b6:	aa af       	std	Y+58, r26	; 0x3a
    76b8:	bb af       	std	Y+59, r27	; 0x3b
				{
					EdgeList2[1]=Event.Time;
					EdgeIdx2++;
    76ba:	12 e0       	ldi	r17, 0x02	; 2
    76bc:	b5 cf       	rjmp	.-150    	; 0x7628 <PageMotorSpeed+0x62>
    76be:	2c 01       	movw	r4, r24
    76c0:	3d 01       	movw	r6, r26
			if (EdgeIdx1==0)
			{
				if (Event.Event==RISING_1A)
				{
					EdgeList1[0]=Event.Time;
					EdgeIdx1++;
    76c2:	01 e0       	ldi	r16, 0x01	; 1
    76c4:	db cf       	rjmp	.-74     	; 0x767c <PageMotorSpeed+0xb6>
					EdgeList2[2]=Event.Time;
					EdgeIdx2++;
				}
			}
		}
		if (EdgeIdx1==3) //All events needed are detected
    76c6:	03 30       	cpi	r16, 0x03	; 3
    76c8:	09 f4       	brne	.+2      	; 0x76cc <PageMotorSpeed+0x106>
    76ca:	c6 c0       	rjmp	.+396    	; 0x7858 <PageMotorSpeed+0x292>
		{
			Phase1=(float) ((EdgeList1[1]-EdgeList1[0])/ (float) (EdgeList1[2]-EdgeList1[0]))*180;
		}
		if (EdgeIdx2==3) //All events needed are detected
    76cc:	13 30       	cpi	r17, 0x03	; 3
    76ce:	09 f4       	brne	.+2      	; 0x76d2 <PageMotorSpeed+0x10c>
    76d0:	8e c0       	rjmp	.+284    	; 0x77ee <PageMotorSpeed+0x228>
		{
			Phase2=(float) ((EdgeList2[1]-EdgeList2[0])/ (float) (EdgeList2[2]-EdgeList2[0]))*180;
		}
		
		
		Stick=DriverCursorStickGetFifo(300);
    76d2:	8c e2       	ldi	r24, 0x2C	; 44
    76d4:	91 e0       	ldi	r25, 0x01	; 1
    76d6:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
    76da:	18 2f       	mov	r17, r24
		
		DriverOLEDClearScreen();
    76dc:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <DriverOLEDClearScreen>
		
		sprintf(s,"  S1:%d",Speed1);
    76e0:	df 92       	push	r13
    76e2:	cf 92       	push	r12
    76e4:	49 ec       	ldi	r20, 0xC9	; 201
    76e6:	56 e2       	ldi	r21, 0x26	; 38
    76e8:	5f 93       	push	r21
    76ea:	4f 93       	push	r20
    76ec:	ff 92       	push	r15
    76ee:	ef 92       	push	r14
    76f0:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    76f4:	40 e0       	ldi	r20, 0x00	; 0
    76f6:	b7 01       	movw	r22, r14
    76f8:	80 e0       	ldi	r24, 0x00	; 0
    76fa:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		sprintf(s,"  S2:%d",Speed2);
    76fe:	bf 92       	push	r11
    7700:	af 92       	push	r10
    7702:	21 ed       	ldi	r18, 0xD1	; 209
    7704:	36 e2       	ldi	r19, 0x26	; 38
    7706:	3f 93       	push	r19
    7708:	2f 93       	push	r18
    770a:	ff 92       	push	r15
    770c:	ef 92       	push	r14
    770e:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    7712:	40 e0       	ldi	r20, 0x00	; 0
    7714:	b7 01       	movw	r22, r14
    7716:	81 e0       	ldi	r24, 0x01	; 1
    7718:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>

		sprintf(s,"  A1:%d",EncoderInfo.Cnt1);
    771c:	3f 92       	push	r3
    771e:	8f 92       	push	r8
    7720:	89 ed       	ldi	r24, 0xD9	; 217
    7722:	96 e2       	ldi	r25, 0x26	; 38
    7724:	9f 93       	push	r25
    7726:	8f 93       	push	r24
    7728:	ff 92       	push	r15
    772a:	ef 92       	push	r14
    772c:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(2,s,0);
    7730:	40 e0       	ldi	r20, 0x00	; 0
    7732:	b7 01       	movw	r22, r14
    7734:	82 e0       	ldi	r24, 0x02	; 2
    7736:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		sprintf(s,"  A2:%d",EncoderInfo.Cnt2);
    773a:	9f 92       	push	r9
    773c:	2f 92       	push	r2
    773e:	41 ee       	ldi	r20, 0xE1	; 225
    7740:	56 e2       	ldi	r21, 0x26	; 38
    7742:	5f 93       	push	r21
    7744:	4f 93       	push	r20
    7746:	ff 92       	push	r15
    7748:	ef 92       	push	r14
    774a:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(3,s,0);
    774e:	40 e0       	ldi	r20, 0x00	; 0
    7750:	b7 01       	movw	r22, r14
    7752:	83 e0       	ldi	r24, 0x03	; 3
    7754:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		
		sprintf(s,"  P1:%f",Phase1);
    7758:	9c a9       	ldd	r25, Y+52	; 0x34
    775a:	9f 93       	push	r25
    775c:	2b a9       	ldd	r18, Y+51	; 0x33
    775e:	2f 93       	push	r18
    7760:	3a a9       	ldd	r19, Y+50	; 0x32
    7762:	3f 93       	push	r19
    7764:	4e a5       	ldd	r20, Y+46	; 0x2e
    7766:	4f 93       	push	r20
    7768:	89 ee       	ldi	r24, 0xE9	; 233
    776a:	96 e2       	ldi	r25, 0x26	; 38
    776c:	9f 93       	push	r25
    776e:	8f 93       	push	r24
    7770:	ff 92       	push	r15
    7772:	ef 92       	push	r14
    7774:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(4,s,0);
    7778:	cd bf       	out	0x3d, r28	; 61
    777a:	de bf       	out	0x3e, r29	; 62
    777c:	40 e0       	ldi	r20, 0x00	; 0
    777e:	b7 01       	movw	r22, r14
    7780:	84 e0       	ldi	r24, 0x04	; 4
    7782:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		sprintf(s,"  P2:%f",Phase2);
    7786:	5a a5       	ldd	r21, Y+42	; 0x2a
    7788:	5f 93       	push	r21
    778a:	8f a9       	ldd	r24, Y+55	; 0x37
    778c:	8f 93       	push	r24
    778e:	9e a9       	ldd	r25, Y+54	; 0x36
    7790:	9f 93       	push	r25
    7792:	2d a9       	ldd	r18, Y+53	; 0x35
    7794:	2f 93       	push	r18
    7796:	41 ef       	ldi	r20, 0xF1	; 241
    7798:	56 e2       	ldi	r21, 0x26	; 38
    779a:	5f 93       	push	r21
    779c:	4f 93       	push	r20
    779e:	ff 92       	push	r15
    77a0:	ef 92       	push	r14
    77a2:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(5,s,0);
    77a6:	40 e0       	ldi	r20, 0x00	; 0
    77a8:	b7 01       	movw	r22, r14
    77aa:	85 e0       	ldi	r24, 0x05	; 5
    77ac:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>

		
		if (Stick & CURSOR_UP) Speed1+=5;
    77b0:	cd bf       	out	0x3d, r28	; 61
    77b2:	de bf       	out	0x3e, r29	; 62
    77b4:	14 ff       	sbrs	r17, 4
    77b6:	03 c0       	rjmp	.+6      	; 0x77be <PageMotorSpeed+0x1f8>
    77b8:	35 e0       	ldi	r19, 0x05	; 5
    77ba:	c3 0e       	add	r12, r19
    77bc:	d1 1c       	adc	r13, r1
		if (Stick & CURSOR_DOWN) Speed1-=5;
    77be:	12 ff       	sbrs	r17, 2
    77c0:	03 c0       	rjmp	.+6      	; 0x77c8 <PageMotorSpeed+0x202>
    77c2:	45 e0       	ldi	r20, 0x05	; 5
    77c4:	c4 1a       	sub	r12, r20
    77c6:	d1 08       	sbc	r13, r1
		if (Stick & CURSOR_RIGHT) Speed2+=5;
    77c8:	11 ff       	sbrs	r17, 1
    77ca:	03 c0       	rjmp	.+6      	; 0x77d2 <PageMotorSpeed+0x20c>
    77cc:	55 e0       	ldi	r21, 0x05	; 5
    77ce:	a5 0e       	add	r10, r21
    77d0:	b1 1c       	adc	r11, r1
		if (Stick & CURSOR_LEFT) Speed2-=5;	
    77d2:	13 ff       	sbrs	r17, 3
    77d4:	03 c0       	rjmp	.+6      	; 0x77dc <PageMotorSpeed+0x216>
    77d6:	85 e0       	ldi	r24, 0x05	; 5
    77d8:	a8 1a       	sub	r10, r24
    77da:	b1 08       	sbc	r11, r1
		if (Stick & CURSOR_PRESS)
    77dc:	10 fd       	sbrc	r17, 0
    77de:	69 c0       	rjmp	.+210    	; 0x78b2 <PageMotorSpeed+0x2ec>
			DisableMotorSpeedTask();
			DisableMotorPosTask();
			
			return;
		}	
		MotorSpeedSet(Speed1,Speed2);
    77e0:	b5 01       	movw	r22, r10
    77e2:	c6 01       	movw	r24, r12
    77e4:	0e 94 be 39 	call	0x737c	; 0x737c <MotorSpeedSet>
		
		
		DriverOLEDUpdate();
    77e8:	0e 94 c5 0c 	call	0x198a	; 0x198a <DriverOLEDUpdate>
		
	}
    77ec:	15 cf       	rjmp	.-470    	; 0x7618 <PageMotorSpeed+0x52>
		{
			Phase1=(float) ((EdgeList1[1]-EdgeList1[0])/ (float) (EdgeList1[2]-EdgeList1[0]))*180;
		}
		if (EdgeIdx2==3) //All events needed are detected
		{
			Phase2=(float) ((EdgeList2[1]-EdgeList2[0])/ (float) (EdgeList2[2]-EdgeList2[0]))*180;
    77ee:	68 ad       	ldd	r22, Y+56	; 0x38
    77f0:	79 ad       	ldd	r23, Y+57	; 0x39
    77f2:	8a ad       	ldd	r24, Y+58	; 0x3a
    77f4:	9b ad       	ldd	r25, Y+59	; 0x3b
    77f6:	2e a1       	ldd	r18, Y+38	; 0x26
    77f8:	3f a1       	ldd	r19, Y+39	; 0x27
    77fa:	48 a5       	ldd	r20, Y+40	; 0x28
    77fc:	59 a5       	ldd	r21, Y+41	; 0x29
    77fe:	62 1b       	sub	r22, r18
    7800:	73 0b       	sbc	r23, r19
    7802:	84 0b       	sbc	r24, r20
    7804:	95 0b       	sbc	r25, r21
    7806:	0e 94 47 44 	call	0x888e	; 0x888e <__floatunsisf>
    780a:	6a a7       	std	Y+42, r22	; 0x2a
    780c:	7b a7       	std	Y+43, r23	; 0x2b
    780e:	8c a7       	std	Y+44, r24	; 0x2c
    7810:	9d a7       	std	Y+45, r25	; 0x2d
    7812:	28 96       	adiw	r28, 0x08	; 8
    7814:	6c ad       	ldd	r22, Y+60	; 0x3c
    7816:	7d ad       	ldd	r23, Y+61	; 0x3d
    7818:	8e ad       	ldd	r24, Y+62	; 0x3e
    781a:	9f ad       	ldd	r25, Y+63	; 0x3f
    781c:	28 97       	sbiw	r28, 0x08	; 8
    781e:	2e a1       	ldd	r18, Y+38	; 0x26
    7820:	3f a1       	ldd	r19, Y+39	; 0x27
    7822:	48 a5       	ldd	r20, Y+40	; 0x28
    7824:	59 a5       	ldd	r21, Y+41	; 0x29
    7826:	62 1b       	sub	r22, r18
    7828:	73 0b       	sbc	r23, r19
    782a:	84 0b       	sbc	r24, r20
    782c:	95 0b       	sbc	r25, r21
    782e:	0e 94 47 44 	call	0x888e	; 0x888e <__floatunsisf>
    7832:	9b 01       	movw	r18, r22
    7834:	ac 01       	movw	r20, r24
    7836:	6a a5       	ldd	r22, Y+42	; 0x2a
    7838:	7b a5       	ldd	r23, Y+43	; 0x2b
    783a:	8c a5       	ldd	r24, Y+44	; 0x2c
    783c:	9d a5       	ldd	r25, Y+45	; 0x2d
    783e:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    7842:	20 e0       	ldi	r18, 0x00	; 0
    7844:	30 e0       	ldi	r19, 0x00	; 0
    7846:	44 e3       	ldi	r20, 0x34	; 52
    7848:	53 e4       	ldi	r21, 0x43	; 67
    784a:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    784e:	6d ab       	std	Y+53, r22	; 0x35
    7850:	7e ab       	std	Y+54, r23	; 0x36
    7852:	8f ab       	std	Y+55, r24	; 0x37
    7854:	9a a7       	std	Y+42, r25	; 0x2a
    7856:	3d cf       	rjmp	.-390    	; 0x76d2 <PageMotorSpeed+0x10c>
				}
			}
		}
		if (EdgeIdx1==3) //All events needed are detected
		{
			Phase1=(float) ((EdgeList1[1]-EdgeList1[0])/ (float) (EdgeList1[2]-EdgeList1[0]))*180;
    7858:	6c ad       	ldd	r22, Y+60	; 0x3c
    785a:	7d ad       	ldd	r23, Y+61	; 0x3d
    785c:	8e ad       	ldd	r24, Y+62	; 0x3e
    785e:	9f ad       	ldd	r25, Y+63	; 0x3f
    7860:	64 19       	sub	r22, r4
    7862:	75 09       	sbc	r23, r5
    7864:	86 09       	sbc	r24, r6
    7866:	97 09       	sbc	r25, r7
    7868:	0e 94 47 44 	call	0x888e	; 0x888e <__floatunsisf>
    786c:	6e a7       	std	Y+46, r22	; 0x2e
    786e:	7f a7       	std	Y+47, r23	; 0x2f
    7870:	88 ab       	std	Y+48, r24	; 0x30
    7872:	99 ab       	std	Y+49, r25	; 0x31
    7874:	24 96       	adiw	r28, 0x04	; 4
    7876:	6c ad       	ldd	r22, Y+60	; 0x3c
    7878:	7d ad       	ldd	r23, Y+61	; 0x3d
    787a:	8e ad       	ldd	r24, Y+62	; 0x3e
    787c:	9f ad       	ldd	r25, Y+63	; 0x3f
    787e:	24 97       	sbiw	r28, 0x04	; 4
    7880:	64 19       	sub	r22, r4
    7882:	75 09       	sbc	r23, r5
    7884:	86 09       	sbc	r24, r6
    7886:	97 09       	sbc	r25, r7
    7888:	0e 94 47 44 	call	0x888e	; 0x888e <__floatunsisf>
    788c:	9b 01       	movw	r18, r22
    788e:	ac 01       	movw	r20, r24
    7890:	6e a5       	ldd	r22, Y+46	; 0x2e
    7892:	7f a5       	ldd	r23, Y+47	; 0x2f
    7894:	88 a9       	ldd	r24, Y+48	; 0x30
    7896:	99 a9       	ldd	r25, Y+49	; 0x31
    7898:	0e 94 9f 43 	call	0x873e	; 0x873e <__divsf3>
    789c:	20 e0       	ldi	r18, 0x00	; 0
    789e:	30 e0       	ldi	r19, 0x00	; 0
    78a0:	44 e3       	ldi	r20, 0x34	; 52
    78a2:	53 e4       	ldi	r21, 0x43	; 67
    78a4:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    78a8:	6e a7       	std	Y+46, r22	; 0x2e
    78aa:	7a ab       	std	Y+50, r23	; 0x32
    78ac:	8b ab       	std	Y+51, r24	; 0x33
    78ae:	9c ab       	std	Y+52, r25	; 0x34
    78b0:	0d cf       	rjmp	.-486    	; 0x76cc <PageMotorSpeed+0x106>
		if (Stick & CURSOR_DOWN) Speed1-=5;
		if (Stick & CURSOR_RIGHT) Speed2+=5;
		if (Stick & CURSOR_LEFT) Speed2-=5;	
		if (Stick & CURSOR_PRESS)
		{
			MotorSpeedSet(0,0);
    78b2:	60 e0       	ldi	r22, 0x00	; 0
    78b4:	70 e0       	ldi	r23, 0x00	; 0
    78b6:	80 e0       	ldi	r24, 0x00	; 0
    78b8:	90 e0       	ldi	r25, 0x00	; 0
    78ba:	0e 94 be 39 	call	0x737c	; 0x737c <MotorSpeedSet>
			vTaskDelay(300);
    78be:	8c e2       	ldi	r24, 0x2C	; 44
    78c0:	91 e0       	ldi	r25, 0x01	; 1
    78c2:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
			DisableMotorSpeedTask();
    78c6:	0e 94 b8 39 	call	0x7370	; 0x7370 <DisableMotorSpeedTask>
			DisableMotorPosTask();
    78ca:	0e 94 f8 38 	call	0x71f0	; 0x71f0 <DisableMotorPosTask>
		
		DriverOLEDUpdate();
		
	}
		
}
    78ce:	c9 5b       	subi	r28, 0xB9	; 185
    78d0:	df 4f       	sbci	r29, 0xFF	; 255
    78d2:	cd bf       	out	0x3d, r28	; 61
    78d4:	de bf       	out	0x3e, r29	; 62
    78d6:	df 91       	pop	r29
    78d8:	cf 91       	pop	r28
    78da:	1f 91       	pop	r17
    78dc:	0f 91       	pop	r16
    78de:	ff 90       	pop	r15
    78e0:	ef 90       	pop	r14
    78e2:	df 90       	pop	r13
    78e4:	cf 90       	pop	r12
    78e6:	bf 90       	pop	r11
    78e8:	af 90       	pop	r10
    78ea:	9f 90       	pop	r9
    78ec:	8f 90       	pop	r8
    78ee:	7f 90       	pop	r7
    78f0:	6f 90       	pop	r6
    78f2:	5f 90       	pop	r5
    78f4:	4f 90       	pop	r4
    78f6:	3f 90       	pop	r3
    78f8:	2f 90       	pop	r2
    78fa:	08 95       	ret

000078fc <PageADPS9960>:

void PageADPS9960()
{
    78fc:	7f 92       	push	r7
    78fe:	8f 92       	push	r8
    7900:	9f 92       	push	r9
    7902:	af 92       	push	r10
    7904:	bf 92       	push	r11
    7906:	cf 92       	push	r12
    7908:	df 92       	push	r13
    790a:	ef 92       	push	r14
    790c:	ff 92       	push	r15
    790e:	0f 93       	push	r16
    7910:	1f 93       	push	r17
    7912:	cf 93       	push	r28
    7914:	df 93       	push	r29
    7916:	cd b7       	in	r28, 0x3d	; 61
    7918:	de b7       	in	r29, 0x3e	; 62
    791a:	a8 97       	sbiw	r28, 0x28	; 40
    791c:	cd bf       	out	0x3d, r28	; 61
    791e:	de bf       	out	0x3e, r29	; 62
	uint8_t Stick;
	uint16_t C,R,G,B;
	char s[32];
	
	DriverLedSet(0b0010);
    7920:	82 e0       	ldi	r24, 0x02	; 2
    7922:	0e 94 83 06 	call	0xd06	; 0xd06 <DriverLedSet>
	vTaskDelay(300);
    7926:	8c e2       	ldi	r24, 0x2C	; 44
    7928:	91 e0       	ldi	r25, 0x01	; 1
    792a:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
    792e:	8e 01       	movw	r16, r28
    7930:	0f 5f       	subi	r16, 0xFF	; 255
    7932:	1f 4f       	sbci	r17, 0xFF	; 255
		
		DriverOLEDClearScreen();
		
		DriverAdps9960Get(&C,&R,&G,&B);
		
		sprintf(s,"C:%u",C);
    7934:	89 ef       	ldi	r24, 0xF9	; 249
    7936:	88 2e       	mov	r8, r24
    7938:	86 e2       	ldi	r24, 0x26	; 38
    793a:	98 2e       	mov	r9, r24
		DriverOLEDPrintSmText(0,s,0);

		sprintf(s,"R:%u",R);
    793c:	9e ef       	ldi	r25, 0xFE	; 254
    793e:	a9 2e       	mov	r10, r25
    7940:	96 e2       	ldi	r25, 0x26	; 38
    7942:	b9 2e       	mov	r11, r25
		DriverOLEDPrintSmText(1,s,0);
		
		sprintf(s,"G:%u",G);
    7944:	23 e0       	ldi	r18, 0x03	; 3
    7946:	c2 2e       	mov	r12, r18
    7948:	27 e2       	ldi	r18, 0x27	; 39
    794a:	d2 2e       	mov	r13, r18
		DriverOLEDPrintSmText(2,s,0);
		
		sprintf(s,"B:%u",B);
    794c:	38 e0       	ldi	r19, 0x08	; 8
    794e:	e3 2e       	mov	r14, r19
    7950:	37 e2       	ldi	r19, 0x27	; 39
    7952:	f3 2e       	mov	r15, r19
    7954:	02 c0       	rjmp	.+4      	; 0x795a <PageADPS9960+0x5e>
			vTaskDelay(300);
			DriverLedClear(0b0010);
			return;
		}
	
		DriverOLEDUpdate();
    7956:	0e 94 c5 0c 	call	0x198a	; 0x198a <DriverOLEDUpdate>
	
	DriverLedSet(0b0010);
	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    795a:	8c e2       	ldi	r24, 0x2C	; 44
    795c:	91 e0       	ldi	r25, 0x01	; 1
    795e:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
    7962:	78 2e       	mov	r7, r24
		
		
		DriverOLEDClearScreen();
    7964:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <DriverOLEDClearScreen>
		
		DriverAdps9960Get(&C,&R,&G,&B);
    7968:	9e 01       	movw	r18, r28
    796a:	2f 5d       	subi	r18, 0xDF	; 223
    796c:	3f 4f       	sbci	r19, 0xFF	; 255
    796e:	ae 01       	movw	r20, r28
    7970:	4d 5d       	subi	r20, 0xDD	; 221
    7972:	5f 4f       	sbci	r21, 0xFF	; 255
    7974:	be 01       	movw	r22, r28
    7976:	6b 5d       	subi	r22, 0xDB	; 219
    7978:	7f 4f       	sbci	r23, 0xFF	; 255
    797a:	ce 01       	movw	r24, r28
    797c:	87 96       	adiw	r24, 0x27	; 39
    797e:	0e 94 88 04 	call	0x910	; 0x910 <DriverAdps9960Get>
		
		sprintf(s,"C:%u",C);
    7982:	88 a5       	ldd	r24, Y+40	; 0x28
    7984:	8f 93       	push	r24
    7986:	8f a1       	ldd	r24, Y+39	; 0x27
    7988:	8f 93       	push	r24
    798a:	9f 92       	push	r9
    798c:	8f 92       	push	r8
    798e:	1f 93       	push	r17
    7990:	0f 93       	push	r16
    7992:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    7996:	40 e0       	ldi	r20, 0x00	; 0
    7998:	b8 01       	movw	r22, r16
    799a:	80 e0       	ldi	r24, 0x00	; 0
    799c:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>

		sprintf(s,"R:%u",R);
    79a0:	8e a1       	ldd	r24, Y+38	; 0x26
    79a2:	8f 93       	push	r24
    79a4:	8d a1       	ldd	r24, Y+37	; 0x25
    79a6:	8f 93       	push	r24
    79a8:	bf 92       	push	r11
    79aa:	af 92       	push	r10
    79ac:	1f 93       	push	r17
    79ae:	0f 93       	push	r16
    79b0:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    79b4:	40 e0       	ldi	r20, 0x00	; 0
    79b6:	b8 01       	movw	r22, r16
    79b8:	81 e0       	ldi	r24, 0x01	; 1
    79ba:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		
		sprintf(s,"G:%u",G);
    79be:	8c a1       	ldd	r24, Y+36	; 0x24
    79c0:	8f 93       	push	r24
    79c2:	8b a1       	ldd	r24, Y+35	; 0x23
    79c4:	8f 93       	push	r24
    79c6:	df 92       	push	r13
    79c8:	cf 92       	push	r12
    79ca:	1f 93       	push	r17
    79cc:	0f 93       	push	r16
    79ce:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(2,s,0);
    79d2:	40 e0       	ldi	r20, 0x00	; 0
    79d4:	b8 01       	movw	r22, r16
    79d6:	82 e0       	ldi	r24, 0x02	; 2
    79d8:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		
		sprintf(s,"B:%u",B);
    79dc:	8a a1       	ldd	r24, Y+34	; 0x22
    79de:	8f 93       	push	r24
    79e0:	89 a1       	ldd	r24, Y+33	; 0x21
    79e2:	8f 93       	push	r24
    79e4:	ff 92       	push	r15
    79e6:	ef 92       	push	r14
    79e8:	1f 93       	push	r17
    79ea:	0f 93       	push	r16
    79ec:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(3,s,0);
    79f0:	40 e0       	ldi	r20, 0x00	; 0
    79f2:	b8 01       	movw	r22, r16
    79f4:	83 e0       	ldi	r24, 0x03	; 3
    79f6:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		
		if (Stick & CURSOR_UP);
		if (Stick & CURSOR_DOWN);
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
    79fa:	cd bf       	out	0x3d, r28	; 61
    79fc:	de bf       	out	0x3e, r29	; 62
    79fe:	70 fe       	sbrs	r7, 0
    7a00:	aa cf       	rjmp	.-172    	; 0x7956 <PageADPS9960+0x5a>
		{
			vTaskDelay(300);
    7a02:	8c e2       	ldi	r24, 0x2C	; 44
    7a04:	91 e0       	ldi	r25, 0x01	; 1
    7a06:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
			DriverLedClear(0b0010);
    7a0a:	82 e0       	ldi	r24, 0x02	; 2
    7a0c:	0e 94 93 06 	call	0xd26	; 0xd26 <DriverLedClear>
		}
	
		DriverOLEDUpdate();
		
	}	
}
    7a10:	a8 96       	adiw	r28, 0x28	; 40
    7a12:	cd bf       	out	0x3d, r28	; 61
    7a14:	de bf       	out	0x3e, r29	; 62
    7a16:	df 91       	pop	r29
    7a18:	cf 91       	pop	r28
    7a1a:	1f 91       	pop	r17
    7a1c:	0f 91       	pop	r16
    7a1e:	ff 90       	pop	r15
    7a20:	ef 90       	pop	r14
    7a22:	df 90       	pop	r13
    7a24:	cf 90       	pop	r12
    7a26:	bf 90       	pop	r11
    7a28:	af 90       	pop	r10
    7a2a:	9f 90       	pop	r9
    7a2c:	8f 90       	pop	r8
    7a2e:	7f 90       	pop	r7
    7a30:	08 95       	ret

00007a32 <PageADC>:

void PageADC()
{
    7a32:	2f 92       	push	r2
    7a34:	3f 92       	push	r3
    7a36:	4f 92       	push	r4
    7a38:	5f 92       	push	r5
    7a3a:	6f 92       	push	r6
    7a3c:	7f 92       	push	r7
    7a3e:	8f 92       	push	r8
    7a40:	9f 92       	push	r9
    7a42:	af 92       	push	r10
    7a44:	bf 92       	push	r11
    7a46:	cf 92       	push	r12
    7a48:	df 92       	push	r13
    7a4a:	ef 92       	push	r14
    7a4c:	ff 92       	push	r15
    7a4e:	0f 93       	push	r16
    7a50:	1f 93       	push	r17
    7a52:	cf 93       	push	r28
    7a54:	df 93       	push	r29
    7a56:	cd b7       	in	r28, 0x3d	; 61
    7a58:	de b7       	in	r29, 0x3e	; 62
    7a5a:	a9 97       	sbiw	r28, 0x29	; 41
    7a5c:	cd bf       	out	0x3d, r28	; 61
    7a5e:	de bf       	out	0x3e, r29	; 62
	uint8_t Stick;
	char s[32];
	ADCStruct ADCData;

	vTaskDelay(300);
    7a60:	8c e2       	ldi	r24, 0x2C	; 44
    7a62:	91 e0       	ldi	r25, 0x01	; 1
    7a64:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
    7a68:	8e 01       	movw	r16, r28
    7a6a:	0f 5f       	subi	r16, 0xFF	; 255
    7a6c:	1f 4f       	sbci	r17, 0xFF	; 255
		
		DriverOLEDClearScreen();
		ADCData=GetADCData();
		

		sprintf(s,"PHOTO1:%d",ADCData.PhotoL);
    7a6e:	8d e0       	ldi	r24, 0x0D	; 13
    7a70:	88 2e       	mov	r8, r24
    7a72:	87 e2       	ldi	r24, 0x27	; 39
    7a74:	98 2e       	mov	r9, r24
		DriverOLEDPrintSmText(0,s,0);

		sprintf(s,"PHOTO2:%d",ADCData.PhotoM);
    7a76:	97 e1       	ldi	r25, 0x17	; 23
    7a78:	a9 2e       	mov	r10, r25
    7a7a:	97 e2       	ldi	r25, 0x27	; 39
    7a7c:	b9 2e       	mov	r11, r25
		DriverOLEDPrintSmText(1,s,0);
		
		sprintf(s,"PHOTO3:%d",ADCData.PhotoR);
    7a7e:	21 e2       	ldi	r18, 0x21	; 33
    7a80:	62 2e       	mov	r6, r18
    7a82:	27 e2       	ldi	r18, 0x27	; 39
    7a84:	72 2e       	mov	r7, r18
		DriverOLEDPrintSmText(2,s,0);
		
		sprintf(s,"POT:%d",ADCData.Potmeter);
    7a86:	3b e2       	ldi	r19, 0x2B	; 43
    7a88:	43 2e       	mov	r4, r19
    7a8a:	37 e2       	ldi	r19, 0x27	; 39
    7a8c:	53 2e       	mov	r5, r19
		DriverOLEDPrintSmText(3,s,0);
		
		sprintf(s,"DIFF:%d",ADCData.PhotoL-ADCData.PhotoR);	
    7a8e:	42 e3       	ldi	r20, 0x32	; 50
    7a90:	24 2e       	mov	r2, r20
    7a92:	47 e2       	ldi	r20, 0x27	; 39
    7a94:	34 2e       	mov	r3, r20
    7a96:	02 c0       	rjmp	.+4      	; 0x7a9c <PageADC+0x6a>
		{
			vTaskDelay(300);
			return;
		}
		
		DriverOLEDUpdate();
    7a98:	0e 94 c5 0c 	call	0x198a	; 0x198a <DriverOLEDUpdate>
	ADCStruct ADCData;

	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    7a9c:	8c e2       	ldi	r24, 0x2C	; 44
    7a9e:	91 e0       	ldi	r25, 0x01	; 1
    7aa0:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
    7aa4:	89 a7       	std	Y+41, r24	; 0x29
		
		
		DriverOLEDClearScreen();
    7aa6:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <DriverOLEDClearScreen>
		ADCData=GetADCData();
    7aaa:	0e 94 1d 32 	call	0x643a	; 0x643a <GetADCData>
    7aae:	29 a3       	std	Y+33, r18	; 0x21
    7ab0:	3a a3       	std	Y+34, r19	; 0x22
    7ab2:	4b a3       	std	Y+35, r20	; 0x23
    7ab4:	5c a3       	std	Y+36, r21	; 0x24
    7ab6:	6d a3       	std	Y+37, r22	; 0x25
    7ab8:	7e a3       	std	Y+38, r23	; 0x26
    7aba:	8f a3       	std	Y+39, r24	; 0x27
    7abc:	98 a7       	std	Y+40, r25	; 0x28
    7abe:	e9 a0       	ldd	r14, Y+33	; 0x21
    7ac0:	fa a0       	ldd	r15, Y+34	; 0x22
    7ac2:	cd a0       	ldd	r12, Y+37	; 0x25
    7ac4:	de a0       	ldd	r13, Y+38	; 0x26
		

		sprintf(s,"PHOTO1:%d",ADCData.PhotoL);
    7ac6:	ff 92       	push	r15
    7ac8:	ef 92       	push	r14
    7aca:	9f 92       	push	r9
    7acc:	8f 92       	push	r8
    7ace:	1f 93       	push	r17
    7ad0:	0f 93       	push	r16
    7ad2:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    7ad6:	40 e0       	ldi	r20, 0x00	; 0
    7ad8:	b8 01       	movw	r22, r16
    7ada:	80 e0       	ldi	r24, 0x00	; 0
    7adc:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>

		sprintf(s,"PHOTO2:%d",ADCData.PhotoM);
    7ae0:	8c a1       	ldd	r24, Y+36	; 0x24
    7ae2:	8f 93       	push	r24
    7ae4:	8b a1       	ldd	r24, Y+35	; 0x23
    7ae6:	8f 93       	push	r24
    7ae8:	bf 92       	push	r11
    7aea:	af 92       	push	r10
    7aec:	1f 93       	push	r17
    7aee:	0f 93       	push	r16
    7af0:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    7af4:	40 e0       	ldi	r20, 0x00	; 0
    7af6:	b8 01       	movw	r22, r16
    7af8:	81 e0       	ldi	r24, 0x01	; 1
    7afa:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		
		sprintf(s,"PHOTO3:%d",ADCData.PhotoR);
    7afe:	df 92       	push	r13
    7b00:	cf 92       	push	r12
    7b02:	7f 92       	push	r7
    7b04:	6f 92       	push	r6
    7b06:	1f 93       	push	r17
    7b08:	0f 93       	push	r16
    7b0a:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(2,s,0);
    7b0e:	40 e0       	ldi	r20, 0x00	; 0
    7b10:	b8 01       	movw	r22, r16
    7b12:	82 e0       	ldi	r24, 0x02	; 2
    7b14:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		
		sprintf(s,"POT:%d",ADCData.Potmeter);
    7b18:	88 a5       	ldd	r24, Y+40	; 0x28
    7b1a:	8f 93       	push	r24
    7b1c:	8f a1       	ldd	r24, Y+39	; 0x27
    7b1e:	8f 93       	push	r24
    7b20:	5f 92       	push	r5
    7b22:	4f 92       	push	r4
    7b24:	1f 93       	push	r17
    7b26:	0f 93       	push	r16
    7b28:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(3,s,0);
    7b2c:	40 e0       	ldi	r20, 0x00	; 0
    7b2e:	b8 01       	movw	r22, r16
    7b30:	83 e0       	ldi	r24, 0x03	; 3
    7b32:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		
		sprintf(s,"DIFF:%d",ADCData.PhotoL-ADCData.PhotoR);	
    7b36:	ec 18       	sub	r14, r12
    7b38:	fd 08       	sbc	r15, r13
    7b3a:	ff 92       	push	r15
    7b3c:	ef 92       	push	r14
    7b3e:	3f 92       	push	r3
    7b40:	2f 92       	push	r2
    7b42:	1f 93       	push	r17
    7b44:	0f 93       	push	r16
    7b46:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(5,s,0);
    7b4a:	40 e0       	ldi	r20, 0x00	; 0
    7b4c:	b8 01       	movw	r22, r16
    7b4e:	85 e0       	ldi	r24, 0x05	; 5
    7b50:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		
		if (Stick & CURSOR_UP);
		if (Stick & CURSOR_DOWN);
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
    7b54:	cd bf       	out	0x3d, r28	; 61
    7b56:	de bf       	out	0x3e, r29	; 62
    7b58:	99 a5       	ldd	r25, Y+41	; 0x29
    7b5a:	90 ff       	sbrs	r25, 0
    7b5c:	9d cf       	rjmp	.-198    	; 0x7a98 <PageADC+0x66>
		{
			vTaskDelay(300);
    7b5e:	8c e2       	ldi	r24, 0x2C	; 44
    7b60:	91 e0       	ldi	r25, 0x01	; 1
    7b62:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
		}
		
		DriverOLEDUpdate();
		
	}
}
    7b66:	a9 96       	adiw	r28, 0x29	; 41
    7b68:	cd bf       	out	0x3d, r28	; 61
    7b6a:	de bf       	out	0x3e, r29	; 62
    7b6c:	df 91       	pop	r29
    7b6e:	cf 91       	pop	r28
    7b70:	1f 91       	pop	r17
    7b72:	0f 91       	pop	r16
    7b74:	ff 90       	pop	r15
    7b76:	ef 90       	pop	r14
    7b78:	df 90       	pop	r13
    7b7a:	cf 90       	pop	r12
    7b7c:	bf 90       	pop	r11
    7b7e:	af 90       	pop	r10
    7b80:	9f 90       	pop	r9
    7b82:	8f 90       	pop	r8
    7b84:	7f 90       	pop	r7
    7b86:	6f 90       	pop	r6
    7b88:	5f 90       	pop	r5
    7b8a:	4f 90       	pop	r4
    7b8c:	3f 90       	pop	r3
    7b8e:	2f 90       	pop	r2
    7b90:	08 95       	ret

00007b92 <PageLineFollowSpeed>:

void PageLineFollowSpeed()
{
    7b92:	cf 93       	push	r28
		uint8_t Stick;
		char s[32];
		
		EnableMotorPosTask();
    7b94:	0e 94 df 38 	call	0x71be	; 0x71be <EnableMotorPosTask>
		EnableMotorSpeedTask();
    7b98:	0e 94 ac 39 	call	0x7358	; 0x7358 <EnableMotorSpeedTask>
		StartLineFollower(40.0);
    7b9c:	60 e0       	ldi	r22, 0x00	; 0
    7b9e:	70 e0       	ldi	r23, 0x00	; 0
    7ba0:	80 e2       	ldi	r24, 0x20	; 32
    7ba2:	92 e4       	ldi	r25, 0x42	; 66
    7ba4:	0e 94 b6 34 	call	0x696c	; 0x696c <StartLineFollower>
		vTaskDelay(300);
    7ba8:	8c e2       	ldi	r24, 0x2C	; 44
    7baa:	91 e0       	ldi	r25, 0x01	; 1
    7bac:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
    7bb0:	02 c0       	rjmp	.+4      	; 0x7bb6 <PageLineFollowSpeed+0x24>
						
				vTaskDelay(300);
				return;
			}
			
			DriverOLEDUpdate();
    7bb2:	0e 94 c5 0c 	call	0x198a	; 0x198a <DriverOLEDUpdate>
		EnableMotorSpeedTask();
		StartLineFollower(40.0);
		vTaskDelay(300);
		while (1)
		{
			Stick=DriverCursorStickGetFifo(300);
    7bb6:	8c e2       	ldi	r24, 0x2C	; 44
    7bb8:	91 e0       	ldi	r25, 0x01	; 1
    7bba:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
    7bbe:	c8 2f       	mov	r28, r24
					
			DriverOLEDClearScreen();
    7bc0:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <DriverOLEDClearScreen>
		
			DriverOLEDPrintSmText(0,"Line follower active",0);
    7bc4:	40 e0       	ldi	r20, 0x00	; 0
    7bc6:	6a e3       	ldi	r22, 0x3A	; 58
    7bc8:	77 e2       	ldi	r23, 0x27	; 39
    7bca:	80 e0       	ldi	r24, 0x00	; 0
    7bcc:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
			
			if (Stick & CURSOR_UP);
			if (Stick & CURSOR_DOWN);
			if (Stick & CURSOR_RIGHT);
			if (Stick & CURSOR_LEFT);
			if (Stick & CURSOR_PRESS)
    7bd0:	c0 ff       	sbrs	r28, 0
    7bd2:	ef cf       	rjmp	.-34     	; 0x7bb2 <PageLineFollowSpeed+0x20>
			{
				StopLineFollower();
    7bd4:	0e 94 c9 34 	call	0x6992	; 0x6992 <StopLineFollower>
				DisableMotorSpeedTask();
    7bd8:	0e 94 b8 39 	call	0x7370	; 0x7370 <DisableMotorSpeedTask>
				DisableMotorPosTask();
    7bdc:	0e 94 f8 38 	call	0x71f0	; 0x71f0 <DisableMotorPosTask>
						
				vTaskDelay(300);
    7be0:	8c e2       	ldi	r24, 0x2C	; 44
    7be2:	91 e0       	ldi	r25, 0x01	; 1
				return;
			}
			
			DriverOLEDUpdate();
		}	
}
    7be4:	cf 91       	pop	r28
			{
				StopLineFollower();
				DisableMotorSpeedTask();
				DisableMotorPosTask();
						
				vTaskDelay(300);
    7be6:	0c 94 2f 2b 	jmp	0x565e	; 0x565e <vTaskDelay>

00007bea <PageLineFollowDirect>:
			DriverOLEDUpdate();
		}	
}

void PageLineFollowDirect()
{
    7bea:	cf 93       	push	r28
	uint8_t Stick;
	char s[32];

	EnableLineFollowerDirectTask();
    7bec:	0e 94 f2 33 	call	0x67e4	; 0x67e4 <EnableLineFollowerDirectTask>
	vTaskDelay(300);
    7bf0:	8c e2       	ldi	r24, 0x2C	; 44
    7bf2:	91 e0       	ldi	r25, 0x01	; 1
    7bf4:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
    7bf8:	02 c0       	rjmp	.+4      	; 0x7bfe <PageLineFollowDirect+0x14>
			vTaskDelay(300);
			DisableLineFollowerDirectTask();
			return;
		}
		
		DriverOLEDUpdate();
    7bfa:	0e 94 c5 0c 	call	0x198a	; 0x198a <DriverOLEDUpdate>

	EnableLineFollowerDirectTask();
	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    7bfe:	8c e2       	ldi	r24, 0x2C	; 44
    7c00:	91 e0       	ldi	r25, 0x01	; 1
    7c02:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
    7c06:	c8 2f       	mov	r28, r24
		
		DriverOLEDClearScreen();
    7c08:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <DriverOLEDClearScreen>
		
		DriverOLEDPrintSmText(0,"Line follower active",0);
    7c0c:	40 e0       	ldi	r20, 0x00	; 0
    7c0e:	6a e3       	ldi	r22, 0x3A	; 58
    7c10:	77 e2       	ldi	r23, 0x27	; 39
    7c12:	80 e0       	ldi	r24, 0x00	; 0
    7c14:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		
		if (Stick & CURSOR_UP);
		if (Stick & CURSOR_DOWN);
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
    7c18:	c0 ff       	sbrs	r28, 0
    7c1a:	ef cf       	rjmp	.-34     	; 0x7bfa <PageLineFollowDirect+0x10>
		{
			vTaskDelay(300);
    7c1c:	8c e2       	ldi	r24, 0x2C	; 44
    7c1e:	91 e0       	ldi	r25, 0x01	; 1
    7c20:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
			return;
		}
		
		DriverOLEDUpdate();
	}
}
    7c24:	cf 91       	pop	r28
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
		{
			vTaskDelay(300);
			DisableLineFollowerDirectTask();
    7c26:	0c 94 f8 33 	jmp	0x67f0	; 0x67f0 <DisableLineFollowerDirectTask>

00007c2a <PageRGB>:
		DriverOLEDUpdate();
	}
}

void PageRGB()
{
    7c2a:	ef 92       	push	r14
    7c2c:	ff 92       	push	r15
    7c2e:	0f 93       	push	r16
    7c30:	1f 93       	push	r17
    7c32:	cf 93       	push	r28
    7c34:	df 93       	push	r29
	uint8_t BlinkLeft=0;
	uint8_t BlinkRight=0;
	uint8_t Brake=0;
	uint8_t Effect=0;

	vTaskDelay(300);
    7c36:	8c e2       	ldi	r24, 0x2C	; 44
    7c38:	91 e0       	ldi	r25, 0x01	; 1
    7c3a:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
	uint8_t Stick;
	uint8_t Light=0;
	uint8_t BlinkLeft=0;
	uint8_t BlinkRight=0;
	uint8_t Brake=0;
	uint8_t Effect=0;
    7c3e:	d0 e0       	ldi	r29, 0x00	; 0
{
	uint8_t Stick;
	uint8_t Light=0;
	uint8_t BlinkLeft=0;
	uint8_t BlinkRight=0;
	uint8_t Brake=0;
    7c40:	e1 2c       	mov	r14, r1
void PageRGB()
{
	uint8_t Stick;
	uint8_t Light=0;
	uint8_t BlinkLeft=0;
	uint8_t BlinkRight=0;
    7c42:	f1 2c       	mov	r15, r1

void PageRGB()
{
	uint8_t Stick;
	uint8_t Light=0;
	uint8_t BlinkLeft=0;
    7c44:	00 e0       	ldi	r16, 0x00	; 0
}

void PageRGB()
{
	uint8_t Stick;
	uint8_t Light=0;
    7c46:	10 e0       	ldi	r17, 0x00	; 0
    7c48:	11 c0       	rjmp	.+34     	; 0x7c6c <PageRGB+0x42>
			vTaskDelay(300);
			return;
		}
		
		if (Light==0) Effect=RGB_NONE;
		if (Light==1) Effect=RGB_HEADLIGHT_LOW;
    7c4a:	11 30       	cpi	r17, 0x01	; 1
    7c4c:	09 f0       	breq	.+2      	; 0x7c50 <PageRGB+0x26>
    7c4e:	4d c0       	rjmp	.+154    	; 0x7cea <PageRGB+0xc0>
    7c50:	d1 e0       	ldi	r29, 0x01	; 1
		if (Light==2) Effect=RGB_HEADLIGHT_HIGH;
		if (Brake==1) Effect|=RGB_BRAKE;
    7c52:	81 e0       	ldi	r24, 0x01	; 1
    7c54:	e8 16       	cp	r14, r24
    7c56:	09 f4       	brne	.+2      	; 0x7c5a <PageRGB+0x30>
    7c58:	44 c0       	rjmp	.+136    	; 0x7ce2 <PageRGB+0xb8>
		if (BlinkLeft) Effect|=RGB_BLINK_LEFT;
    7c5a:	01 11       	cpse	r16, r1
    7c5c:	d4 60       	ori	r29, 0x04	; 4
		if (BlinkRight) Effect|=RGB_BLINK_RIGHT;
    7c5e:	f1 10       	cpse	r15, r1
    7c60:	d8 60       	ori	r29, 0x08	; 8
		SetRGB(Effect);
    7c62:	8d 2f       	mov	r24, r29
    7c64:	0e 94 4f 40 	call	0x809e	; 0x809e <SetRGB>
		
		DriverOLEDUpdate();
    7c68:	0e 94 c5 0c 	call	0x198a	; 0x198a <DriverOLEDUpdate>
	uint8_t Effect=0;

	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    7c6c:	8c e2       	ldi	r24, 0x2C	; 44
    7c6e:	91 e0       	ldi	r25, 0x01	; 1
    7c70:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
    7c74:	c8 2f       	mov	r28, r24
		
		DriverOLEDClearScreen();
    7c76:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <DriverOLEDClearScreen>
		
		DriverOLEDPrintSmText(0,"Left:toggle blink",0);
    7c7a:	40 e0       	ldi	r20, 0x00	; 0
    7c7c:	6f e4       	ldi	r22, 0x4F	; 79
    7c7e:	77 e2       	ldi	r23, 0x27	; 39
    7c80:	80 e0       	ldi	r24, 0x00	; 0
    7c82:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		DriverOLEDPrintSmText(1,"Right:toggle blink",0);
    7c86:	40 e0       	ldi	r20, 0x00	; 0
    7c88:	61 e6       	ldi	r22, 0x61	; 97
    7c8a:	77 e2       	ldi	r23, 0x27	; 39
    7c8c:	81 e0       	ldi	r24, 0x01	; 1
    7c8e:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		DriverOLEDPrintSmText(2,"Down:toggle brake",0);
    7c92:	40 e0       	ldi	r20, 0x00	; 0
    7c94:	64 e7       	ldi	r22, 0x74	; 116
    7c96:	77 e2       	ldi	r23, 0x27	; 39
    7c98:	82 e0       	ldi	r24, 0x02	; 2
    7c9a:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		DriverOLEDPrintSmText(3,"Up:toggle light",0);		
    7c9e:	40 e0       	ldi	r20, 0x00	; 0
    7ca0:	66 e8       	ldi	r22, 0x86	; 134
    7ca2:	77 e2       	ldi	r23, 0x27	; 39
    7ca4:	83 e0       	ldi	r24, 0x03	; 3
    7ca6:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>


		
		if (Stick & CURSOR_UP)
    7caa:	c4 ff       	sbrs	r28, 4
    7cac:	06 c0       	rjmp	.+12     	; 0x7cba <PageRGB+0x90>
		{
			if (Light==0) Light=1;
    7cae:	11 23       	and	r17, r17
    7cb0:	d1 f0       	breq	.+52     	; 0x7ce6 <PageRGB+0xbc>
			else if (Light==1) Light=2;
    7cb2:	11 30       	cpi	r17, 0x01	; 1
    7cb4:	49 f1       	breq	.+82     	; 0x7d08 <PageRGB+0xde>
			else if (Light==2) Light=0;
    7cb6:	12 30       	cpi	r17, 0x02	; 2
    7cb8:	49 f1       	breq	.+82     	; 0x7d0c <PageRGB+0xe2>
		}
		if (Stick & CURSOR_DOWN)
    7cba:	c2 ff       	sbrs	r28, 2
    7cbc:	02 c0       	rjmp	.+4      	; 0x7cc2 <PageRGB+0x98>
    7cbe:	81 e0       	ldi	r24, 0x01	; 1
    7cc0:	e8 26       	eor	r14, r24
		{
			if (Brake==0) Brake=1;
			else Brake=0;
		}
		if (Stick & CURSOR_RIGHT)
    7cc2:	c1 ff       	sbrs	r28, 1
    7cc4:	02 c0       	rjmp	.+4      	; 0x7cca <PageRGB+0xa0>
    7cc6:	81 e0       	ldi	r24, 0x01	; 1
    7cc8:	f8 26       	eor	r15, r24
		{
			if (BlinkRight==0) BlinkRight=1;
			else BlinkRight=0;
		}
		if (Stick & CURSOR_LEFT)
    7cca:	c3 ff       	sbrs	r28, 3
    7ccc:	02 c0       	rjmp	.+4      	; 0x7cd2 <PageRGB+0xa8>
    7cce:	81 e0       	ldi	r24, 0x01	; 1
    7cd0:	08 27       	eor	r16, r24
		{
			if (BlinkLeft==0) BlinkLeft=1;
			else BlinkLeft=0;
		}
		if (Stick & CURSOR_PRESS)
    7cd2:	c0 fd       	sbrc	r28, 0
    7cd4:	0f c0       	rjmp	.+30     	; 0x7cf4 <PageRGB+0xca>
		{
			vTaskDelay(300);
			return;
		}
		
		if (Light==0) Effect=RGB_NONE;
    7cd6:	11 11       	cpse	r17, r1
    7cd8:	b8 cf       	rjmp	.-144    	; 0x7c4a <PageRGB+0x20>
    7cda:	d0 e0       	ldi	r29, 0x00	; 0
		if (Light==1) Effect=RGB_HEADLIGHT_LOW;
		if (Light==2) Effect=RGB_HEADLIGHT_HIGH;
		if (Brake==1) Effect|=RGB_BRAKE;
    7cdc:	81 e0       	ldi	r24, 0x01	; 1
    7cde:	e8 12       	cpse	r14, r24
    7ce0:	bc cf       	rjmp	.-136    	; 0x7c5a <PageRGB+0x30>
    7ce2:	d0 61       	ori	r29, 0x10	; 16
    7ce4:	ba cf       	rjmp	.-140    	; 0x7c5a <PageRGB+0x30>


		
		if (Stick & CURSOR_UP)
		{
			if (Light==0) Light=1;
    7ce6:	11 e0       	ldi	r17, 0x01	; 1
    7ce8:	e8 cf       	rjmp	.-48     	; 0x7cba <PageRGB+0x90>
			return;
		}
		
		if (Light==0) Effect=RGB_NONE;
		if (Light==1) Effect=RGB_HEADLIGHT_LOW;
		if (Light==2) Effect=RGB_HEADLIGHT_HIGH;
    7cea:	12 30       	cpi	r17, 0x02	; 2
    7cec:	09 f0       	breq	.+2      	; 0x7cf0 <PageRGB+0xc6>
    7cee:	b1 cf       	rjmp	.-158    	; 0x7c52 <PageRGB+0x28>
    7cf0:	d2 e0       	ldi	r29, 0x02	; 2
    7cf2:	af cf       	rjmp	.-162    	; 0x7c52 <PageRGB+0x28>
			if (BlinkLeft==0) BlinkLeft=1;
			else BlinkLeft=0;
		}
		if (Stick & CURSOR_PRESS)
		{
			vTaskDelay(300);
    7cf4:	8c e2       	ldi	r24, 0x2C	; 44
    7cf6:	91 e0       	ldi	r25, 0x01	; 1
		
		DriverOLEDUpdate();

		
	}	
}
    7cf8:	df 91       	pop	r29
    7cfa:	cf 91       	pop	r28
    7cfc:	1f 91       	pop	r17
    7cfe:	0f 91       	pop	r16
    7d00:	ff 90       	pop	r15
    7d02:	ef 90       	pop	r14
			if (BlinkLeft==0) BlinkLeft=1;
			else BlinkLeft=0;
		}
		if (Stick & CURSOR_PRESS)
		{
			vTaskDelay(300);
    7d04:	0c 94 2f 2b 	jmp	0x565e	; 0x565e <vTaskDelay>

		
		if (Stick & CURSOR_UP)
		{
			if (Light==0) Light=1;
			else if (Light==1) Light=2;
    7d08:	12 e0       	ldi	r17, 0x02	; 2
    7d0a:	d7 cf       	rjmp	.-82     	; 0x7cba <PageRGB+0x90>
			else if (Light==2) Light=0;
    7d0c:	10 e0       	ldi	r17, 0x00	; 0
    7d0e:	d5 cf       	rjmp	.-86     	; 0x7cba <PageRGB+0x90>

00007d10 <PageGyro>:
		
	}	
}

void PageGyro()
{
    7d10:	bf 92       	push	r11
    7d12:	cf 92       	push	r12
    7d14:	df 92       	push	r13
    7d16:	ef 92       	push	r14
    7d18:	ff 92       	push	r15
    7d1a:	0f 93       	push	r16
    7d1c:	1f 93       	push	r17
    7d1e:	cf 93       	push	r28
    7d20:	df 93       	push	r29
    7d22:	cd b7       	in	r28, 0x3d	; 61
    7d24:	de b7       	in	r29, 0x3e	; 62
    7d26:	a8 97       	sbiw	r28, 0x28	; 40
    7d28:	cd bf       	out	0x3d, r28	; 61
    7d2a:	de bf       	out	0x3e, r29	; 62
	uint8_t Stick;
	int16_t x,y,z;
	char s[32];
	float Yaw,YawRate;
	
	vTaskDelay(300);
    7d2c:	8c e2       	ldi	r24, 0x2C	; 44
    7d2e:	91 e0       	ldi	r25, 0x01	; 1
    7d30:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
    7d34:	8e 01       	movw	r16, r28
    7d36:	0f 5f       	subi	r16, 0xFF	; 255
    7d38:	1f 4f       	sbci	r17, 0xFF	; 255
		
		DriverOLEDClearScreen();
		
		GyroGet(&YawRate,&Yaw);
		
		sprintf(s,"Yaw:%f",Yaw);
    7d3a:	86 e9       	ldi	r24, 0x96	; 150
    7d3c:	c8 2e       	mov	r12, r24
    7d3e:	87 e2       	ldi	r24, 0x27	; 39
    7d40:	d8 2e       	mov	r13, r24
		DriverOLEDPrintSmText(0,s,0);

		sprintf(s,"YawRate:%f",YawRate);
    7d42:	9d e9       	ldi	r25, 0x9D	; 157
    7d44:	e9 2e       	mov	r14, r25
    7d46:	97 e2       	ldi	r25, 0x27	; 39
    7d48:	f9 2e       	mov	r15, r25
    7d4a:	02 c0       	rjmp	.+4      	; 0x7d50 <PageGyro+0x40>
		{
			vTaskDelay(300);
			return;
		}
		
		DriverOLEDUpdate();
    7d4c:	0e 94 c5 0c 	call	0x198a	; 0x198a <DriverOLEDUpdate>
	float Yaw,YawRate;
	
	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    7d50:	8c e2       	ldi	r24, 0x2C	; 44
    7d52:	91 e0       	ldi	r25, 0x01	; 1
    7d54:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
    7d58:	b8 2e       	mov	r11, r24
		
		
		DriverOLEDClearScreen();
    7d5a:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <DriverOLEDClearScreen>
		
		GyroGet(&YawRate,&Yaw);
    7d5e:	be 01       	movw	r22, r28
    7d60:	6b 5d       	subi	r22, 0xDB	; 219
    7d62:	7f 4f       	sbci	r23, 0xFF	; 255
    7d64:	ce 01       	movw	r24, r28
    7d66:	81 96       	adiw	r24, 0x21	; 33
    7d68:	0e 94 24 33 	call	0x6648	; 0x6648 <GyroGet>
		
		sprintf(s,"Yaw:%f",Yaw);
    7d6c:	88 a5       	ldd	r24, Y+40	; 0x28
    7d6e:	8f 93       	push	r24
    7d70:	8f a1       	ldd	r24, Y+39	; 0x27
    7d72:	8f 93       	push	r24
    7d74:	8e a1       	ldd	r24, Y+38	; 0x26
    7d76:	8f 93       	push	r24
    7d78:	8d a1       	ldd	r24, Y+37	; 0x25
    7d7a:	8f 93       	push	r24
    7d7c:	df 92       	push	r13
    7d7e:	cf 92       	push	r12
    7d80:	1f 93       	push	r17
    7d82:	0f 93       	push	r16
    7d84:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    7d88:	40 e0       	ldi	r20, 0x00	; 0
    7d8a:	b8 01       	movw	r22, r16
    7d8c:	80 e0       	ldi	r24, 0x00	; 0
    7d8e:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>

		sprintf(s,"YawRate:%f",YawRate);
    7d92:	8c a1       	ldd	r24, Y+36	; 0x24
    7d94:	8f 93       	push	r24
    7d96:	8b a1       	ldd	r24, Y+35	; 0x23
    7d98:	8f 93       	push	r24
    7d9a:	8a a1       	ldd	r24, Y+34	; 0x22
    7d9c:	8f 93       	push	r24
    7d9e:	89 a1       	ldd	r24, Y+33	; 0x21
    7da0:	8f 93       	push	r24
    7da2:	ff 92       	push	r15
    7da4:	ef 92       	push	r14
    7da6:	1f 93       	push	r17
    7da8:	0f 93       	push	r16
    7daa:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    7dae:	40 e0       	ldi	r20, 0x00	; 0
    7db0:	b8 01       	movw	r22, r16
    7db2:	81 e0       	ldi	r24, 0x01	; 1
    7db4:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		
		if (Stick & CURSOR_UP);
		if (Stick & CURSOR_DOWN);
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
    7db8:	cd bf       	out	0x3d, r28	; 61
    7dba:	de bf       	out	0x3e, r29	; 62
    7dbc:	b0 fe       	sbrs	r11, 0
    7dbe:	c6 cf       	rjmp	.-116    	; 0x7d4c <PageGyro+0x3c>
		{
			vTaskDelay(300);
    7dc0:	8c e2       	ldi	r24, 0x2C	; 44
    7dc2:	91 e0       	ldi	r25, 0x01	; 1
    7dc4:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
		}
		
		DriverOLEDUpdate();
		
	}
}
    7dc8:	a8 96       	adiw	r28, 0x28	; 40
    7dca:	cd bf       	out	0x3d, r28	; 61
    7dcc:	de bf       	out	0x3e, r29	; 62
    7dce:	df 91       	pop	r29
    7dd0:	cf 91       	pop	r28
    7dd2:	1f 91       	pop	r17
    7dd4:	0f 91       	pop	r16
    7dd6:	ff 90       	pop	r15
    7dd8:	ef 90       	pop	r14
    7dda:	df 90       	pop	r13
    7ddc:	cf 90       	pop	r12
    7dde:	bf 90       	pop	r11
    7de0:	08 95       	ret

00007de2 <PageRanger>:

void PageRanger()
{
    7de2:	df 92       	push	r13
    7de4:	ef 92       	push	r14
    7de6:	ff 92       	push	r15
    7de8:	0f 93       	push	r16
    7dea:	1f 93       	push	r17
    7dec:	cf 93       	push	r28
    7dee:	df 93       	push	r29
    7df0:	cd b7       	in	r28, 0x3d	; 61
    7df2:	de b7       	in	r29, 0x3e	; 62
    7df4:	a0 97       	sbiw	r28, 0x20	; 32
    7df6:	cd bf       	out	0x3d, r28	; 61
    7df8:	de bf       	out	0x3e, r29	; 62
	uint8_t Stick;
	uint16_t Distance;
	char s[32];
	
	vTaskDelay(300);
    7dfa:	8c e2       	ldi	r24, 0x2C	; 44
    7dfc:	91 e0       	ldi	r25, 0x01	; 1
    7dfe:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
    7e02:	ce 01       	movw	r24, r28
    7e04:	01 96       	adiw	r24, 0x01	; 1
    7e06:	7c 01       	movw	r14, r24
		
		DriverOLEDClearScreen();
		
		Distance=DriverVL53L0XReadSingle();
		
		sprintf(s,"Range:%u",Distance);
    7e08:	08 ea       	ldi	r16, 0xA8	; 168
    7e0a:	17 e2       	ldi	r17, 0x27	; 39
    7e0c:	02 c0       	rjmp	.+4      	; 0x7e12 <PageRanger+0x30>
		{
			vTaskDelay(300);
			return;
		}
		
		DriverOLEDUpdate();
    7e0e:	0e 94 c5 0c 	call	0x198a	; 0x198a <DriverOLEDUpdate>
	char s[32];
	
	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    7e12:	8c e2       	ldi	r24, 0x2C	; 44
    7e14:	91 e0       	ldi	r25, 0x01	; 1
    7e16:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
    7e1a:	d8 2e       	mov	r13, r24
		
		
		DriverOLEDClearScreen();
    7e1c:	0e 94 80 0d 	call	0x1b00	; 0x1b00 <DriverOLEDClearScreen>
		
		Distance=DriverVL53L0XReadSingle();
    7e20:	0e 94 8c 1b 	call	0x3718	; 0x3718 <DriverVL53L0XReadSingle>
		
		sprintf(s,"Range:%u",Distance);
    7e24:	9f 93       	push	r25
    7e26:	8f 93       	push	r24
    7e28:	1f 93       	push	r17
    7e2a:	0f 93       	push	r16
    7e2c:	ff 92       	push	r15
    7e2e:	ef 92       	push	r14
    7e30:	0e 94 ce 4e 	call	0x9d9c	; 0x9d9c <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    7e34:	40 e0       	ldi	r20, 0x00	; 0
    7e36:	b7 01       	movw	r22, r14
    7e38:	80 e0       	ldi	r24, 0x00	; 0
    7e3a:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <DriverOLEDPrintSmText>
		
		if (Stick & CURSOR_UP);
		if (Stick & CURSOR_DOWN);
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
    7e3e:	0f 90       	pop	r0
    7e40:	0f 90       	pop	r0
    7e42:	0f 90       	pop	r0
    7e44:	0f 90       	pop	r0
    7e46:	0f 90       	pop	r0
    7e48:	0f 90       	pop	r0
    7e4a:	d0 fe       	sbrs	r13, 0
    7e4c:	e0 cf       	rjmp	.-64     	; 0x7e0e <PageRanger+0x2c>
		{
			vTaskDelay(300);
    7e4e:	8c e2       	ldi	r24, 0x2C	; 44
    7e50:	91 e0       	ldi	r25, 0x01	; 1
    7e52:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
		}
		
		DriverOLEDUpdate();
		
	}
    7e56:	a0 96       	adiw	r28, 0x20	; 32
    7e58:	cd bf       	out	0x3d, r28	; 61
    7e5a:	de bf       	out	0x3e, r29	; 62
    7e5c:	df 91       	pop	r29
    7e5e:	cf 91       	pop	r28
    7e60:	1f 91       	pop	r17
    7e62:	0f 91       	pop	r16
    7e64:	ff 90       	pop	r15
    7e66:	ef 90       	pop	r14
    7e68:	df 90       	pop	r13
    7e6a:	08 95       	ret

00007e6c <WorkerOLEDMenu>:
{
	uint8_t Stick;
	
	while(1)
	{
		Stick=DriverCursorStickGetFifo(300);
    7e6c:	8c e2       	ldi	r24, 0x2C	; 44
    7e6e:	91 e0       	ldi	r25, 0x01	; 1
    7e70:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
}


void DownMenu()
{
	if (SelItem<NUM_LINES-1) SelItem++;
    7e74:	60 91 bb 2d 	lds	r22, 0x2DBB	; 0x802dbb <SelItem>
	uint8_t Stick;
	
	while(1)
	{
		Stick=DriverCursorStickGetFifo(300);
		if (Stick & CURSOR_DOWN) DownMenu();
    7e78:	82 ff       	sbrs	r24, 2
    7e7a:	1f c0       	rjmp	.+62     	; 0x7eba <WorkerOLEDMenu+0x4e>
}


void DownMenu()
{
	if (SelItem<NUM_LINES-1) SelItem++;
    7e7c:	69 30       	cpi	r22, 0x09	; 9
    7e7e:	18 f4       	brcc	.+6      	; 0x7e86 <WorkerOLEDMenu+0x1a>
    7e80:	6f 5f       	subi	r22, 0xFF	; 255
    7e82:	60 93 bb 2d 	sts	0x2DBB, r22	; 0x802dbb <SelItem>
	if (SelItem>=TopItem+DISPLAYED_LINES) TopItem++;
    7e86:	20 91 bc 2d 	lds	r18, 0x2DBC	; 0x802dbc <TopItem>
    7e8a:	82 2f       	mov	r24, r18
    7e8c:	90 e0       	ldi	r25, 0x00	; 0
    7e8e:	70 e0       	ldi	r23, 0x00	; 0
    7e90:	ac 01       	movw	r20, r24
    7e92:	4b 5f       	subi	r20, 0xFB	; 251
    7e94:	5f 4f       	sbci	r21, 0xFF	; 255
    7e96:	46 17       	cp	r20, r22
    7e98:	57 07       	cpc	r21, r23
    7e9a:	2c f4       	brge	.+10     	; 0x7ea6 <WorkerOLEDMenu+0x3a>
    7e9c:	2f 5f       	subi	r18, 0xFF	; 255
    7e9e:	20 93 bc 2d 	sts	0x2DBC, r18	; 0x802dbc <TopItem>
    7ea2:	82 2f       	mov	r24, r18
    7ea4:	90 e0       	ldi	r25, 0x00	; 0
			else if (SelItem==7) PageGyro();	
			else if (SelItem==8) PageRanger();
			else if (SelItem==9) configASSERT(false); //Force halt
		}
		
		DrawMenu(TopItem,SelItem);
    7ea6:	0e 94 e2 39 	call	0x73c4	; 0x73c4 <DrawMenu>
{
	uint8_t Stick;
	
	while(1)
	{
		Stick=DriverCursorStickGetFifo(300);
    7eaa:	8c e2       	ldi	r24, 0x2C	; 44
    7eac:	91 e0       	ldi	r25, 0x01	; 1
    7eae:	0e 94 37 05 	call	0xa6e	; 0xa6e <DriverCursorStickGetFifo>
}


void DownMenu()
{
	if (SelItem<NUM_LINES-1) SelItem++;
    7eb2:	60 91 bb 2d 	lds	r22, 0x2DBB	; 0x802dbb <SelItem>
	uint8_t Stick;
	
	while(1)
	{
		Stick=DriverCursorStickGetFifo(300);
		if (Stick & CURSOR_DOWN) DownMenu();
    7eb6:	82 fd       	sbrc	r24, 2
    7eb8:	e1 cf       	rjmp	.-62     	; 0x7e7c <WorkerOLEDMenu+0x10>
		else if (Stick & CURSOR_UP) UpMenu();
    7eba:	84 ff       	sbrs	r24, 4
    7ebc:	10 c0       	rjmp	.+32     	; 0x7ede <WorkerOLEDMenu+0x72>
	if (SelItem>=TopItem+DISPLAYED_LINES) TopItem++;
}

void UpMenu()
{
	if (SelItem>0) SelItem--;
    7ebe:	66 23       	and	r22, r22
    7ec0:	19 f0       	breq	.+6      	; 0x7ec8 <WorkerOLEDMenu+0x5c>
    7ec2:	61 50       	subi	r22, 0x01	; 1
    7ec4:	60 93 bb 2d 	sts	0x2DBB, r22	; 0x802dbb <SelItem>
	if (SelItem<TopItem) TopItem=SelItem;
    7ec8:	80 91 bc 2d 	lds	r24, 0x2DBC	; 0x802dbc <TopItem>
    7ecc:	68 17       	cp	r22, r24
    7ece:	60 f5       	brcc	.+88     	; 0x7f28 <WorkerOLEDMenu+0xbc>
    7ed0:	60 93 bc 2d 	sts	0x2DBC, r22	; 0x802dbc <TopItem>
    7ed4:	70 e0       	ldi	r23, 0x00	; 0
    7ed6:	cb 01       	movw	r24, r22
			else if (SelItem==7) PageGyro();	
			else if (SelItem==8) PageRanger();
			else if (SelItem==9) configASSERT(false); //Force halt
		}
		
		DrawMenu(TopItem,SelItem);
    7ed8:	0e 94 e2 39 	call	0x73c4	; 0x73c4 <DrawMenu>
    7edc:	e6 cf       	rjmp	.-52     	; 0x7eaa <WorkerOLEDMenu+0x3e>
	while(1)
	{
		Stick=DriverCursorStickGetFifo(300);
		if (Stick & CURSOR_DOWN) DownMenu();
		else if (Stick & CURSOR_UP) UpMenu();
		else if (Stick & CURSOR_PRESS)
    7ede:	80 ff       	sbrs	r24, 0
    7ee0:	1c c0       	rjmp	.+56     	; 0x7f1a <WorkerOLEDMenu+0xae>
		{
			if (SelItem==0) PageCPUStatus();
    7ee2:	66 23       	and	r22, r22
    7ee4:	49 f1       	breq	.+82     	; 0x7f38 <WorkerOLEDMenu+0xcc>
			else if (SelItem==1) PageMotorSpeed();
    7ee6:	61 30       	cpi	r22, 0x01	; 1
    7ee8:	51 f1       	breq	.+84     	; 0x7f3e <WorkerOLEDMenu+0xd2>
			else if (SelItem==2) PageADPS9960();
    7eea:	62 30       	cpi	r22, 0x02	; 2
    7eec:	59 f1       	breq	.+86     	; 0x7f44 <WorkerOLEDMenu+0xd8>
			else if (SelItem==3) PageADC();
    7eee:	63 30       	cpi	r22, 0x03	; 3
    7ef0:	61 f1       	breq	.+88     	; 0x7f4a <WorkerOLEDMenu+0xde>
			else if (SelItem==4) PageLineFollowSpeed();
    7ef2:	64 30       	cpi	r22, 0x04	; 4
    7ef4:	f1 f0       	breq	.+60     	; 0x7f32 <WorkerOLEDMenu+0xc6>
			else if (SelItem==5) PageLineFollowDirect();
    7ef6:	65 30       	cpi	r22, 0x05	; 5
    7ef8:	59 f1       	breq	.+86     	; 0x7f50 <WorkerOLEDMenu+0xe4>
			else if (SelItem==6) PageRGB();
    7efa:	66 30       	cpi	r22, 0x06	; 6
    7efc:	61 f1       	breq	.+88     	; 0x7f56 <WorkerOLEDMenu+0xea>
			else if (SelItem==7) PageGyro();	
    7efe:	67 30       	cpi	r22, 0x07	; 7
    7f00:	69 f1       	breq	.+90     	; 0x7f5c <WorkerOLEDMenu+0xf0>
			else if (SelItem==8) PageRanger();
    7f02:	68 30       	cpi	r22, 0x08	; 8
    7f04:	71 f1       	breq	.+92     	; 0x7f62 <WorkerOLEDMenu+0xf6>
			else if (SelItem==9) configASSERT(false); //Force halt
    7f06:	69 30       	cpi	r22, 0x09	; 9
    7f08:	41 f4       	brne	.+16     	; 0x7f1a <WorkerOLEDMenu+0xae>
    7f0a:	67 e5       	ldi	r22, 0x57	; 87
    7f0c:	70 e0       	ldi	r23, 0x00	; 0
    7f0e:	81 eb       	ldi	r24, 0xB1	; 177
    7f10:	97 e2       	ldi	r25, 0x27	; 39
    7f12:	0e 94 20 30 	call	0x6040	; 0x6040 <vAssertCalled>
    7f16:	60 91 bb 2d 	lds	r22, 0x2DBB	; 0x802dbb <SelItem>
    7f1a:	70 e0       	ldi	r23, 0x00	; 0
    7f1c:	80 91 bc 2d 	lds	r24, 0x2DBC	; 0x802dbc <TopItem>
    7f20:	90 e0       	ldi	r25, 0x00	; 0
		}
		
		DrawMenu(TopItem,SelItem);
    7f22:	0e 94 e2 39 	call	0x73c4	; 0x73c4 <DrawMenu>
    7f26:	c1 cf       	rjmp	.-126    	; 0x7eaa <WorkerOLEDMenu+0x3e>
    7f28:	70 e0       	ldi	r23, 0x00	; 0
    7f2a:	90 e0       	ldi	r25, 0x00	; 0
    7f2c:	0e 94 e2 39 	call	0x73c4	; 0x73c4 <DrawMenu>
    7f30:	bc cf       	rjmp	.-136    	; 0x7eaa <WorkerOLEDMenu+0x3e>
		{
			if (SelItem==0) PageCPUStatus();
			else if (SelItem==1) PageMotorSpeed();
			else if (SelItem==2) PageADPS9960();
			else if (SelItem==3) PageADC();
			else if (SelItem==4) PageLineFollowSpeed();
    7f32:	0e 94 c9 3d 	call	0x7b92	; 0x7b92 <PageLineFollowSpeed>
    7f36:	ef cf       	rjmp	.-34     	; 0x7f16 <WorkerOLEDMenu+0xaa>
		Stick=DriverCursorStickGetFifo(300);
		if (Stick & CURSOR_DOWN) DownMenu();
		else if (Stick & CURSOR_UP) UpMenu();
		else if (Stick & CURSOR_PRESS)
		{
			if (SelItem==0) PageCPUStatus();
    7f38:	0e 94 0d 3a 	call	0x741a	; 0x741a <PageCPUStatus>
    7f3c:	ec cf       	rjmp	.-40     	; 0x7f16 <WorkerOLEDMenu+0xaa>
			else if (SelItem==1) PageMotorSpeed();
    7f3e:	0e 94 e3 3a 	call	0x75c6	; 0x75c6 <PageMotorSpeed>
    7f42:	e9 cf       	rjmp	.-46     	; 0x7f16 <WorkerOLEDMenu+0xaa>
			else if (SelItem==2) PageADPS9960();
    7f44:	0e 94 7e 3c 	call	0x78fc	; 0x78fc <PageADPS9960>
    7f48:	e6 cf       	rjmp	.-52     	; 0x7f16 <WorkerOLEDMenu+0xaa>
			else if (SelItem==3) PageADC();
    7f4a:	0e 94 19 3d 	call	0x7a32	; 0x7a32 <PageADC>
    7f4e:	e3 cf       	rjmp	.-58     	; 0x7f16 <WorkerOLEDMenu+0xaa>
			else if (SelItem==4) PageLineFollowSpeed();
			else if (SelItem==5) PageLineFollowDirect();
    7f50:	0e 94 f5 3d 	call	0x7bea	; 0x7bea <PageLineFollowDirect>
    7f54:	e0 cf       	rjmp	.-64     	; 0x7f16 <WorkerOLEDMenu+0xaa>
			else if (SelItem==6) PageRGB();
    7f56:	0e 94 15 3e 	call	0x7c2a	; 0x7c2a <PageRGB>
    7f5a:	dd cf       	rjmp	.-70     	; 0x7f16 <WorkerOLEDMenu+0xaa>
			else if (SelItem==7) PageGyro();	
    7f5c:	0e 94 88 3e 	call	0x7d10	; 0x7d10 <PageGyro>
    7f60:	da cf       	rjmp	.-76     	; 0x7f16 <WorkerOLEDMenu+0xaa>
			else if (SelItem==8) PageRanger();
    7f62:	0e 94 f1 3e 	call	0x7de2	; 0x7de2 <PageRanger>
    7f66:	d7 cf       	rjmp	.-82     	; 0x7f16 <WorkerOLEDMenu+0xaa>

00007f68 <WorkerRGB>:
	xQueueOverwrite(EffectQueue,&Effect);
	
}

void WorkerRGB(void *pvParameters)
{
    7f68:	cf 93       	push	r28
    7f6a:	df 93       	push	r29
    7f6c:	1f 92       	push	r1
    7f6e:	cd b7       	in	r28, 0x3d	; 61
    7f70:	de b7       	in	r29, 0x3e	; 62
    7f72:	4a c0       	rjmp	.+148    	; 0x8008 <WorkerRGB+0xa0>
		
		//Time slot 1
		if (Effect & RGB_HEADLIGHT_HIGH)
		{
			FrontRight=PL9823_RGB(255,255,255);
			FrontLeft=PL9823_RGB(255,255,255);
    7f74:	66 24       	eor	r6, r6
    7f76:	6a 94       	dec	r6
    7f78:	77 24       	eor	r7, r7
    7f7a:	7a 94       	dec	r7
    7f7c:	88 24       	eor	r8, r8
    7f7e:	8a 94       	dec	r8
    7f80:	91 2c       	mov	r9, r1
		}
		if (Effect & RGB_HEADLIGHT_LOW)
    7f82:	80 ff       	sbrs	r24, 0
    7f84:	07 c0       	rjmp	.+14     	; 0x7f94 <WorkerRGB+0x2c>
		{
			FrontRight=PL9823_RGB(128,128,128);
			FrontLeft=PL9823_RGB(128,128,128);
    7f86:	90 e8       	ldi	r25, 0x80	; 128
    7f88:	69 2e       	mov	r6, r25
    7f8a:	20 e8       	ldi	r18, 0x80	; 128
    7f8c:	72 2e       	mov	r7, r18
    7f8e:	30 e8       	ldi	r19, 0x80	; 128
    7f90:	83 2e       	mov	r8, r19
    7f92:	91 2c       	mov	r9, r1
		}
		if (Effect & RGB_BRAKE)
    7f94:	84 ff       	sbrs	r24, 4
    7f96:	4b c0       	rjmp	.+150    	; 0x802e <WorkerRGB+0xc6>
		{
			RearRight=PL9823_RED;
    7f98:	22 24       	eor	r2, r2
    7f9a:	2a 94       	dec	r2
    7f9c:	31 2c       	mov	r3, r1
    7f9e:	41 2c       	mov	r4, r1
    7fa0:	51 2c       	mov	r5, r1
			RearLeft=PL9823_RED;
		}

		DriverPL9823Set(FrontLeft,FrontRight,RearRight,RearLeft);
    7fa2:	51 01       	movw	r10, r2
    7fa4:	62 01       	movw	r12, r4
    7fa6:	71 01       	movw	r14, r2
    7fa8:	82 01       	movw	r16, r4
    7faa:	93 01       	movw	r18, r6
    7fac:	a4 01       	movw	r20, r8
    7fae:	b3 01       	movw	r22, r6
    7fb0:	c4 01       	movw	r24, r8
    7fb2:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DriverPL9823Set>
		vTaskDelay(250); 
    7fb6:	8a ef       	ldi	r24, 0xFA	; 250
    7fb8:	90 e0       	ldi	r25, 0x00	; 0
    7fba:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
		
		//Time slot 2
		if (Effect & RGB_BLINK_LEFT)
    7fbe:	29 81       	ldd	r18, Y+1	; 0x01
    7fc0:	22 ff       	sbrs	r18, 2
    7fc2:	3a c0       	rjmp	.+116    	; 0x8038 <WorkerRGB+0xd0>
		{
			FrontLeft=PL9823_YELLOW;
			RearLeft=PL9823_YELLOW;
    7fc4:	aa 24       	eor	r10, r10
    7fc6:	aa 94       	dec	r10
    7fc8:	bb 24       	eor	r11, r11
    7fca:	ba 94       	dec	r11
    7fcc:	c1 2c       	mov	r12, r1
    7fce:	d1 2c       	mov	r13, r1
		vTaskDelay(250); 
		
		//Time slot 2
		if (Effect & RGB_BLINK_LEFT)
		{
			FrontLeft=PL9823_YELLOW;
    7fd0:	6f ef       	ldi	r22, 0xFF	; 255
    7fd2:	7f ef       	ldi	r23, 0xFF	; 255
    7fd4:	80 e0       	ldi	r24, 0x00	; 0
    7fd6:	90 e0       	ldi	r25, 0x00	; 0
			RearLeft=PL9823_YELLOW;
		}
		if (Effect & RGB_BLINK_RIGHT)
    7fd8:	23 ff       	sbrs	r18, 3
    7fda:	0c c0       	rjmp	.+24     	; 0x7ff4 <WorkerRGB+0x8c>
		{
			FrontRight=PL9823_YELLOW;
			RearRight=PL9823_YELLOW;
    7fdc:	22 24       	eor	r2, r2
    7fde:	2a 94       	dec	r2
    7fe0:	33 24       	eor	r3, r3
    7fe2:	3a 94       	dec	r3
    7fe4:	41 2c       	mov	r4, r1
    7fe6:	51 2c       	mov	r5, r1
			FrontLeft=PL9823_YELLOW;
			RearLeft=PL9823_YELLOW;
		}
		if (Effect & RGB_BLINK_RIGHT)
		{
			FrontRight=PL9823_YELLOW;
    7fe8:	66 24       	eor	r6, r6
    7fea:	6a 94       	dec	r6
    7fec:	77 24       	eor	r7, r7
    7fee:	7a 94       	dec	r7
    7ff0:	81 2c       	mov	r8, r1
    7ff2:	91 2c       	mov	r9, r1
			RearRight=PL9823_YELLOW;
		}
		DriverPL9823Set(FrontLeft,FrontRight,RearRight,RearLeft);
    7ff4:	71 01       	movw	r14, r2
    7ff6:	82 01       	movw	r16, r4
    7ff8:	93 01       	movw	r18, r6
    7ffa:	a4 01       	movw	r20, r8
    7ffc:	0e 94 f7 0e 	call	0x1dee	; 0x1dee <DriverPL9823Set>
		vTaskDelay(250);
    8000:	8a ef       	ldi	r24, 0xFA	; 250
    8002:	90 e0       	ldi	r25, 0x00	; 0
    8004:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
	{
		FrontLeft=PL9823_BLANK;
		FrontRight=PL9823_BLANK;
		RearLeft=PL9823_BLANK;
		RearRight=PL9823_BLANK;	
		xQueuePeek(EffectQueue,&Effect,0);
    8008:	40 e0       	ldi	r20, 0x00	; 0
    800a:	50 e0       	ldi	r21, 0x00	; 0
    800c:	be 01       	movw	r22, r28
    800e:	6f 5f       	subi	r22, 0xFF	; 255
    8010:	7f 4f       	sbci	r23, 0xFF	; 255
    8012:	80 91 d7 2d 	lds	r24, 0x2DD7	; 0x802dd7 <EffectQueue>
    8016:	90 91 d8 2d 	lds	r25, 0x2DD8	; 0x802dd8 <EffectQueue+0x1>
    801a:	0e 94 0c 24 	call	0x4818	; 0x4818 <xQueuePeek>
		
		
		
		//Time slot 1
		if (Effect & RGB_HEADLIGHT_HIGH)
    801e:	89 81       	ldd	r24, Y+1	; 0x01
    8020:	81 fd       	sbrc	r24, 1
    8022:	a8 cf       	rjmp	.-176    	; 0x7f74 <WorkerRGB+0xc>
	uint8_t Effect;
	uint32_t FrontLeft,FrontRight,RearRight,RearLeft;
	
	while(1)
	{
		FrontLeft=PL9823_BLANK;
    8024:	61 2c       	mov	r6, r1
    8026:	71 2c       	mov	r7, r1
    8028:	81 2c       	mov	r8, r1
    802a:	91 2c       	mov	r9, r1
    802c:	aa cf       	rjmp	.-172    	; 0x7f82 <WorkerRGB+0x1a>
		FrontRight=PL9823_BLANK;
		RearLeft=PL9823_BLANK;
		RearRight=PL9823_BLANK;	
    802e:	21 2c       	mov	r2, r1
    8030:	31 2c       	mov	r3, r1
    8032:	41 2c       	mov	r4, r1
    8034:	51 2c       	mov	r5, r1
    8036:	b5 cf       	rjmp	.-150    	; 0x7fa2 <WorkerRGB+0x3a>
    8038:	51 01       	movw	r10, r2
    803a:	62 01       	movw	r12, r4
    803c:	b3 01       	movw	r22, r6
    803e:	c4 01       	movw	r24, r8
    8040:	cb cf       	rjmp	.-106    	; 0x7fd8 <WorkerRGB+0x70>

00008042 <InitRGBTask>:
void WorkerRGB(void *pvParameters);


//Function definitions
void InitRGBTask()
{
    8042:	ef 92       	push	r14
    8044:	ff 92       	push	r15
    8046:	0f 93       	push	r16
    8048:	cf 93       	push	r28
    804a:	df 93       	push	r29
    804c:	1f 92       	push	r1
    804e:	cd b7       	in	r28, 0x3d	; 61
    8050:	de b7       	in	r29, 0x3e	; 62
	EffectQueue=xQueueCreate(1,sizeof(uint8_t));
    8052:	40 e0       	ldi	r20, 0x00	; 0
    8054:	61 e0       	ldi	r22, 0x01	; 1
    8056:	81 e0       	ldi	r24, 0x01	; 1
    8058:	0e 94 7a 20 	call	0x40f4	; 0x40f4 <xQueueGenericCreate>
    805c:	80 93 d7 2d 	sts	0x2DD7, r24	; 0x802dd7 <EffectQueue>
    8060:	90 93 d8 2d 	sts	0x2DD8, r25	; 0x802dd8 <EffectQueue+0x1>
    8064:	19 82       	std	Y+1, r1	; 0x01
	xTaskCreate( WorkerRGB, "rgb", 512, NULL, tskIDLE_PRIORITY+4, NULL );	
}

void SetRGB(uint8_t Effect)
{
	xQueueOverwrite(EffectQueue,&Effect);
    8066:	22 e0       	ldi	r18, 0x02	; 2
    8068:	40 e0       	ldi	r20, 0x00	; 0
    806a:	50 e0       	ldi	r21, 0x00	; 0
    806c:	be 01       	movw	r22, r28
    806e:	6f 5f       	subi	r22, 0xFF	; 255
    8070:	7f 4f       	sbci	r23, 0xFF	; 255
    8072:	0e 94 be 20 	call	0x417c	; 0x417c <xQueueGenericSend>
//Function definitions
void InitRGBTask()
{
	EffectQueue=xQueueCreate(1,sizeof(uint8_t));
	SetRGB(RGB_NONE);
	xTaskCreate( WorkerRGB, "rgb", 512, NULL, tskIDLE_PRIORITY+4, NULL );	
    8076:	e1 2c       	mov	r14, r1
    8078:	f1 2c       	mov	r15, r1
    807a:	04 e0       	ldi	r16, 0x04	; 4
    807c:	20 e0       	ldi	r18, 0x00	; 0
    807e:	30 e0       	ldi	r19, 0x00	; 0
    8080:	40 e0       	ldi	r20, 0x00	; 0
    8082:	52 e0       	ldi	r21, 0x02	; 2
    8084:	64 e2       	ldi	r22, 0x24	; 36
    8086:	78 e2       	ldi	r23, 0x28	; 40
    8088:	84 eb       	ldi	r24, 0xB4	; 180
    808a:	9f e3       	ldi	r25, 0x3F	; 63
    808c:	0e 94 c8 26 	call	0x4d90	; 0x4d90 <xTaskCreate>
}
    8090:	0f 90       	pop	r0
    8092:	df 91       	pop	r29
    8094:	cf 91       	pop	r28
    8096:	0f 91       	pop	r16
    8098:	ff 90       	pop	r15
    809a:	ef 90       	pop	r14
    809c:	08 95       	ret

0000809e <SetRGB>:

void SetRGB(uint8_t Effect)
{
    809e:	cf 93       	push	r28
    80a0:	df 93       	push	r29
    80a2:	1f 92       	push	r1
    80a4:	cd b7       	in	r28, 0x3d	; 61
    80a6:	de b7       	in	r29, 0x3e	; 62
    80a8:	89 83       	std	Y+1, r24	; 0x01
	xQueueOverwrite(EffectQueue,&Effect);
    80aa:	22 e0       	ldi	r18, 0x02	; 2
    80ac:	40 e0       	ldi	r20, 0x00	; 0
    80ae:	50 e0       	ldi	r21, 0x00	; 0
    80b0:	be 01       	movw	r22, r28
    80b2:	6f 5f       	subi	r22, 0xFF	; 255
    80b4:	7f 4f       	sbci	r23, 0xFF	; 255
    80b6:	80 91 d7 2d 	lds	r24, 0x2DD7	; 0x802dd7 <EffectQueue>
    80ba:	90 91 d8 2d 	lds	r25, 0x2DD8	; 0x802dd8 <EffectQueue+0x1>
    80be:	0e 94 be 20 	call	0x417c	; 0x417c <xQueueGenericSend>
	
}
    80c2:	0f 90       	pop	r0
    80c4:	df 91       	pop	r29
    80c6:	cf 91       	pop	r28
    80c8:	08 95       	ret

000080ca <WorkerStartup>:

static void WorkerStartup(void *pvParameters)
{
	int res;
	
	DriverPowerVccAuxSet(1);//Enable Auxillary power line
    80ca:	81 e0       	ldi	r24, 0x01	; 1
    80cc:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <DriverPowerVccAuxSet>
	DriverCursorstickInit();//Initialize cursor stick
    80d0:	0e 94 06 05 	call	0xa0c	; 0xa0c <DriverCursorstickInit>
	DriverLedInit();		//Initialize LED's
    80d4:	0e 94 75 06 	call	0xcea	; 0xcea <DriverLedInit>
	DriverUSARTInit();		//USART init and link to stdio
    80d8:	0e 94 85 11 	call	0x230a	; 0x230a <DriverUSARTInit>
	DriverPowerInit();		//Initialize aux power driver
    80dc:	0e 94 8c 0f 	call	0x1f18	; 0x1f18 <DriverPowerInit>
	
	DriverTWIMInit();		//Initialize TWI in master mode
    80e0:	0e 94 b5 0f 	call	0x1f6a	; 0x1f6a <DriverTWIMInit>
	DriverPL9823Init();		//Initialize PL9823 LEDs
    80e4:	0e 94 f1 0e 	call	0x1de2	; 0x1de2 <DriverPL9823Init>
	DriverAdcInit();		//Initialize ADC driver
    80e8:	0e 94 86 03 	call	0x70c	; 0x70c <DriverAdcInit>
	
	DriverOLEDInit(2);		//Initialize OLED display
    80ec:	82 e0       	ldi	r24, 0x02	; 2
    80ee:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <DriverOLEDInit>
	DriverAdps9960Init();	//Initialize color sensor	
    80f2:	0e 94 40 04 	call	0x880	; 0x880 <DriverAdps9960Init>
	DriverVL53L0XInit();	//Initialize rangefinder
    80f6:	0e 94 f1 14 	call	0x29e2	; 0x29e2 <DriverVL53L0XInit>

	
	vTaskDelay(50);
    80fa:	82 e3       	ldi	r24, 0x32	; 50
    80fc:	90 e0       	ldi	r25, 0x00	; 0
    80fe:	0e 94 2f 2b 	call	0x565e	; 0x565e <vTaskDelay>
	
	//Enable test output (T21)
	PORTA.DIRSET=1<<5;	
    8102:	80 e2       	ldi	r24, 0x20	; 32
    8104:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	//Initialize application tasks			
	
	InitOLEDMenuTask();
    8108:	0e 94 ce 39 	call	0x739c	; 0x739c <InitOLEDMenuTask>
	InitADCTask();
    810c:	0e 94 00 32 	call	0x6400	; 0x6400 <InitADCTask>
	InitMotorPosTask();
    8110:	0e 94 04 39 	call	0x7208	; 0x7208 <InitMotorPosTask>
	InitMotorSpeedTask();
    8114:	0e 94 7c 39 	call	0x72f8	; 0x72f8 <InitMotorSpeedTask>
	InitLineFollowerSpeedTask();
    8118:	0e 94 90 34 	call	0x6920	; 0x6920 <InitLineFollowerSpeedTask>
	InitLineFollowerDirectTask();
    811c:	0e 94 d7 33 	call	0x67ae	; 0x67ae <InitLineFollowerDirectTask>
	InitRGBTask();
    8120:	0e 94 21 40 	call	0x8042	; 0x8042 <InitRGBTask>
	InitGyroTask();
    8124:	0e 94 09 33 	call	0x6612	; 0x6612 <InitGyroTask>
	InitTerminalTask();
    8128:	0e 94 19 43 	call	0x8632	; 0x8632 <InitTerminalTask>
	InitMotionTask();
    812c:	0e 94 f7 36 	call	0x6dee	; 0x6dee <InitMotionTask>
	
	vTaskSuspend(NULL);
    8130:	80 e0       	ldi	r24, 0x00	; 0
    8132:	90 e0       	ldi	r25, 0x00	; 0
    8134:	0c 94 4a 28 	jmp	0x5094	; 0x5094 <vTaskSuspend>

00008138 <InitStartupTask>:
//Private function prototypes
static void WorkerStartup(void *pvParameters);

//Function definitions
void InitStartupTask()
{
    8138:	ef 92       	push	r14
    813a:	ff 92       	push	r15
    813c:	0f 93       	push	r16
	xTaskCreate( WorkerStartup, "startup", 256, NULL, tskIDLE_PRIORITY+3, NULL );	
    813e:	e1 2c       	mov	r14, r1
    8140:	f1 2c       	mov	r15, r1
    8142:	03 e0       	ldi	r16, 0x03	; 3
    8144:	20 e0       	ldi	r18, 0x00	; 0
    8146:	30 e0       	ldi	r19, 0x00	; 0
    8148:	40 e0       	ldi	r20, 0x00	; 0
    814a:	51 e0       	ldi	r21, 0x01	; 1
    814c:	69 ec       	ldi	r22, 0xC9	; 201
    814e:	77 e2       	ldi	r23, 0x27	; 39
    8150:	85 e6       	ldi	r24, 0x65	; 101
    8152:	90 e4       	ldi	r25, 0x40	; 64
    8154:	0e 94 c8 26 	call	0x4d90	; 0x4d90 <xTaskCreate>
}
    8158:	0f 91       	pop	r16
    815a:	ff 90       	pop	r15
    815c:	ef 90       	pop	r14
    815e:	08 95       	ret

00008160 <WorkerTerminal>:
	*/

}

static void WorkerTerminal(void *pvParameters)
{
    8160:	cf 93       	push	r28
    8162:	df 93       	push	r29
    8164:	cd b7       	in	r28, 0x3d	; 61
    8166:	de b7       	in	r29, 0x3e	; 62
    8168:	cc 51       	subi	r28, 0x1C	; 28
    816a:	d1 40       	sbci	r29, 0x01	; 1
    816c:	cd bf       	out	0x3d, r28	; 61
    816e:	de bf       	out	0x3e, r29	; 62
		SplitCmd(sbuf,Cmd,Pars);
		
		//Task list command
		if (strstr(Cmd,"help"))
		{
			printf_P (PSTR("Command list:\r\n"));
    8170:	86 eb       	ldi	r24, 0xB6	; 182
    8172:	e8 2e       	mov	r14, r24
    8174:	86 e0       	ldi	r24, 0x06	; 6
    8176:	f8 2e       	mov	r15, r24
			printf_P (PSTR("help :this help page\r\n"));
    8178:	0f e9       	ldi	r16, 0x9F	; 159
    817a:	16 e0       	ldi	r17, 0x06	; 6
			printf_P (PSTR("tsklst :list FreeRTOS tasks\r\n"));
    817c:	91 e8       	ldi	r25, 0x81	; 129
    817e:	c9 2e       	mov	r12, r25
    8180:	96 e0       	ldi	r25, 0x06	; 6
    8182:	d9 2e       	mov	r13, r25
			printf_P (PSTR("memmap :show memory map\r\n"));
    8184:	27 e6       	ldi	r18, 0x67	; 103
    8186:	22 2e       	mov	r2, r18
    8188:	26 e0       	ldi	r18, 0x06	; 6
    818a:	32 2e       	mov	r3, r18
	char Cmd[64];
	uint16_t c,r,g,b;
	
	while (1)
	{
		printf ("C>\r\n");
    818c:	81 ed       	ldi	r24, 0xD1	; 209
    818e:	97 e2       	ldi	r25, 0x27	; 39
    8190:	0e 94 9e 4e 	call	0x9d3c	; 0x9d3c <puts>
		fgets(sbuf,199,stdin);
    8194:	40 91 dd 2d 	lds	r20, 0x2DDD	; 0x802ddd <__iob>
    8198:	50 91 de 2d 	lds	r21, 0x2DDE	; 0x802dde <__iob+0x1>
    819c:	67 ec       	ldi	r22, 0xC7	; 199
    819e:	70 e0       	ldi	r23, 0x00	; 0
    81a0:	ce 01       	movw	r24, r28
    81a2:	01 96       	adiw	r24, 0x01	; 1
    81a4:	0e 94 f4 4d 	call	0x9be8	; 0x9be8 <fgets>
static void SplitCmd(char *Data,char *Cmd,float *Pars)
{
	uint8_t a;
	char *ss;
	
	ss=strtok(Data," ");
    81a8:	69 e6       	ldi	r22, 0x69	; 105
    81aa:	74 e2       	ldi	r23, 0x24	; 36
    81ac:	ce 01       	movw	r24, r28
    81ae:	01 96       	adiw	r24, 0x01	; 1
    81b0:	0e 94 8d 4d 	call	0x9b1a	; 0x9b1a <strtok>
	if (ss!=NULL) strcpy(Cmd,ss);
    81b4:	00 97       	sbiw	r24, 0x00	; 0
    81b6:	31 f0       	breq	.+12     	; 0x81c4 <WorkerTerminal+0x64>
    81b8:	bc 01       	movw	r22, r24
    81ba:	ce 01       	movw	r24, r28
    81bc:	87 53       	subi	r24, 0x37	; 55
    81be:	9f 4f       	sbci	r25, 0xFF	; 255
    81c0:	0e 94 a1 4d 	call	0x9b42	; 0x9b42 <strcpy>
	for (a=0;a<MAX_PARS;a++) 
	{
		ss=strtok(NULL," ");
    81c4:	69 e6       	ldi	r22, 0x69	; 105
    81c6:	74 e2       	ldi	r23, 0x24	; 36
    81c8:	80 e0       	ldi	r24, 0x00	; 0
    81ca:	90 e0       	ldi	r25, 0x00	; 0
    81cc:	0e 94 8d 4d 	call	0x9b1a	; 0x9b1a <strtok>
		if (ss!=NULL)
    81d0:	00 97       	sbiw	r24, 0x00	; 0
    81d2:	09 f4       	brne	.+2      	; 0x81d6 <WorkerTerminal+0x76>
    81d4:	6a c0       	rjmp	.+212    	; 0x82aa <WorkerTerminal+0x14a>
		{
			Pars[a]=atof(ss);
    81d6:	0e 94 a6 4c 	call	0x994c	; 0x994c <atof>
    81da:	4b 01       	movw	r8, r22
    81dc:	5c 01       	movw	r10, r24
	
	ss=strtok(Data," ");
	if (ss!=NULL) strcpy(Cmd,ss);
	for (a=0;a<MAX_PARS;a++) 
	{
		ss=strtok(NULL," ");
    81de:	69 e6       	ldi	r22, 0x69	; 105
    81e0:	74 e2       	ldi	r23, 0x24	; 36
    81e2:	80 e0       	ldi	r24, 0x00	; 0
    81e4:	90 e0       	ldi	r25, 0x00	; 0
    81e6:	0e 94 8d 4d 	call	0x9b1a	; 0x9b1a <strtok>
		if (ss!=NULL)
    81ea:	00 97       	sbiw	r24, 0x00	; 0
    81ec:	09 f4       	brne	.+2      	; 0x81f0 <WorkerTerminal+0x90>
    81ee:	69 c0       	rjmp	.+210    	; 0x82c2 <WorkerTerminal+0x162>
		{
			Pars[a]=atof(ss);
    81f0:	0e 94 a6 4c 	call	0x994c	; 0x994c <atof>
    81f4:	2b 01       	movw	r4, r22
    81f6:	3c 01       	movw	r6, r24
		printf ("C>\r\n");
		fgets(sbuf,199,stdin);
		SplitCmd(sbuf,Cmd,Pars);
		
		//Task list command
		if (strstr(Cmd,"help"))
    81f8:	65 ed       	ldi	r22, 0xD5	; 213
    81fa:	77 e2       	ldi	r23, 0x27	; 39
    81fc:	ce 01       	movw	r24, r28
    81fe:	87 53       	subi	r24, 0x37	; 55
    8200:	9f 4f       	sbci	r25, 0xFF	; 255
    8202:	0e 94 b3 4d 	call	0x9b66	; 0x9b66 <strstr>
    8206:	89 2b       	or	r24, r25
    8208:	09 f4       	brne	.+2      	; 0x820c <WorkerTerminal+0xac>
    820a:	5f c0       	rjmp	.+190    	; 0x82ca <WorkerTerminal+0x16a>
		{
			printf_P (PSTR("Command list:\r\n"));
    820c:	ff 92       	push	r15
    820e:	ef 92       	push	r14
    8210:	0e 94 76 4e 	call	0x9cec	; 0x9cec <printf_P>
			printf_P (PSTR("help :this help page\r\n"));
    8214:	1f 93       	push	r17
    8216:	0f 93       	push	r16
    8218:	0e 94 76 4e 	call	0x9cec	; 0x9cec <printf_P>
			printf_P (PSTR("tsklst :list FreeRTOS tasks\r\n"));
    821c:	df 92       	push	r13
    821e:	cf 92       	push	r12
    8220:	0e 94 76 4e 	call	0x9cec	; 0x9cec <printf_P>
			printf_P (PSTR("memmap :show memory map\r\n"));
    8224:	3f 92       	push	r3
    8226:	2f 92       	push	r2
    8228:	0e 94 76 4e 	call	0x9cec	; 0x9cec <printf_P>
			printf_P (PSTR("drvstr distance speed :Drive straight over 'distance' mm at a speed of 'speed' mm/s\r\n"));
    822c:	81 e1       	ldi	r24, 0x11	; 17
    822e:	96 e0       	ldi	r25, 0x06	; 6
    8230:	9f 93       	push	r25
    8232:	8f 93       	push	r24
    8234:	0e 94 76 4e 	call	0x9cec	; 0x9cec <printf_P>
			printf_P (PSTR("rotctr angle speed :rotate 'angle' degrees around center of robot at a speed of 'speed' mm/s\r\n"));
    8238:	82 eb       	ldi	r24, 0xB2	; 178
    823a:	95 e0       	ldi	r25, 0x05	; 5
    823c:	9f 93       	push	r25
    823e:	8f 93       	push	r24
    8240:	0e 94 76 4e 	call	0x9cec	; 0x9cec <printf_P>
			printf_P (PSTR("drvseg speed :follow line segment until end at a speed of 'speed' mm/s\r\n"));
    8244:	89 e6       	ldi	r24, 0x69	; 105
    8246:	95 e0       	ldi	r25, 0x05	; 5
    8248:	9f 93       	push	r25
    824a:	8f 93       	push	r24
    824c:	0e 94 76 4e 	call	0x9cec	; 0x9cec <printf_P>
			printf_P (PSTR("setled effect :set RGB led effect (see RGBTask.h)\r\n"));
    8250:	85 e3       	ldi	r24, 0x35	; 53
    8252:	95 e0       	ldi	r25, 0x05	; 5
    8254:	9f 93       	push	r25
    8256:	8f 93       	push	r24
    8258:	0e 94 76 4e 	call	0x9cec	; 0x9cec <printf_P>
			printf_P (PSTR("setmot leftmotor_pwm rightmotor_pwm :directly control motor pwm signal. Pwm is in a range of -4095 to 4095\r\n"));
    825c:	88 ec       	ldi	r24, 0xC8	; 200
    825e:	94 e0       	ldi	r25, 0x04	; 4
    8260:	9f 93       	push	r25
    8262:	8f 93       	push	r24
    8264:	0e 94 76 4e 	call	0x9cec	; 0x9cec <printf_P>
			printf_P (PSTR("getenc :get motor encoder values\r\n"));
    8268:	85 ea       	ldi	r24, 0xA5	; 165
    826a:	94 e0       	ldi	r25, 0x04	; 4
    826c:	9f 93       	push	r25
    826e:	8f 93       	push	r24
    8270:	0e 94 76 4e 	call	0x9cec	; 0x9cec <printf_P>
			printf_P (PSTR("getrgb :returns RGB light sensor values\r\n"));
    8274:	8b e7       	ldi	r24, 0x7B	; 123
    8276:	94 e0       	ldi	r25, 0x04	; 4
    8278:	9f 93       	push	r25
    827a:	8f 93       	push	r24
    827c:	0e 94 76 4e 	call	0x9cec	; 0x9cec <printf_P>
			printf_P (PSTR("getgyr :returns gyroscope info in format 'yawrate (deg/s) yaw(deg)\r\n"));
    8280:	86 e3       	ldi	r24, 0x36	; 54
    8282:	94 e0       	ldi	r25, 0x04	; 4
    8284:	9f 93       	push	r25
    8286:	8f 93       	push	r24
    8288:	0e 94 76 4e 	call	0x9cec	; 0x9cec <printf_P>
			printf_P (PSTR("getadc :returns Analog channels in format 'left_line_sensor mid_line_sensor right_line_sensor potentiometer\r\n"));
    828c:	88 ec       	ldi	r24, 0xC8	; 200
    828e:	93 e0       	ldi	r25, 0x03	; 3
    8290:	9f 93       	push	r25
    8292:	8f 93       	push	r24
    8294:	0e 94 76 4e 	call	0x9cec	; 0x9cec <printf_P>
			printf_P (PSTR("auxpwr state:'state'=1: turn on aux power net, 'state'=0: turn off aux power net\r\n"));
    8298:	85 e7       	ldi	r24, 0x75	; 117
    829a:	93 e0       	ldi	r25, 0x03	; 3
    829c:	9f 93       	push	r25
    829e:	8f 93       	push	r24
    82a0:	0e 94 76 4e 	call	0x9cec	; 0x9cec <printf_P>
    82a4:	cd bf       	out	0x3d, r28	; 61
    82a6:	de bf       	out	0x3e, r29	; 62
    82a8:	71 cf       	rjmp	.-286    	; 0x818c <WorkerTerminal+0x2c>
		if (ss!=NULL)
		{
			Pars[a]=atof(ss);
		}
		else
			Pars[a]=0.0;
    82aa:	81 2c       	mov	r8, r1
    82ac:	91 2c       	mov	r9, r1
    82ae:	54 01       	movw	r10, r8
	
	ss=strtok(Data," ");
	if (ss!=NULL) strcpy(Cmd,ss);
	for (a=0;a<MAX_PARS;a++) 
	{
		ss=strtok(NULL," ");
    82b0:	69 e6       	ldi	r22, 0x69	; 105
    82b2:	74 e2       	ldi	r23, 0x24	; 36
    82b4:	80 e0       	ldi	r24, 0x00	; 0
    82b6:	90 e0       	ldi	r25, 0x00	; 0
    82b8:	0e 94 8d 4d 	call	0x9b1a	; 0x9b1a <strtok>
		if (ss!=NULL)
    82bc:	00 97       	sbiw	r24, 0x00	; 0
    82be:	09 f0       	breq	.+2      	; 0x82c2 <WorkerTerminal+0x162>
    82c0:	97 cf       	rjmp	.-210    	; 0x81f0 <WorkerTerminal+0x90>
		{
			Pars[a]=atof(ss);
		}
		else
			Pars[a]=0.0;
    82c2:	41 2c       	mov	r4, r1
    82c4:	51 2c       	mov	r5, r1
    82c6:	32 01       	movw	r6, r4
    82c8:	97 cf       	rjmp	.-210    	; 0x81f8 <WorkerTerminal+0x98>
			printf_P (PSTR("getrgb :returns RGB light sensor values\r\n"));
			printf_P (PSTR("getgyr :returns gyroscope info in format 'yawrate (deg/s) yaw(deg)\r\n"));
			printf_P (PSTR("getadc :returns Analog channels in format 'left_line_sensor mid_line_sensor right_line_sensor potentiometer\r\n"));
			printf_P (PSTR("auxpwr state:'state'=1: turn on aux power net, 'state'=0: turn off aux power net\r\n"));
		}
		else if (strstr(Cmd,"tsklst"))
    82ca:	6a ed       	ldi	r22, 0xDA	; 218
    82cc:	77 e2       	ldi	r23, 0x27	; 39
    82ce:	ce 01       	movw	r24, r28
    82d0:	87 53       	subi	r24, 0x37	; 55
    82d2:	9f 4f       	sbci	r25, 0xFF	; 255
    82d4:	0e 94 b3 4d 	call	0x9b66	; 0x9b66 <strstr>
    82d8:	89 2b       	or	r24, r25
    82da:	49 f0       	breq	.+18     	; 0x82ee <WorkerTerminal+0x18e>
		{
			vTaskGetRunTimeStats(sbuf);
    82dc:	ce 01       	movw	r24, r28
    82de:	01 96       	adiw	r24, 0x01	; 1
    82e0:	0e 94 0e 2f 	call	0x5e1c	; 0x5e1c <vTaskGetRunTimeStats>
			puts(sbuf);
    82e4:	ce 01       	movw	r24, r28
    82e6:	01 96       	adiw	r24, 0x01	; 1
    82e8:	0e 94 9e 4e 	call	0x9d3c	; 0x9d3c <puts>
    82ec:	4f cf       	rjmp	.-354    	; 0x818c <WorkerTerminal+0x2c>
		}
		else if (strstr(Cmd,"memmap"))
    82ee:	61 ee       	ldi	r22, 0xE1	; 225
    82f0:	77 e2       	ldi	r23, 0x27	; 39
    82f2:	ce 01       	movw	r24, r28
    82f4:	87 53       	subi	r24, 0x37	; 55
    82f6:	9f 4f       	sbci	r25, 0xFF	; 255
    82f8:	0e 94 b3 4d 	call	0x9b66	; 0x9b66 <strstr>
    82fc:	89 2b       	or	r24, r25
    82fe:	19 f0       	breq	.+6      	; 0x8306 <WorkerTerminal+0x1a6>
		{
			MemMap();
    8300:	0e 94 88 30 	call	0x6110	; 0x6110 <MemMap>
    8304:	43 cf       	rjmp	.-378    	; 0x818c <WorkerTerminal+0x2c>
		}
		else if (strstr(Cmd,"drvstr"))
    8306:	68 ee       	ldi	r22, 0xE8	; 232
    8308:	77 e2       	ldi	r23, 0x27	; 39
    830a:	ce 01       	movw	r24, r28
    830c:	87 53       	subi	r24, 0x37	; 55
    830e:	9f 4f       	sbci	r25, 0xFF	; 255
    8310:	0e 94 b3 4d 	call	0x9b66	; 0x9b66 <strstr>
    8314:	89 2b       	or	r24, r25
    8316:	59 f0       	breq	.+22     	; 0x832e <WorkerTerminal+0x1ce>
		{
			DriveStraight(Pars[0],Pars[1]);
    8318:	a3 01       	movw	r20, r6
    831a:	92 01       	movw	r18, r4
    831c:	c5 01       	movw	r24, r10
    831e:	b4 01       	movw	r22, r8
    8320:	0e 94 1d 37 	call	0x6e3a	; 0x6e3a <DriveStraight>
			printf ("OK\r\n");
    8324:	8f ee       	ldi	r24, 0xEF	; 239
    8326:	97 e2       	ldi	r25, 0x27	; 39
    8328:	0e 94 9e 4e 	call	0x9d3c	; 0x9d3c <puts>
    832c:	2f cf       	rjmp	.-418    	; 0x818c <WorkerTerminal+0x2c>
		}
		else if (strstr(Cmd,"drvseg"))
    832e:	63 ef       	ldi	r22, 0xF3	; 243
    8330:	77 e2       	ldi	r23, 0x27	; 39
    8332:	ce 01       	movw	r24, r28
    8334:	87 53       	subi	r24, 0x37	; 55
    8336:	9f 4f       	sbci	r25, 0xFF	; 255
    8338:	0e 94 b3 4d 	call	0x9b66	; 0x9b66 <strstr>
    833c:	89 2b       	or	r24, r25
    833e:	49 f0       	breq	.+18     	; 0x8352 <WorkerTerminal+0x1f2>
		{
			DriveSegment(Pars[0]);
    8340:	c5 01       	movw	r24, r10
    8342:	b4 01       	movw	r22, r8
    8344:	0e 94 48 37 	call	0x6e90	; 0x6e90 <DriveSegment>
			printf ("OK\r\n");
    8348:	8f ee       	ldi	r24, 0xEF	; 239
    834a:	97 e2       	ldi	r25, 0x27	; 39
    834c:	0e 94 9e 4e 	call	0x9d3c	; 0x9d3c <puts>
    8350:	1d cf       	rjmp	.-454    	; 0x818c <WorkerTerminal+0x2c>
		}
		else if (strstr(Cmd,"rotctr"))
    8352:	6a ef       	ldi	r22, 0xFA	; 250
    8354:	77 e2       	ldi	r23, 0x27	; 39
    8356:	ce 01       	movw	r24, r28
    8358:	87 53       	subi	r24, 0x37	; 55
    835a:	9f 4f       	sbci	r25, 0xFF	; 255
    835c:	0e 94 b3 4d 	call	0x9b66	; 0x9b66 <strstr>
    8360:	89 2b       	or	r24, r25
    8362:	59 f0       	breq	.+22     	; 0x837a <WorkerTerminal+0x21a>
		{
			RotateCenter(Pars[0],Pars[1]);
    8364:	a3 01       	movw	r20, r6
    8366:	92 01       	movw	r18, r4
    8368:	c5 01       	movw	r24, r10
    836a:	b4 01       	movw	r22, r8
    836c:	0e 94 6f 37 	call	0x6ede	; 0x6ede <RotateCenter>
			printf ("OK\r\n");
    8370:	8f ee       	ldi	r24, 0xEF	; 239
    8372:	97 e2       	ldi	r25, 0x27	; 39
    8374:	0e 94 9e 4e 	call	0x9d3c	; 0x9d3c <puts>
    8378:	09 cf       	rjmp	.-494    	; 0x818c <WorkerTerminal+0x2c>
		}
		else if (strstr(Cmd,"setled"))
    837a:	61 e0       	ldi	r22, 0x01	; 1
    837c:	78 e2       	ldi	r23, 0x28	; 40
    837e:	ce 01       	movw	r24, r28
    8380:	87 53       	subi	r24, 0x37	; 55
    8382:	9f 4f       	sbci	r25, 0xFF	; 255
    8384:	0e 94 b3 4d 	call	0x9b66	; 0x9b66 <strstr>
    8388:	89 2b       	or	r24, r25
    838a:	61 f0       	breq	.+24     	; 0x83a4 <WorkerTerminal+0x244>
		{
			SetRGB(Pars[0]);
    838c:	c5 01       	movw	r24, r10
    838e:	b4 01       	movw	r22, r8
    8390:	0e 94 18 44 	call	0x8830	; 0x8830 <__fixunssfsi>
    8394:	86 2f       	mov	r24, r22
    8396:	0e 94 4f 40 	call	0x809e	; 0x809e <SetRGB>
			printf ("OK\r\n");
    839a:	8f ee       	ldi	r24, 0xEF	; 239
    839c:	97 e2       	ldi	r25, 0x27	; 39
    839e:	0e 94 9e 4e 	call	0x9d3c	; 0x9d3c <puts>
    83a2:	f4 ce       	rjmp	.-536    	; 0x818c <WorkerTerminal+0x2c>
		}
		else if (strstr(Cmd,"setmot"))
    83a4:	68 e0       	ldi	r22, 0x08	; 8
    83a6:	78 e2       	ldi	r23, 0x28	; 40
    83a8:	ce 01       	movw	r24, r28
    83aa:	87 53       	subi	r24, 0x37	; 55
    83ac:	9f 4f       	sbci	r25, 0xFF	; 255
    83ae:	0e 94 b3 4d 	call	0x9b66	; 0x9b66 <strstr>
    83b2:	89 2b       	or	r24, r25
    83b4:	a1 f0       	breq	.+40     	; 0x83de <WorkerTerminal+0x27e>
		{
			DriverMotorSet((int16_t) Pars[0],(int16_t) Pars[1]);
    83b6:	c3 01       	movw	r24, r6
    83b8:	b2 01       	movw	r22, r4
    83ba:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
    83be:	2b 01       	movw	r4, r22
    83c0:	3c 01       	movw	r6, r24
    83c2:	c5 01       	movw	r24, r10
    83c4:	b4 01       	movw	r22, r8
    83c6:	0e 94 11 44 	call	0x8822	; 0x8822 <__fixsfsi>
    83ca:	dc 01       	movw	r26, r24
    83cc:	cb 01       	movw	r24, r22
    83ce:	b2 01       	movw	r22, r4
    83d0:	0e 94 d6 06 	call	0xdac	; 0xdac <DriverMotorSet>
			printf ("OK\r\n");
    83d4:	8f ee       	ldi	r24, 0xEF	; 239
    83d6:	97 e2       	ldi	r25, 0x27	; 39
    83d8:	0e 94 9e 4e 	call	0x9d3c	; 0x9d3c <puts>
    83dc:	d7 ce       	rjmp	.-594    	; 0x818c <WorkerTerminal+0x2c>
		}
		else if (strstr(Cmd,"getenc"))
    83de:	6f e0       	ldi	r22, 0x0F	; 15
    83e0:	78 e2       	ldi	r23, 0x28	; 40
    83e2:	ce 01       	movw	r24, r28
    83e4:	87 53       	subi	r24, 0x37	; 55
    83e6:	9f 4f       	sbci	r25, 0xFF	; 255
    83e8:	0e 94 b3 4d 	call	0x9b66	; 0x9b66 <strstr>
    83ec:	89 2b       	or	r24, r25
    83ee:	99 f0       	breq	.+38     	; 0x8416 <WorkerTerminal+0x2b6>
		{	
			EncoderStruct Encoder;
			Encoder=DriverMotorGetEncoder();
    83f0:	0e 94 41 07 	call	0xe82	; 0xe82 <DriverMotorGetEncoder>
			printf ("OK %d %d\r\n",Encoder.Cnt1,Encoder.Cnt2);
    83f4:	9f 93       	push	r25
    83f6:	8f 93       	push	r24
    83f8:	7f 93       	push	r23
    83fa:	6f 93       	push	r22
    83fc:	86 e1       	ldi	r24, 0x16	; 22
    83fe:	98 e2       	ldi	r25, 0x28	; 40
    8400:	9f 93       	push	r25
    8402:	8f 93       	push	r24
    8404:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
    8408:	0f 90       	pop	r0
    840a:	0f 90       	pop	r0
    840c:	0f 90       	pop	r0
    840e:	0f 90       	pop	r0
    8410:	0f 90       	pop	r0
    8412:	0f 90       	pop	r0
    8414:	bb ce       	rjmp	.-650    	; 0x818c <WorkerTerminal+0x2c>
		}		
		else if (strstr(Cmd,"getrgb"))
    8416:	61 e2       	ldi	r22, 0x21	; 33
    8418:	78 e2       	ldi	r23, 0x28	; 40
    841a:	ce 01       	movw	r24, r28
    841c:	87 53       	subi	r24, 0x37	; 55
    841e:	9f 4f       	sbci	r25, 0xFF	; 255
    8420:	0e 94 b3 4d 	call	0x9b66	; 0x9b66 <strstr>
    8424:	89 2b       	or	r24, r25
    8426:	09 f4       	brne	.+2      	; 0x842a <WorkerTerminal+0x2ca>
    8428:	47 c0       	rjmp	.+142    	; 0x84b8 <WorkerTerminal+0x358>
		{
			DriverAdps9960Get(&c,&r,&g,&b);
    842a:	9e 01       	movw	r18, r28
    842c:	2b 5e       	subi	r18, 0xEB	; 235
    842e:	3e 4f       	sbci	r19, 0xFE	; 254
    8430:	ae 01       	movw	r20, r28
    8432:	49 5e       	subi	r20, 0xE9	; 233
    8434:	5e 4f       	sbci	r21, 0xFE	; 254
    8436:	be 01       	movw	r22, r28
    8438:	67 5e       	subi	r22, 0xE7	; 231
    843a:	7e 4f       	sbci	r23, 0xFE	; 254
    843c:	ce 01       	movw	r24, r28
    843e:	85 5e       	subi	r24, 0xE5	; 229
    8440:	9e 4f       	sbci	r25, 0xFE	; 254
    8442:	0e 94 88 04 	call	0x910	; 0x910 <DriverAdps9960Get>
			printf ("OK %d %d %d %d\r\n",c,r,g,b);
    8446:	ca 5e       	subi	r28, 0xEA	; 234
    8448:	de 4f       	sbci	r29, 0xFE	; 254
    844a:	88 81       	ld	r24, Y
    844c:	c6 51       	subi	r28, 0x16	; 22
    844e:	d1 40       	sbci	r29, 0x01	; 1
    8450:	8f 93       	push	r24
    8452:	cb 5e       	subi	r28, 0xEB	; 235
    8454:	de 4f       	sbci	r29, 0xFE	; 254
    8456:	88 81       	ld	r24, Y
    8458:	c5 51       	subi	r28, 0x15	; 21
    845a:	d1 40       	sbci	r29, 0x01	; 1
    845c:	8f 93       	push	r24
    845e:	c8 5e       	subi	r28, 0xE8	; 232
    8460:	de 4f       	sbci	r29, 0xFE	; 254
    8462:	88 81       	ld	r24, Y
    8464:	c8 51       	subi	r28, 0x18	; 24
    8466:	d1 40       	sbci	r29, 0x01	; 1
    8468:	8f 93       	push	r24
    846a:	c9 5e       	subi	r28, 0xE9	; 233
    846c:	de 4f       	sbci	r29, 0xFE	; 254
    846e:	88 81       	ld	r24, Y
    8470:	c7 51       	subi	r28, 0x17	; 23
    8472:	d1 40       	sbci	r29, 0x01	; 1
    8474:	8f 93       	push	r24
    8476:	c6 5e       	subi	r28, 0xE6	; 230
    8478:	de 4f       	sbci	r29, 0xFE	; 254
    847a:	88 81       	ld	r24, Y
    847c:	ca 51       	subi	r28, 0x1A	; 26
    847e:	d1 40       	sbci	r29, 0x01	; 1
    8480:	8f 93       	push	r24
    8482:	c7 5e       	subi	r28, 0xE7	; 231
    8484:	de 4f       	sbci	r29, 0xFE	; 254
    8486:	88 81       	ld	r24, Y
    8488:	c9 51       	subi	r28, 0x19	; 25
    848a:	d1 40       	sbci	r29, 0x01	; 1
    848c:	8f 93       	push	r24
    848e:	c4 5e       	subi	r28, 0xE4	; 228
    8490:	de 4f       	sbci	r29, 0xFE	; 254
    8492:	88 81       	ld	r24, Y
    8494:	cc 51       	subi	r28, 0x1C	; 28
    8496:	d1 40       	sbci	r29, 0x01	; 1
    8498:	8f 93       	push	r24
    849a:	c5 5e       	subi	r28, 0xE5	; 229
    849c:	de 4f       	sbci	r29, 0xFE	; 254
    849e:	88 81       	ld	r24, Y
    84a0:	cb 51       	subi	r28, 0x1B	; 27
    84a2:	d1 40       	sbci	r29, 0x01	; 1
		}
		else if (strstr(Cmd,"getadc"))
		{
			ADCStruct ADCData;
			ADCData=GetADCData();
			printf ("OK %d %d %d %d\r\n",ADCData.PhotoL,ADCData.PhotoM,ADCData.PhotoR,ADCData.Potmeter);
    84a4:	8f 93       	push	r24
    84a6:	88 e2       	ldi	r24, 0x28	; 40
    84a8:	98 e2       	ldi	r25, 0x28	; 40
    84aa:	9f 93       	push	r25
    84ac:	8f 93       	push	r24
    84ae:	0e 94 62 4e 	call	0x9cc4	; 0x9cc4 <printf>
    84b2:	cd bf       	out	0x3d, r28	; 61
    84b4:	de bf       	out	0x3e, r29	; 62
    84b6:	6a ce       	rjmp	.-812    	; 0x818c <WorkerTerminal+0x2c>
		else if (strstr(Cmd,"getrgb"))
		{
			DriverAdps9960Get(&c,&r,&g,&b);
			printf ("OK %d %d %d %d\r\n",c,r,g,b);
		}
		else if (strstr(Cmd,"getgyr"))
    84b8:	69 e3       	ldi	r22, 0x39	; 57
    84ba:	78 e2       	ldi	r23, 0x28	; 40
    84bc:	ce 01       	movw	r24, r28
    84be:	87 53       	subi	r24, 0x37	; 55
    84c0:	9f 4f       	sbci	r25, 0xFF	; 255
    84c2:	0e 94 b3 4d 	call	0x9b66	; 0x9b66 <strstr>
    84c6:	89 2b       	or	r24, r25
    84c8:	d9 f1       	breq	.+118    	; 0x8540 <WorkerTerminal+0x3e0>
		{
			float YawRate,Yaw;
			GyroGet(&YawRate,&Yaw);
    84ca:	be 01       	movw	r22, r28
    84cc:	67 5f       	subi	r22, 0xF7	; 247
    84ce:	7e 4f       	sbci	r23, 0xFE	; 254
    84d0:	ce 01       	movw	r24, r28
    84d2:	8f 5e       	subi	r24, 0xEF	; 239
    84d4:	9e 4f       	sbci	r25, 0xFE	; 254
    84d6:	0e 94 24 33 	call	0x6648	; 0x6648 <GyroGet>
			printf ("OK %f %f\r\n",YawRate,Yaw);
    84da:	c4 5f       	subi	r28, 0xF4	; 244
    84dc:	de 4f       	sbci	r29, 0xFE	; 254
    84de:	88 81       	ld	r24, Y
    84e0:	cc 50       	subi	r28, 0x0C	; 12
    84e2:	d1 40       	sbci	r29, 0x01	; 1
    84e4:	8f 93       	push	r24
    84e6:	c5 5f       	subi	r28, 0xF5	; 245
    84e8:	de 4f       	sbci	r29, 0xFE	; 254
    84ea:	88 81       	ld	r24, Y
    84ec:	cb 50       	subi	r28, 0x0B	; 11
    84ee:	d1 40       	sbci	r29, 0x01	; 1
    84f0:	8f 93       	push	r24
    84f2:	c6 5f       	subi	r28, 0xF6	; 246
    84f4:	de 4f       	sbci	r29, 0xFE	; 254
    84f6:	88 81       	ld	r24, Y
    84f8:	ca 50       	subi	r28, 0x0A	; 10
    84fa:	d1 40       	sbci	r29, 0x01	; 1
    84fc:	8f 93       	push	r24
    84fe:	c7 5f       	subi	r28, 0xF7	; 247
    8500:	de 4f       	sbci	r29, 0xFE	; 254
    8502:	88 81       	ld	r24, Y
    8504:	c9 50       	subi	r28, 0x09	; 9
    8506:	d1 40       	sbci	r29, 0x01	; 1
    8508:	8f 93       	push	r24
    850a:	cc 5e       	subi	r28, 0xEC	; 236
    850c:	de 4f       	sbci	r29, 0xFE	; 254
    850e:	88 81       	ld	r24, Y
    8510:	c4 51       	subi	r28, 0x14	; 20
    8512:	d1 40       	sbci	r29, 0x01	; 1
    8514:	8f 93       	push	r24
    8516:	cd 5e       	subi	r28, 0xED	; 237
    8518:	de 4f       	sbci	r29, 0xFE	; 254
    851a:	88 81       	ld	r24, Y
    851c:	c3 51       	subi	r28, 0x13	; 19
    851e:	d1 40       	sbci	r29, 0x01	; 1
    8520:	8f 93       	push	r24
    8522:	ce 5e       	subi	r28, 0xEE	; 238
    8524:	de 4f       	sbci	r29, 0xFE	; 254
    8526:	88 81       	ld	r24, Y
    8528:	c2 51       	subi	r28, 0x12	; 18
    852a:	d1 40       	sbci	r29, 0x01	; 1
    852c:	8f 93       	push	r24
    852e:	cf 5e       	subi	r28, 0xEF	; 239
    8530:	de 4f       	sbci	r29, 0xFE	; 254
    8532:	88 81       	ld	r24, Y
    8534:	c1 51       	subi	r28, 0x11	; 17
    8536:	d1 40       	sbci	r29, 0x01	; 1
    8538:	8f 93       	push	r24
    853a:	80 e4       	ldi	r24, 0x40	; 64
    853c:	98 e2       	ldi	r25, 0x28	; 40
    853e:	b5 cf       	rjmp	.-150    	; 0x84aa <WorkerTerminal+0x34a>
		}
		else if (strstr(Cmd,"getadc"))
    8540:	6b e4       	ldi	r22, 0x4B	; 75
    8542:	78 e2       	ldi	r23, 0x28	; 40
    8544:	ce 01       	movw	r24, r28
    8546:	87 53       	subi	r24, 0x37	; 55
    8548:	9f 4f       	sbci	r25, 0xFF	; 255
    854a:	0e 94 b3 4d 	call	0x9b66	; 0x9b66 <strstr>
    854e:	89 2b       	or	r24, r25
    8550:	09 f4       	brne	.+2      	; 0x8554 <WorkerTerminal+0x3f4>
    8552:	55 c0       	rjmp	.+170    	; 0x85fe <WorkerTerminal+0x49e>
		{
			ADCStruct ADCData;
			ADCData=GetADCData();
    8554:	0e 94 1d 32 	call	0x643a	; 0x643a <GetADCData>
    8558:	c7 5f       	subi	r28, 0xF7	; 247
    855a:	de 4f       	sbci	r29, 0xFE	; 254
    855c:	28 83       	st	Y, r18
    855e:	c9 50       	subi	r28, 0x09	; 9
    8560:	d1 40       	sbci	r29, 0x01	; 1
    8562:	c6 5f       	subi	r28, 0xF6	; 246
    8564:	de 4f       	sbci	r29, 0xFE	; 254
    8566:	38 83       	st	Y, r19
    8568:	ca 50       	subi	r28, 0x0A	; 10
    856a:	d1 40       	sbci	r29, 0x01	; 1
    856c:	c5 5f       	subi	r28, 0xF5	; 245
    856e:	de 4f       	sbci	r29, 0xFE	; 254
    8570:	48 83       	st	Y, r20
    8572:	cb 50       	subi	r28, 0x0B	; 11
    8574:	d1 40       	sbci	r29, 0x01	; 1
    8576:	c4 5f       	subi	r28, 0xF4	; 244
    8578:	de 4f       	sbci	r29, 0xFE	; 254
    857a:	58 83       	st	Y, r21
    857c:	cc 50       	subi	r28, 0x0C	; 12
    857e:	d1 40       	sbci	r29, 0x01	; 1
    8580:	c3 5f       	subi	r28, 0xF3	; 243
    8582:	de 4f       	sbci	r29, 0xFE	; 254
    8584:	68 83       	st	Y, r22
    8586:	cd 50       	subi	r28, 0x0D	; 13
    8588:	d1 40       	sbci	r29, 0x01	; 1
    858a:	c2 5f       	subi	r28, 0xF2	; 242
    858c:	de 4f       	sbci	r29, 0xFE	; 254
    858e:	78 83       	st	Y, r23
    8590:	ce 50       	subi	r28, 0x0E	; 14
    8592:	d1 40       	sbci	r29, 0x01	; 1
    8594:	c1 5f       	subi	r28, 0xF1	; 241
    8596:	de 4f       	sbci	r29, 0xFE	; 254
    8598:	88 83       	st	Y, r24
    859a:	cf 50       	subi	r28, 0x0F	; 15
    859c:	d1 40       	sbci	r29, 0x01	; 1
    859e:	c0 5f       	subi	r28, 0xF0	; 240
    85a0:	de 4f       	sbci	r29, 0xFE	; 254
    85a2:	98 83       	st	Y, r25
    85a4:	c0 51       	subi	r28, 0x10	; 16
    85a6:	d1 40       	sbci	r29, 0x01	; 1
			printf ("OK %d %d %d %d\r\n",ADCData.PhotoL,ADCData.PhotoM,ADCData.PhotoR,ADCData.Potmeter);
    85a8:	9f 93       	push	r25
    85aa:	c1 5f       	subi	r28, 0xF1	; 241
    85ac:	de 4f       	sbci	r29, 0xFE	; 254
    85ae:	88 81       	ld	r24, Y
    85b0:	cf 50       	subi	r28, 0x0F	; 15
    85b2:	d1 40       	sbci	r29, 0x01	; 1
    85b4:	8f 93       	push	r24
    85b6:	c2 5f       	subi	r28, 0xF2	; 242
    85b8:	de 4f       	sbci	r29, 0xFE	; 254
    85ba:	88 81       	ld	r24, Y
    85bc:	ce 50       	subi	r28, 0x0E	; 14
    85be:	d1 40       	sbci	r29, 0x01	; 1
    85c0:	8f 93       	push	r24
    85c2:	c3 5f       	subi	r28, 0xF3	; 243
    85c4:	de 4f       	sbci	r29, 0xFE	; 254
    85c6:	88 81       	ld	r24, Y
    85c8:	cd 50       	subi	r28, 0x0D	; 13
    85ca:	d1 40       	sbci	r29, 0x01	; 1
    85cc:	8f 93       	push	r24
    85ce:	c4 5f       	subi	r28, 0xF4	; 244
    85d0:	de 4f       	sbci	r29, 0xFE	; 254
    85d2:	88 81       	ld	r24, Y
    85d4:	cc 50       	subi	r28, 0x0C	; 12
    85d6:	d1 40       	sbci	r29, 0x01	; 1
    85d8:	8f 93       	push	r24
    85da:	c5 5f       	subi	r28, 0xF5	; 245
    85dc:	de 4f       	sbci	r29, 0xFE	; 254
    85de:	88 81       	ld	r24, Y
    85e0:	cb 50       	subi	r28, 0x0B	; 11
    85e2:	d1 40       	sbci	r29, 0x01	; 1
    85e4:	8f 93       	push	r24
    85e6:	c6 5f       	subi	r28, 0xF6	; 246
    85e8:	de 4f       	sbci	r29, 0xFE	; 254
    85ea:	88 81       	ld	r24, Y
    85ec:	ca 50       	subi	r28, 0x0A	; 10
    85ee:	d1 40       	sbci	r29, 0x01	; 1
    85f0:	8f 93       	push	r24
    85f2:	c7 5f       	subi	r28, 0xF7	; 247
    85f4:	de 4f       	sbci	r29, 0xFE	; 254
    85f6:	88 81       	ld	r24, Y
    85f8:	c9 50       	subi	r28, 0x09	; 9
    85fa:	d1 40       	sbci	r29, 0x01	; 1
    85fc:	53 cf       	rjmp	.-346    	; 0x84a4 <WorkerTerminal+0x344>
		}
		else if (strstr(Cmd,"auxpwr"))
    85fe:	62 e5       	ldi	r22, 0x52	; 82
    8600:	78 e2       	ldi	r23, 0x28	; 40
    8602:	ce 01       	movw	r24, r28
    8604:	87 53       	subi	r24, 0x37	; 55
    8606:	9f 4f       	sbci	r25, 0xFF	; 255
    8608:	0e 94 b3 4d 	call	0x9b66	; 0x9b66 <strstr>
    860c:	89 2b       	or	r24, r25
    860e:	61 f0       	breq	.+24     	; 0x8628 <WorkerTerminal+0x4c8>
		{
			DriverPowerVccAuxSet((uint8_t) Pars[0]);
    8610:	c5 01       	movw	r24, r10
    8612:	b4 01       	movw	r22, r8
    8614:	0e 94 18 44 	call	0x8830	; 0x8830 <__fixunssfsi>
    8618:	86 2f       	mov	r24, r22
    861a:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <DriverPowerVccAuxSet>
			printf ("OK\r\n");
    861e:	8f ee       	ldi	r24, 0xEF	; 239
    8620:	97 e2       	ldi	r25, 0x27	; 39
    8622:	0e 94 9e 4e 	call	0x9d3c	; 0x9d3c <puts>
    8626:	b2 cd       	rjmp	.-1180   	; 0x818c <WorkerTerminal+0x2c>
		}
		else
		printf ("Unknown command\r\n");
    8628:	89 e5       	ldi	r24, 0x59	; 89
    862a:	98 e2       	ldi	r25, 0x28	; 40
    862c:	0e 94 9e 4e 	call	0x9d3c	; 0x9d3c <puts>
    8630:	ad cd       	rjmp	.-1190   	; 0x818c <WorkerTerminal+0x2c>

00008632 <InitTerminalTask>:
static void WorkerTerminal(void *pvParameters);
static void SplitCmd(char *Data,char *Cmd,float *Pars);

//Function definitions
void InitTerminalTask()
{
    8632:	ef 92       	push	r14
    8634:	ff 92       	push	r15
    8636:	0f 93       	push	r16
	xTaskCreate( WorkerTerminal, "term", 1024, NULL, tskIDLE_PRIORITY+1, NULL );	
    8638:	e1 2c       	mov	r14, r1
    863a:	f1 2c       	mov	r15, r1
    863c:	01 e0       	ldi	r16, 0x01	; 1
    863e:	20 e0       	ldi	r18, 0x00	; 0
    8640:	30 e0       	ldi	r19, 0x00	; 0
    8642:	40 e0       	ldi	r20, 0x00	; 0
    8644:	54 e0       	ldi	r21, 0x04	; 4
    8646:	6a e6       	ldi	r22, 0x6A	; 106
    8648:	78 e2       	ldi	r23, 0x28	; 40
    864a:	80 eb       	ldi	r24, 0xB0	; 176
    864c:	90 e4       	ldi	r25, 0x40	; 64
    864e:	0e 94 c8 26 	call	0x4d90	; 0x4d90 <xTaskCreate>
}
    8652:	0f 91       	pop	r16
    8654:	ff 90       	pop	r15
    8656:	ef 90       	pop	r14
    8658:	08 95       	ret

0000865a <__subsf3>:
    865a:	50 58       	subi	r21, 0x80	; 128

0000865c <__addsf3>:
    865c:	bb 27       	eor	r27, r27
    865e:	aa 27       	eor	r26, r26
    8660:	0e 94 45 43 	call	0x868a	; 0x868a <__addsf3x>
    8664:	0c 94 bf 44 	jmp	0x897e	; 0x897e <__fp_round>
    8668:	0e 94 b1 44 	call	0x8962	; 0x8962 <__fp_pscA>
    866c:	38 f0       	brcs	.+14     	; 0x867c <__addsf3+0x20>
    866e:	0e 94 b8 44 	call	0x8970	; 0x8970 <__fp_pscB>
    8672:	20 f0       	brcs	.+8      	; 0x867c <__addsf3+0x20>
    8674:	39 f4       	brne	.+14     	; 0x8684 <__addsf3+0x28>
    8676:	9f 3f       	cpi	r25, 0xFF	; 255
    8678:	19 f4       	brne	.+6      	; 0x8680 <__addsf3+0x24>
    867a:	26 f4       	brtc	.+8      	; 0x8684 <__addsf3+0x28>
    867c:	0c 94 ae 44 	jmp	0x895c	; 0x895c <__fp_nan>
    8680:	0e f4       	brtc	.+2      	; 0x8684 <__addsf3+0x28>
    8682:	e0 95       	com	r30
    8684:	e7 fb       	bst	r30, 7
    8686:	0c 94 a8 44 	jmp	0x8950	; 0x8950 <__fp_inf>

0000868a <__addsf3x>:
    868a:	e9 2f       	mov	r30, r25
    868c:	0e 94 d0 44 	call	0x89a0	; 0x89a0 <__fp_split3>
    8690:	58 f3       	brcs	.-42     	; 0x8668 <__addsf3+0xc>
    8692:	ba 17       	cp	r27, r26
    8694:	62 07       	cpc	r22, r18
    8696:	73 07       	cpc	r23, r19
    8698:	84 07       	cpc	r24, r20
    869a:	95 07       	cpc	r25, r21
    869c:	20 f0       	brcs	.+8      	; 0x86a6 <__addsf3x+0x1c>
    869e:	79 f4       	brne	.+30     	; 0x86be <__addsf3x+0x34>
    86a0:	a6 f5       	brtc	.+104    	; 0x870a <__addsf3x+0x80>
    86a2:	0c 94 f2 44 	jmp	0x89e4	; 0x89e4 <__fp_zero>
    86a6:	0e f4       	brtc	.+2      	; 0x86aa <__addsf3x+0x20>
    86a8:	e0 95       	com	r30
    86aa:	0b 2e       	mov	r0, r27
    86ac:	ba 2f       	mov	r27, r26
    86ae:	a0 2d       	mov	r26, r0
    86b0:	0b 01       	movw	r0, r22
    86b2:	b9 01       	movw	r22, r18
    86b4:	90 01       	movw	r18, r0
    86b6:	0c 01       	movw	r0, r24
    86b8:	ca 01       	movw	r24, r20
    86ba:	a0 01       	movw	r20, r0
    86bc:	11 24       	eor	r1, r1
    86be:	ff 27       	eor	r31, r31
    86c0:	59 1b       	sub	r21, r25
    86c2:	99 f0       	breq	.+38     	; 0x86ea <__addsf3x+0x60>
    86c4:	59 3f       	cpi	r21, 0xF9	; 249
    86c6:	50 f4       	brcc	.+20     	; 0x86dc <__addsf3x+0x52>
    86c8:	50 3e       	cpi	r21, 0xE0	; 224
    86ca:	68 f1       	brcs	.+90     	; 0x8726 <__addsf3x+0x9c>
    86cc:	1a 16       	cp	r1, r26
    86ce:	f0 40       	sbci	r31, 0x00	; 0
    86d0:	a2 2f       	mov	r26, r18
    86d2:	23 2f       	mov	r18, r19
    86d4:	34 2f       	mov	r19, r20
    86d6:	44 27       	eor	r20, r20
    86d8:	58 5f       	subi	r21, 0xF8	; 248
    86da:	f3 cf       	rjmp	.-26     	; 0x86c2 <__addsf3x+0x38>
    86dc:	46 95       	lsr	r20
    86de:	37 95       	ror	r19
    86e0:	27 95       	ror	r18
    86e2:	a7 95       	ror	r26
    86e4:	f0 40       	sbci	r31, 0x00	; 0
    86e6:	53 95       	inc	r21
    86e8:	c9 f7       	brne	.-14     	; 0x86dc <__addsf3x+0x52>
    86ea:	7e f4       	brtc	.+30     	; 0x870a <__addsf3x+0x80>
    86ec:	1f 16       	cp	r1, r31
    86ee:	ba 0b       	sbc	r27, r26
    86f0:	62 0b       	sbc	r22, r18
    86f2:	73 0b       	sbc	r23, r19
    86f4:	84 0b       	sbc	r24, r20
    86f6:	ba f0       	brmi	.+46     	; 0x8726 <__addsf3x+0x9c>
    86f8:	91 50       	subi	r25, 0x01	; 1
    86fa:	a1 f0       	breq	.+40     	; 0x8724 <__addsf3x+0x9a>
    86fc:	ff 0f       	add	r31, r31
    86fe:	bb 1f       	adc	r27, r27
    8700:	66 1f       	adc	r22, r22
    8702:	77 1f       	adc	r23, r23
    8704:	88 1f       	adc	r24, r24
    8706:	c2 f7       	brpl	.-16     	; 0x86f8 <__addsf3x+0x6e>
    8708:	0e c0       	rjmp	.+28     	; 0x8726 <__addsf3x+0x9c>
    870a:	ba 0f       	add	r27, r26
    870c:	62 1f       	adc	r22, r18
    870e:	73 1f       	adc	r23, r19
    8710:	84 1f       	adc	r24, r20
    8712:	48 f4       	brcc	.+18     	; 0x8726 <__addsf3x+0x9c>
    8714:	87 95       	ror	r24
    8716:	77 95       	ror	r23
    8718:	67 95       	ror	r22
    871a:	b7 95       	ror	r27
    871c:	f7 95       	ror	r31
    871e:	9e 3f       	cpi	r25, 0xFE	; 254
    8720:	08 f0       	brcs	.+2      	; 0x8724 <__addsf3x+0x9a>
    8722:	b0 cf       	rjmp	.-160    	; 0x8684 <__addsf3+0x28>
    8724:	93 95       	inc	r25
    8726:	88 0f       	add	r24, r24
    8728:	08 f0       	brcs	.+2      	; 0x872c <__addsf3x+0xa2>
    872a:	99 27       	eor	r25, r25
    872c:	ee 0f       	add	r30, r30
    872e:	97 95       	ror	r25
    8730:	87 95       	ror	r24
    8732:	08 95       	ret

00008734 <__cmpsf2>:
    8734:	0e 94 84 44 	call	0x8908	; 0x8908 <__fp_cmp>
    8738:	08 f4       	brcc	.+2      	; 0x873c <__cmpsf2+0x8>
    873a:	81 e0       	ldi	r24, 0x01	; 1
    873c:	08 95       	ret

0000873e <__divsf3>:
    873e:	0e 94 b3 43 	call	0x8766	; 0x8766 <__divsf3x>
    8742:	0c 94 bf 44 	jmp	0x897e	; 0x897e <__fp_round>
    8746:	0e 94 b8 44 	call	0x8970	; 0x8970 <__fp_pscB>
    874a:	58 f0       	brcs	.+22     	; 0x8762 <__divsf3+0x24>
    874c:	0e 94 b1 44 	call	0x8962	; 0x8962 <__fp_pscA>
    8750:	40 f0       	brcs	.+16     	; 0x8762 <__divsf3+0x24>
    8752:	29 f4       	brne	.+10     	; 0x875e <__divsf3+0x20>
    8754:	5f 3f       	cpi	r21, 0xFF	; 255
    8756:	29 f0       	breq	.+10     	; 0x8762 <__divsf3+0x24>
    8758:	0c 94 a8 44 	jmp	0x8950	; 0x8950 <__fp_inf>
    875c:	51 11       	cpse	r21, r1
    875e:	0c 94 f3 44 	jmp	0x89e6	; 0x89e6 <__fp_szero>
    8762:	0c 94 ae 44 	jmp	0x895c	; 0x895c <__fp_nan>

00008766 <__divsf3x>:
    8766:	0e 94 d0 44 	call	0x89a0	; 0x89a0 <__fp_split3>
    876a:	68 f3       	brcs	.-38     	; 0x8746 <__divsf3+0x8>

0000876c <__divsf3_pse>:
    876c:	99 23       	and	r25, r25
    876e:	b1 f3       	breq	.-20     	; 0x875c <__divsf3+0x1e>
    8770:	55 23       	and	r21, r21
    8772:	91 f3       	breq	.-28     	; 0x8758 <__divsf3+0x1a>
    8774:	95 1b       	sub	r25, r21
    8776:	55 0b       	sbc	r21, r21
    8778:	bb 27       	eor	r27, r27
    877a:	aa 27       	eor	r26, r26
    877c:	62 17       	cp	r22, r18
    877e:	73 07       	cpc	r23, r19
    8780:	84 07       	cpc	r24, r20
    8782:	38 f0       	brcs	.+14     	; 0x8792 <__divsf3_pse+0x26>
    8784:	9f 5f       	subi	r25, 0xFF	; 255
    8786:	5f 4f       	sbci	r21, 0xFF	; 255
    8788:	22 0f       	add	r18, r18
    878a:	33 1f       	adc	r19, r19
    878c:	44 1f       	adc	r20, r20
    878e:	aa 1f       	adc	r26, r26
    8790:	a9 f3       	breq	.-22     	; 0x877c <__divsf3_pse+0x10>
    8792:	35 d0       	rcall	.+106    	; 0x87fe <__divsf3_pse+0x92>
    8794:	0e 2e       	mov	r0, r30
    8796:	3a f0       	brmi	.+14     	; 0x87a6 <__divsf3_pse+0x3a>
    8798:	e0 e8       	ldi	r30, 0x80	; 128
    879a:	32 d0       	rcall	.+100    	; 0x8800 <__divsf3_pse+0x94>
    879c:	91 50       	subi	r25, 0x01	; 1
    879e:	50 40       	sbci	r21, 0x00	; 0
    87a0:	e6 95       	lsr	r30
    87a2:	00 1c       	adc	r0, r0
    87a4:	ca f7       	brpl	.-14     	; 0x8798 <__divsf3_pse+0x2c>
    87a6:	2b d0       	rcall	.+86     	; 0x87fe <__divsf3_pse+0x92>
    87a8:	fe 2f       	mov	r31, r30
    87aa:	29 d0       	rcall	.+82     	; 0x87fe <__divsf3_pse+0x92>
    87ac:	66 0f       	add	r22, r22
    87ae:	77 1f       	adc	r23, r23
    87b0:	88 1f       	adc	r24, r24
    87b2:	bb 1f       	adc	r27, r27
    87b4:	26 17       	cp	r18, r22
    87b6:	37 07       	cpc	r19, r23
    87b8:	48 07       	cpc	r20, r24
    87ba:	ab 07       	cpc	r26, r27
    87bc:	b0 e8       	ldi	r27, 0x80	; 128
    87be:	09 f0       	breq	.+2      	; 0x87c2 <__divsf3_pse+0x56>
    87c0:	bb 0b       	sbc	r27, r27
    87c2:	80 2d       	mov	r24, r0
    87c4:	bf 01       	movw	r22, r30
    87c6:	ff 27       	eor	r31, r31
    87c8:	93 58       	subi	r25, 0x83	; 131
    87ca:	5f 4f       	sbci	r21, 0xFF	; 255
    87cc:	3a f0       	brmi	.+14     	; 0x87dc <__divsf3_pse+0x70>
    87ce:	9e 3f       	cpi	r25, 0xFE	; 254
    87d0:	51 05       	cpc	r21, r1
    87d2:	78 f0       	brcs	.+30     	; 0x87f2 <__divsf3_pse+0x86>
    87d4:	0c 94 a8 44 	jmp	0x8950	; 0x8950 <__fp_inf>
    87d8:	0c 94 f3 44 	jmp	0x89e6	; 0x89e6 <__fp_szero>
    87dc:	5f 3f       	cpi	r21, 0xFF	; 255
    87de:	e4 f3       	brlt	.-8      	; 0x87d8 <__divsf3_pse+0x6c>
    87e0:	98 3e       	cpi	r25, 0xE8	; 232
    87e2:	d4 f3       	brlt	.-12     	; 0x87d8 <__divsf3_pse+0x6c>
    87e4:	86 95       	lsr	r24
    87e6:	77 95       	ror	r23
    87e8:	67 95       	ror	r22
    87ea:	b7 95       	ror	r27
    87ec:	f7 95       	ror	r31
    87ee:	9f 5f       	subi	r25, 0xFF	; 255
    87f0:	c9 f7       	brne	.-14     	; 0x87e4 <__divsf3_pse+0x78>
    87f2:	88 0f       	add	r24, r24
    87f4:	91 1d       	adc	r25, r1
    87f6:	96 95       	lsr	r25
    87f8:	87 95       	ror	r24
    87fa:	97 f9       	bld	r25, 7
    87fc:	08 95       	ret
    87fe:	e1 e0       	ldi	r30, 0x01	; 1
    8800:	66 0f       	add	r22, r22
    8802:	77 1f       	adc	r23, r23
    8804:	88 1f       	adc	r24, r24
    8806:	bb 1f       	adc	r27, r27
    8808:	62 17       	cp	r22, r18
    880a:	73 07       	cpc	r23, r19
    880c:	84 07       	cpc	r24, r20
    880e:	ba 07       	cpc	r27, r26
    8810:	20 f0       	brcs	.+8      	; 0x881a <__divsf3_pse+0xae>
    8812:	62 1b       	sub	r22, r18
    8814:	73 0b       	sbc	r23, r19
    8816:	84 0b       	sbc	r24, r20
    8818:	ba 0b       	sbc	r27, r26
    881a:	ee 1f       	adc	r30, r30
    881c:	88 f7       	brcc	.-30     	; 0x8800 <__divsf3_pse+0x94>
    881e:	e0 95       	com	r30
    8820:	08 95       	ret

00008822 <__fixsfsi>:
    8822:	0e 94 18 44 	call	0x8830	; 0x8830 <__fixunssfsi>
    8826:	68 94       	set
    8828:	b1 11       	cpse	r27, r1
    882a:	0c 94 f3 44 	jmp	0x89e6	; 0x89e6 <__fp_szero>
    882e:	08 95       	ret

00008830 <__fixunssfsi>:
    8830:	0e 94 d8 44 	call	0x89b0	; 0x89b0 <__fp_splitA>
    8834:	88 f0       	brcs	.+34     	; 0x8858 <__fixunssfsi+0x28>
    8836:	9f 57       	subi	r25, 0x7F	; 127
    8838:	98 f0       	brcs	.+38     	; 0x8860 <__fixunssfsi+0x30>
    883a:	b9 2f       	mov	r27, r25
    883c:	99 27       	eor	r25, r25
    883e:	b7 51       	subi	r27, 0x17	; 23
    8840:	b0 f0       	brcs	.+44     	; 0x886e <__fixunssfsi+0x3e>
    8842:	e1 f0       	breq	.+56     	; 0x887c <__fixunssfsi+0x4c>
    8844:	66 0f       	add	r22, r22
    8846:	77 1f       	adc	r23, r23
    8848:	88 1f       	adc	r24, r24
    884a:	99 1f       	adc	r25, r25
    884c:	1a f0       	brmi	.+6      	; 0x8854 <__fixunssfsi+0x24>
    884e:	ba 95       	dec	r27
    8850:	c9 f7       	brne	.-14     	; 0x8844 <__fixunssfsi+0x14>
    8852:	14 c0       	rjmp	.+40     	; 0x887c <__fixunssfsi+0x4c>
    8854:	b1 30       	cpi	r27, 0x01	; 1
    8856:	91 f0       	breq	.+36     	; 0x887c <__fixunssfsi+0x4c>
    8858:	0e 94 f2 44 	call	0x89e4	; 0x89e4 <__fp_zero>
    885c:	b1 e0       	ldi	r27, 0x01	; 1
    885e:	08 95       	ret
    8860:	0c 94 f2 44 	jmp	0x89e4	; 0x89e4 <__fp_zero>
    8864:	67 2f       	mov	r22, r23
    8866:	78 2f       	mov	r23, r24
    8868:	88 27       	eor	r24, r24
    886a:	b8 5f       	subi	r27, 0xF8	; 248
    886c:	39 f0       	breq	.+14     	; 0x887c <__fixunssfsi+0x4c>
    886e:	b9 3f       	cpi	r27, 0xF9	; 249
    8870:	cc f3       	brlt	.-14     	; 0x8864 <__fixunssfsi+0x34>
    8872:	86 95       	lsr	r24
    8874:	77 95       	ror	r23
    8876:	67 95       	ror	r22
    8878:	b3 95       	inc	r27
    887a:	d9 f7       	brne	.-10     	; 0x8872 <__fixunssfsi+0x42>
    887c:	3e f4       	brtc	.+14     	; 0x888c <__fixunssfsi+0x5c>
    887e:	90 95       	com	r25
    8880:	80 95       	com	r24
    8882:	70 95       	com	r23
    8884:	61 95       	neg	r22
    8886:	7f 4f       	sbci	r23, 0xFF	; 255
    8888:	8f 4f       	sbci	r24, 0xFF	; 255
    888a:	9f 4f       	sbci	r25, 0xFF	; 255
    888c:	08 95       	ret

0000888e <__floatunsisf>:
    888e:	e8 94       	clt
    8890:	09 c0       	rjmp	.+18     	; 0x88a4 <__floatsisf+0x12>

00008892 <__floatsisf>:
    8892:	97 fb       	bst	r25, 7
    8894:	3e f4       	brtc	.+14     	; 0x88a4 <__floatsisf+0x12>
    8896:	90 95       	com	r25
    8898:	80 95       	com	r24
    889a:	70 95       	com	r23
    889c:	61 95       	neg	r22
    889e:	7f 4f       	sbci	r23, 0xFF	; 255
    88a0:	8f 4f       	sbci	r24, 0xFF	; 255
    88a2:	9f 4f       	sbci	r25, 0xFF	; 255
    88a4:	99 23       	and	r25, r25
    88a6:	a9 f0       	breq	.+42     	; 0x88d2 <__floatsisf+0x40>
    88a8:	f9 2f       	mov	r31, r25
    88aa:	96 e9       	ldi	r25, 0x96	; 150
    88ac:	bb 27       	eor	r27, r27
    88ae:	93 95       	inc	r25
    88b0:	f6 95       	lsr	r31
    88b2:	87 95       	ror	r24
    88b4:	77 95       	ror	r23
    88b6:	67 95       	ror	r22
    88b8:	b7 95       	ror	r27
    88ba:	f1 11       	cpse	r31, r1
    88bc:	f8 cf       	rjmp	.-16     	; 0x88ae <__floatsisf+0x1c>
    88be:	fa f4       	brpl	.+62     	; 0x88fe <__floatsisf+0x6c>
    88c0:	bb 0f       	add	r27, r27
    88c2:	11 f4       	brne	.+4      	; 0x88c8 <__floatsisf+0x36>
    88c4:	60 ff       	sbrs	r22, 0
    88c6:	1b c0       	rjmp	.+54     	; 0x88fe <__floatsisf+0x6c>
    88c8:	6f 5f       	subi	r22, 0xFF	; 255
    88ca:	7f 4f       	sbci	r23, 0xFF	; 255
    88cc:	8f 4f       	sbci	r24, 0xFF	; 255
    88ce:	9f 4f       	sbci	r25, 0xFF	; 255
    88d0:	16 c0       	rjmp	.+44     	; 0x88fe <__floatsisf+0x6c>
    88d2:	88 23       	and	r24, r24
    88d4:	11 f0       	breq	.+4      	; 0x88da <__floatsisf+0x48>
    88d6:	96 e9       	ldi	r25, 0x96	; 150
    88d8:	11 c0       	rjmp	.+34     	; 0x88fc <__floatsisf+0x6a>
    88da:	77 23       	and	r23, r23
    88dc:	21 f0       	breq	.+8      	; 0x88e6 <__floatsisf+0x54>
    88de:	9e e8       	ldi	r25, 0x8E	; 142
    88e0:	87 2f       	mov	r24, r23
    88e2:	76 2f       	mov	r23, r22
    88e4:	05 c0       	rjmp	.+10     	; 0x88f0 <__floatsisf+0x5e>
    88e6:	66 23       	and	r22, r22
    88e8:	71 f0       	breq	.+28     	; 0x8906 <__floatsisf+0x74>
    88ea:	96 e8       	ldi	r25, 0x86	; 134
    88ec:	86 2f       	mov	r24, r22
    88ee:	70 e0       	ldi	r23, 0x00	; 0
    88f0:	60 e0       	ldi	r22, 0x00	; 0
    88f2:	2a f0       	brmi	.+10     	; 0x88fe <__floatsisf+0x6c>
    88f4:	9a 95       	dec	r25
    88f6:	66 0f       	add	r22, r22
    88f8:	77 1f       	adc	r23, r23
    88fa:	88 1f       	adc	r24, r24
    88fc:	da f7       	brpl	.-10     	; 0x88f4 <__floatsisf+0x62>
    88fe:	88 0f       	add	r24, r24
    8900:	96 95       	lsr	r25
    8902:	87 95       	ror	r24
    8904:	97 f9       	bld	r25, 7
    8906:	08 95       	ret

00008908 <__fp_cmp>:
    8908:	99 0f       	add	r25, r25
    890a:	00 08       	sbc	r0, r0
    890c:	55 0f       	add	r21, r21
    890e:	aa 0b       	sbc	r26, r26
    8910:	e0 e8       	ldi	r30, 0x80	; 128
    8912:	fe ef       	ldi	r31, 0xFE	; 254
    8914:	16 16       	cp	r1, r22
    8916:	17 06       	cpc	r1, r23
    8918:	e8 07       	cpc	r30, r24
    891a:	f9 07       	cpc	r31, r25
    891c:	c0 f0       	brcs	.+48     	; 0x894e <__fp_cmp+0x46>
    891e:	12 16       	cp	r1, r18
    8920:	13 06       	cpc	r1, r19
    8922:	e4 07       	cpc	r30, r20
    8924:	f5 07       	cpc	r31, r21
    8926:	98 f0       	brcs	.+38     	; 0x894e <__fp_cmp+0x46>
    8928:	62 1b       	sub	r22, r18
    892a:	73 0b       	sbc	r23, r19
    892c:	84 0b       	sbc	r24, r20
    892e:	95 0b       	sbc	r25, r21
    8930:	39 f4       	brne	.+14     	; 0x8940 <__fp_cmp+0x38>
    8932:	0a 26       	eor	r0, r26
    8934:	61 f0       	breq	.+24     	; 0x894e <__fp_cmp+0x46>
    8936:	23 2b       	or	r18, r19
    8938:	24 2b       	or	r18, r20
    893a:	25 2b       	or	r18, r21
    893c:	21 f4       	brne	.+8      	; 0x8946 <__fp_cmp+0x3e>
    893e:	08 95       	ret
    8940:	0a 26       	eor	r0, r26
    8942:	09 f4       	brne	.+2      	; 0x8946 <__fp_cmp+0x3e>
    8944:	a1 40       	sbci	r26, 0x01	; 1
    8946:	a6 95       	lsr	r26
    8948:	8f ef       	ldi	r24, 0xFF	; 255
    894a:	81 1d       	adc	r24, r1
    894c:	81 1d       	adc	r24, r1
    894e:	08 95       	ret

00008950 <__fp_inf>:
    8950:	97 f9       	bld	r25, 7
    8952:	9f 67       	ori	r25, 0x7F	; 127
    8954:	80 e8       	ldi	r24, 0x80	; 128
    8956:	70 e0       	ldi	r23, 0x00	; 0
    8958:	60 e0       	ldi	r22, 0x00	; 0
    895a:	08 95       	ret

0000895c <__fp_nan>:
    895c:	9f ef       	ldi	r25, 0xFF	; 255
    895e:	80 ec       	ldi	r24, 0xC0	; 192
    8960:	08 95       	ret

00008962 <__fp_pscA>:
    8962:	00 24       	eor	r0, r0
    8964:	0a 94       	dec	r0
    8966:	16 16       	cp	r1, r22
    8968:	17 06       	cpc	r1, r23
    896a:	18 06       	cpc	r1, r24
    896c:	09 06       	cpc	r0, r25
    896e:	08 95       	ret

00008970 <__fp_pscB>:
    8970:	00 24       	eor	r0, r0
    8972:	0a 94       	dec	r0
    8974:	12 16       	cp	r1, r18
    8976:	13 06       	cpc	r1, r19
    8978:	14 06       	cpc	r1, r20
    897a:	05 06       	cpc	r0, r21
    897c:	08 95       	ret

0000897e <__fp_round>:
    897e:	09 2e       	mov	r0, r25
    8980:	03 94       	inc	r0
    8982:	00 0c       	add	r0, r0
    8984:	11 f4       	brne	.+4      	; 0x898a <__fp_round+0xc>
    8986:	88 23       	and	r24, r24
    8988:	52 f0       	brmi	.+20     	; 0x899e <__fp_round+0x20>
    898a:	bb 0f       	add	r27, r27
    898c:	40 f4       	brcc	.+16     	; 0x899e <__fp_round+0x20>
    898e:	bf 2b       	or	r27, r31
    8990:	11 f4       	brne	.+4      	; 0x8996 <__fp_round+0x18>
    8992:	60 ff       	sbrs	r22, 0
    8994:	04 c0       	rjmp	.+8      	; 0x899e <__fp_round+0x20>
    8996:	6f 5f       	subi	r22, 0xFF	; 255
    8998:	7f 4f       	sbci	r23, 0xFF	; 255
    899a:	8f 4f       	sbci	r24, 0xFF	; 255
    899c:	9f 4f       	sbci	r25, 0xFF	; 255
    899e:	08 95       	ret

000089a0 <__fp_split3>:
    89a0:	57 fd       	sbrc	r21, 7
    89a2:	90 58       	subi	r25, 0x80	; 128
    89a4:	44 0f       	add	r20, r20
    89a6:	55 1f       	adc	r21, r21
    89a8:	59 f0       	breq	.+22     	; 0x89c0 <__fp_splitA+0x10>
    89aa:	5f 3f       	cpi	r21, 0xFF	; 255
    89ac:	71 f0       	breq	.+28     	; 0x89ca <__fp_splitA+0x1a>
    89ae:	47 95       	ror	r20

000089b0 <__fp_splitA>:
    89b0:	88 0f       	add	r24, r24
    89b2:	97 fb       	bst	r25, 7
    89b4:	99 1f       	adc	r25, r25
    89b6:	61 f0       	breq	.+24     	; 0x89d0 <__fp_splitA+0x20>
    89b8:	9f 3f       	cpi	r25, 0xFF	; 255
    89ba:	79 f0       	breq	.+30     	; 0x89da <__fp_splitA+0x2a>
    89bc:	87 95       	ror	r24
    89be:	08 95       	ret
    89c0:	12 16       	cp	r1, r18
    89c2:	13 06       	cpc	r1, r19
    89c4:	14 06       	cpc	r1, r20
    89c6:	55 1f       	adc	r21, r21
    89c8:	f2 cf       	rjmp	.-28     	; 0x89ae <__fp_split3+0xe>
    89ca:	46 95       	lsr	r20
    89cc:	f1 df       	rcall	.-30     	; 0x89b0 <__fp_splitA>
    89ce:	08 c0       	rjmp	.+16     	; 0x89e0 <__fp_splitA+0x30>
    89d0:	16 16       	cp	r1, r22
    89d2:	17 06       	cpc	r1, r23
    89d4:	18 06       	cpc	r1, r24
    89d6:	99 1f       	adc	r25, r25
    89d8:	f1 cf       	rjmp	.-30     	; 0x89bc <__fp_splitA+0xc>
    89da:	86 95       	lsr	r24
    89dc:	71 05       	cpc	r23, r1
    89de:	61 05       	cpc	r22, r1
    89e0:	08 94       	sec
    89e2:	08 95       	ret

000089e4 <__fp_zero>:
    89e4:	e8 94       	clt

000089e6 <__fp_szero>:
    89e6:	bb 27       	eor	r27, r27
    89e8:	66 27       	eor	r22, r22
    89ea:	77 27       	eor	r23, r23
    89ec:	cb 01       	movw	r24, r22
    89ee:	97 f9       	bld	r25, 7
    89f0:	08 95       	ret

000089f2 <__gesf2>:
    89f2:	0e 94 84 44 	call	0x8908	; 0x8908 <__fp_cmp>
    89f6:	08 f4       	brcc	.+2      	; 0x89fa <__gesf2+0x8>
    89f8:	8f ef       	ldi	r24, 0xFF	; 255
    89fa:	08 95       	ret

000089fc <__mulsf3>:
    89fc:	0e 94 11 45 	call	0x8a22	; 0x8a22 <__mulsf3x>
    8a00:	0c 94 bf 44 	jmp	0x897e	; 0x897e <__fp_round>
    8a04:	0e 94 b1 44 	call	0x8962	; 0x8962 <__fp_pscA>
    8a08:	38 f0       	brcs	.+14     	; 0x8a18 <__mulsf3+0x1c>
    8a0a:	0e 94 b8 44 	call	0x8970	; 0x8970 <__fp_pscB>
    8a0e:	20 f0       	brcs	.+8      	; 0x8a18 <__mulsf3+0x1c>
    8a10:	95 23       	and	r25, r21
    8a12:	11 f0       	breq	.+4      	; 0x8a18 <__mulsf3+0x1c>
    8a14:	0c 94 a8 44 	jmp	0x8950	; 0x8950 <__fp_inf>
    8a18:	0c 94 ae 44 	jmp	0x895c	; 0x895c <__fp_nan>
    8a1c:	11 24       	eor	r1, r1
    8a1e:	0c 94 f3 44 	jmp	0x89e6	; 0x89e6 <__fp_szero>

00008a22 <__mulsf3x>:
    8a22:	0e 94 d0 44 	call	0x89a0	; 0x89a0 <__fp_split3>
    8a26:	70 f3       	brcs	.-36     	; 0x8a04 <__mulsf3+0x8>

00008a28 <__mulsf3_pse>:
    8a28:	95 9f       	mul	r25, r21
    8a2a:	c1 f3       	breq	.-16     	; 0x8a1c <__mulsf3+0x20>
    8a2c:	95 0f       	add	r25, r21
    8a2e:	50 e0       	ldi	r21, 0x00	; 0
    8a30:	55 1f       	adc	r21, r21
    8a32:	62 9f       	mul	r22, r18
    8a34:	f0 01       	movw	r30, r0
    8a36:	72 9f       	mul	r23, r18
    8a38:	bb 27       	eor	r27, r27
    8a3a:	f0 0d       	add	r31, r0
    8a3c:	b1 1d       	adc	r27, r1
    8a3e:	63 9f       	mul	r22, r19
    8a40:	aa 27       	eor	r26, r26
    8a42:	f0 0d       	add	r31, r0
    8a44:	b1 1d       	adc	r27, r1
    8a46:	aa 1f       	adc	r26, r26
    8a48:	64 9f       	mul	r22, r20
    8a4a:	66 27       	eor	r22, r22
    8a4c:	b0 0d       	add	r27, r0
    8a4e:	a1 1d       	adc	r26, r1
    8a50:	66 1f       	adc	r22, r22
    8a52:	82 9f       	mul	r24, r18
    8a54:	22 27       	eor	r18, r18
    8a56:	b0 0d       	add	r27, r0
    8a58:	a1 1d       	adc	r26, r1
    8a5a:	62 1f       	adc	r22, r18
    8a5c:	73 9f       	mul	r23, r19
    8a5e:	b0 0d       	add	r27, r0
    8a60:	a1 1d       	adc	r26, r1
    8a62:	62 1f       	adc	r22, r18
    8a64:	83 9f       	mul	r24, r19
    8a66:	a0 0d       	add	r26, r0
    8a68:	61 1d       	adc	r22, r1
    8a6a:	22 1f       	adc	r18, r18
    8a6c:	74 9f       	mul	r23, r20
    8a6e:	33 27       	eor	r19, r19
    8a70:	a0 0d       	add	r26, r0
    8a72:	61 1d       	adc	r22, r1
    8a74:	23 1f       	adc	r18, r19
    8a76:	84 9f       	mul	r24, r20
    8a78:	60 0d       	add	r22, r0
    8a7a:	21 1d       	adc	r18, r1
    8a7c:	82 2f       	mov	r24, r18
    8a7e:	76 2f       	mov	r23, r22
    8a80:	6a 2f       	mov	r22, r26
    8a82:	11 24       	eor	r1, r1
    8a84:	9f 57       	subi	r25, 0x7F	; 127
    8a86:	50 40       	sbci	r21, 0x00	; 0
    8a88:	9a f0       	brmi	.+38     	; 0x8ab0 <__mulsf3_pse+0x88>
    8a8a:	f1 f0       	breq	.+60     	; 0x8ac8 <__mulsf3_pse+0xa0>
    8a8c:	88 23       	and	r24, r24
    8a8e:	4a f0       	brmi	.+18     	; 0x8aa2 <__mulsf3_pse+0x7a>
    8a90:	ee 0f       	add	r30, r30
    8a92:	ff 1f       	adc	r31, r31
    8a94:	bb 1f       	adc	r27, r27
    8a96:	66 1f       	adc	r22, r22
    8a98:	77 1f       	adc	r23, r23
    8a9a:	88 1f       	adc	r24, r24
    8a9c:	91 50       	subi	r25, 0x01	; 1
    8a9e:	50 40       	sbci	r21, 0x00	; 0
    8aa0:	a9 f7       	brne	.-22     	; 0x8a8c <__mulsf3_pse+0x64>
    8aa2:	9e 3f       	cpi	r25, 0xFE	; 254
    8aa4:	51 05       	cpc	r21, r1
    8aa6:	80 f0       	brcs	.+32     	; 0x8ac8 <__mulsf3_pse+0xa0>
    8aa8:	0c 94 a8 44 	jmp	0x8950	; 0x8950 <__fp_inf>
    8aac:	0c 94 f3 44 	jmp	0x89e6	; 0x89e6 <__fp_szero>
    8ab0:	5f 3f       	cpi	r21, 0xFF	; 255
    8ab2:	e4 f3       	brlt	.-8      	; 0x8aac <__mulsf3_pse+0x84>
    8ab4:	98 3e       	cpi	r25, 0xE8	; 232
    8ab6:	d4 f3       	brlt	.-12     	; 0x8aac <__mulsf3_pse+0x84>
    8ab8:	86 95       	lsr	r24
    8aba:	77 95       	ror	r23
    8abc:	67 95       	ror	r22
    8abe:	b7 95       	ror	r27
    8ac0:	f7 95       	ror	r31
    8ac2:	e7 95       	ror	r30
    8ac4:	9f 5f       	subi	r25, 0xFF	; 255
    8ac6:	c1 f7       	brne	.-16     	; 0x8ab8 <__mulsf3_pse+0x90>
    8ac8:	fe 2b       	or	r31, r30
    8aca:	88 0f       	add	r24, r24
    8acc:	91 1d       	adc	r25, r1
    8ace:	96 95       	lsr	r25
    8ad0:	87 95       	ror	r24
    8ad2:	97 f9       	bld	r25, 7
    8ad4:	08 95       	ret

00008ad6 <vfprintf>:
    8ad6:	2f 92       	push	r2
    8ad8:	3f 92       	push	r3
    8ada:	4f 92       	push	r4
    8adc:	5f 92       	push	r5
    8ade:	6f 92       	push	r6
    8ae0:	7f 92       	push	r7
    8ae2:	8f 92       	push	r8
    8ae4:	9f 92       	push	r9
    8ae6:	af 92       	push	r10
    8ae8:	bf 92       	push	r11
    8aea:	cf 92       	push	r12
    8aec:	df 92       	push	r13
    8aee:	ef 92       	push	r14
    8af0:	ff 92       	push	r15
    8af2:	0f 93       	push	r16
    8af4:	1f 93       	push	r17
    8af6:	cf 93       	push	r28
    8af8:	df 93       	push	r29
    8afa:	cd b7       	in	r28, 0x3d	; 61
    8afc:	de b7       	in	r29, 0x3e	; 62
    8afe:	60 97       	sbiw	r28, 0x10	; 16
    8b00:	cd bf       	out	0x3d, r28	; 61
    8b02:	de bf       	out	0x3e, r29	; 62
    8b04:	7c 01       	movw	r14, r24
    8b06:	1b 01       	movw	r2, r22
    8b08:	6a 01       	movw	r12, r20
    8b0a:	fc 01       	movw	r30, r24
    8b0c:	16 82       	std	Z+6, r1	; 0x06
    8b0e:	17 82       	std	Z+7, r1	; 0x07
    8b10:	83 81       	ldd	r24, Z+3	; 0x03
    8b12:	81 ff       	sbrs	r24, 1
    8b14:	44 c3       	rjmp	.+1672   	; 0x919e <vfprintf+0x6c8>
    8b16:	9e 01       	movw	r18, r28
    8b18:	2f 5f       	subi	r18, 0xFF	; 255
    8b1a:	3f 4f       	sbci	r19, 0xFF	; 255
    8b1c:	39 01       	movw	r6, r18
    8b1e:	f7 01       	movw	r30, r14
    8b20:	93 81       	ldd	r25, Z+3	; 0x03
    8b22:	f1 01       	movw	r30, r2
    8b24:	93 fd       	sbrc	r25, 3
    8b26:	85 91       	lpm	r24, Z+
    8b28:	93 ff       	sbrs	r25, 3
    8b2a:	81 91       	ld	r24, Z+
    8b2c:	1f 01       	movw	r2, r30
    8b2e:	88 23       	and	r24, r24
    8b30:	09 f4       	brne	.+2      	; 0x8b34 <vfprintf+0x5e>
    8b32:	31 c3       	rjmp	.+1634   	; 0x9196 <vfprintf+0x6c0>
    8b34:	85 32       	cpi	r24, 0x25	; 37
    8b36:	39 f4       	brne	.+14     	; 0x8b46 <vfprintf+0x70>
    8b38:	93 fd       	sbrc	r25, 3
    8b3a:	85 91       	lpm	r24, Z+
    8b3c:	93 ff       	sbrs	r25, 3
    8b3e:	81 91       	ld	r24, Z+
    8b40:	1f 01       	movw	r2, r30
    8b42:	85 32       	cpi	r24, 0x25	; 37
    8b44:	39 f4       	brne	.+14     	; 0x8b54 <vfprintf+0x7e>
    8b46:	b7 01       	movw	r22, r14
    8b48:	90 e0       	ldi	r25, 0x00	; 0
    8b4a:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    8b4e:	56 01       	movw	r10, r12
    8b50:	65 01       	movw	r12, r10
    8b52:	e5 cf       	rjmp	.-54     	; 0x8b1e <vfprintf+0x48>
    8b54:	10 e0       	ldi	r17, 0x00	; 0
    8b56:	51 2c       	mov	r5, r1
    8b58:	91 2c       	mov	r9, r1
    8b5a:	ff e1       	ldi	r31, 0x1F	; 31
    8b5c:	f9 15       	cp	r31, r9
    8b5e:	d8 f0       	brcs	.+54     	; 0x8b96 <vfprintf+0xc0>
    8b60:	8b 32       	cpi	r24, 0x2B	; 43
    8b62:	79 f0       	breq	.+30     	; 0x8b82 <vfprintf+0xac>
    8b64:	38 f4       	brcc	.+14     	; 0x8b74 <vfprintf+0x9e>
    8b66:	80 32       	cpi	r24, 0x20	; 32
    8b68:	79 f0       	breq	.+30     	; 0x8b88 <vfprintf+0xb2>
    8b6a:	83 32       	cpi	r24, 0x23	; 35
    8b6c:	a1 f4       	brne	.+40     	; 0x8b96 <vfprintf+0xc0>
    8b6e:	f9 2d       	mov	r31, r9
    8b70:	f0 61       	ori	r31, 0x10	; 16
    8b72:	2e c0       	rjmp	.+92     	; 0x8bd0 <vfprintf+0xfa>
    8b74:	8d 32       	cpi	r24, 0x2D	; 45
    8b76:	61 f0       	breq	.+24     	; 0x8b90 <vfprintf+0xba>
    8b78:	80 33       	cpi	r24, 0x30	; 48
    8b7a:	69 f4       	brne	.+26     	; 0x8b96 <vfprintf+0xc0>
    8b7c:	29 2d       	mov	r18, r9
    8b7e:	21 60       	ori	r18, 0x01	; 1
    8b80:	2d c0       	rjmp	.+90     	; 0x8bdc <vfprintf+0x106>
    8b82:	39 2d       	mov	r19, r9
    8b84:	32 60       	ori	r19, 0x02	; 2
    8b86:	93 2e       	mov	r9, r19
    8b88:	89 2d       	mov	r24, r9
    8b8a:	84 60       	ori	r24, 0x04	; 4
    8b8c:	98 2e       	mov	r9, r24
    8b8e:	2a c0       	rjmp	.+84     	; 0x8be4 <vfprintf+0x10e>
    8b90:	e9 2d       	mov	r30, r9
    8b92:	e8 60       	ori	r30, 0x08	; 8
    8b94:	15 c0       	rjmp	.+42     	; 0x8bc0 <vfprintf+0xea>
    8b96:	97 fc       	sbrc	r9, 7
    8b98:	2d c0       	rjmp	.+90     	; 0x8bf4 <vfprintf+0x11e>
    8b9a:	20 ed       	ldi	r18, 0xD0	; 208
    8b9c:	28 0f       	add	r18, r24
    8b9e:	2a 30       	cpi	r18, 0x0A	; 10
    8ba0:	88 f4       	brcc	.+34     	; 0x8bc4 <vfprintf+0xee>
    8ba2:	96 fe       	sbrs	r9, 6
    8ba4:	06 c0       	rjmp	.+12     	; 0x8bb2 <vfprintf+0xdc>
    8ba6:	3a e0       	ldi	r19, 0x0A	; 10
    8ba8:	13 9f       	mul	r17, r19
    8baa:	20 0d       	add	r18, r0
    8bac:	11 24       	eor	r1, r1
    8bae:	12 2f       	mov	r17, r18
    8bb0:	19 c0       	rjmp	.+50     	; 0x8be4 <vfprintf+0x10e>
    8bb2:	8a e0       	ldi	r24, 0x0A	; 10
    8bb4:	58 9e       	mul	r5, r24
    8bb6:	20 0d       	add	r18, r0
    8bb8:	11 24       	eor	r1, r1
    8bba:	52 2e       	mov	r5, r18
    8bbc:	e9 2d       	mov	r30, r9
    8bbe:	e0 62       	ori	r30, 0x20	; 32
    8bc0:	9e 2e       	mov	r9, r30
    8bc2:	10 c0       	rjmp	.+32     	; 0x8be4 <vfprintf+0x10e>
    8bc4:	8e 32       	cpi	r24, 0x2E	; 46
    8bc6:	31 f4       	brne	.+12     	; 0x8bd4 <vfprintf+0xfe>
    8bc8:	96 fc       	sbrc	r9, 6
    8bca:	e5 c2       	rjmp	.+1482   	; 0x9196 <vfprintf+0x6c0>
    8bcc:	f9 2d       	mov	r31, r9
    8bce:	f0 64       	ori	r31, 0x40	; 64
    8bd0:	9f 2e       	mov	r9, r31
    8bd2:	08 c0       	rjmp	.+16     	; 0x8be4 <vfprintf+0x10e>
    8bd4:	8c 36       	cpi	r24, 0x6C	; 108
    8bd6:	21 f4       	brne	.+8      	; 0x8be0 <vfprintf+0x10a>
    8bd8:	29 2d       	mov	r18, r9
    8bda:	20 68       	ori	r18, 0x80	; 128
    8bdc:	92 2e       	mov	r9, r18
    8bde:	02 c0       	rjmp	.+4      	; 0x8be4 <vfprintf+0x10e>
    8be0:	88 36       	cpi	r24, 0x68	; 104
    8be2:	41 f4       	brne	.+16     	; 0x8bf4 <vfprintf+0x11e>
    8be4:	f1 01       	movw	r30, r2
    8be6:	93 fd       	sbrc	r25, 3
    8be8:	85 91       	lpm	r24, Z+
    8bea:	93 ff       	sbrs	r25, 3
    8bec:	81 91       	ld	r24, Z+
    8bee:	1f 01       	movw	r2, r30
    8bf0:	81 11       	cpse	r24, r1
    8bf2:	b3 cf       	rjmp	.-154    	; 0x8b5a <vfprintf+0x84>
    8bf4:	9b eb       	ldi	r25, 0xBB	; 187
    8bf6:	98 0f       	add	r25, r24
    8bf8:	93 30       	cpi	r25, 0x03	; 3
    8bfa:	20 f4       	brcc	.+8      	; 0x8c04 <vfprintf+0x12e>
    8bfc:	99 2d       	mov	r25, r9
    8bfe:	90 61       	ori	r25, 0x10	; 16
    8c00:	80 5e       	subi	r24, 0xE0	; 224
    8c02:	07 c0       	rjmp	.+14     	; 0x8c12 <vfprintf+0x13c>
    8c04:	9b e9       	ldi	r25, 0x9B	; 155
    8c06:	98 0f       	add	r25, r24
    8c08:	93 30       	cpi	r25, 0x03	; 3
    8c0a:	08 f0       	brcs	.+2      	; 0x8c0e <vfprintf+0x138>
    8c0c:	66 c1       	rjmp	.+716    	; 0x8eda <vfprintf+0x404>
    8c0e:	99 2d       	mov	r25, r9
    8c10:	9f 7e       	andi	r25, 0xEF	; 239
    8c12:	96 ff       	sbrs	r25, 6
    8c14:	16 e0       	ldi	r17, 0x06	; 6
    8c16:	9f 73       	andi	r25, 0x3F	; 63
    8c18:	99 2e       	mov	r9, r25
    8c1a:	85 36       	cpi	r24, 0x65	; 101
    8c1c:	19 f4       	brne	.+6      	; 0x8c24 <vfprintf+0x14e>
    8c1e:	90 64       	ori	r25, 0x40	; 64
    8c20:	99 2e       	mov	r9, r25
    8c22:	08 c0       	rjmp	.+16     	; 0x8c34 <vfprintf+0x15e>
    8c24:	86 36       	cpi	r24, 0x66	; 102
    8c26:	21 f4       	brne	.+8      	; 0x8c30 <vfprintf+0x15a>
    8c28:	39 2f       	mov	r19, r25
    8c2a:	30 68       	ori	r19, 0x80	; 128
    8c2c:	93 2e       	mov	r9, r19
    8c2e:	02 c0       	rjmp	.+4      	; 0x8c34 <vfprintf+0x15e>
    8c30:	11 11       	cpse	r17, r1
    8c32:	11 50       	subi	r17, 0x01	; 1
    8c34:	97 fe       	sbrs	r9, 7
    8c36:	07 c0       	rjmp	.+14     	; 0x8c46 <vfprintf+0x170>
    8c38:	1c 33       	cpi	r17, 0x3C	; 60
    8c3a:	50 f4       	brcc	.+20     	; 0x8c50 <vfprintf+0x17a>
    8c3c:	44 24       	eor	r4, r4
    8c3e:	43 94       	inc	r4
    8c40:	41 0e       	add	r4, r17
    8c42:	27 e0       	ldi	r18, 0x07	; 7
    8c44:	0b c0       	rjmp	.+22     	; 0x8c5c <vfprintf+0x186>
    8c46:	18 30       	cpi	r17, 0x08	; 8
    8c48:	38 f0       	brcs	.+14     	; 0x8c58 <vfprintf+0x182>
    8c4a:	27 e0       	ldi	r18, 0x07	; 7
    8c4c:	17 e0       	ldi	r17, 0x07	; 7
    8c4e:	05 c0       	rjmp	.+10     	; 0x8c5a <vfprintf+0x184>
    8c50:	27 e0       	ldi	r18, 0x07	; 7
    8c52:	9c e3       	ldi	r25, 0x3C	; 60
    8c54:	49 2e       	mov	r4, r25
    8c56:	02 c0       	rjmp	.+4      	; 0x8c5c <vfprintf+0x186>
    8c58:	21 2f       	mov	r18, r17
    8c5a:	41 2c       	mov	r4, r1
    8c5c:	56 01       	movw	r10, r12
    8c5e:	84 e0       	ldi	r24, 0x04	; 4
    8c60:	a8 0e       	add	r10, r24
    8c62:	b1 1c       	adc	r11, r1
    8c64:	f6 01       	movw	r30, r12
    8c66:	60 81       	ld	r22, Z
    8c68:	71 81       	ldd	r23, Z+1	; 0x01
    8c6a:	82 81       	ldd	r24, Z+2	; 0x02
    8c6c:	93 81       	ldd	r25, Z+3	; 0x03
    8c6e:	04 2d       	mov	r16, r4
    8c70:	a3 01       	movw	r20, r6
    8c72:	0e 94 aa 4c 	call	0x9954	; 0x9954 <__ftoa_engine>
    8c76:	6c 01       	movw	r12, r24
    8c78:	f9 81       	ldd	r31, Y+1	; 0x01
    8c7a:	fc 87       	std	Y+12, r31	; 0x0c
    8c7c:	f0 ff       	sbrs	r31, 0
    8c7e:	02 c0       	rjmp	.+4      	; 0x8c84 <vfprintf+0x1ae>
    8c80:	f3 ff       	sbrs	r31, 3
    8c82:	06 c0       	rjmp	.+12     	; 0x8c90 <vfprintf+0x1ba>
    8c84:	91 fc       	sbrc	r9, 1
    8c86:	06 c0       	rjmp	.+12     	; 0x8c94 <vfprintf+0x1be>
    8c88:	92 fe       	sbrs	r9, 2
    8c8a:	06 c0       	rjmp	.+12     	; 0x8c98 <vfprintf+0x1c2>
    8c8c:	00 e2       	ldi	r16, 0x20	; 32
    8c8e:	05 c0       	rjmp	.+10     	; 0x8c9a <vfprintf+0x1c4>
    8c90:	0d e2       	ldi	r16, 0x2D	; 45
    8c92:	03 c0       	rjmp	.+6      	; 0x8c9a <vfprintf+0x1c4>
    8c94:	0b e2       	ldi	r16, 0x2B	; 43
    8c96:	01 c0       	rjmp	.+2      	; 0x8c9a <vfprintf+0x1c4>
    8c98:	00 e0       	ldi	r16, 0x00	; 0
    8c9a:	8c 85       	ldd	r24, Y+12	; 0x0c
    8c9c:	8c 70       	andi	r24, 0x0C	; 12
    8c9e:	19 f0       	breq	.+6      	; 0x8ca6 <vfprintf+0x1d0>
    8ca0:	01 11       	cpse	r16, r1
    8ca2:	5a c2       	rjmp	.+1204   	; 0x9158 <vfprintf+0x682>
    8ca4:	9b c2       	rjmp	.+1334   	; 0x91dc <vfprintf+0x706>
    8ca6:	97 fe       	sbrs	r9, 7
    8ca8:	10 c0       	rjmp	.+32     	; 0x8cca <vfprintf+0x1f4>
    8caa:	4c 0c       	add	r4, r12
    8cac:	fc 85       	ldd	r31, Y+12	; 0x0c
    8cae:	f4 ff       	sbrs	r31, 4
    8cb0:	04 c0       	rjmp	.+8      	; 0x8cba <vfprintf+0x1e4>
    8cb2:	8a 81       	ldd	r24, Y+2	; 0x02
    8cb4:	81 33       	cpi	r24, 0x31	; 49
    8cb6:	09 f4       	brne	.+2      	; 0x8cba <vfprintf+0x1e4>
    8cb8:	4a 94       	dec	r4
    8cba:	14 14       	cp	r1, r4
    8cbc:	74 f5       	brge	.+92     	; 0x8d1a <vfprintf+0x244>
    8cbe:	28 e0       	ldi	r18, 0x08	; 8
    8cc0:	24 15       	cp	r18, r4
    8cc2:	78 f5       	brcc	.+94     	; 0x8d22 <vfprintf+0x24c>
    8cc4:	88 e0       	ldi	r24, 0x08	; 8
    8cc6:	48 2e       	mov	r4, r24
    8cc8:	2c c0       	rjmp	.+88     	; 0x8d22 <vfprintf+0x24c>
    8cca:	96 fc       	sbrc	r9, 6
    8ccc:	2a c0       	rjmp	.+84     	; 0x8d22 <vfprintf+0x24c>
    8cce:	81 2f       	mov	r24, r17
    8cd0:	90 e0       	ldi	r25, 0x00	; 0
    8cd2:	8c 15       	cp	r24, r12
    8cd4:	9d 05       	cpc	r25, r13
    8cd6:	9c f0       	brlt	.+38     	; 0x8cfe <vfprintf+0x228>
    8cd8:	3c ef       	ldi	r19, 0xFC	; 252
    8cda:	c3 16       	cp	r12, r19
    8cdc:	3f ef       	ldi	r19, 0xFF	; 255
    8cde:	d3 06       	cpc	r13, r19
    8ce0:	74 f0       	brlt	.+28     	; 0x8cfe <vfprintf+0x228>
    8ce2:	89 2d       	mov	r24, r9
    8ce4:	80 68       	ori	r24, 0x80	; 128
    8ce6:	98 2e       	mov	r9, r24
    8ce8:	0a c0       	rjmp	.+20     	; 0x8cfe <vfprintf+0x228>
    8cea:	e2 e0       	ldi	r30, 0x02	; 2
    8cec:	f0 e0       	ldi	r31, 0x00	; 0
    8cee:	ec 0f       	add	r30, r28
    8cf0:	fd 1f       	adc	r31, r29
    8cf2:	e1 0f       	add	r30, r17
    8cf4:	f1 1d       	adc	r31, r1
    8cf6:	80 81       	ld	r24, Z
    8cf8:	80 33       	cpi	r24, 0x30	; 48
    8cfa:	19 f4       	brne	.+6      	; 0x8d02 <vfprintf+0x22c>
    8cfc:	11 50       	subi	r17, 0x01	; 1
    8cfe:	11 11       	cpse	r17, r1
    8d00:	f4 cf       	rjmp	.-24     	; 0x8cea <vfprintf+0x214>
    8d02:	97 fe       	sbrs	r9, 7
    8d04:	0e c0       	rjmp	.+28     	; 0x8d22 <vfprintf+0x24c>
    8d06:	44 24       	eor	r4, r4
    8d08:	43 94       	inc	r4
    8d0a:	41 0e       	add	r4, r17
    8d0c:	81 2f       	mov	r24, r17
    8d0e:	90 e0       	ldi	r25, 0x00	; 0
    8d10:	c8 16       	cp	r12, r24
    8d12:	d9 06       	cpc	r13, r25
    8d14:	2c f4       	brge	.+10     	; 0x8d20 <vfprintf+0x24a>
    8d16:	1c 19       	sub	r17, r12
    8d18:	04 c0       	rjmp	.+8      	; 0x8d22 <vfprintf+0x24c>
    8d1a:	44 24       	eor	r4, r4
    8d1c:	43 94       	inc	r4
    8d1e:	01 c0       	rjmp	.+2      	; 0x8d22 <vfprintf+0x24c>
    8d20:	10 e0       	ldi	r17, 0x00	; 0
    8d22:	97 fe       	sbrs	r9, 7
    8d24:	06 c0       	rjmp	.+12     	; 0x8d32 <vfprintf+0x25c>
    8d26:	1c 14       	cp	r1, r12
    8d28:	1d 04       	cpc	r1, r13
    8d2a:	34 f4       	brge	.+12     	; 0x8d38 <vfprintf+0x262>
    8d2c:	c6 01       	movw	r24, r12
    8d2e:	01 96       	adiw	r24, 0x01	; 1
    8d30:	05 c0       	rjmp	.+10     	; 0x8d3c <vfprintf+0x266>
    8d32:	85 e0       	ldi	r24, 0x05	; 5
    8d34:	90 e0       	ldi	r25, 0x00	; 0
    8d36:	02 c0       	rjmp	.+4      	; 0x8d3c <vfprintf+0x266>
    8d38:	81 e0       	ldi	r24, 0x01	; 1
    8d3a:	90 e0       	ldi	r25, 0x00	; 0
    8d3c:	01 11       	cpse	r16, r1
    8d3e:	01 96       	adiw	r24, 0x01	; 1
    8d40:	11 23       	and	r17, r17
    8d42:	31 f0       	breq	.+12     	; 0x8d50 <vfprintf+0x27a>
    8d44:	21 2f       	mov	r18, r17
    8d46:	30 e0       	ldi	r19, 0x00	; 0
    8d48:	2f 5f       	subi	r18, 0xFF	; 255
    8d4a:	3f 4f       	sbci	r19, 0xFF	; 255
    8d4c:	82 0f       	add	r24, r18
    8d4e:	93 1f       	adc	r25, r19
    8d50:	25 2d       	mov	r18, r5
    8d52:	30 e0       	ldi	r19, 0x00	; 0
    8d54:	82 17       	cp	r24, r18
    8d56:	93 07       	cpc	r25, r19
    8d58:	14 f4       	brge	.+4      	; 0x8d5e <vfprintf+0x288>
    8d5a:	58 1a       	sub	r5, r24
    8d5c:	01 c0       	rjmp	.+2      	; 0x8d60 <vfprintf+0x28a>
    8d5e:	51 2c       	mov	r5, r1
    8d60:	89 2d       	mov	r24, r9
    8d62:	89 70       	andi	r24, 0x09	; 9
    8d64:	49 f4       	brne	.+18     	; 0x8d78 <vfprintf+0x2a2>
    8d66:	55 20       	and	r5, r5
    8d68:	39 f0       	breq	.+14     	; 0x8d78 <vfprintf+0x2a2>
    8d6a:	b7 01       	movw	r22, r14
    8d6c:	80 e2       	ldi	r24, 0x20	; 32
    8d6e:	90 e0       	ldi	r25, 0x00	; 0
    8d70:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    8d74:	5a 94       	dec	r5
    8d76:	f7 cf       	rjmp	.-18     	; 0x8d66 <vfprintf+0x290>
    8d78:	00 23       	and	r16, r16
    8d7a:	29 f0       	breq	.+10     	; 0x8d86 <vfprintf+0x2b0>
    8d7c:	b7 01       	movw	r22, r14
    8d7e:	80 2f       	mov	r24, r16
    8d80:	90 e0       	ldi	r25, 0x00	; 0
    8d82:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    8d86:	93 fc       	sbrc	r9, 3
    8d88:	09 c0       	rjmp	.+18     	; 0x8d9c <vfprintf+0x2c6>
    8d8a:	55 20       	and	r5, r5
    8d8c:	39 f0       	breq	.+14     	; 0x8d9c <vfprintf+0x2c6>
    8d8e:	b7 01       	movw	r22, r14
    8d90:	80 e3       	ldi	r24, 0x30	; 48
    8d92:	90 e0       	ldi	r25, 0x00	; 0
    8d94:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    8d98:	5a 94       	dec	r5
    8d9a:	f7 cf       	rjmp	.-18     	; 0x8d8a <vfprintf+0x2b4>
    8d9c:	97 fe       	sbrs	r9, 7
    8d9e:	4c c0       	rjmp	.+152    	; 0x8e38 <vfprintf+0x362>
    8da0:	46 01       	movw	r8, r12
    8da2:	d7 fe       	sbrs	r13, 7
    8da4:	02 c0       	rjmp	.+4      	; 0x8daa <vfprintf+0x2d4>
    8da6:	81 2c       	mov	r8, r1
    8da8:	91 2c       	mov	r9, r1
    8daa:	c6 01       	movw	r24, r12
    8dac:	88 19       	sub	r24, r8
    8dae:	99 09       	sbc	r25, r9
    8db0:	f3 01       	movw	r30, r6
    8db2:	e8 0f       	add	r30, r24
    8db4:	f9 1f       	adc	r31, r25
    8db6:	ed 87       	std	Y+13, r30	; 0x0d
    8db8:	fe 87       	std	Y+14, r31	; 0x0e
    8dba:	96 01       	movw	r18, r12
    8dbc:	24 19       	sub	r18, r4
    8dbe:	31 09       	sbc	r19, r1
    8dc0:	2f 87       	std	Y+15, r18	; 0x0f
    8dc2:	38 8b       	std	Y+16, r19	; 0x10
    8dc4:	01 2f       	mov	r16, r17
    8dc6:	10 e0       	ldi	r17, 0x00	; 0
    8dc8:	11 95       	neg	r17
    8dca:	01 95       	neg	r16
    8dcc:	11 09       	sbc	r17, r1
    8dce:	3f ef       	ldi	r19, 0xFF	; 255
    8dd0:	83 16       	cp	r8, r19
    8dd2:	93 06       	cpc	r9, r19
    8dd4:	29 f4       	brne	.+10     	; 0x8de0 <vfprintf+0x30a>
    8dd6:	b7 01       	movw	r22, r14
    8dd8:	8e e2       	ldi	r24, 0x2E	; 46
    8dda:	90 e0       	ldi	r25, 0x00	; 0
    8ddc:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    8de0:	c8 14       	cp	r12, r8
    8de2:	d9 04       	cpc	r13, r9
    8de4:	4c f0       	brlt	.+18     	; 0x8df8 <vfprintf+0x322>
    8de6:	8f 85       	ldd	r24, Y+15	; 0x0f
    8de8:	98 89       	ldd	r25, Y+16	; 0x10
    8dea:	88 15       	cp	r24, r8
    8dec:	99 05       	cpc	r25, r9
    8dee:	24 f4       	brge	.+8      	; 0x8df8 <vfprintf+0x322>
    8df0:	ed 85       	ldd	r30, Y+13	; 0x0d
    8df2:	fe 85       	ldd	r31, Y+14	; 0x0e
    8df4:	81 81       	ldd	r24, Z+1	; 0x01
    8df6:	01 c0       	rjmp	.+2      	; 0x8dfa <vfprintf+0x324>
    8df8:	80 e3       	ldi	r24, 0x30	; 48
    8dfa:	f1 e0       	ldi	r31, 0x01	; 1
    8dfc:	8f 1a       	sub	r8, r31
    8dfe:	91 08       	sbc	r9, r1
    8e00:	2d 85       	ldd	r18, Y+13	; 0x0d
    8e02:	3e 85       	ldd	r19, Y+14	; 0x0e
    8e04:	2f 5f       	subi	r18, 0xFF	; 255
    8e06:	3f 4f       	sbci	r19, 0xFF	; 255
    8e08:	2d 87       	std	Y+13, r18	; 0x0d
    8e0a:	3e 87       	std	Y+14, r19	; 0x0e
    8e0c:	80 16       	cp	r8, r16
    8e0e:	91 06       	cpc	r9, r17
    8e10:	2c f0       	brlt	.+10     	; 0x8e1c <vfprintf+0x346>
    8e12:	b7 01       	movw	r22, r14
    8e14:	90 e0       	ldi	r25, 0x00	; 0
    8e16:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    8e1a:	d9 cf       	rjmp	.-78     	; 0x8dce <vfprintf+0x2f8>
    8e1c:	c8 14       	cp	r12, r8
    8e1e:	d9 04       	cpc	r13, r9
    8e20:	41 f4       	brne	.+16     	; 0x8e32 <vfprintf+0x35c>
    8e22:	9a 81       	ldd	r25, Y+2	; 0x02
    8e24:	96 33       	cpi	r25, 0x36	; 54
    8e26:	20 f4       	brcc	.+8      	; 0x8e30 <vfprintf+0x35a>
    8e28:	95 33       	cpi	r25, 0x35	; 53
    8e2a:	19 f4       	brne	.+6      	; 0x8e32 <vfprintf+0x35c>
    8e2c:	3c 85       	ldd	r19, Y+12	; 0x0c
    8e2e:	34 ff       	sbrs	r19, 4
    8e30:	81 e3       	ldi	r24, 0x31	; 49
    8e32:	b7 01       	movw	r22, r14
    8e34:	90 e0       	ldi	r25, 0x00	; 0
    8e36:	4e c0       	rjmp	.+156    	; 0x8ed4 <vfprintf+0x3fe>
    8e38:	8a 81       	ldd	r24, Y+2	; 0x02
    8e3a:	81 33       	cpi	r24, 0x31	; 49
    8e3c:	19 f0       	breq	.+6      	; 0x8e44 <vfprintf+0x36e>
    8e3e:	9c 85       	ldd	r25, Y+12	; 0x0c
    8e40:	9f 7e       	andi	r25, 0xEF	; 239
    8e42:	9c 87       	std	Y+12, r25	; 0x0c
    8e44:	b7 01       	movw	r22, r14
    8e46:	90 e0       	ldi	r25, 0x00	; 0
    8e48:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    8e4c:	11 11       	cpse	r17, r1
    8e4e:	05 c0       	rjmp	.+10     	; 0x8e5a <vfprintf+0x384>
    8e50:	94 fc       	sbrc	r9, 4
    8e52:	18 c0       	rjmp	.+48     	; 0x8e84 <vfprintf+0x3ae>
    8e54:	85 e6       	ldi	r24, 0x65	; 101
    8e56:	90 e0       	ldi	r25, 0x00	; 0
    8e58:	17 c0       	rjmp	.+46     	; 0x8e88 <vfprintf+0x3b2>
    8e5a:	b7 01       	movw	r22, r14
    8e5c:	8e e2       	ldi	r24, 0x2E	; 46
    8e5e:	90 e0       	ldi	r25, 0x00	; 0
    8e60:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    8e64:	1e 5f       	subi	r17, 0xFE	; 254
    8e66:	82 e0       	ldi	r24, 0x02	; 2
    8e68:	01 e0       	ldi	r16, 0x01	; 1
    8e6a:	08 0f       	add	r16, r24
    8e6c:	f3 01       	movw	r30, r6
    8e6e:	e8 0f       	add	r30, r24
    8e70:	f1 1d       	adc	r31, r1
    8e72:	80 81       	ld	r24, Z
    8e74:	b7 01       	movw	r22, r14
    8e76:	90 e0       	ldi	r25, 0x00	; 0
    8e78:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    8e7c:	80 2f       	mov	r24, r16
    8e7e:	01 13       	cpse	r16, r17
    8e80:	f3 cf       	rjmp	.-26     	; 0x8e68 <vfprintf+0x392>
    8e82:	e6 cf       	rjmp	.-52     	; 0x8e50 <vfprintf+0x37a>
    8e84:	85 e4       	ldi	r24, 0x45	; 69
    8e86:	90 e0       	ldi	r25, 0x00	; 0
    8e88:	b7 01       	movw	r22, r14
    8e8a:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    8e8e:	d7 fc       	sbrc	r13, 7
    8e90:	06 c0       	rjmp	.+12     	; 0x8e9e <vfprintf+0x3c8>
    8e92:	c1 14       	cp	r12, r1
    8e94:	d1 04       	cpc	r13, r1
    8e96:	41 f4       	brne	.+16     	; 0x8ea8 <vfprintf+0x3d2>
    8e98:	ec 85       	ldd	r30, Y+12	; 0x0c
    8e9a:	e4 ff       	sbrs	r30, 4
    8e9c:	05 c0       	rjmp	.+10     	; 0x8ea8 <vfprintf+0x3d2>
    8e9e:	d1 94       	neg	r13
    8ea0:	c1 94       	neg	r12
    8ea2:	d1 08       	sbc	r13, r1
    8ea4:	8d e2       	ldi	r24, 0x2D	; 45
    8ea6:	01 c0       	rjmp	.+2      	; 0x8eaa <vfprintf+0x3d4>
    8ea8:	8b e2       	ldi	r24, 0x2B	; 43
    8eaa:	b7 01       	movw	r22, r14
    8eac:	90 e0       	ldi	r25, 0x00	; 0
    8eae:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    8eb2:	80 e3       	ldi	r24, 0x30	; 48
    8eb4:	2a e0       	ldi	r18, 0x0A	; 10
    8eb6:	c2 16       	cp	r12, r18
    8eb8:	d1 04       	cpc	r13, r1
    8eba:	2c f0       	brlt	.+10     	; 0x8ec6 <vfprintf+0x3f0>
    8ebc:	8f 5f       	subi	r24, 0xFF	; 255
    8ebe:	fa e0       	ldi	r31, 0x0A	; 10
    8ec0:	cf 1a       	sub	r12, r31
    8ec2:	d1 08       	sbc	r13, r1
    8ec4:	f7 cf       	rjmp	.-18     	; 0x8eb4 <vfprintf+0x3de>
    8ec6:	b7 01       	movw	r22, r14
    8ec8:	90 e0       	ldi	r25, 0x00	; 0
    8eca:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    8ece:	b7 01       	movw	r22, r14
    8ed0:	c6 01       	movw	r24, r12
    8ed2:	c0 96       	adiw	r24, 0x30	; 48
    8ed4:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    8ed8:	54 c1       	rjmp	.+680    	; 0x9182 <vfprintf+0x6ac>
    8eda:	83 36       	cpi	r24, 0x63	; 99
    8edc:	31 f0       	breq	.+12     	; 0x8eea <vfprintf+0x414>
    8ede:	83 37       	cpi	r24, 0x73	; 115
    8ee0:	79 f0       	breq	.+30     	; 0x8f00 <vfprintf+0x42a>
    8ee2:	83 35       	cpi	r24, 0x53	; 83
    8ee4:	09 f0       	breq	.+2      	; 0x8ee8 <vfprintf+0x412>
    8ee6:	56 c0       	rjmp	.+172    	; 0x8f94 <vfprintf+0x4be>
    8ee8:	20 c0       	rjmp	.+64     	; 0x8f2a <vfprintf+0x454>
    8eea:	56 01       	movw	r10, r12
    8eec:	32 e0       	ldi	r19, 0x02	; 2
    8eee:	a3 0e       	add	r10, r19
    8ef0:	b1 1c       	adc	r11, r1
    8ef2:	f6 01       	movw	r30, r12
    8ef4:	80 81       	ld	r24, Z
    8ef6:	89 83       	std	Y+1, r24	; 0x01
    8ef8:	01 e0       	ldi	r16, 0x01	; 1
    8efa:	10 e0       	ldi	r17, 0x00	; 0
    8efc:	63 01       	movw	r12, r6
    8efe:	12 c0       	rjmp	.+36     	; 0x8f24 <vfprintf+0x44e>
    8f00:	56 01       	movw	r10, r12
    8f02:	f2 e0       	ldi	r31, 0x02	; 2
    8f04:	af 0e       	add	r10, r31
    8f06:	b1 1c       	adc	r11, r1
    8f08:	f6 01       	movw	r30, r12
    8f0a:	c0 80       	ld	r12, Z
    8f0c:	d1 80       	ldd	r13, Z+1	; 0x01
    8f0e:	96 fe       	sbrs	r9, 6
    8f10:	03 c0       	rjmp	.+6      	; 0x8f18 <vfprintf+0x442>
    8f12:	61 2f       	mov	r22, r17
    8f14:	70 e0       	ldi	r23, 0x00	; 0
    8f16:	02 c0       	rjmp	.+4      	; 0x8f1c <vfprintf+0x446>
    8f18:	6f ef       	ldi	r22, 0xFF	; 255
    8f1a:	7f ef       	ldi	r23, 0xFF	; 255
    8f1c:	c6 01       	movw	r24, r12
    8f1e:	0e 94 a8 4d 	call	0x9b50	; 0x9b50 <strnlen>
    8f22:	8c 01       	movw	r16, r24
    8f24:	f9 2d       	mov	r31, r9
    8f26:	ff 77       	andi	r31, 0x7F	; 127
    8f28:	14 c0       	rjmp	.+40     	; 0x8f52 <vfprintf+0x47c>
    8f2a:	56 01       	movw	r10, r12
    8f2c:	22 e0       	ldi	r18, 0x02	; 2
    8f2e:	a2 0e       	add	r10, r18
    8f30:	b1 1c       	adc	r11, r1
    8f32:	f6 01       	movw	r30, r12
    8f34:	c0 80       	ld	r12, Z
    8f36:	d1 80       	ldd	r13, Z+1	; 0x01
    8f38:	96 fe       	sbrs	r9, 6
    8f3a:	03 c0       	rjmp	.+6      	; 0x8f42 <vfprintf+0x46c>
    8f3c:	61 2f       	mov	r22, r17
    8f3e:	70 e0       	ldi	r23, 0x00	; 0
    8f40:	02 c0       	rjmp	.+4      	; 0x8f46 <vfprintf+0x470>
    8f42:	6f ef       	ldi	r22, 0xFF	; 255
    8f44:	7f ef       	ldi	r23, 0xFF	; 255
    8f46:	c6 01       	movw	r24, r12
    8f48:	0e 94 82 4d 	call	0x9b04	; 0x9b04 <strnlen_P>
    8f4c:	8c 01       	movw	r16, r24
    8f4e:	f9 2d       	mov	r31, r9
    8f50:	f0 68       	ori	r31, 0x80	; 128
    8f52:	9f 2e       	mov	r9, r31
    8f54:	f3 fd       	sbrc	r31, 3
    8f56:	1a c0       	rjmp	.+52     	; 0x8f8c <vfprintf+0x4b6>
    8f58:	85 2d       	mov	r24, r5
    8f5a:	90 e0       	ldi	r25, 0x00	; 0
    8f5c:	08 17       	cp	r16, r24
    8f5e:	19 07       	cpc	r17, r25
    8f60:	a8 f4       	brcc	.+42     	; 0x8f8c <vfprintf+0x4b6>
    8f62:	b7 01       	movw	r22, r14
    8f64:	80 e2       	ldi	r24, 0x20	; 32
    8f66:	90 e0       	ldi	r25, 0x00	; 0
    8f68:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    8f6c:	5a 94       	dec	r5
    8f6e:	f4 cf       	rjmp	.-24     	; 0x8f58 <vfprintf+0x482>
    8f70:	f6 01       	movw	r30, r12
    8f72:	97 fc       	sbrc	r9, 7
    8f74:	85 91       	lpm	r24, Z+
    8f76:	97 fe       	sbrs	r9, 7
    8f78:	81 91       	ld	r24, Z+
    8f7a:	6f 01       	movw	r12, r30
    8f7c:	b7 01       	movw	r22, r14
    8f7e:	90 e0       	ldi	r25, 0x00	; 0
    8f80:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    8f84:	51 10       	cpse	r5, r1
    8f86:	5a 94       	dec	r5
    8f88:	01 50       	subi	r16, 0x01	; 1
    8f8a:	11 09       	sbc	r17, r1
    8f8c:	01 15       	cp	r16, r1
    8f8e:	11 05       	cpc	r17, r1
    8f90:	79 f7       	brne	.-34     	; 0x8f70 <vfprintf+0x49a>
    8f92:	f7 c0       	rjmp	.+494    	; 0x9182 <vfprintf+0x6ac>
    8f94:	84 36       	cpi	r24, 0x64	; 100
    8f96:	11 f0       	breq	.+4      	; 0x8f9c <vfprintf+0x4c6>
    8f98:	89 36       	cpi	r24, 0x69	; 105
    8f9a:	61 f5       	brne	.+88     	; 0x8ff4 <vfprintf+0x51e>
    8f9c:	56 01       	movw	r10, r12
    8f9e:	97 fe       	sbrs	r9, 7
    8fa0:	09 c0       	rjmp	.+18     	; 0x8fb4 <vfprintf+0x4de>
    8fa2:	24 e0       	ldi	r18, 0x04	; 4
    8fa4:	a2 0e       	add	r10, r18
    8fa6:	b1 1c       	adc	r11, r1
    8fa8:	f6 01       	movw	r30, r12
    8faa:	60 81       	ld	r22, Z
    8fac:	71 81       	ldd	r23, Z+1	; 0x01
    8fae:	82 81       	ldd	r24, Z+2	; 0x02
    8fb0:	93 81       	ldd	r25, Z+3	; 0x03
    8fb2:	0a c0       	rjmp	.+20     	; 0x8fc8 <vfprintf+0x4f2>
    8fb4:	f2 e0       	ldi	r31, 0x02	; 2
    8fb6:	af 0e       	add	r10, r31
    8fb8:	b1 1c       	adc	r11, r1
    8fba:	f6 01       	movw	r30, r12
    8fbc:	60 81       	ld	r22, Z
    8fbe:	71 81       	ldd	r23, Z+1	; 0x01
    8fc0:	07 2e       	mov	r0, r23
    8fc2:	00 0c       	add	r0, r0
    8fc4:	88 0b       	sbc	r24, r24
    8fc6:	99 0b       	sbc	r25, r25
    8fc8:	f9 2d       	mov	r31, r9
    8fca:	ff 76       	andi	r31, 0x6F	; 111
    8fcc:	9f 2e       	mov	r9, r31
    8fce:	97 ff       	sbrs	r25, 7
    8fd0:	09 c0       	rjmp	.+18     	; 0x8fe4 <vfprintf+0x50e>
    8fd2:	90 95       	com	r25
    8fd4:	80 95       	com	r24
    8fd6:	70 95       	com	r23
    8fd8:	61 95       	neg	r22
    8fda:	7f 4f       	sbci	r23, 0xFF	; 255
    8fdc:	8f 4f       	sbci	r24, 0xFF	; 255
    8fde:	9f 4f       	sbci	r25, 0xFF	; 255
    8fe0:	f0 68       	ori	r31, 0x80	; 128
    8fe2:	9f 2e       	mov	r9, r31
    8fe4:	2a e0       	ldi	r18, 0x0A	; 10
    8fe6:	30 e0       	ldi	r19, 0x00	; 0
    8fe8:	a3 01       	movw	r20, r6
    8fea:	0e 94 f7 4e 	call	0x9dee	; 0x9dee <__ultoa_invert>
    8fee:	c8 2e       	mov	r12, r24
    8ff0:	c6 18       	sub	r12, r6
    8ff2:	3f c0       	rjmp	.+126    	; 0x9072 <vfprintf+0x59c>
    8ff4:	09 2d       	mov	r16, r9
    8ff6:	85 37       	cpi	r24, 0x75	; 117
    8ff8:	21 f4       	brne	.+8      	; 0x9002 <vfprintf+0x52c>
    8ffa:	0f 7e       	andi	r16, 0xEF	; 239
    8ffc:	2a e0       	ldi	r18, 0x0A	; 10
    8ffe:	30 e0       	ldi	r19, 0x00	; 0
    9000:	1d c0       	rjmp	.+58     	; 0x903c <vfprintf+0x566>
    9002:	09 7f       	andi	r16, 0xF9	; 249
    9004:	8f 36       	cpi	r24, 0x6F	; 111
    9006:	91 f0       	breq	.+36     	; 0x902c <vfprintf+0x556>
    9008:	18 f4       	brcc	.+6      	; 0x9010 <vfprintf+0x53a>
    900a:	88 35       	cpi	r24, 0x58	; 88
    900c:	59 f0       	breq	.+22     	; 0x9024 <vfprintf+0x54e>
    900e:	c3 c0       	rjmp	.+390    	; 0x9196 <vfprintf+0x6c0>
    9010:	80 37       	cpi	r24, 0x70	; 112
    9012:	19 f0       	breq	.+6      	; 0x901a <vfprintf+0x544>
    9014:	88 37       	cpi	r24, 0x78	; 120
    9016:	11 f0       	breq	.+4      	; 0x901c <vfprintf+0x546>
    9018:	be c0       	rjmp	.+380    	; 0x9196 <vfprintf+0x6c0>
    901a:	00 61       	ori	r16, 0x10	; 16
    901c:	04 ff       	sbrs	r16, 4
    901e:	09 c0       	rjmp	.+18     	; 0x9032 <vfprintf+0x55c>
    9020:	04 60       	ori	r16, 0x04	; 4
    9022:	07 c0       	rjmp	.+14     	; 0x9032 <vfprintf+0x55c>
    9024:	94 fe       	sbrs	r9, 4
    9026:	08 c0       	rjmp	.+16     	; 0x9038 <vfprintf+0x562>
    9028:	06 60       	ori	r16, 0x06	; 6
    902a:	06 c0       	rjmp	.+12     	; 0x9038 <vfprintf+0x562>
    902c:	28 e0       	ldi	r18, 0x08	; 8
    902e:	30 e0       	ldi	r19, 0x00	; 0
    9030:	05 c0       	rjmp	.+10     	; 0x903c <vfprintf+0x566>
    9032:	20 e1       	ldi	r18, 0x10	; 16
    9034:	30 e0       	ldi	r19, 0x00	; 0
    9036:	02 c0       	rjmp	.+4      	; 0x903c <vfprintf+0x566>
    9038:	20 e1       	ldi	r18, 0x10	; 16
    903a:	32 e0       	ldi	r19, 0x02	; 2
    903c:	56 01       	movw	r10, r12
    903e:	07 ff       	sbrs	r16, 7
    9040:	09 c0       	rjmp	.+18     	; 0x9054 <vfprintf+0x57e>
    9042:	84 e0       	ldi	r24, 0x04	; 4
    9044:	a8 0e       	add	r10, r24
    9046:	b1 1c       	adc	r11, r1
    9048:	f6 01       	movw	r30, r12
    904a:	60 81       	ld	r22, Z
    904c:	71 81       	ldd	r23, Z+1	; 0x01
    904e:	82 81       	ldd	r24, Z+2	; 0x02
    9050:	93 81       	ldd	r25, Z+3	; 0x03
    9052:	08 c0       	rjmp	.+16     	; 0x9064 <vfprintf+0x58e>
    9054:	f2 e0       	ldi	r31, 0x02	; 2
    9056:	af 0e       	add	r10, r31
    9058:	b1 1c       	adc	r11, r1
    905a:	f6 01       	movw	r30, r12
    905c:	60 81       	ld	r22, Z
    905e:	71 81       	ldd	r23, Z+1	; 0x01
    9060:	80 e0       	ldi	r24, 0x00	; 0
    9062:	90 e0       	ldi	r25, 0x00	; 0
    9064:	a3 01       	movw	r20, r6
    9066:	0e 94 f7 4e 	call	0x9dee	; 0x9dee <__ultoa_invert>
    906a:	c8 2e       	mov	r12, r24
    906c:	c6 18       	sub	r12, r6
    906e:	0f 77       	andi	r16, 0x7F	; 127
    9070:	90 2e       	mov	r9, r16
    9072:	96 fe       	sbrs	r9, 6
    9074:	0b c0       	rjmp	.+22     	; 0x908c <vfprintf+0x5b6>
    9076:	09 2d       	mov	r16, r9
    9078:	0e 7f       	andi	r16, 0xFE	; 254
    907a:	c1 16       	cp	r12, r17
    907c:	50 f4       	brcc	.+20     	; 0x9092 <vfprintf+0x5bc>
    907e:	94 fe       	sbrs	r9, 4
    9080:	0a c0       	rjmp	.+20     	; 0x9096 <vfprintf+0x5c0>
    9082:	92 fc       	sbrc	r9, 2
    9084:	08 c0       	rjmp	.+16     	; 0x9096 <vfprintf+0x5c0>
    9086:	09 2d       	mov	r16, r9
    9088:	0e 7e       	andi	r16, 0xEE	; 238
    908a:	05 c0       	rjmp	.+10     	; 0x9096 <vfprintf+0x5c0>
    908c:	dc 2c       	mov	r13, r12
    908e:	09 2d       	mov	r16, r9
    9090:	03 c0       	rjmp	.+6      	; 0x9098 <vfprintf+0x5c2>
    9092:	dc 2c       	mov	r13, r12
    9094:	01 c0       	rjmp	.+2      	; 0x9098 <vfprintf+0x5c2>
    9096:	d1 2e       	mov	r13, r17
    9098:	04 ff       	sbrs	r16, 4
    909a:	0d c0       	rjmp	.+26     	; 0x90b6 <vfprintf+0x5e0>
    909c:	fe 01       	movw	r30, r28
    909e:	ec 0d       	add	r30, r12
    90a0:	f1 1d       	adc	r31, r1
    90a2:	80 81       	ld	r24, Z
    90a4:	80 33       	cpi	r24, 0x30	; 48
    90a6:	11 f4       	brne	.+4      	; 0x90ac <vfprintf+0x5d6>
    90a8:	09 7e       	andi	r16, 0xE9	; 233
    90aa:	09 c0       	rjmp	.+18     	; 0x90be <vfprintf+0x5e8>
    90ac:	02 ff       	sbrs	r16, 2
    90ae:	06 c0       	rjmp	.+12     	; 0x90bc <vfprintf+0x5e6>
    90b0:	d3 94       	inc	r13
    90b2:	d3 94       	inc	r13
    90b4:	04 c0       	rjmp	.+8      	; 0x90be <vfprintf+0x5e8>
    90b6:	80 2f       	mov	r24, r16
    90b8:	86 78       	andi	r24, 0x86	; 134
    90ba:	09 f0       	breq	.+2      	; 0x90be <vfprintf+0x5e8>
    90bc:	d3 94       	inc	r13
    90be:	03 fd       	sbrc	r16, 3
    90c0:	11 c0       	rjmp	.+34     	; 0x90e4 <vfprintf+0x60e>
    90c2:	00 ff       	sbrs	r16, 0
    90c4:	06 c0       	rjmp	.+12     	; 0x90d2 <vfprintf+0x5fc>
    90c6:	1c 2d       	mov	r17, r12
    90c8:	d5 14       	cp	r13, r5
    90ca:	80 f4       	brcc	.+32     	; 0x90ec <vfprintf+0x616>
    90cc:	15 0d       	add	r17, r5
    90ce:	1d 19       	sub	r17, r13
    90d0:	0d c0       	rjmp	.+26     	; 0x90ec <vfprintf+0x616>
    90d2:	d5 14       	cp	r13, r5
    90d4:	58 f4       	brcc	.+22     	; 0x90ec <vfprintf+0x616>
    90d6:	b7 01       	movw	r22, r14
    90d8:	80 e2       	ldi	r24, 0x20	; 32
    90da:	90 e0       	ldi	r25, 0x00	; 0
    90dc:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    90e0:	d3 94       	inc	r13
    90e2:	f7 cf       	rjmp	.-18     	; 0x90d2 <vfprintf+0x5fc>
    90e4:	d5 14       	cp	r13, r5
    90e6:	10 f4       	brcc	.+4      	; 0x90ec <vfprintf+0x616>
    90e8:	5d 18       	sub	r5, r13
    90ea:	01 c0       	rjmp	.+2      	; 0x90ee <vfprintf+0x618>
    90ec:	51 2c       	mov	r5, r1
    90ee:	04 ff       	sbrs	r16, 4
    90f0:	10 c0       	rjmp	.+32     	; 0x9112 <vfprintf+0x63c>
    90f2:	b7 01       	movw	r22, r14
    90f4:	80 e3       	ldi	r24, 0x30	; 48
    90f6:	90 e0       	ldi	r25, 0x00	; 0
    90f8:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    90fc:	02 ff       	sbrs	r16, 2
    90fe:	17 c0       	rjmp	.+46     	; 0x912e <vfprintf+0x658>
    9100:	01 fd       	sbrc	r16, 1
    9102:	03 c0       	rjmp	.+6      	; 0x910a <vfprintf+0x634>
    9104:	88 e7       	ldi	r24, 0x78	; 120
    9106:	90 e0       	ldi	r25, 0x00	; 0
    9108:	02 c0       	rjmp	.+4      	; 0x910e <vfprintf+0x638>
    910a:	88 e5       	ldi	r24, 0x58	; 88
    910c:	90 e0       	ldi	r25, 0x00	; 0
    910e:	b7 01       	movw	r22, r14
    9110:	0c c0       	rjmp	.+24     	; 0x912a <vfprintf+0x654>
    9112:	80 2f       	mov	r24, r16
    9114:	86 78       	andi	r24, 0x86	; 134
    9116:	59 f0       	breq	.+22     	; 0x912e <vfprintf+0x658>
    9118:	01 ff       	sbrs	r16, 1
    911a:	02 c0       	rjmp	.+4      	; 0x9120 <vfprintf+0x64a>
    911c:	8b e2       	ldi	r24, 0x2B	; 43
    911e:	01 c0       	rjmp	.+2      	; 0x9122 <vfprintf+0x64c>
    9120:	80 e2       	ldi	r24, 0x20	; 32
    9122:	07 fd       	sbrc	r16, 7
    9124:	8d e2       	ldi	r24, 0x2D	; 45
    9126:	b7 01       	movw	r22, r14
    9128:	90 e0       	ldi	r25, 0x00	; 0
    912a:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    912e:	c1 16       	cp	r12, r17
    9130:	38 f4       	brcc	.+14     	; 0x9140 <vfprintf+0x66a>
    9132:	b7 01       	movw	r22, r14
    9134:	80 e3       	ldi	r24, 0x30	; 48
    9136:	90 e0       	ldi	r25, 0x00	; 0
    9138:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    913c:	11 50       	subi	r17, 0x01	; 1
    913e:	f7 cf       	rjmp	.-18     	; 0x912e <vfprintf+0x658>
    9140:	ca 94       	dec	r12
    9142:	f3 01       	movw	r30, r6
    9144:	ec 0d       	add	r30, r12
    9146:	f1 1d       	adc	r31, r1
    9148:	80 81       	ld	r24, Z
    914a:	b7 01       	movw	r22, r14
    914c:	90 e0       	ldi	r25, 0x00	; 0
    914e:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    9152:	c1 10       	cpse	r12, r1
    9154:	f5 cf       	rjmp	.-22     	; 0x9140 <vfprintf+0x66a>
    9156:	15 c0       	rjmp	.+42     	; 0x9182 <vfprintf+0x6ac>
    9158:	f4 e0       	ldi	r31, 0x04	; 4
    915a:	f5 15       	cp	r31, r5
    915c:	60 f5       	brcc	.+88     	; 0x91b6 <vfprintf+0x6e0>
    915e:	84 e0       	ldi	r24, 0x04	; 4
    9160:	58 1a       	sub	r5, r24
    9162:	93 fe       	sbrs	r9, 3
    9164:	1f c0       	rjmp	.+62     	; 0x91a4 <vfprintf+0x6ce>
    9166:	01 11       	cpse	r16, r1
    9168:	27 c0       	rjmp	.+78     	; 0x91b8 <vfprintf+0x6e2>
    916a:	2c 85       	ldd	r18, Y+12	; 0x0c
    916c:	23 ff       	sbrs	r18, 3
    916e:	2a c0       	rjmp	.+84     	; 0x91c4 <vfprintf+0x6ee>
    9170:	08 e3       	ldi	r16, 0x38	; 56
    9172:	12 e0       	ldi	r17, 0x02	; 2
    9174:	39 2d       	mov	r19, r9
    9176:	30 71       	andi	r19, 0x10	; 16
    9178:	93 2e       	mov	r9, r19
    917a:	f8 01       	movw	r30, r16
    917c:	84 91       	lpm	r24, Z
    917e:	81 11       	cpse	r24, r1
    9180:	24 c0       	rjmp	.+72     	; 0x91ca <vfprintf+0x6f4>
    9182:	55 20       	and	r5, r5
    9184:	09 f4       	brne	.+2      	; 0x9188 <vfprintf+0x6b2>
    9186:	e4 cc       	rjmp	.-1592   	; 0x8b50 <vfprintf+0x7a>
    9188:	b7 01       	movw	r22, r14
    918a:	80 e2       	ldi	r24, 0x20	; 32
    918c:	90 e0       	ldi	r25, 0x00	; 0
    918e:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    9192:	5a 94       	dec	r5
    9194:	f6 cf       	rjmp	.-20     	; 0x9182 <vfprintf+0x6ac>
    9196:	f7 01       	movw	r30, r14
    9198:	86 81       	ldd	r24, Z+6	; 0x06
    919a:	97 81       	ldd	r25, Z+7	; 0x07
    919c:	26 c0       	rjmp	.+76     	; 0x91ea <vfprintf+0x714>
    919e:	8f ef       	ldi	r24, 0xFF	; 255
    91a0:	9f ef       	ldi	r25, 0xFF	; 255
    91a2:	23 c0       	rjmp	.+70     	; 0x91ea <vfprintf+0x714>
    91a4:	b7 01       	movw	r22, r14
    91a6:	80 e2       	ldi	r24, 0x20	; 32
    91a8:	90 e0       	ldi	r25, 0x00	; 0
    91aa:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    91ae:	5a 94       	dec	r5
    91b0:	51 10       	cpse	r5, r1
    91b2:	f8 cf       	rjmp	.-16     	; 0x91a4 <vfprintf+0x6ce>
    91b4:	d8 cf       	rjmp	.-80     	; 0x9166 <vfprintf+0x690>
    91b6:	51 2c       	mov	r5, r1
    91b8:	b7 01       	movw	r22, r14
    91ba:	80 2f       	mov	r24, r16
    91bc:	90 e0       	ldi	r25, 0x00	; 0
    91be:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    91c2:	d3 cf       	rjmp	.-90     	; 0x916a <vfprintf+0x694>
    91c4:	0c e3       	ldi	r16, 0x3C	; 60
    91c6:	12 e0       	ldi	r17, 0x02	; 2
    91c8:	d5 cf       	rjmp	.-86     	; 0x9174 <vfprintf+0x69e>
    91ca:	91 10       	cpse	r9, r1
    91cc:	80 52       	subi	r24, 0x20	; 32
    91ce:	b7 01       	movw	r22, r14
    91d0:	90 e0       	ldi	r25, 0x00	; 0
    91d2:	0e 94 26 4e 	call	0x9c4c	; 0x9c4c <fputc>
    91d6:	0f 5f       	subi	r16, 0xFF	; 255
    91d8:	1f 4f       	sbci	r17, 0xFF	; 255
    91da:	cf cf       	rjmp	.-98     	; 0x917a <vfprintf+0x6a4>
    91dc:	23 e0       	ldi	r18, 0x03	; 3
    91de:	25 15       	cp	r18, r5
    91e0:	10 f4       	brcc	.+4      	; 0x91e6 <vfprintf+0x710>
    91e2:	83 e0       	ldi	r24, 0x03	; 3
    91e4:	bd cf       	rjmp	.-134    	; 0x9160 <vfprintf+0x68a>
    91e6:	51 2c       	mov	r5, r1
    91e8:	c0 cf       	rjmp	.-128    	; 0x916a <vfprintf+0x694>
    91ea:	60 96       	adiw	r28, 0x10	; 16
    91ec:	cd bf       	out	0x3d, r28	; 61
    91ee:	de bf       	out	0x3e, r29	; 62
    91f0:	df 91       	pop	r29
    91f2:	cf 91       	pop	r28
    91f4:	1f 91       	pop	r17
    91f6:	0f 91       	pop	r16
    91f8:	ff 90       	pop	r15
    91fa:	ef 90       	pop	r14
    91fc:	df 90       	pop	r13
    91fe:	cf 90       	pop	r12
    9200:	bf 90       	pop	r11
    9202:	af 90       	pop	r10
    9204:	9f 90       	pop	r9
    9206:	8f 90       	pop	r8
    9208:	7f 90       	pop	r7
    920a:	6f 90       	pop	r6
    920c:	5f 90       	pop	r5
    920e:	4f 90       	pop	r4
    9210:	3f 90       	pop	r3
    9212:	2f 90       	pop	r2
    9214:	08 95       	ret

00009216 <__udivmodhi4>:
    9216:	aa 1b       	sub	r26, r26
    9218:	bb 1b       	sub	r27, r27
    921a:	51 e1       	ldi	r21, 0x11	; 17
    921c:	07 c0       	rjmp	.+14     	; 0x922c <__udivmodhi4_ep>

0000921e <__udivmodhi4_loop>:
    921e:	aa 1f       	adc	r26, r26
    9220:	bb 1f       	adc	r27, r27
    9222:	a6 17       	cp	r26, r22
    9224:	b7 07       	cpc	r27, r23
    9226:	10 f0       	brcs	.+4      	; 0x922c <__udivmodhi4_ep>
    9228:	a6 1b       	sub	r26, r22
    922a:	b7 0b       	sbc	r27, r23

0000922c <__udivmodhi4_ep>:
    922c:	88 1f       	adc	r24, r24
    922e:	99 1f       	adc	r25, r25
    9230:	5a 95       	dec	r21
    9232:	a9 f7       	brne	.-22     	; 0x921e <__udivmodhi4_loop>
    9234:	80 95       	com	r24
    9236:	90 95       	com	r25
    9238:	bc 01       	movw	r22, r24
    923a:	cd 01       	movw	r24, r26
    923c:	08 95       	ret

0000923e <__divmodhi4>:
    923e:	97 fb       	bst	r25, 7
    9240:	07 2e       	mov	r0, r23
    9242:	16 f4       	brtc	.+4      	; 0x9248 <__divmodhi4+0xa>
    9244:	00 94       	com	r0
    9246:	07 d0       	rcall	.+14     	; 0x9256 <__divmodhi4_neg1>
    9248:	77 fd       	sbrc	r23, 7
    924a:	09 d0       	rcall	.+18     	; 0x925e <__divmodhi4_neg2>
    924c:	0e 94 0b 49 	call	0x9216	; 0x9216 <__udivmodhi4>
    9250:	07 fc       	sbrc	r0, 7
    9252:	05 d0       	rcall	.+10     	; 0x925e <__divmodhi4_neg2>
    9254:	3e f4       	brtc	.+14     	; 0x9264 <__divmodhi4_exit>

00009256 <__divmodhi4_neg1>:
    9256:	90 95       	com	r25
    9258:	81 95       	neg	r24
    925a:	9f 4f       	sbci	r25, 0xFF	; 255
    925c:	08 95       	ret

0000925e <__divmodhi4_neg2>:
    925e:	70 95       	com	r23
    9260:	61 95       	neg	r22
    9262:	7f 4f       	sbci	r23, 0xFF	; 255

00009264 <__divmodhi4_exit>:
    9264:	08 95       	ret

00009266 <__udivmodsi4>:
    9266:	a1 e2       	ldi	r26, 0x21	; 33
    9268:	1a 2e       	mov	r1, r26
    926a:	aa 1b       	sub	r26, r26
    926c:	bb 1b       	sub	r27, r27
    926e:	fd 01       	movw	r30, r26
    9270:	0d c0       	rjmp	.+26     	; 0x928c <__udivmodsi4_ep>

00009272 <__udivmodsi4_loop>:
    9272:	aa 1f       	adc	r26, r26
    9274:	bb 1f       	adc	r27, r27
    9276:	ee 1f       	adc	r30, r30
    9278:	ff 1f       	adc	r31, r31
    927a:	a2 17       	cp	r26, r18
    927c:	b3 07       	cpc	r27, r19
    927e:	e4 07       	cpc	r30, r20
    9280:	f5 07       	cpc	r31, r21
    9282:	20 f0       	brcs	.+8      	; 0x928c <__udivmodsi4_ep>
    9284:	a2 1b       	sub	r26, r18
    9286:	b3 0b       	sbc	r27, r19
    9288:	e4 0b       	sbc	r30, r20
    928a:	f5 0b       	sbc	r31, r21

0000928c <__udivmodsi4_ep>:
    928c:	66 1f       	adc	r22, r22
    928e:	77 1f       	adc	r23, r23
    9290:	88 1f       	adc	r24, r24
    9292:	99 1f       	adc	r25, r25
    9294:	1a 94       	dec	r1
    9296:	69 f7       	brne	.-38     	; 0x9272 <__udivmodsi4_loop>
    9298:	60 95       	com	r22
    929a:	70 95       	com	r23
    929c:	80 95       	com	r24
    929e:	90 95       	com	r25
    92a0:	9b 01       	movw	r18, r22
    92a2:	ac 01       	movw	r20, r24
    92a4:	bd 01       	movw	r22, r26
    92a6:	cf 01       	movw	r24, r30
    92a8:	08 95       	ret

000092aa <__umulhisi3>:
    92aa:	a2 9f       	mul	r26, r18
    92ac:	b0 01       	movw	r22, r0
    92ae:	b3 9f       	mul	r27, r19
    92b0:	c0 01       	movw	r24, r0
    92b2:	a3 9f       	mul	r26, r19
    92b4:	70 0d       	add	r23, r0
    92b6:	81 1d       	adc	r24, r1
    92b8:	11 24       	eor	r1, r1
    92ba:	91 1d       	adc	r25, r1
    92bc:	b2 9f       	mul	r27, r18
    92be:	70 0d       	add	r23, r0
    92c0:	81 1d       	adc	r24, r1
    92c2:	11 24       	eor	r1, r1
    92c4:	91 1d       	adc	r25, r1
    92c6:	08 95       	ret

000092c8 <__muluhisi3>:
    92c8:	0e 94 55 49 	call	0x92aa	; 0x92aa <__umulhisi3>
    92cc:	a5 9f       	mul	r26, r21
    92ce:	90 0d       	add	r25, r0
    92d0:	b4 9f       	mul	r27, r20
    92d2:	90 0d       	add	r25, r0
    92d4:	a4 9f       	mul	r26, r20
    92d6:	80 0d       	add	r24, r0
    92d8:	91 1d       	adc	r25, r1
    92da:	11 24       	eor	r1, r1
    92dc:	08 95       	ret

000092de <__mulshisi3>:
    92de:	b7 ff       	sbrs	r27, 7
    92e0:	0c 94 64 49 	jmp	0x92c8	; 0x92c8 <__muluhisi3>

000092e4 <__mulohisi3>:
    92e4:	0e 94 64 49 	call	0x92c8	; 0x92c8 <__muluhisi3>
    92e8:	82 1b       	sub	r24, r18
    92ea:	93 0b       	sbc	r25, r19
    92ec:	08 95       	ret

000092ee <malloc>:
    92ee:	0f 93       	push	r16
    92f0:	1f 93       	push	r17
    92f2:	cf 93       	push	r28
    92f4:	df 93       	push	r29
    92f6:	82 30       	cpi	r24, 0x02	; 2
    92f8:	91 05       	cpc	r25, r1
    92fa:	10 f4       	brcc	.+4      	; 0x9300 <malloc+0x12>
    92fc:	82 e0       	ldi	r24, 0x02	; 2
    92fe:	90 e0       	ldi	r25, 0x00	; 0
    9300:	e0 91 db 2d 	lds	r30, 0x2DDB	; 0x802ddb <__flp>
    9304:	f0 91 dc 2d 	lds	r31, 0x2DDC	; 0x802ddc <__flp+0x1>
    9308:	20 e0       	ldi	r18, 0x00	; 0
    930a:	30 e0       	ldi	r19, 0x00	; 0
    930c:	a0 e0       	ldi	r26, 0x00	; 0
    930e:	b0 e0       	ldi	r27, 0x00	; 0
    9310:	30 97       	sbiw	r30, 0x00	; 0
    9312:	19 f1       	breq	.+70     	; 0x935a <malloc+0x6c>
    9314:	40 81       	ld	r20, Z
    9316:	51 81       	ldd	r21, Z+1	; 0x01
    9318:	02 81       	ldd	r16, Z+2	; 0x02
    931a:	13 81       	ldd	r17, Z+3	; 0x03
    931c:	48 17       	cp	r20, r24
    931e:	59 07       	cpc	r21, r25
    9320:	c8 f0       	brcs	.+50     	; 0x9354 <malloc+0x66>
    9322:	84 17       	cp	r24, r20
    9324:	95 07       	cpc	r25, r21
    9326:	69 f4       	brne	.+26     	; 0x9342 <malloc+0x54>
    9328:	10 97       	sbiw	r26, 0x00	; 0
    932a:	31 f0       	breq	.+12     	; 0x9338 <malloc+0x4a>
    932c:	12 96       	adiw	r26, 0x02	; 2
    932e:	0c 93       	st	X, r16
    9330:	12 97       	sbiw	r26, 0x02	; 2
    9332:	13 96       	adiw	r26, 0x03	; 3
    9334:	1c 93       	st	X, r17
    9336:	27 c0       	rjmp	.+78     	; 0x9386 <malloc+0x98>
    9338:	00 93 db 2d 	sts	0x2DDB, r16	; 0x802ddb <__flp>
    933c:	10 93 dc 2d 	sts	0x2DDC, r17	; 0x802ddc <__flp+0x1>
    9340:	22 c0       	rjmp	.+68     	; 0x9386 <malloc+0x98>
    9342:	21 15       	cp	r18, r1
    9344:	31 05       	cpc	r19, r1
    9346:	19 f0       	breq	.+6      	; 0x934e <malloc+0x60>
    9348:	42 17       	cp	r20, r18
    934a:	53 07       	cpc	r21, r19
    934c:	18 f4       	brcc	.+6      	; 0x9354 <malloc+0x66>
    934e:	9a 01       	movw	r18, r20
    9350:	bd 01       	movw	r22, r26
    9352:	ef 01       	movw	r28, r30
    9354:	df 01       	movw	r26, r30
    9356:	f8 01       	movw	r30, r16
    9358:	db cf       	rjmp	.-74     	; 0x9310 <malloc+0x22>
    935a:	21 15       	cp	r18, r1
    935c:	31 05       	cpc	r19, r1
    935e:	f9 f0       	breq	.+62     	; 0x939e <malloc+0xb0>
    9360:	28 1b       	sub	r18, r24
    9362:	39 0b       	sbc	r19, r25
    9364:	24 30       	cpi	r18, 0x04	; 4
    9366:	31 05       	cpc	r19, r1
    9368:	80 f4       	brcc	.+32     	; 0x938a <malloc+0x9c>
    936a:	8a 81       	ldd	r24, Y+2	; 0x02
    936c:	9b 81       	ldd	r25, Y+3	; 0x03
    936e:	61 15       	cp	r22, r1
    9370:	71 05       	cpc	r23, r1
    9372:	21 f0       	breq	.+8      	; 0x937c <malloc+0x8e>
    9374:	fb 01       	movw	r30, r22
    9376:	82 83       	std	Z+2, r24	; 0x02
    9378:	93 83       	std	Z+3, r25	; 0x03
    937a:	04 c0       	rjmp	.+8      	; 0x9384 <malloc+0x96>
    937c:	80 93 db 2d 	sts	0x2DDB, r24	; 0x802ddb <__flp>
    9380:	90 93 dc 2d 	sts	0x2DDC, r25	; 0x802ddc <__flp+0x1>
    9384:	fe 01       	movw	r30, r28
    9386:	32 96       	adiw	r30, 0x02	; 2
    9388:	44 c0       	rjmp	.+136    	; 0x9412 <malloc+0x124>
    938a:	fe 01       	movw	r30, r28
    938c:	e2 0f       	add	r30, r18
    938e:	f3 1f       	adc	r31, r19
    9390:	81 93       	st	Z+, r24
    9392:	91 93       	st	Z+, r25
    9394:	22 50       	subi	r18, 0x02	; 2
    9396:	31 09       	sbc	r19, r1
    9398:	28 83       	st	Y, r18
    939a:	39 83       	std	Y+1, r19	; 0x01
    939c:	3a c0       	rjmp	.+116    	; 0x9412 <malloc+0x124>
    939e:	20 91 d9 2d 	lds	r18, 0x2DD9	; 0x802dd9 <__brkval>
    93a2:	30 91 da 2d 	lds	r19, 0x2DDA	; 0x802dda <__brkval+0x1>
    93a6:	23 2b       	or	r18, r19
    93a8:	41 f4       	brne	.+16     	; 0x93ba <malloc+0xcc>
    93aa:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    93ae:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    93b2:	20 93 d9 2d 	sts	0x2DD9, r18	; 0x802dd9 <__brkval>
    93b6:	30 93 da 2d 	sts	0x2DDA, r19	; 0x802dda <__brkval+0x1>
    93ba:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
    93be:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
    93c2:	21 15       	cp	r18, r1
    93c4:	31 05       	cpc	r19, r1
    93c6:	41 f4       	brne	.+16     	; 0x93d8 <malloc+0xea>
    93c8:	2d b7       	in	r18, 0x3d	; 61
    93ca:	3e b7       	in	r19, 0x3e	; 62
    93cc:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    93d0:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    93d4:	24 1b       	sub	r18, r20
    93d6:	35 0b       	sbc	r19, r21
    93d8:	e0 91 d9 2d 	lds	r30, 0x2DD9	; 0x802dd9 <__brkval>
    93dc:	f0 91 da 2d 	lds	r31, 0x2DDA	; 0x802dda <__brkval+0x1>
    93e0:	e2 17       	cp	r30, r18
    93e2:	f3 07       	cpc	r31, r19
    93e4:	a0 f4       	brcc	.+40     	; 0x940e <malloc+0x120>
    93e6:	2e 1b       	sub	r18, r30
    93e8:	3f 0b       	sbc	r19, r31
    93ea:	28 17       	cp	r18, r24
    93ec:	39 07       	cpc	r19, r25
    93ee:	78 f0       	brcs	.+30     	; 0x940e <malloc+0x120>
    93f0:	ac 01       	movw	r20, r24
    93f2:	4e 5f       	subi	r20, 0xFE	; 254
    93f4:	5f 4f       	sbci	r21, 0xFF	; 255
    93f6:	24 17       	cp	r18, r20
    93f8:	35 07       	cpc	r19, r21
    93fa:	48 f0       	brcs	.+18     	; 0x940e <malloc+0x120>
    93fc:	4e 0f       	add	r20, r30
    93fe:	5f 1f       	adc	r21, r31
    9400:	40 93 d9 2d 	sts	0x2DD9, r20	; 0x802dd9 <__brkval>
    9404:	50 93 da 2d 	sts	0x2DDA, r21	; 0x802dda <__brkval+0x1>
    9408:	81 93       	st	Z+, r24
    940a:	91 93       	st	Z+, r25
    940c:	02 c0       	rjmp	.+4      	; 0x9412 <malloc+0x124>
    940e:	e0 e0       	ldi	r30, 0x00	; 0
    9410:	f0 e0       	ldi	r31, 0x00	; 0
    9412:	cf 01       	movw	r24, r30
    9414:	df 91       	pop	r29
    9416:	cf 91       	pop	r28
    9418:	1f 91       	pop	r17
    941a:	0f 91       	pop	r16
    941c:	08 95       	ret

0000941e <free>:
    941e:	cf 93       	push	r28
    9420:	df 93       	push	r29
    9422:	00 97       	sbiw	r24, 0x00	; 0
    9424:	09 f4       	brne	.+2      	; 0x9428 <free+0xa>
    9426:	81 c0       	rjmp	.+258    	; 0x952a <free+0x10c>
    9428:	fc 01       	movw	r30, r24
    942a:	32 97       	sbiw	r30, 0x02	; 2
    942c:	12 82       	std	Z+2, r1	; 0x02
    942e:	13 82       	std	Z+3, r1	; 0x03
    9430:	a0 91 db 2d 	lds	r26, 0x2DDB	; 0x802ddb <__flp>
    9434:	b0 91 dc 2d 	lds	r27, 0x2DDC	; 0x802ddc <__flp+0x1>
    9438:	10 97       	sbiw	r26, 0x00	; 0
    943a:	81 f4       	brne	.+32     	; 0x945c <free+0x3e>
    943c:	20 81       	ld	r18, Z
    943e:	31 81       	ldd	r19, Z+1	; 0x01
    9440:	82 0f       	add	r24, r18
    9442:	93 1f       	adc	r25, r19
    9444:	20 91 d9 2d 	lds	r18, 0x2DD9	; 0x802dd9 <__brkval>
    9448:	30 91 da 2d 	lds	r19, 0x2DDA	; 0x802dda <__brkval+0x1>
    944c:	28 17       	cp	r18, r24
    944e:	39 07       	cpc	r19, r25
    9450:	51 f5       	brne	.+84     	; 0x94a6 <free+0x88>
    9452:	e0 93 d9 2d 	sts	0x2DD9, r30	; 0x802dd9 <__brkval>
    9456:	f0 93 da 2d 	sts	0x2DDA, r31	; 0x802dda <__brkval+0x1>
    945a:	67 c0       	rjmp	.+206    	; 0x952a <free+0x10c>
    945c:	ed 01       	movw	r28, r26
    945e:	20 e0       	ldi	r18, 0x00	; 0
    9460:	30 e0       	ldi	r19, 0x00	; 0
    9462:	ce 17       	cp	r28, r30
    9464:	df 07       	cpc	r29, r31
    9466:	40 f4       	brcc	.+16     	; 0x9478 <free+0x5a>
    9468:	4a 81       	ldd	r20, Y+2	; 0x02
    946a:	5b 81       	ldd	r21, Y+3	; 0x03
    946c:	9e 01       	movw	r18, r28
    946e:	41 15       	cp	r20, r1
    9470:	51 05       	cpc	r21, r1
    9472:	f1 f0       	breq	.+60     	; 0x94b0 <free+0x92>
    9474:	ea 01       	movw	r28, r20
    9476:	f5 cf       	rjmp	.-22     	; 0x9462 <free+0x44>
    9478:	c2 83       	std	Z+2, r28	; 0x02
    947a:	d3 83       	std	Z+3, r29	; 0x03
    947c:	40 81       	ld	r20, Z
    947e:	51 81       	ldd	r21, Z+1	; 0x01
    9480:	84 0f       	add	r24, r20
    9482:	95 1f       	adc	r25, r21
    9484:	c8 17       	cp	r28, r24
    9486:	d9 07       	cpc	r29, r25
    9488:	59 f4       	brne	.+22     	; 0x94a0 <free+0x82>
    948a:	88 81       	ld	r24, Y
    948c:	99 81       	ldd	r25, Y+1	; 0x01
    948e:	84 0f       	add	r24, r20
    9490:	95 1f       	adc	r25, r21
    9492:	02 96       	adiw	r24, 0x02	; 2
    9494:	80 83       	st	Z, r24
    9496:	91 83       	std	Z+1, r25	; 0x01
    9498:	8a 81       	ldd	r24, Y+2	; 0x02
    949a:	9b 81       	ldd	r25, Y+3	; 0x03
    949c:	82 83       	std	Z+2, r24	; 0x02
    949e:	93 83       	std	Z+3, r25	; 0x03
    94a0:	21 15       	cp	r18, r1
    94a2:	31 05       	cpc	r19, r1
    94a4:	29 f4       	brne	.+10     	; 0x94b0 <free+0x92>
    94a6:	e0 93 db 2d 	sts	0x2DDB, r30	; 0x802ddb <__flp>
    94aa:	f0 93 dc 2d 	sts	0x2DDC, r31	; 0x802ddc <__flp+0x1>
    94ae:	3d c0       	rjmp	.+122    	; 0x952a <free+0x10c>
    94b0:	e9 01       	movw	r28, r18
    94b2:	ea 83       	std	Y+2, r30	; 0x02
    94b4:	fb 83       	std	Y+3, r31	; 0x03
    94b6:	49 91       	ld	r20, Y+
    94b8:	59 91       	ld	r21, Y+
    94ba:	c4 0f       	add	r28, r20
    94bc:	d5 1f       	adc	r29, r21
    94be:	ec 17       	cp	r30, r28
    94c0:	fd 07       	cpc	r31, r29
    94c2:	61 f4       	brne	.+24     	; 0x94dc <free+0xbe>
    94c4:	80 81       	ld	r24, Z
    94c6:	91 81       	ldd	r25, Z+1	; 0x01
    94c8:	84 0f       	add	r24, r20
    94ca:	95 1f       	adc	r25, r21
    94cc:	02 96       	adiw	r24, 0x02	; 2
    94ce:	e9 01       	movw	r28, r18
    94d0:	88 83       	st	Y, r24
    94d2:	99 83       	std	Y+1, r25	; 0x01
    94d4:	82 81       	ldd	r24, Z+2	; 0x02
    94d6:	93 81       	ldd	r25, Z+3	; 0x03
    94d8:	8a 83       	std	Y+2, r24	; 0x02
    94da:	9b 83       	std	Y+3, r25	; 0x03
    94dc:	e0 e0       	ldi	r30, 0x00	; 0
    94de:	f0 e0       	ldi	r31, 0x00	; 0
    94e0:	12 96       	adiw	r26, 0x02	; 2
    94e2:	8d 91       	ld	r24, X+
    94e4:	9c 91       	ld	r25, X
    94e6:	13 97       	sbiw	r26, 0x03	; 3
    94e8:	00 97       	sbiw	r24, 0x00	; 0
    94ea:	19 f0       	breq	.+6      	; 0x94f2 <free+0xd4>
    94ec:	fd 01       	movw	r30, r26
    94ee:	dc 01       	movw	r26, r24
    94f0:	f7 cf       	rjmp	.-18     	; 0x94e0 <free+0xc2>
    94f2:	8d 91       	ld	r24, X+
    94f4:	9c 91       	ld	r25, X
    94f6:	11 97       	sbiw	r26, 0x01	; 1
    94f8:	9d 01       	movw	r18, r26
    94fa:	2e 5f       	subi	r18, 0xFE	; 254
    94fc:	3f 4f       	sbci	r19, 0xFF	; 255
    94fe:	82 0f       	add	r24, r18
    9500:	93 1f       	adc	r25, r19
    9502:	20 91 d9 2d 	lds	r18, 0x2DD9	; 0x802dd9 <__brkval>
    9506:	30 91 da 2d 	lds	r19, 0x2DDA	; 0x802dda <__brkval+0x1>
    950a:	28 17       	cp	r18, r24
    950c:	39 07       	cpc	r19, r25
    950e:	69 f4       	brne	.+26     	; 0x952a <free+0x10c>
    9510:	30 97       	sbiw	r30, 0x00	; 0
    9512:	29 f4       	brne	.+10     	; 0x951e <free+0x100>
    9514:	10 92 db 2d 	sts	0x2DDB, r1	; 0x802ddb <__flp>
    9518:	10 92 dc 2d 	sts	0x2DDC, r1	; 0x802ddc <__flp+0x1>
    951c:	02 c0       	rjmp	.+4      	; 0x9522 <free+0x104>
    951e:	12 82       	std	Z+2, r1	; 0x02
    9520:	13 82       	std	Z+3, r1	; 0x03
    9522:	a0 93 d9 2d 	sts	0x2DD9, r26	; 0x802dd9 <__brkval>
    9526:	b0 93 da 2d 	sts	0x2DDA, r27	; 0x802dda <__brkval+0x1>
    952a:	df 91       	pop	r29
    952c:	cf 91       	pop	r28
    952e:	08 95       	ret

00009530 <swapfunc>:
    9530:	dc 01       	movw	r26, r24
    9532:	fb 01       	movw	r30, r22
    9534:	8c 91       	ld	r24, X
    9536:	90 81       	ld	r25, Z
    9538:	9d 93       	st	X+, r25
    953a:	81 93       	st	Z+, r24
    953c:	41 50       	subi	r20, 0x01	; 1
    953e:	51 09       	sbc	r21, r1
    9540:	14 16       	cp	r1, r20
    9542:	15 06       	cpc	r1, r21
    9544:	bc f3       	brlt	.-18     	; 0x9534 <swapfunc+0x4>
    9546:	08 95       	ret

00009548 <med3>:
    9548:	cf 92       	push	r12
    954a:	df 92       	push	r13
    954c:	ef 92       	push	r14
    954e:	ff 92       	push	r15
    9550:	0f 93       	push	r16
    9552:	1f 93       	push	r17
    9554:	cf 93       	push	r28
    9556:	df 93       	push	r29
    9558:	7c 01       	movw	r14, r24
    955a:	6b 01       	movw	r12, r22
    955c:	d4 2f       	mov	r29, r20
    955e:	c5 2f       	mov	r28, r21
    9560:	89 01       	movw	r16, r18
    9562:	f9 01       	movw	r30, r18
    9564:	19 95       	eicall
    9566:	6d 2f       	mov	r22, r29
    9568:	7c 2f       	mov	r23, r28
    956a:	97 ff       	sbrs	r25, 7
    956c:	10 c0       	rjmp	.+32     	; 0x958e <med3+0x46>
    956e:	c6 01       	movw	r24, r12
    9570:	f8 01       	movw	r30, r16
    9572:	19 95       	eicall
    9574:	97 ff       	sbrs	r25, 7
    9576:	02 c0       	rjmp	.+4      	; 0x957c <med3+0x34>
    9578:	c6 01       	movw	r24, r12
    957a:	18 c0       	rjmp	.+48     	; 0x95ac <med3+0x64>
    957c:	6d 2f       	mov	r22, r29
    957e:	7c 2f       	mov	r23, r28
    9580:	c7 01       	movw	r24, r14
    9582:	f8 01       	movw	r30, r16
    9584:	19 95       	eicall
    9586:	97 fd       	sbrc	r25, 7
    9588:	0f c0       	rjmp	.+30     	; 0x95a8 <med3+0x60>
    958a:	c7 01       	movw	r24, r14
    958c:	0f c0       	rjmp	.+30     	; 0x95ac <med3+0x64>
    958e:	c6 01       	movw	r24, r12
    9590:	f8 01       	movw	r30, r16
    9592:	19 95       	eicall
    9594:	18 16       	cp	r1, r24
    9596:	19 06       	cpc	r1, r25
    9598:	7c f3       	brlt	.-34     	; 0x9578 <med3+0x30>
    959a:	6d 2f       	mov	r22, r29
    959c:	7c 2f       	mov	r23, r28
    959e:	c7 01       	movw	r24, r14
    95a0:	f8 01       	movw	r30, r16
    95a2:	19 95       	eicall
    95a4:	97 fd       	sbrc	r25, 7
    95a6:	f1 cf       	rjmp	.-30     	; 0x958a <med3+0x42>
    95a8:	8d 2f       	mov	r24, r29
    95aa:	9c 2f       	mov	r25, r28
    95ac:	df 91       	pop	r29
    95ae:	cf 91       	pop	r28
    95b0:	1f 91       	pop	r17
    95b2:	0f 91       	pop	r16
    95b4:	ff 90       	pop	r15
    95b6:	ef 90       	pop	r14
    95b8:	df 90       	pop	r13
    95ba:	cf 90       	pop	r12
    95bc:	08 95       	ret

000095be <qsort>:
    95be:	2f 92       	push	r2
    95c0:	3f 92       	push	r3
    95c2:	4f 92       	push	r4
    95c4:	5f 92       	push	r5
    95c6:	6f 92       	push	r6
    95c8:	7f 92       	push	r7
    95ca:	8f 92       	push	r8
    95cc:	9f 92       	push	r9
    95ce:	af 92       	push	r10
    95d0:	bf 92       	push	r11
    95d2:	cf 92       	push	r12
    95d4:	df 92       	push	r13
    95d6:	ef 92       	push	r14
    95d8:	ff 92       	push	r15
    95da:	0f 93       	push	r16
    95dc:	1f 93       	push	r17
    95de:	cf 93       	push	r28
    95e0:	df 93       	push	r29
    95e2:	cd b7       	in	r28, 0x3d	; 61
    95e4:	de b7       	in	r29, 0x3e	; 62
    95e6:	2a 97       	sbiw	r28, 0x0a	; 10
    95e8:	cd bf       	out	0x3d, r28	; 61
    95ea:	de bf       	out	0x3e, r29	; 62
    95ec:	8c 01       	movw	r16, r24
    95ee:	7b 01       	movw	r14, r22
    95f0:	49 87       	std	Y+9, r20	; 0x09
    95f2:	5a 87       	std	Y+10, r21	; 0x0a
    95f4:	69 01       	movw	r12, r18
    95f6:	29 85       	ldd	r18, Y+9	; 0x09
    95f8:	3a 85       	ldd	r19, Y+10	; 0x0a
    95fa:	20 0f       	add	r18, r16
    95fc:	31 1f       	adc	r19, r17
    95fe:	29 83       	std	Y+1, r18	; 0x01
    9600:	3a 83       	std	Y+2, r19	; 0x02
    9602:	37 e0       	ldi	r19, 0x07	; 7
    9604:	e3 16       	cp	r14, r19
    9606:	f1 04       	cpc	r15, r1
    9608:	70 f5       	brcc	.+92     	; 0x9666 <qsort+0xa8>
    960a:	69 80       	ldd	r6, Y+1	; 0x01
    960c:	7a 80       	ldd	r7, Y+2	; 0x02
    960e:	49 85       	ldd	r20, Y+9	; 0x09
    9610:	5a 85       	ldd	r21, Y+10	; 0x0a
    9612:	e4 9e       	mul	r14, r20
    9614:	50 01       	movw	r10, r0
    9616:	e5 9e       	mul	r14, r21
    9618:	b0 0c       	add	r11, r0
    961a:	f4 9e       	mul	r15, r20
    961c:	b0 0c       	add	r11, r0
    961e:	11 24       	eor	r1, r1
    9620:	a0 0e       	add	r10, r16
    9622:	b1 1e       	adc	r11, r17
    9624:	6a 14       	cp	r6, r10
    9626:	7b 04       	cpc	r7, r11
    9628:	08 f0       	brcs	.+2      	; 0x962c <qsort+0x6e>
    962a:	7a c1       	rjmp	.+756    	; 0x9920 <qsort+0x362>
    962c:	73 01       	movw	r14, r6
    962e:	0e 15       	cp	r16, r14
    9630:	1f 05       	cpc	r17, r15
    9632:	28 f0       	brcs	.+10     	; 0x963e <qsort+0x80>
    9634:	89 85       	ldd	r24, Y+9	; 0x09
    9636:	9a 85       	ldd	r25, Y+10	; 0x0a
    9638:	68 0e       	add	r6, r24
    963a:	79 1e       	adc	r7, r25
    963c:	f3 cf       	rjmp	.-26     	; 0x9624 <qsort+0x66>
    963e:	47 01       	movw	r8, r14
    9640:	e9 85       	ldd	r30, Y+9	; 0x09
    9642:	fa 85       	ldd	r31, Y+10	; 0x0a
    9644:	8e 1a       	sub	r8, r30
    9646:	9f 0a       	sbc	r9, r31
    9648:	b7 01       	movw	r22, r14
    964a:	c4 01       	movw	r24, r8
    964c:	f6 01       	movw	r30, r12
    964e:	19 95       	eicall
    9650:	18 16       	cp	r1, r24
    9652:	19 06       	cpc	r1, r25
    9654:	7c f7       	brge	.-34     	; 0x9634 <qsort+0x76>
    9656:	49 85       	ldd	r20, Y+9	; 0x09
    9658:	5a 85       	ldd	r21, Y+10	; 0x0a
    965a:	b4 01       	movw	r22, r8
    965c:	c7 01       	movw	r24, r14
    965e:	0e 94 98 4a 	call	0x9530	; 0x9530 <swapfunc>
    9662:	74 01       	movw	r14, r8
    9664:	e4 cf       	rjmp	.-56     	; 0x962e <qsort+0x70>
    9666:	c7 01       	movw	r24, r14
    9668:	96 95       	lsr	r25
    966a:	87 95       	ror	r24
    966c:	29 85       	ldd	r18, Y+9	; 0x09
    966e:	3a 85       	ldd	r19, Y+10	; 0x0a
    9670:	82 9f       	mul	r24, r18
    9672:	50 01       	movw	r10, r0
    9674:	83 9f       	mul	r24, r19
    9676:	b0 0c       	add	r11, r0
    9678:	92 9f       	mul	r25, r18
    967a:	b0 0c       	add	r11, r0
    967c:	11 24       	eor	r1, r1
    967e:	a0 0e       	add	r10, r16
    9680:	b1 1e       	adc	r11, r17
    9682:	a7 01       	movw	r20, r14
    9684:	41 50       	subi	r20, 0x01	; 1
    9686:	51 09       	sbc	r21, r1
    9688:	4b 83       	std	Y+3, r20	; 0x03
    968a:	5c 83       	std	Y+4, r21	; 0x04
    968c:	57 e0       	ldi	r21, 0x07	; 7
    968e:	e5 16       	cp	r14, r21
    9690:	f1 04       	cpc	r15, r1
    9692:	09 f4       	brne	.+2      	; 0x9696 <qsort+0xd8>
    9694:	4c c0       	rjmp	.+152    	; 0x972e <qsort+0x170>
    9696:	8b 81       	ldd	r24, Y+3	; 0x03
    9698:	9c 81       	ldd	r25, Y+4	; 0x04
    969a:	82 9f       	mul	r24, r18
    969c:	30 01       	movw	r6, r0
    969e:	83 9f       	mul	r24, r19
    96a0:	70 0c       	add	r7, r0
    96a2:	92 9f       	mul	r25, r18
    96a4:	70 0c       	add	r7, r0
    96a6:	11 24       	eor	r1, r1
    96a8:	60 0e       	add	r6, r16
    96aa:	71 1e       	adc	r7, r17
    96ac:	99 e2       	ldi	r25, 0x29	; 41
    96ae:	e9 16       	cp	r14, r25
    96b0:	f1 04       	cpc	r15, r1
    96b2:	a8 f1       	brcs	.+106    	; 0x971e <qsort+0x160>
    96b4:	c7 01       	movw	r24, r14
    96b6:	43 e0       	ldi	r20, 0x03	; 3
    96b8:	96 95       	lsr	r25
    96ba:	87 95       	ror	r24
    96bc:	4a 95       	dec	r20
    96be:	e1 f7       	brne	.-8      	; 0x96b8 <qsort+0xfa>
    96c0:	82 9f       	mul	r24, r18
    96c2:	40 01       	movw	r8, r0
    96c4:	83 9f       	mul	r24, r19
    96c6:	90 0c       	add	r9, r0
    96c8:	92 9f       	mul	r25, r18
    96ca:	90 0c       	add	r9, r0
    96cc:	11 24       	eor	r1, r1
    96ce:	14 01       	movw	r2, r8
    96d0:	22 0c       	add	r2, r2
    96d2:	33 1c       	adc	r3, r3
    96d4:	a8 01       	movw	r20, r16
    96d6:	42 0d       	add	r20, r2
    96d8:	53 1d       	adc	r21, r3
    96da:	b8 01       	movw	r22, r16
    96dc:	68 0d       	add	r22, r8
    96de:	79 1d       	adc	r23, r9
    96e0:	96 01       	movw	r18, r12
    96e2:	c8 01       	movw	r24, r16
    96e4:	0e 94 a4 4a 	call	0x9548	; 0x9548 <med3>
    96e8:	2c 01       	movw	r4, r24
    96ea:	a5 01       	movw	r20, r10
    96ec:	48 0d       	add	r20, r8
    96ee:	59 1d       	adc	r21, r9
    96f0:	91 94       	neg	r9
    96f2:	81 94       	neg	r8
    96f4:	91 08       	sbc	r9, r1
    96f6:	96 01       	movw	r18, r12
    96f8:	b5 01       	movw	r22, r10
    96fa:	c5 01       	movw	r24, r10
    96fc:	88 0d       	add	r24, r8
    96fe:	99 1d       	adc	r25, r9
    9700:	0e 94 a4 4a 	call	0x9548	; 0x9548 <med3>
    9704:	5c 01       	movw	r10, r24
    9706:	b3 01       	movw	r22, r6
    9708:	68 0d       	add	r22, r8
    970a:	79 1d       	adc	r23, r9
    970c:	96 01       	movw	r18, r12
    970e:	a3 01       	movw	r20, r6
    9710:	c3 01       	movw	r24, r6
    9712:	82 19       	sub	r24, r2
    9714:	93 09       	sbc	r25, r3
    9716:	0e 94 a4 4a 	call	0x9548	; 0x9548 <med3>
    971a:	3c 01       	movw	r6, r24
    971c:	01 c0       	rjmp	.+2      	; 0x9720 <qsort+0x162>
    971e:	28 01       	movw	r4, r16
    9720:	96 01       	movw	r18, r12
    9722:	a3 01       	movw	r20, r6
    9724:	b5 01       	movw	r22, r10
    9726:	c2 01       	movw	r24, r4
    9728:	0e 94 a4 4a 	call	0x9548	; 0x9548 <med3>
    972c:	5c 01       	movw	r10, r24
    972e:	49 85       	ldd	r20, Y+9	; 0x09
    9730:	5a 85       	ldd	r21, Y+10	; 0x0a
    9732:	b5 01       	movw	r22, r10
    9734:	c8 01       	movw	r24, r16
    9736:	0e 94 98 4a 	call	0x9530	; 0x9530 <swapfunc>
    973a:	69 80       	ldd	r6, Y+1	; 0x01
    973c:	7a 80       	ldd	r7, Y+2	; 0x02
    973e:	2b 81       	ldd	r18, Y+3	; 0x03
    9740:	3c 81       	ldd	r19, Y+4	; 0x04
    9742:	49 85       	ldd	r20, Y+9	; 0x09
    9744:	5a 85       	ldd	r21, Y+10	; 0x0a
    9746:	24 9f       	mul	r18, r20
    9748:	f0 01       	movw	r30, r0
    974a:	25 9f       	mul	r18, r21
    974c:	f0 0d       	add	r31, r0
    974e:	34 9f       	mul	r19, r20
    9750:	f0 0d       	add	r31, r0
    9752:	11 24       	eor	r1, r1
    9754:	ed 83       	std	Y+5, r30	; 0x05
    9756:	fe 83       	std	Y+6, r31	; 0x06
    9758:	5f 01       	movw	r10, r30
    975a:	a0 0e       	add	r10, r16
    975c:	b1 1e       	adc	r11, r17
    975e:	46 0d       	add	r20, r6
    9760:	57 1d       	adc	r21, r7
    9762:	4b 83       	std	Y+3, r20	; 0x03
    9764:	5c 83       	std	Y+4, r21	; 0x04
    9766:	25 01       	movw	r4, r10
    9768:	13 01       	movw	r2, r6
    976a:	19 82       	std	Y+1, r1	; 0x01
    976c:	1a 82       	std	Y+2, r1	; 0x02
    976e:	8b 80       	ldd	r8, Y+3	; 0x03
    9770:	9c 80       	ldd	r9, Y+4	; 0x04
    9772:	89 85       	ldd	r24, Y+9	; 0x09
    9774:	9a 85       	ldd	r25, Y+10	; 0x0a
    9776:	88 1a       	sub	r8, r24
    9778:	99 0a       	sbc	r9, r25
    977a:	a8 14       	cp	r10, r8
    977c:	b9 04       	cpc	r11, r9
    977e:	08 f4       	brcc	.+2      	; 0x9782 <qsort+0x1c4>
    9780:	50 c0       	rjmp	.+160    	; 0x9822 <qsort+0x264>
    9782:	b8 01       	movw	r22, r16
    9784:	c4 01       	movw	r24, r8
    9786:	f6 01       	movw	r30, r12
    9788:	19 95       	eicall
    978a:	18 16       	cp	r1, r24
    978c:	19 06       	cpc	r1, r25
    978e:	c4 f1       	brlt	.+112    	; 0x9800 <qsort+0x242>
    9790:	89 2b       	or	r24, r25
    9792:	71 f4       	brne	.+28     	; 0x97b0 <qsort+0x1f2>
    9794:	49 85       	ldd	r20, Y+9	; 0x09
    9796:	5a 85       	ldd	r21, Y+10	; 0x0a
    9798:	b4 01       	movw	r22, r8
    979a:	c1 01       	movw	r24, r2
    979c:	0e 94 98 4a 	call	0x9530	; 0x9530 <swapfunc>
    97a0:	89 85       	ldd	r24, Y+9	; 0x09
    97a2:	9a 85       	ldd	r25, Y+10	; 0x0a
    97a4:	28 0e       	add	r2, r24
    97a6:	39 1e       	adc	r3, r25
    97a8:	e1 e0       	ldi	r30, 0x01	; 1
    97aa:	f0 e0       	ldi	r31, 0x00	; 0
    97ac:	e9 83       	std	Y+1, r30	; 0x01
    97ae:	fa 83       	std	Y+2, r31	; 0x02
    97b0:	2b 81       	ldd	r18, Y+3	; 0x03
    97b2:	3c 81       	ldd	r19, Y+4	; 0x04
    97b4:	49 85       	ldd	r20, Y+9	; 0x09
    97b6:	5a 85       	ldd	r21, Y+10	; 0x0a
    97b8:	24 0f       	add	r18, r20
    97ba:	35 1f       	adc	r19, r21
    97bc:	2b 83       	std	Y+3, r18	; 0x03
    97be:	3c 83       	std	Y+4, r19	; 0x04
    97c0:	d6 cf       	rjmp	.-84     	; 0x976e <qsort+0x1b0>
    97c2:	b8 01       	movw	r22, r16
    97c4:	c5 01       	movw	r24, r10
    97c6:	f6 01       	movw	r30, r12
    97c8:	19 95       	eicall
    97ca:	95 01       	movw	r18, r10
    97cc:	49 85       	ldd	r20, Y+9	; 0x09
    97ce:	5a 85       	ldd	r21, Y+10	; 0x0a
    97d0:	24 1b       	sub	r18, r20
    97d2:	35 0b       	sbc	r19, r21
    97d4:	2f 83       	std	Y+7, r18	; 0x07
    97d6:	38 87       	std	Y+8, r19	; 0x08
    97d8:	97 fd       	sbrc	r25, 7
    97da:	16 c0       	rjmp	.+44     	; 0x9808 <qsort+0x24a>
    97dc:	89 2b       	or	r24, r25
    97de:	71 f4       	brne	.+28     	; 0x97fc <qsort+0x23e>
    97e0:	49 85       	ldd	r20, Y+9	; 0x09
    97e2:	5a 85       	ldd	r21, Y+10	; 0x0a
    97e4:	b2 01       	movw	r22, r4
    97e6:	c5 01       	movw	r24, r10
    97e8:	0e 94 98 4a 	call	0x9530	; 0x9530 <swapfunc>
    97ec:	29 85       	ldd	r18, Y+9	; 0x09
    97ee:	3a 85       	ldd	r19, Y+10	; 0x0a
    97f0:	42 1a       	sub	r4, r18
    97f2:	53 0a       	sbc	r5, r19
    97f4:	41 e0       	ldi	r20, 0x01	; 1
    97f6:	50 e0       	ldi	r21, 0x00	; 0
    97f8:	49 83       	std	Y+1, r20	; 0x01
    97fa:	5a 83       	std	Y+2, r21	; 0x02
    97fc:	af 80       	ldd	r10, Y+7	; 0x07
    97fe:	b8 84       	ldd	r11, Y+8	; 0x08
    9800:	a8 14       	cp	r10, r8
    9802:	b9 04       	cpc	r11, r9
    9804:	f0 f6       	brcc	.-68     	; 0x97c2 <qsort+0x204>
    9806:	0d c0       	rjmp	.+26     	; 0x9822 <qsort+0x264>
    9808:	49 85       	ldd	r20, Y+9	; 0x09
    980a:	5a 85       	ldd	r21, Y+10	; 0x0a
    980c:	b5 01       	movw	r22, r10
    980e:	c4 01       	movw	r24, r8
    9810:	0e 94 98 4a 	call	0x9530	; 0x9530 <swapfunc>
    9814:	af 80       	ldd	r10, Y+7	; 0x07
    9816:	b8 84       	ldd	r11, Y+8	; 0x08
    9818:	41 e0       	ldi	r20, 0x01	; 1
    981a:	50 e0       	ldi	r21, 0x00	; 0
    981c:	49 83       	std	Y+1, r20	; 0x01
    981e:	5a 83       	std	Y+2, r21	; 0x02
    9820:	c7 cf       	rjmp	.-114    	; 0x97b0 <qsort+0x1f2>
    9822:	89 81       	ldd	r24, Y+1	; 0x01
    9824:	9a 81       	ldd	r25, Y+2	; 0x02
    9826:	89 2b       	or	r24, r25
    9828:	09 f4       	brne	.+2      	; 0x982c <qsort+0x26e>
    982a:	4f c0       	rjmp	.+158    	; 0x98ca <qsort+0x30c>
    982c:	6d 80       	ldd	r6, Y+5	; 0x05
    982e:	7e 80       	ldd	r7, Y+6	; 0x06
    9830:	29 85       	ldd	r18, Y+9	; 0x09
    9832:	3a 85       	ldd	r19, Y+10	; 0x0a
    9834:	62 0e       	add	r6, r18
    9836:	73 1e       	adc	r7, r19
    9838:	60 0e       	add	r6, r16
    983a:	71 1e       	adc	r7, r17
    983c:	74 01       	movw	r14, r8
    983e:	e2 18       	sub	r14, r2
    9840:	f3 08       	sbc	r15, r3
    9842:	a1 01       	movw	r20, r2
    9844:	40 1b       	sub	r20, r16
    9846:	51 0b       	sbc	r21, r17
    9848:	e4 16       	cp	r14, r20
    984a:	f5 06       	cpc	r15, r21
    984c:	0c f4       	brge	.+2      	; 0x9850 <qsort+0x292>
    984e:	a7 01       	movw	r20, r14
    9850:	14 16       	cp	r1, r20
    9852:	15 06       	cpc	r1, r21
    9854:	34 f4       	brge	.+12     	; 0x9862 <qsort+0x2a4>
    9856:	b4 01       	movw	r22, r8
    9858:	64 1b       	sub	r22, r20
    985a:	75 0b       	sbc	r23, r21
    985c:	c8 01       	movw	r24, r16
    985e:	0e 94 98 4a 	call	0x9530	; 0x9530 <swapfunc>
    9862:	a2 01       	movw	r20, r4
    9864:	4a 19       	sub	r20, r10
    9866:	5b 09       	sbc	r21, r11
    9868:	5a 01       	movw	r10, r20
    986a:	a3 01       	movw	r20, r6
    986c:	44 19       	sub	r20, r4
    986e:	55 09       	sbc	r21, r5
    9870:	89 85       	ldd	r24, Y+9	; 0x09
    9872:	9a 85       	ldd	r25, Y+10	; 0x0a
    9874:	48 1b       	sub	r20, r24
    9876:	59 0b       	sbc	r21, r25
    9878:	a4 16       	cp	r10, r20
    987a:	b5 06       	cpc	r11, r21
    987c:	08 f4       	brcc	.+2      	; 0x9880 <qsort+0x2c2>
    987e:	a5 01       	movw	r20, r10
    9880:	14 16       	cp	r1, r20
    9882:	15 06       	cpc	r1, r21
    9884:	34 f4       	brge	.+12     	; 0x9892 <qsort+0x2d4>
    9886:	b3 01       	movw	r22, r6
    9888:	64 1b       	sub	r22, r20
    988a:	75 0b       	sbc	r23, r21
    988c:	c4 01       	movw	r24, r8
    988e:	0e 94 98 4a 	call	0x9530	; 0x9530 <swapfunc>
    9892:	e9 85       	ldd	r30, Y+9	; 0x09
    9894:	fa 85       	ldd	r31, Y+10	; 0x0a
    9896:	ee 15       	cp	r30, r14
    9898:	ff 05       	cpc	r31, r15
    989a:	48 f4       	brcc	.+18     	; 0x98ae <qsort+0x2f0>
    989c:	c7 01       	movw	r24, r14
    989e:	bf 01       	movw	r22, r30
    98a0:	0e 94 0b 49 	call	0x9216	; 0x9216 <__udivmodhi4>
    98a4:	96 01       	movw	r18, r12
    98a6:	af 01       	movw	r20, r30
    98a8:	c8 01       	movw	r24, r16
    98aa:	0e 94 df 4a 	call	0x95be	; 0x95be <qsort>
    98ae:	29 85       	ldd	r18, Y+9	; 0x09
    98b0:	3a 85       	ldd	r19, Y+10	; 0x0a
    98b2:	2a 15       	cp	r18, r10
    98b4:	3b 05       	cpc	r19, r11
    98b6:	a0 f5       	brcc	.+104    	; 0x9920 <qsort+0x362>
    98b8:	83 01       	movw	r16, r6
    98ba:	0a 19       	sub	r16, r10
    98bc:	1b 09       	sbc	r17, r11
    98be:	c5 01       	movw	r24, r10
    98c0:	b9 01       	movw	r22, r18
    98c2:	0e 94 0b 49 	call	0x9216	; 0x9216 <__udivmodhi4>
    98c6:	7b 01       	movw	r14, r22
    98c8:	96 ce       	rjmp	.-724    	; 0x95f6 <qsort+0x38>
    98ca:	e9 85       	ldd	r30, Y+9	; 0x09
    98cc:	fa 85       	ldd	r31, Y+10	; 0x0a
    98ce:	ee 9e       	mul	r14, r30
    98d0:	50 01       	movw	r10, r0
    98d2:	ef 9e       	mul	r14, r31
    98d4:	b0 0c       	add	r11, r0
    98d6:	fe 9e       	mul	r15, r30
    98d8:	b0 0c       	add	r11, r0
    98da:	11 24       	eor	r1, r1
    98dc:	a0 0e       	add	r10, r16
    98de:	b1 1e       	adc	r11, r17
    98e0:	6a 14       	cp	r6, r10
    98e2:	7b 04       	cpc	r7, r11
    98e4:	e8 f4       	brcc	.+58     	; 0x9920 <qsort+0x362>
    98e6:	73 01       	movw	r14, r6
    98e8:	0e 15       	cp	r16, r14
    98ea:	1f 05       	cpc	r17, r15
    98ec:	28 f0       	brcs	.+10     	; 0x98f8 <qsort+0x33a>
    98ee:	89 85       	ldd	r24, Y+9	; 0x09
    98f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    98f2:	68 0e       	add	r6, r24
    98f4:	79 1e       	adc	r7, r25
    98f6:	f4 cf       	rjmp	.-24     	; 0x98e0 <qsort+0x322>
    98f8:	47 01       	movw	r8, r14
    98fa:	e9 85       	ldd	r30, Y+9	; 0x09
    98fc:	fa 85       	ldd	r31, Y+10	; 0x0a
    98fe:	8e 1a       	sub	r8, r30
    9900:	9f 0a       	sbc	r9, r31
    9902:	b7 01       	movw	r22, r14
    9904:	c4 01       	movw	r24, r8
    9906:	f6 01       	movw	r30, r12
    9908:	19 95       	eicall
    990a:	18 16       	cp	r1, r24
    990c:	19 06       	cpc	r1, r25
    990e:	7c f7       	brge	.-34     	; 0x98ee <qsort+0x330>
    9910:	49 85       	ldd	r20, Y+9	; 0x09
    9912:	5a 85       	ldd	r21, Y+10	; 0x0a
    9914:	b4 01       	movw	r22, r8
    9916:	c7 01       	movw	r24, r14
    9918:	0e 94 98 4a 	call	0x9530	; 0x9530 <swapfunc>
    991c:	74 01       	movw	r14, r8
    991e:	e4 cf       	rjmp	.-56     	; 0x98e8 <qsort+0x32a>
    9920:	2a 96       	adiw	r28, 0x0a	; 10
    9922:	cd bf       	out	0x3d, r28	; 61
    9924:	de bf       	out	0x3e, r29	; 62
    9926:	df 91       	pop	r29
    9928:	cf 91       	pop	r28
    992a:	1f 91       	pop	r17
    992c:	0f 91       	pop	r16
    992e:	ff 90       	pop	r15
    9930:	ef 90       	pop	r14
    9932:	df 90       	pop	r13
    9934:	cf 90       	pop	r12
    9936:	bf 90       	pop	r11
    9938:	af 90       	pop	r10
    993a:	9f 90       	pop	r9
    993c:	8f 90       	pop	r8
    993e:	7f 90       	pop	r7
    9940:	6f 90       	pop	r6
    9942:	5f 90       	pop	r5
    9944:	4f 90       	pop	r4
    9946:	3f 90       	pop	r3
    9948:	2f 90       	pop	r2
    994a:	08 95       	ret

0000994c <atof>:
    994c:	66 27       	eor	r22, r22
    994e:	77 27       	eor	r23, r23
    9950:	0c 94 55 4f 	jmp	0x9eaa	; 0x9eaa <strtod>

00009954 <__ftoa_engine>:
    9954:	28 30       	cpi	r18, 0x08	; 8
    9956:	08 f0       	brcs	.+2      	; 0x995a <__ftoa_engine+0x6>
    9958:	27 e0       	ldi	r18, 0x07	; 7
    995a:	33 27       	eor	r19, r19
    995c:	da 01       	movw	r26, r20
    995e:	99 0f       	add	r25, r25
    9960:	31 1d       	adc	r19, r1
    9962:	87 fd       	sbrc	r24, 7
    9964:	91 60       	ori	r25, 0x01	; 1
    9966:	00 96       	adiw	r24, 0x00	; 0
    9968:	61 05       	cpc	r22, r1
    996a:	71 05       	cpc	r23, r1
    996c:	39 f4       	brne	.+14     	; 0x997c <__ftoa_engine+0x28>
    996e:	32 60       	ori	r19, 0x02	; 2
    9970:	2e 5f       	subi	r18, 0xFE	; 254
    9972:	3d 93       	st	X+, r19
    9974:	30 e3       	ldi	r19, 0x30	; 48
    9976:	2a 95       	dec	r18
    9978:	e1 f7       	brne	.-8      	; 0x9972 <__ftoa_engine+0x1e>
    997a:	08 95       	ret
    997c:	9f 3f       	cpi	r25, 0xFF	; 255
    997e:	30 f0       	brcs	.+12     	; 0x998c <__ftoa_engine+0x38>
    9980:	80 38       	cpi	r24, 0x80	; 128
    9982:	71 05       	cpc	r23, r1
    9984:	61 05       	cpc	r22, r1
    9986:	09 f0       	breq	.+2      	; 0x998a <__ftoa_engine+0x36>
    9988:	3c 5f       	subi	r19, 0xFC	; 252
    998a:	3c 5f       	subi	r19, 0xFC	; 252
    998c:	3d 93       	st	X+, r19
    998e:	91 30       	cpi	r25, 0x01	; 1
    9990:	08 f0       	brcs	.+2      	; 0x9994 <__ftoa_engine+0x40>
    9992:	80 68       	ori	r24, 0x80	; 128
    9994:	91 1d       	adc	r25, r1
    9996:	df 93       	push	r29
    9998:	cf 93       	push	r28
    999a:	1f 93       	push	r17
    999c:	0f 93       	push	r16
    999e:	ff 92       	push	r15
    99a0:	ef 92       	push	r14
    99a2:	19 2f       	mov	r17, r25
    99a4:	98 7f       	andi	r25, 0xF8	; 248
    99a6:	96 95       	lsr	r25
    99a8:	e9 2f       	mov	r30, r25
    99aa:	96 95       	lsr	r25
    99ac:	96 95       	lsr	r25
    99ae:	e9 0f       	add	r30, r25
    99b0:	ff 27       	eor	r31, r31
    99b2:	e6 56       	subi	r30, 0x66	; 102
    99b4:	fd 4f       	sbci	r31, 0xFD	; 253
    99b6:	99 27       	eor	r25, r25
    99b8:	33 27       	eor	r19, r19
    99ba:	ee 24       	eor	r14, r14
    99bc:	ff 24       	eor	r15, r15
    99be:	a7 01       	movw	r20, r14
    99c0:	e7 01       	movw	r28, r14
    99c2:	05 90       	lpm	r0, Z+
    99c4:	08 94       	sec
    99c6:	07 94       	ror	r0
    99c8:	28 f4       	brcc	.+10     	; 0x99d4 <__ftoa_engine+0x80>
    99ca:	36 0f       	add	r19, r22
    99cc:	e7 1e       	adc	r14, r23
    99ce:	f8 1e       	adc	r15, r24
    99d0:	49 1f       	adc	r20, r25
    99d2:	51 1d       	adc	r21, r1
    99d4:	66 0f       	add	r22, r22
    99d6:	77 1f       	adc	r23, r23
    99d8:	88 1f       	adc	r24, r24
    99da:	99 1f       	adc	r25, r25
    99dc:	06 94       	lsr	r0
    99de:	a1 f7       	brne	.-24     	; 0x99c8 <__ftoa_engine+0x74>
    99e0:	05 90       	lpm	r0, Z+
    99e2:	07 94       	ror	r0
    99e4:	28 f4       	brcc	.+10     	; 0x99f0 <__ftoa_engine+0x9c>
    99e6:	e7 0e       	add	r14, r23
    99e8:	f8 1e       	adc	r15, r24
    99ea:	49 1f       	adc	r20, r25
    99ec:	56 1f       	adc	r21, r22
    99ee:	c1 1d       	adc	r28, r1
    99f0:	77 0f       	add	r23, r23
    99f2:	88 1f       	adc	r24, r24
    99f4:	99 1f       	adc	r25, r25
    99f6:	66 1f       	adc	r22, r22
    99f8:	06 94       	lsr	r0
    99fa:	a1 f7       	brne	.-24     	; 0x99e4 <__ftoa_engine+0x90>
    99fc:	05 90       	lpm	r0, Z+
    99fe:	07 94       	ror	r0
    9a00:	28 f4       	brcc	.+10     	; 0x9a0c <__ftoa_engine+0xb8>
    9a02:	f8 0e       	add	r15, r24
    9a04:	49 1f       	adc	r20, r25
    9a06:	56 1f       	adc	r21, r22
    9a08:	c7 1f       	adc	r28, r23
    9a0a:	d1 1d       	adc	r29, r1
    9a0c:	88 0f       	add	r24, r24
    9a0e:	99 1f       	adc	r25, r25
    9a10:	66 1f       	adc	r22, r22
    9a12:	77 1f       	adc	r23, r23
    9a14:	06 94       	lsr	r0
    9a16:	a1 f7       	brne	.-24     	; 0x9a00 <__ftoa_engine+0xac>
    9a18:	05 90       	lpm	r0, Z+
    9a1a:	07 94       	ror	r0
    9a1c:	20 f4       	brcc	.+8      	; 0x9a26 <__ftoa_engine+0xd2>
    9a1e:	49 0f       	add	r20, r25
    9a20:	56 1f       	adc	r21, r22
    9a22:	c7 1f       	adc	r28, r23
    9a24:	d8 1f       	adc	r29, r24
    9a26:	99 0f       	add	r25, r25
    9a28:	66 1f       	adc	r22, r22
    9a2a:	77 1f       	adc	r23, r23
    9a2c:	88 1f       	adc	r24, r24
    9a2e:	06 94       	lsr	r0
    9a30:	a9 f7       	brne	.-22     	; 0x9a1c <__ftoa_engine+0xc8>
    9a32:	84 91       	lpm	r24, Z
    9a34:	10 95       	com	r17
    9a36:	17 70       	andi	r17, 0x07	; 7
    9a38:	41 f0       	breq	.+16     	; 0x9a4a <__ftoa_engine+0xf6>
    9a3a:	d6 95       	lsr	r29
    9a3c:	c7 95       	ror	r28
    9a3e:	57 95       	ror	r21
    9a40:	47 95       	ror	r20
    9a42:	f7 94       	ror	r15
    9a44:	e7 94       	ror	r14
    9a46:	1a 95       	dec	r17
    9a48:	c1 f7       	brne	.-16     	; 0x9a3a <__ftoa_engine+0xe6>
    9a4a:	e0 e4       	ldi	r30, 0x40	; 64
    9a4c:	f2 e0       	ldi	r31, 0x02	; 2
    9a4e:	68 94       	set
    9a50:	15 90       	lpm	r1, Z+
    9a52:	15 91       	lpm	r17, Z+
    9a54:	35 91       	lpm	r19, Z+
    9a56:	65 91       	lpm	r22, Z+
    9a58:	95 91       	lpm	r25, Z+
    9a5a:	05 90       	lpm	r0, Z+
    9a5c:	7f e2       	ldi	r23, 0x2F	; 47
    9a5e:	73 95       	inc	r23
    9a60:	e1 18       	sub	r14, r1
    9a62:	f1 0a       	sbc	r15, r17
    9a64:	43 0b       	sbc	r20, r19
    9a66:	56 0b       	sbc	r21, r22
    9a68:	c9 0b       	sbc	r28, r25
    9a6a:	d0 09       	sbc	r29, r0
    9a6c:	c0 f7       	brcc	.-16     	; 0x9a5e <__ftoa_engine+0x10a>
    9a6e:	e1 0c       	add	r14, r1
    9a70:	f1 1e       	adc	r15, r17
    9a72:	43 1f       	adc	r20, r19
    9a74:	56 1f       	adc	r21, r22
    9a76:	c9 1f       	adc	r28, r25
    9a78:	d0 1d       	adc	r29, r0
    9a7a:	7e f4       	brtc	.+30     	; 0x9a9a <__ftoa_engine+0x146>
    9a7c:	70 33       	cpi	r23, 0x30	; 48
    9a7e:	11 f4       	brne	.+4      	; 0x9a84 <__ftoa_engine+0x130>
    9a80:	8a 95       	dec	r24
    9a82:	e6 cf       	rjmp	.-52     	; 0x9a50 <__ftoa_engine+0xfc>
    9a84:	e8 94       	clt
    9a86:	01 50       	subi	r16, 0x01	; 1
    9a88:	30 f0       	brcs	.+12     	; 0x9a96 <__ftoa_engine+0x142>
    9a8a:	08 0f       	add	r16, r24
    9a8c:	0a f4       	brpl	.+2      	; 0x9a90 <__ftoa_engine+0x13c>
    9a8e:	00 27       	eor	r16, r16
    9a90:	02 17       	cp	r16, r18
    9a92:	08 f4       	brcc	.+2      	; 0x9a96 <__ftoa_engine+0x142>
    9a94:	20 2f       	mov	r18, r16
    9a96:	23 95       	inc	r18
    9a98:	02 2f       	mov	r16, r18
    9a9a:	7a 33       	cpi	r23, 0x3A	; 58
    9a9c:	28 f0       	brcs	.+10     	; 0x9aa8 <__ftoa_engine+0x154>
    9a9e:	79 e3       	ldi	r23, 0x39	; 57
    9aa0:	7d 93       	st	X+, r23
    9aa2:	2a 95       	dec	r18
    9aa4:	e9 f7       	brne	.-6      	; 0x9aa0 <__ftoa_engine+0x14c>
    9aa6:	10 c0       	rjmp	.+32     	; 0x9ac8 <__ftoa_engine+0x174>
    9aa8:	7d 93       	st	X+, r23
    9aaa:	2a 95       	dec	r18
    9aac:	89 f6       	brne	.-94     	; 0x9a50 <__ftoa_engine+0xfc>
    9aae:	06 94       	lsr	r0
    9ab0:	97 95       	ror	r25
    9ab2:	67 95       	ror	r22
    9ab4:	37 95       	ror	r19
    9ab6:	17 95       	ror	r17
    9ab8:	17 94       	ror	r1
    9aba:	e1 18       	sub	r14, r1
    9abc:	f1 0a       	sbc	r15, r17
    9abe:	43 0b       	sbc	r20, r19
    9ac0:	56 0b       	sbc	r21, r22
    9ac2:	c9 0b       	sbc	r28, r25
    9ac4:	d0 09       	sbc	r29, r0
    9ac6:	98 f0       	brcs	.+38     	; 0x9aee <__ftoa_engine+0x19a>
    9ac8:	23 95       	inc	r18
    9aca:	7e 91       	ld	r23, -X
    9acc:	73 95       	inc	r23
    9ace:	7a 33       	cpi	r23, 0x3A	; 58
    9ad0:	08 f0       	brcs	.+2      	; 0x9ad4 <__ftoa_engine+0x180>
    9ad2:	70 e3       	ldi	r23, 0x30	; 48
    9ad4:	7c 93       	st	X, r23
    9ad6:	20 13       	cpse	r18, r16
    9ad8:	b8 f7       	brcc	.-18     	; 0x9ac8 <__ftoa_engine+0x174>
    9ada:	7e 91       	ld	r23, -X
    9adc:	70 61       	ori	r23, 0x10	; 16
    9ade:	7d 93       	st	X+, r23
    9ae0:	30 f0       	brcs	.+12     	; 0x9aee <__ftoa_engine+0x19a>
    9ae2:	83 95       	inc	r24
    9ae4:	71 e3       	ldi	r23, 0x31	; 49
    9ae6:	7d 93       	st	X+, r23
    9ae8:	70 e3       	ldi	r23, 0x30	; 48
    9aea:	2a 95       	dec	r18
    9aec:	e1 f7       	brne	.-8      	; 0x9ae6 <__ftoa_engine+0x192>
    9aee:	11 24       	eor	r1, r1
    9af0:	ef 90       	pop	r14
    9af2:	ff 90       	pop	r15
    9af4:	0f 91       	pop	r16
    9af6:	1f 91       	pop	r17
    9af8:	cf 91       	pop	r28
    9afa:	df 91       	pop	r29
    9afc:	99 27       	eor	r25, r25
    9afe:	87 fd       	sbrc	r24, 7
    9b00:	90 95       	com	r25
    9b02:	08 95       	ret

00009b04 <strnlen_P>:
    9b04:	fc 01       	movw	r30, r24
    9b06:	05 90       	lpm	r0, Z+
    9b08:	61 50       	subi	r22, 0x01	; 1
    9b0a:	70 40       	sbci	r23, 0x00	; 0
    9b0c:	01 10       	cpse	r0, r1
    9b0e:	d8 f7       	brcc	.-10     	; 0x9b06 <strnlen_P+0x2>
    9b10:	80 95       	com	r24
    9b12:	90 95       	com	r25
    9b14:	8e 0f       	add	r24, r30
    9b16:	9f 1f       	adc	r25, r31
    9b18:	08 95       	ret

00009b1a <strtok>:
    9b1a:	40 e7       	ldi	r20, 0x70	; 112
    9b1c:	58 e2       	ldi	r21, 0x28	; 40
    9b1e:	0c 94 cd 4d 	jmp	0x9b9a	; 0x9b9a <strtok_r>

00009b22 <memcpy>:
    9b22:	fb 01       	movw	r30, r22
    9b24:	dc 01       	movw	r26, r24
    9b26:	02 c0       	rjmp	.+4      	; 0x9b2c <memcpy+0xa>
    9b28:	01 90       	ld	r0, Z+
    9b2a:	0d 92       	st	X+, r0
    9b2c:	41 50       	subi	r20, 0x01	; 1
    9b2e:	50 40       	sbci	r21, 0x00	; 0
    9b30:	d8 f7       	brcc	.-10     	; 0x9b28 <memcpy+0x6>
    9b32:	08 95       	ret

00009b34 <memset>:
    9b34:	dc 01       	movw	r26, r24
    9b36:	01 c0       	rjmp	.+2      	; 0x9b3a <memset+0x6>
    9b38:	6d 93       	st	X+, r22
    9b3a:	41 50       	subi	r20, 0x01	; 1
    9b3c:	50 40       	sbci	r21, 0x00	; 0
    9b3e:	e0 f7       	brcc	.-8      	; 0x9b38 <memset+0x4>
    9b40:	08 95       	ret

00009b42 <strcpy>:
    9b42:	fb 01       	movw	r30, r22
    9b44:	dc 01       	movw	r26, r24
    9b46:	01 90       	ld	r0, Z+
    9b48:	0d 92       	st	X+, r0
    9b4a:	00 20       	and	r0, r0
    9b4c:	e1 f7       	brne	.-8      	; 0x9b46 <strcpy+0x4>
    9b4e:	08 95       	ret

00009b50 <strnlen>:
    9b50:	fc 01       	movw	r30, r24
    9b52:	61 50       	subi	r22, 0x01	; 1
    9b54:	70 40       	sbci	r23, 0x00	; 0
    9b56:	01 90       	ld	r0, Z+
    9b58:	01 10       	cpse	r0, r1
    9b5a:	d8 f7       	brcc	.-10     	; 0x9b52 <strnlen+0x2>
    9b5c:	80 95       	com	r24
    9b5e:	90 95       	com	r25
    9b60:	8e 0f       	add	r24, r30
    9b62:	9f 1f       	adc	r25, r31
    9b64:	08 95       	ret

00009b66 <strstr>:
    9b66:	fb 01       	movw	r30, r22
    9b68:	51 91       	ld	r21, Z+
    9b6a:	55 23       	and	r21, r21
    9b6c:	a9 f0       	breq	.+42     	; 0x9b98 <strstr+0x32>
    9b6e:	bf 01       	movw	r22, r30
    9b70:	dc 01       	movw	r26, r24
    9b72:	4d 91       	ld	r20, X+
    9b74:	45 17       	cp	r20, r21
    9b76:	41 11       	cpse	r20, r1
    9b78:	e1 f7       	brne	.-8      	; 0x9b72 <strstr+0xc>
    9b7a:	59 f4       	brne	.+22     	; 0x9b92 <strstr+0x2c>
    9b7c:	cd 01       	movw	r24, r26
    9b7e:	01 90       	ld	r0, Z+
    9b80:	00 20       	and	r0, r0
    9b82:	49 f0       	breq	.+18     	; 0x9b96 <strstr+0x30>
    9b84:	4d 91       	ld	r20, X+
    9b86:	40 15       	cp	r20, r0
    9b88:	41 11       	cpse	r20, r1
    9b8a:	c9 f3       	breq	.-14     	; 0x9b7e <strstr+0x18>
    9b8c:	fb 01       	movw	r30, r22
    9b8e:	41 11       	cpse	r20, r1
    9b90:	ef cf       	rjmp	.-34     	; 0x9b70 <strstr+0xa>
    9b92:	81 e0       	ldi	r24, 0x01	; 1
    9b94:	90 e0       	ldi	r25, 0x00	; 0
    9b96:	01 97       	sbiw	r24, 0x01	; 1
    9b98:	08 95       	ret

00009b9a <strtok_r>:
    9b9a:	fa 01       	movw	r30, r20
    9b9c:	a1 91       	ld	r26, Z+
    9b9e:	b0 81       	ld	r27, Z
    9ba0:	00 97       	sbiw	r24, 0x00	; 0
    9ba2:	19 f4       	brne	.+6      	; 0x9baa <strtok_r+0x10>
    9ba4:	10 97       	sbiw	r26, 0x00	; 0
    9ba6:	e1 f0       	breq	.+56     	; 0x9be0 <strtok_r+0x46>
    9ba8:	cd 01       	movw	r24, r26
    9baa:	dc 01       	movw	r26, r24
    9bac:	cd 01       	movw	r24, r26
    9bae:	0d 90       	ld	r0, X+
    9bb0:	00 20       	and	r0, r0
    9bb2:	11 f4       	brne	.+4      	; 0x9bb8 <strtok_r+0x1e>
    9bb4:	c0 01       	movw	r24, r0
    9bb6:	13 c0       	rjmp	.+38     	; 0x9bde <strtok_r+0x44>
    9bb8:	fb 01       	movw	r30, r22
    9bba:	21 91       	ld	r18, Z+
    9bbc:	22 23       	and	r18, r18
    9bbe:	19 f0       	breq	.+6      	; 0x9bc6 <strtok_r+0x2c>
    9bc0:	20 15       	cp	r18, r0
    9bc2:	d9 f7       	brne	.-10     	; 0x9bba <strtok_r+0x20>
    9bc4:	f3 cf       	rjmp	.-26     	; 0x9bac <strtok_r+0x12>
    9bc6:	fb 01       	movw	r30, r22
    9bc8:	21 91       	ld	r18, Z+
    9bca:	20 15       	cp	r18, r0
    9bcc:	19 f4       	brne	.+6      	; 0x9bd4 <strtok_r+0x3a>
    9bce:	1e 92       	st	-X, r1
    9bd0:	11 96       	adiw	r26, 0x01	; 1
    9bd2:	06 c0       	rjmp	.+12     	; 0x9be0 <strtok_r+0x46>
    9bd4:	22 23       	and	r18, r18
    9bd6:	c1 f7       	brne	.-16     	; 0x9bc8 <strtok_r+0x2e>
    9bd8:	0d 90       	ld	r0, X+
    9bda:	00 20       	and	r0, r0
    9bdc:	a1 f7       	brne	.-24     	; 0x9bc6 <strtok_r+0x2c>
    9bde:	d0 01       	movw	r26, r0
    9be0:	fa 01       	movw	r30, r20
    9be2:	a1 93       	st	Z+, r26
    9be4:	b0 83       	st	Z, r27
    9be6:	08 95       	ret

00009be8 <fgets>:
    9be8:	cf 92       	push	r12
    9bea:	df 92       	push	r13
    9bec:	ef 92       	push	r14
    9bee:	ff 92       	push	r15
    9bf0:	0f 93       	push	r16
    9bf2:	1f 93       	push	r17
    9bf4:	cf 93       	push	r28
    9bf6:	df 93       	push	r29
    9bf8:	fa 01       	movw	r30, r20
    9bfa:	23 81       	ldd	r18, Z+3	; 0x03
    9bfc:	20 fd       	sbrc	r18, 0
    9bfe:	03 c0       	rjmp	.+6      	; 0x9c06 <fgets+0x1e>
    9c00:	80 e0       	ldi	r24, 0x00	; 0
    9c02:	90 e0       	ldi	r25, 0x00	; 0
    9c04:	1a c0       	rjmp	.+52     	; 0x9c3a <fgets+0x52>
    9c06:	16 16       	cp	r1, r22
    9c08:	17 06       	cpc	r1, r23
    9c0a:	d4 f7       	brge	.-12     	; 0x9c00 <fgets+0x18>
    9c0c:	7a 01       	movw	r14, r20
    9c0e:	8c 01       	movw	r16, r24
    9c10:	eb 01       	movw	r28, r22
    9c12:	6c 01       	movw	r12, r24
    9c14:	c1 30       	cpi	r28, 0x01	; 1
    9c16:	d1 05       	cpc	r29, r1
    9c18:	69 f0       	breq	.+26     	; 0x9c34 <fgets+0x4c>
    9c1a:	c7 01       	movw	r24, r14
    9c1c:	0e 94 d2 50 	call	0xa1a4	; 0xa1a4 <fgetc>
    9c20:	8f 3f       	cpi	r24, 0xFF	; 255
    9c22:	ff ef       	ldi	r31, 0xFF	; 255
    9c24:	9f 07       	cpc	r25, r31
    9c26:	61 f3       	breq	.-40     	; 0x9c00 <fgets+0x18>
    9c28:	f6 01       	movw	r30, r12
    9c2a:	81 93       	st	Z+, r24
    9c2c:	6f 01       	movw	r12, r30
    9c2e:	21 97       	sbiw	r28, 0x01	; 1
    9c30:	0a 97       	sbiw	r24, 0x0a	; 10
    9c32:	81 f7       	brne	.-32     	; 0x9c14 <fgets+0x2c>
    9c34:	f6 01       	movw	r30, r12
    9c36:	10 82       	st	Z, r1
    9c38:	c8 01       	movw	r24, r16
    9c3a:	df 91       	pop	r29
    9c3c:	cf 91       	pop	r28
    9c3e:	1f 91       	pop	r17
    9c40:	0f 91       	pop	r16
    9c42:	ff 90       	pop	r15
    9c44:	ef 90       	pop	r14
    9c46:	df 90       	pop	r13
    9c48:	cf 90       	pop	r12
    9c4a:	08 95       	ret

00009c4c <fputc>:
    9c4c:	0f 93       	push	r16
    9c4e:	1f 93       	push	r17
    9c50:	cf 93       	push	r28
    9c52:	df 93       	push	r29
    9c54:	fb 01       	movw	r30, r22
    9c56:	23 81       	ldd	r18, Z+3	; 0x03
    9c58:	21 fd       	sbrc	r18, 1
    9c5a:	03 c0       	rjmp	.+6      	; 0x9c62 <fputc+0x16>
    9c5c:	8f ef       	ldi	r24, 0xFF	; 255
    9c5e:	9f ef       	ldi	r25, 0xFF	; 255
    9c60:	2c c0       	rjmp	.+88     	; 0x9cba <fputc+0x6e>
    9c62:	22 ff       	sbrs	r18, 2
    9c64:	16 c0       	rjmp	.+44     	; 0x9c92 <fputc+0x46>
    9c66:	46 81       	ldd	r20, Z+6	; 0x06
    9c68:	57 81       	ldd	r21, Z+7	; 0x07
    9c6a:	24 81       	ldd	r18, Z+4	; 0x04
    9c6c:	35 81       	ldd	r19, Z+5	; 0x05
    9c6e:	42 17       	cp	r20, r18
    9c70:	53 07       	cpc	r21, r19
    9c72:	44 f4       	brge	.+16     	; 0x9c84 <fputc+0x38>
    9c74:	a0 81       	ld	r26, Z
    9c76:	b1 81       	ldd	r27, Z+1	; 0x01
    9c78:	9d 01       	movw	r18, r26
    9c7a:	2f 5f       	subi	r18, 0xFF	; 255
    9c7c:	3f 4f       	sbci	r19, 0xFF	; 255
    9c7e:	20 83       	st	Z, r18
    9c80:	31 83       	std	Z+1, r19	; 0x01
    9c82:	8c 93       	st	X, r24
    9c84:	26 81       	ldd	r18, Z+6	; 0x06
    9c86:	37 81       	ldd	r19, Z+7	; 0x07
    9c88:	2f 5f       	subi	r18, 0xFF	; 255
    9c8a:	3f 4f       	sbci	r19, 0xFF	; 255
    9c8c:	26 83       	std	Z+6, r18	; 0x06
    9c8e:	37 83       	std	Z+7, r19	; 0x07
    9c90:	14 c0       	rjmp	.+40     	; 0x9cba <fputc+0x6e>
    9c92:	8b 01       	movw	r16, r22
    9c94:	ec 01       	movw	r28, r24
    9c96:	fb 01       	movw	r30, r22
    9c98:	00 84       	ldd	r0, Z+8	; 0x08
    9c9a:	f1 85       	ldd	r31, Z+9	; 0x09
    9c9c:	e0 2d       	mov	r30, r0
    9c9e:	19 95       	eicall
    9ca0:	89 2b       	or	r24, r25
    9ca2:	e1 f6       	brne	.-72     	; 0x9c5c <fputc+0x10>
    9ca4:	d8 01       	movw	r26, r16
    9ca6:	16 96       	adiw	r26, 0x06	; 6
    9ca8:	8d 91       	ld	r24, X+
    9caa:	9c 91       	ld	r25, X
    9cac:	17 97       	sbiw	r26, 0x07	; 7
    9cae:	01 96       	adiw	r24, 0x01	; 1
    9cb0:	16 96       	adiw	r26, 0x06	; 6
    9cb2:	8d 93       	st	X+, r24
    9cb4:	9c 93       	st	X, r25
    9cb6:	17 97       	sbiw	r26, 0x07	; 7
    9cb8:	ce 01       	movw	r24, r28
    9cba:	df 91       	pop	r29
    9cbc:	cf 91       	pop	r28
    9cbe:	1f 91       	pop	r17
    9cc0:	0f 91       	pop	r16
    9cc2:	08 95       	ret

00009cc4 <printf>:
    9cc4:	cf 93       	push	r28
    9cc6:	df 93       	push	r29
    9cc8:	cd b7       	in	r28, 0x3d	; 61
    9cca:	de b7       	in	r29, 0x3e	; 62
    9ccc:	ae 01       	movw	r20, r28
    9cce:	4a 5f       	subi	r20, 0xFA	; 250
    9cd0:	5f 4f       	sbci	r21, 0xFF	; 255
    9cd2:	fa 01       	movw	r30, r20
    9cd4:	61 91       	ld	r22, Z+
    9cd6:	71 91       	ld	r23, Z+
    9cd8:	af 01       	movw	r20, r30
    9cda:	80 91 df 2d 	lds	r24, 0x2DDF	; 0x802ddf <__iob+0x2>
    9cde:	90 91 e0 2d 	lds	r25, 0x2DE0	; 0x802de0 <__iob+0x3>
    9ce2:	0e 94 6b 45 	call	0x8ad6	; 0x8ad6 <vfprintf>
    9ce6:	df 91       	pop	r29
    9ce8:	cf 91       	pop	r28
    9cea:	08 95       	ret

00009cec <printf_P>:
    9cec:	0f 93       	push	r16
    9cee:	1f 93       	push	r17
    9cf0:	cf 93       	push	r28
    9cf2:	df 93       	push	r29
    9cf4:	cd b7       	in	r28, 0x3d	; 61
    9cf6:	de b7       	in	r29, 0x3e	; 62
    9cf8:	ae 01       	movw	r20, r28
    9cfa:	48 5f       	subi	r20, 0xF8	; 248
    9cfc:	5f 4f       	sbci	r21, 0xFF	; 255
    9cfe:	da 01       	movw	r26, r20
    9d00:	6d 91       	ld	r22, X+
    9d02:	7d 91       	ld	r23, X+
    9d04:	ad 01       	movw	r20, r26
    9d06:	0d ed       	ldi	r16, 0xDD	; 221
    9d08:	1d e2       	ldi	r17, 0x2D	; 45
    9d0a:	f8 01       	movw	r30, r16
    9d0c:	82 81       	ldd	r24, Z+2	; 0x02
    9d0e:	93 81       	ldd	r25, Z+3	; 0x03
    9d10:	dc 01       	movw	r26, r24
    9d12:	13 96       	adiw	r26, 0x03	; 3
    9d14:	2c 91       	ld	r18, X
    9d16:	13 97       	sbiw	r26, 0x03	; 3
    9d18:	28 60       	ori	r18, 0x08	; 8
    9d1a:	13 96       	adiw	r26, 0x03	; 3
    9d1c:	2c 93       	st	X, r18
    9d1e:	0e 94 6b 45 	call	0x8ad6	; 0x8ad6 <vfprintf>
    9d22:	d8 01       	movw	r26, r16
    9d24:	12 96       	adiw	r26, 0x02	; 2
    9d26:	ed 91       	ld	r30, X+
    9d28:	fc 91       	ld	r31, X
    9d2a:	13 97       	sbiw	r26, 0x03	; 3
    9d2c:	23 81       	ldd	r18, Z+3	; 0x03
    9d2e:	27 7f       	andi	r18, 0xF7	; 247
    9d30:	23 83       	std	Z+3, r18	; 0x03
    9d32:	df 91       	pop	r29
    9d34:	cf 91       	pop	r28
    9d36:	1f 91       	pop	r17
    9d38:	0f 91       	pop	r16
    9d3a:	08 95       	ret

00009d3c <puts>:
    9d3c:	0f 93       	push	r16
    9d3e:	1f 93       	push	r17
    9d40:	cf 93       	push	r28
    9d42:	df 93       	push	r29
    9d44:	e0 91 df 2d 	lds	r30, 0x2DDF	; 0x802ddf <__iob+0x2>
    9d48:	f0 91 e0 2d 	lds	r31, 0x2DE0	; 0x802de0 <__iob+0x3>
    9d4c:	23 81       	ldd	r18, Z+3	; 0x03
    9d4e:	21 ff       	sbrs	r18, 1
    9d50:	1b c0       	rjmp	.+54     	; 0x9d88 <puts+0x4c>
    9d52:	8c 01       	movw	r16, r24
    9d54:	d0 e0       	ldi	r29, 0x00	; 0
    9d56:	c0 e0       	ldi	r28, 0x00	; 0
    9d58:	f8 01       	movw	r30, r16
    9d5a:	81 91       	ld	r24, Z+
    9d5c:	8f 01       	movw	r16, r30
    9d5e:	60 91 df 2d 	lds	r22, 0x2DDF	; 0x802ddf <__iob+0x2>
    9d62:	70 91 e0 2d 	lds	r23, 0x2DE0	; 0x802de0 <__iob+0x3>
    9d66:	db 01       	movw	r26, r22
    9d68:	18 96       	adiw	r26, 0x08	; 8
    9d6a:	ed 91       	ld	r30, X+
    9d6c:	fc 91       	ld	r31, X
    9d6e:	19 97       	sbiw	r26, 0x09	; 9
    9d70:	88 23       	and	r24, r24
    9d72:	31 f0       	breq	.+12     	; 0x9d80 <puts+0x44>
    9d74:	19 95       	eicall
    9d76:	89 2b       	or	r24, r25
    9d78:	79 f3       	breq	.-34     	; 0x9d58 <puts+0x1c>
    9d7a:	df ef       	ldi	r29, 0xFF	; 255
    9d7c:	cf ef       	ldi	r28, 0xFF	; 255
    9d7e:	ec cf       	rjmp	.-40     	; 0x9d58 <puts+0x1c>
    9d80:	8a e0       	ldi	r24, 0x0A	; 10
    9d82:	19 95       	eicall
    9d84:	89 2b       	or	r24, r25
    9d86:	19 f0       	breq	.+6      	; 0x9d8e <puts+0x52>
    9d88:	8f ef       	ldi	r24, 0xFF	; 255
    9d8a:	9f ef       	ldi	r25, 0xFF	; 255
    9d8c:	02 c0       	rjmp	.+4      	; 0x9d92 <puts+0x56>
    9d8e:	8d 2f       	mov	r24, r29
    9d90:	9c 2f       	mov	r25, r28
    9d92:	df 91       	pop	r29
    9d94:	cf 91       	pop	r28
    9d96:	1f 91       	pop	r17
    9d98:	0f 91       	pop	r16
    9d9a:	08 95       	ret

00009d9c <sprintf>:
    9d9c:	0f 93       	push	r16
    9d9e:	1f 93       	push	r17
    9da0:	cf 93       	push	r28
    9da2:	df 93       	push	r29
    9da4:	cd b7       	in	r28, 0x3d	; 61
    9da6:	de b7       	in	r29, 0x3e	; 62
    9da8:	2e 97       	sbiw	r28, 0x0e	; 14
    9daa:	cd bf       	out	0x3d, r28	; 61
    9dac:	de bf       	out	0x3e, r29	; 62
    9dae:	0e 89       	ldd	r16, Y+22	; 0x16
    9db0:	1f 89       	ldd	r17, Y+23	; 0x17
    9db2:	86 e0       	ldi	r24, 0x06	; 6
    9db4:	8c 83       	std	Y+4, r24	; 0x04
    9db6:	09 83       	std	Y+1, r16	; 0x01
    9db8:	1a 83       	std	Y+2, r17	; 0x02
    9dba:	8f ef       	ldi	r24, 0xFF	; 255
    9dbc:	9f e7       	ldi	r25, 0x7F	; 127
    9dbe:	8d 83       	std	Y+5, r24	; 0x05
    9dc0:	9e 83       	std	Y+6, r25	; 0x06
    9dc2:	ae 01       	movw	r20, r28
    9dc4:	46 5e       	subi	r20, 0xE6	; 230
    9dc6:	5f 4f       	sbci	r21, 0xFF	; 255
    9dc8:	68 8d       	ldd	r22, Y+24	; 0x18
    9dca:	79 8d       	ldd	r23, Y+25	; 0x19
    9dcc:	ce 01       	movw	r24, r28
    9dce:	01 96       	adiw	r24, 0x01	; 1
    9dd0:	0e 94 6b 45 	call	0x8ad6	; 0x8ad6 <vfprintf>
    9dd4:	ef 81       	ldd	r30, Y+7	; 0x07
    9dd6:	f8 85       	ldd	r31, Y+8	; 0x08
    9dd8:	e0 0f       	add	r30, r16
    9dda:	f1 1f       	adc	r31, r17
    9ddc:	10 82       	st	Z, r1
    9dde:	2e 96       	adiw	r28, 0x0e	; 14
    9de0:	cd bf       	out	0x3d, r28	; 61
    9de2:	de bf       	out	0x3e, r29	; 62
    9de4:	df 91       	pop	r29
    9de6:	cf 91       	pop	r28
    9de8:	1f 91       	pop	r17
    9dea:	0f 91       	pop	r16
    9dec:	08 95       	ret

00009dee <__ultoa_invert>:
    9dee:	fa 01       	movw	r30, r20
    9df0:	aa 27       	eor	r26, r26
    9df2:	28 30       	cpi	r18, 0x08	; 8
    9df4:	51 f1       	breq	.+84     	; 0x9e4a <__ultoa_invert+0x5c>
    9df6:	20 31       	cpi	r18, 0x10	; 16
    9df8:	81 f1       	breq	.+96     	; 0x9e5a <__ultoa_invert+0x6c>
    9dfa:	e8 94       	clt
    9dfc:	6f 93       	push	r22
    9dfe:	6e 7f       	andi	r22, 0xFE	; 254
    9e00:	6e 5f       	subi	r22, 0xFE	; 254
    9e02:	7f 4f       	sbci	r23, 0xFF	; 255
    9e04:	8f 4f       	sbci	r24, 0xFF	; 255
    9e06:	9f 4f       	sbci	r25, 0xFF	; 255
    9e08:	af 4f       	sbci	r26, 0xFF	; 255
    9e0a:	b1 e0       	ldi	r27, 0x01	; 1
    9e0c:	3e d0       	rcall	.+124    	; 0x9e8a <__ultoa_invert+0x9c>
    9e0e:	b4 e0       	ldi	r27, 0x04	; 4
    9e10:	3c d0       	rcall	.+120    	; 0x9e8a <__ultoa_invert+0x9c>
    9e12:	67 0f       	add	r22, r23
    9e14:	78 1f       	adc	r23, r24
    9e16:	89 1f       	adc	r24, r25
    9e18:	9a 1f       	adc	r25, r26
    9e1a:	a1 1d       	adc	r26, r1
    9e1c:	68 0f       	add	r22, r24
    9e1e:	79 1f       	adc	r23, r25
    9e20:	8a 1f       	adc	r24, r26
    9e22:	91 1d       	adc	r25, r1
    9e24:	a1 1d       	adc	r26, r1
    9e26:	6a 0f       	add	r22, r26
    9e28:	71 1d       	adc	r23, r1
    9e2a:	81 1d       	adc	r24, r1
    9e2c:	91 1d       	adc	r25, r1
    9e2e:	a1 1d       	adc	r26, r1
    9e30:	20 d0       	rcall	.+64     	; 0x9e72 <__ultoa_invert+0x84>
    9e32:	09 f4       	brne	.+2      	; 0x9e36 <__ultoa_invert+0x48>
    9e34:	68 94       	set
    9e36:	3f 91       	pop	r19
    9e38:	2a e0       	ldi	r18, 0x0A	; 10
    9e3a:	26 9f       	mul	r18, r22
    9e3c:	11 24       	eor	r1, r1
    9e3e:	30 19       	sub	r19, r0
    9e40:	30 5d       	subi	r19, 0xD0	; 208
    9e42:	31 93       	st	Z+, r19
    9e44:	de f6       	brtc	.-74     	; 0x9dfc <__ultoa_invert+0xe>
    9e46:	cf 01       	movw	r24, r30
    9e48:	08 95       	ret
    9e4a:	46 2f       	mov	r20, r22
    9e4c:	47 70       	andi	r20, 0x07	; 7
    9e4e:	40 5d       	subi	r20, 0xD0	; 208
    9e50:	41 93       	st	Z+, r20
    9e52:	b3 e0       	ldi	r27, 0x03	; 3
    9e54:	0f d0       	rcall	.+30     	; 0x9e74 <__ultoa_invert+0x86>
    9e56:	c9 f7       	brne	.-14     	; 0x9e4a <__ultoa_invert+0x5c>
    9e58:	f6 cf       	rjmp	.-20     	; 0x9e46 <__ultoa_invert+0x58>
    9e5a:	46 2f       	mov	r20, r22
    9e5c:	4f 70       	andi	r20, 0x0F	; 15
    9e5e:	40 5d       	subi	r20, 0xD0	; 208
    9e60:	4a 33       	cpi	r20, 0x3A	; 58
    9e62:	18 f0       	brcs	.+6      	; 0x9e6a <__ultoa_invert+0x7c>
    9e64:	49 5d       	subi	r20, 0xD9	; 217
    9e66:	31 fd       	sbrc	r19, 1
    9e68:	40 52       	subi	r20, 0x20	; 32
    9e6a:	41 93       	st	Z+, r20
    9e6c:	02 d0       	rcall	.+4      	; 0x9e72 <__ultoa_invert+0x84>
    9e6e:	a9 f7       	brne	.-22     	; 0x9e5a <__ultoa_invert+0x6c>
    9e70:	ea cf       	rjmp	.-44     	; 0x9e46 <__ultoa_invert+0x58>
    9e72:	b4 e0       	ldi	r27, 0x04	; 4
    9e74:	a6 95       	lsr	r26
    9e76:	97 95       	ror	r25
    9e78:	87 95       	ror	r24
    9e7a:	77 95       	ror	r23
    9e7c:	67 95       	ror	r22
    9e7e:	ba 95       	dec	r27
    9e80:	c9 f7       	brne	.-14     	; 0x9e74 <__ultoa_invert+0x86>
    9e82:	00 97       	sbiw	r24, 0x00	; 0
    9e84:	61 05       	cpc	r22, r1
    9e86:	71 05       	cpc	r23, r1
    9e88:	08 95       	ret
    9e8a:	9b 01       	movw	r18, r22
    9e8c:	ac 01       	movw	r20, r24
    9e8e:	0a 2e       	mov	r0, r26
    9e90:	06 94       	lsr	r0
    9e92:	57 95       	ror	r21
    9e94:	47 95       	ror	r20
    9e96:	37 95       	ror	r19
    9e98:	27 95       	ror	r18
    9e9a:	ba 95       	dec	r27
    9e9c:	c9 f7       	brne	.-14     	; 0x9e90 <__ultoa_invert+0xa2>
    9e9e:	62 0f       	add	r22, r18
    9ea0:	73 1f       	adc	r23, r19
    9ea2:	84 1f       	adc	r24, r20
    9ea4:	95 1f       	adc	r25, r21
    9ea6:	a0 1d       	adc	r26, r0
    9ea8:	08 95       	ret

00009eaa <strtod>:
    9eaa:	8f 92       	push	r8
    9eac:	9f 92       	push	r9
    9eae:	af 92       	push	r10
    9eb0:	bf 92       	push	r11
    9eb2:	cf 92       	push	r12
    9eb4:	df 92       	push	r13
    9eb6:	ef 92       	push	r14
    9eb8:	ff 92       	push	r15
    9eba:	0f 93       	push	r16
    9ebc:	1f 93       	push	r17
    9ebe:	cf 93       	push	r28
    9ec0:	df 93       	push	r29
    9ec2:	ec 01       	movw	r28, r24
    9ec4:	6b 01       	movw	r12, r22
    9ec6:	61 15       	cp	r22, r1
    9ec8:	71 05       	cpc	r23, r1
    9eca:	19 f0       	breq	.+6      	; 0x9ed2 <strtod+0x28>
    9ecc:	fb 01       	movw	r30, r22
    9ece:	80 83       	st	Z, r24
    9ed0:	91 83       	std	Z+1, r25	; 0x01
    9ed2:	7e 01       	movw	r14, r28
    9ed4:	ff ef       	ldi	r31, 0xFF	; 255
    9ed6:	ef 1a       	sub	r14, r31
    9ed8:	ff 0a       	sbc	r15, r31
    9eda:	08 81       	ld	r16, Y
    9edc:	80 2f       	mov	r24, r16
    9ede:	90 e0       	ldi	r25, 0x00	; 0
    9ee0:	0e 94 b1 50 	call	0xa162	; 0xa162 <isspace>
    9ee4:	89 2b       	or	r24, r25
    9ee6:	11 f0       	breq	.+4      	; 0x9eec <strtod+0x42>
    9ee8:	e7 01       	movw	r28, r14
    9eea:	f3 cf       	rjmp	.-26     	; 0x9ed2 <strtod+0x28>
    9eec:	0d 32       	cpi	r16, 0x2D	; 45
    9eee:	39 f4       	brne	.+14     	; 0x9efe <strtod+0x54>
    9ef0:	7e 01       	movw	r14, r28
    9ef2:	82 e0       	ldi	r24, 0x02	; 2
    9ef4:	e8 0e       	add	r14, r24
    9ef6:	f1 1c       	adc	r15, r1
    9ef8:	09 81       	ldd	r16, Y+1	; 0x01
    9efa:	11 e0       	ldi	r17, 0x01	; 1
    9efc:	08 c0       	rjmp	.+16     	; 0x9f0e <strtod+0x64>
    9efe:	0b 32       	cpi	r16, 0x2B	; 43
    9f00:	29 f4       	brne	.+10     	; 0x9f0c <strtod+0x62>
    9f02:	7e 01       	movw	r14, r28
    9f04:	92 e0       	ldi	r25, 0x02	; 2
    9f06:	e9 0e       	add	r14, r25
    9f08:	f1 1c       	adc	r15, r1
    9f0a:	09 81       	ldd	r16, Y+1	; 0x01
    9f0c:	10 e0       	ldi	r17, 0x00	; 0
    9f0e:	e7 01       	movw	r28, r14
    9f10:	21 97       	sbiw	r28, 0x01	; 1
    9f12:	43 e0       	ldi	r20, 0x03	; 3
    9f14:	50 e0       	ldi	r21, 0x00	; 0
    9f16:	62 e4       	ldi	r22, 0x42	; 66
    9f18:	73 e0       	ldi	r23, 0x03	; 3
    9f1a:	ce 01       	movw	r24, r28
    9f1c:	0e 94 ba 50 	call	0xa174	; 0xa174 <strncasecmp_P>
    9f20:	89 2b       	or	r24, r25
    9f22:	c1 f4       	brne	.+48     	; 0x9f54 <strtod+0xaa>
    9f24:	23 96       	adiw	r28, 0x03	; 3
    9f26:	45 e0       	ldi	r20, 0x05	; 5
    9f28:	50 e0       	ldi	r21, 0x00	; 0
    9f2a:	6d e3       	ldi	r22, 0x3D	; 61
    9f2c:	73 e0       	ldi	r23, 0x03	; 3
    9f2e:	ce 01       	movw	r24, r28
    9f30:	0e 94 ba 50 	call	0xa174	; 0xa174 <strncasecmp_P>
    9f34:	89 2b       	or	r24, r25
    9f36:	09 f4       	brne	.+2      	; 0x9f3a <strtod+0x90>
    9f38:	25 96       	adiw	r28, 0x05	; 5
    9f3a:	c1 14       	cp	r12, r1
    9f3c:	d1 04       	cpc	r13, r1
    9f3e:	19 f0       	breq	.+6      	; 0x9f46 <strtod+0x9c>
    9f40:	f6 01       	movw	r30, r12
    9f42:	c0 83       	st	Z, r28
    9f44:	d1 83       	std	Z+1, r29	; 0x01
    9f46:	11 11       	cpse	r17, r1
    9f48:	f6 c0       	rjmp	.+492    	; 0xa136 <__stack+0x137>
    9f4a:	60 e0       	ldi	r22, 0x00	; 0
    9f4c:	70 e0       	ldi	r23, 0x00	; 0
    9f4e:	80 e8       	ldi	r24, 0x80	; 128
    9f50:	9f e7       	ldi	r25, 0x7F	; 127
    9f52:	fa c0       	rjmp	.+500    	; 0xa148 <__stack+0x149>
    9f54:	43 e0       	ldi	r20, 0x03	; 3
    9f56:	50 e0       	ldi	r21, 0x00	; 0
    9f58:	6a e3       	ldi	r22, 0x3A	; 58
    9f5a:	73 e0       	ldi	r23, 0x03	; 3
    9f5c:	ce 01       	movw	r24, r28
    9f5e:	0e 94 ba 50 	call	0xa174	; 0xa174 <strncasecmp_P>
    9f62:	89 2b       	or	r24, r25
    9f64:	59 f4       	brne	.+22     	; 0x9f7c <strtod+0xd2>
    9f66:	c1 14       	cp	r12, r1
    9f68:	d1 04       	cpc	r13, r1
    9f6a:	09 f4       	brne	.+2      	; 0x9f6e <strtod+0xc4>
    9f6c:	e9 c0       	rjmp	.+466    	; 0xa140 <__stack+0x141>
    9f6e:	f2 e0       	ldi	r31, 0x02	; 2
    9f70:	ef 0e       	add	r14, r31
    9f72:	f1 1c       	adc	r15, r1
    9f74:	f6 01       	movw	r30, r12
    9f76:	e0 82       	st	Z, r14
    9f78:	f1 82       	std	Z+1, r15	; 0x01
    9f7a:	e2 c0       	rjmp	.+452    	; 0xa140 <__stack+0x141>
    9f7c:	20 e0       	ldi	r18, 0x00	; 0
    9f7e:	30 e0       	ldi	r19, 0x00	; 0
    9f80:	a9 01       	movw	r20, r18
    9f82:	c0 e0       	ldi	r28, 0x00	; 0
    9f84:	d0 e0       	ldi	r29, 0x00	; 0
    9f86:	f7 01       	movw	r30, r14
    9f88:	60 ed       	ldi	r22, 0xD0	; 208
    9f8a:	a6 2e       	mov	r10, r22
    9f8c:	a0 0e       	add	r10, r16
    9f8e:	89 e0       	ldi	r24, 0x09	; 9
    9f90:	8a 15       	cp	r24, r10
    9f92:	30 f1       	brcs	.+76     	; 0x9fe0 <strtod+0x136>
    9f94:	91 2f       	mov	r25, r17
    9f96:	92 60       	ori	r25, 0x02	; 2
    9f98:	b9 2e       	mov	r11, r25
    9f9a:	81 2f       	mov	r24, r17
    9f9c:	88 70       	andi	r24, 0x08	; 8
    9f9e:	12 ff       	sbrs	r17, 2
    9fa0:	04 c0       	rjmp	.+8      	; 0x9faa <strtod+0x100>
    9fa2:	81 11       	cpse	r24, r1
    9fa4:	24 c0       	rjmp	.+72     	; 0x9fee <strtod+0x144>
    9fa6:	21 96       	adiw	r28, 0x01	; 1
    9fa8:	22 c0       	rjmp	.+68     	; 0x9fee <strtod+0x144>
    9faa:	81 11       	cpse	r24, r1
    9fac:	21 97       	sbiw	r28, 0x01	; 1
    9fae:	a5 e0       	ldi	r26, 0x05	; 5
    9fb0:	b0 e0       	ldi	r27, 0x00	; 0
    9fb2:	0e 94 64 49 	call	0x92c8	; 0x92c8 <__muluhisi3>
    9fb6:	dc 01       	movw	r26, r24
    9fb8:	cb 01       	movw	r24, r22
    9fba:	88 0f       	add	r24, r24
    9fbc:	99 1f       	adc	r25, r25
    9fbe:	aa 1f       	adc	r26, r26
    9fc0:	bb 1f       	adc	r27, r27
    9fc2:	9c 01       	movw	r18, r24
    9fc4:	ad 01       	movw	r20, r26
    9fc6:	2a 0d       	add	r18, r10
    9fc8:	31 1d       	adc	r19, r1
    9fca:	41 1d       	adc	r20, r1
    9fcc:	51 1d       	adc	r21, r1
    9fce:	28 39       	cpi	r18, 0x98	; 152
    9fd0:	89 e9       	ldi	r24, 0x99	; 153
    9fd2:	38 07       	cpc	r19, r24
    9fd4:	48 07       	cpc	r20, r24
    9fd6:	89 e1       	ldi	r24, 0x19	; 25
    9fd8:	58 07       	cpc	r21, r24
    9fda:	48 f0       	brcs	.+18     	; 0x9fee <strtod+0x144>
    9fdc:	16 60       	ori	r17, 0x06	; 6
    9fde:	06 c0       	rjmp	.+12     	; 0x9fec <strtod+0x142>
    9fe0:	9e ef       	ldi	r25, 0xFE	; 254
    9fe2:	a9 12       	cpse	r10, r25
    9fe4:	0a c0       	rjmp	.+20     	; 0x9ffa <strtod+0x150>
    9fe6:	13 fd       	sbrc	r17, 3
    9fe8:	40 c0       	rjmp	.+128    	; 0xa06a <__stack+0x6b>
    9fea:	18 60       	ori	r17, 0x08	; 8
    9fec:	b1 2e       	mov	r11, r17
    9fee:	8f ef       	ldi	r24, 0xFF	; 255
    9ff0:	e8 1a       	sub	r14, r24
    9ff2:	f8 0a       	sbc	r15, r24
    9ff4:	00 81       	ld	r16, Z
    9ff6:	1b 2d       	mov	r17, r11
    9ff8:	c6 cf       	rjmp	.-116    	; 0x9f86 <strtod+0xdc>
    9ffa:	80 2f       	mov	r24, r16
    9ffc:	8f 7d       	andi	r24, 0xDF	; 223
    9ffe:	85 34       	cpi	r24, 0x45	; 69
    a000:	a1 f5       	brne	.+104    	; 0xa06a <__stack+0x6b>
    a002:	80 81       	ld	r24, Z
    a004:	8d 32       	cpi	r24, 0x2D	; 45
    a006:	11 f4       	brne	.+4      	; 0xa00c <__stack+0xd>
    a008:	10 61       	ori	r17, 0x10	; 16
    a00a:	06 c0       	rjmp	.+12     	; 0xa018 <__stack+0x19>
    a00c:	8b 32       	cpi	r24, 0x2B	; 43
    a00e:	21 f0       	breq	.+8      	; 0xa018 <__stack+0x19>
    a010:	31 96       	adiw	r30, 0x01	; 1
    a012:	61 e0       	ldi	r22, 0x01	; 1
    a014:	70 e0       	ldi	r23, 0x00	; 0
    a016:	04 c0       	rjmp	.+8      	; 0xa020 <__stack+0x21>
    a018:	81 81       	ldd	r24, Z+1	; 0x01
    a01a:	32 96       	adiw	r30, 0x02	; 2
    a01c:	62 e0       	ldi	r22, 0x02	; 2
    a01e:	70 e0       	ldi	r23, 0x00	; 0
    a020:	80 53       	subi	r24, 0x30	; 48
    a022:	8a 30       	cpi	r24, 0x0A	; 10
    a024:	18 f0       	brcs	.+6      	; 0xa02c <__stack+0x2d>
    a026:	e6 1b       	sub	r30, r22
    a028:	f7 0b       	sbc	r31, r23
    a02a:	1f c0       	rjmp	.+62     	; 0xa06a <__stack+0x6b>
    a02c:	60 e0       	ldi	r22, 0x00	; 0
    a02e:	70 e0       	ldi	r23, 0x00	; 0
    a030:	60 38       	cpi	r22, 0x80	; 128
    a032:	9c e0       	ldi	r25, 0x0C	; 12
    a034:	79 07       	cpc	r23, r25
    a036:	5c f4       	brge	.+22     	; 0xa04e <__stack+0x4f>
    a038:	db 01       	movw	r26, r22
    a03a:	aa 0f       	add	r26, r26
    a03c:	bb 1f       	adc	r27, r27
    a03e:	aa 0f       	add	r26, r26
    a040:	bb 1f       	adc	r27, r27
    a042:	6a 0f       	add	r22, r26
    a044:	7b 1f       	adc	r23, r27
    a046:	66 0f       	add	r22, r22
    a048:	77 1f       	adc	r23, r23
    a04a:	68 0f       	add	r22, r24
    a04c:	71 1d       	adc	r23, r1
    a04e:	31 96       	adiw	r30, 0x01	; 1
    a050:	df 01       	movw	r26, r30
    a052:	11 97       	sbiw	r26, 0x01	; 1
    a054:	8c 91       	ld	r24, X
    a056:	80 53       	subi	r24, 0x30	; 48
    a058:	8a 30       	cpi	r24, 0x0A	; 10
    a05a:	50 f3       	brcs	.-44     	; 0xa030 <__stack+0x31>
    a05c:	14 ff       	sbrs	r17, 4
    a05e:	03 c0       	rjmp	.+6      	; 0xa066 <__stack+0x67>
    a060:	71 95       	neg	r23
    a062:	61 95       	neg	r22
    a064:	71 09       	sbc	r23, r1
    a066:	c6 0f       	add	r28, r22
    a068:	d7 1f       	adc	r29, r23
    a06a:	11 ff       	sbrs	r17, 1
    a06c:	08 c0       	rjmp	.+16     	; 0xa07e <__stack+0x7f>
    a06e:	c1 14       	cp	r12, r1
    a070:	d1 04       	cpc	r13, r1
    a072:	29 f0       	breq	.+10     	; 0xa07e <__stack+0x7f>
    a074:	cf 01       	movw	r24, r30
    a076:	01 97       	sbiw	r24, 0x01	; 1
    a078:	f6 01       	movw	r30, r12
    a07a:	80 83       	st	Z, r24
    a07c:	91 83       	std	Z+1, r25	; 0x01
    a07e:	ca 01       	movw	r24, r20
    a080:	b9 01       	movw	r22, r18
    a082:	0e 94 47 44 	call	0x888e	; 0x888e <__floatunsisf>
    a086:	21 2f       	mov	r18, r17
    a088:	23 70       	andi	r18, 0x03	; 3
    a08a:	23 30       	cpi	r18, 0x03	; 3
    a08c:	19 f0       	breq	.+6      	; 0xa094 <__stack+0x95>
    a08e:	4b 01       	movw	r8, r22
    a090:	5c 01       	movw	r10, r24
    a092:	06 c0       	rjmp	.+12     	; 0xa0a0 <__stack+0xa1>
    a094:	4b 01       	movw	r8, r22
    a096:	5c 01       	movw	r10, r24
    a098:	b7 fa       	bst	r11, 7
    a09a:	b0 94       	com	r11
    a09c:	b7 f8       	bld	r11, 7
    a09e:	b0 94       	com	r11
    a0a0:	20 e0       	ldi	r18, 0x00	; 0
    a0a2:	30 e0       	ldi	r19, 0x00	; 0
    a0a4:	a9 01       	movw	r20, r18
    a0a6:	c5 01       	movw	r24, r10
    a0a8:	b4 01       	movw	r22, r8
    a0aa:	0e 94 9a 43 	call	0x8734	; 0x8734 <__cmpsf2>
    a0ae:	88 23       	and	r24, r24
    a0b0:	09 f4       	brne	.+2      	; 0xa0b4 <__stack+0xb5>
    a0b2:	3e c0       	rjmp	.+124    	; 0xa130 <__stack+0x131>
    a0b4:	d7 ff       	sbrs	r29, 7
    a0b6:	06 c0       	rjmp	.+12     	; 0xa0c4 <__stack+0xc5>
    a0b8:	d1 95       	neg	r29
    a0ba:	c1 95       	neg	r28
    a0bc:	d1 09       	sbc	r29, r1
    a0be:	09 e5       	ldi	r16, 0x59	; 89
    a0c0:	13 e0       	ldi	r17, 0x03	; 3
    a0c2:	02 c0       	rjmp	.+4      	; 0xa0c8 <__stack+0xc9>
    a0c4:	01 e7       	ldi	r16, 0x71	; 113
    a0c6:	13 e0       	ldi	r17, 0x03	; 3
    a0c8:	68 01       	movw	r12, r16
    a0ca:	f8 e1       	ldi	r31, 0x18	; 24
    a0cc:	cf 1a       	sub	r12, r31
    a0ce:	d1 08       	sbc	r13, r1
    a0d0:	90 e2       	ldi	r25, 0x20	; 32
    a0d2:	e9 2e       	mov	r14, r25
    a0d4:	f1 2c       	mov	r15, r1
    a0d6:	ce 15       	cp	r28, r14
    a0d8:	df 05       	cpc	r29, r15
    a0da:	74 f0       	brlt	.+28     	; 0xa0f8 <__stack+0xf9>
    a0dc:	f8 01       	movw	r30, r16
    a0de:	25 91       	lpm	r18, Z+
    a0e0:	35 91       	lpm	r19, Z+
    a0e2:	45 91       	lpm	r20, Z+
    a0e4:	54 91       	lpm	r21, Z
    a0e6:	c5 01       	movw	r24, r10
    a0e8:	b4 01       	movw	r22, r8
    a0ea:	0e 94 fe 44 	call	0x89fc	; 0x89fc <__mulsf3>
    a0ee:	4b 01       	movw	r8, r22
    a0f0:	5c 01       	movw	r10, r24
    a0f2:	ce 19       	sub	r28, r14
    a0f4:	df 09       	sbc	r29, r15
    a0f6:	ef cf       	rjmp	.-34     	; 0xa0d6 <__stack+0xd7>
    a0f8:	04 50       	subi	r16, 0x04	; 4
    a0fa:	11 09       	sbc	r17, r1
    a0fc:	f5 94       	asr	r15
    a0fe:	e7 94       	ror	r14
    a100:	0c 15       	cp	r16, r12
    a102:	1d 05       	cpc	r17, r13
    a104:	41 f7       	brne	.-48     	; 0xa0d6 <__stack+0xd7>
    a106:	8a 2d       	mov	r24, r10
    a108:	88 0f       	add	r24, r24
    a10a:	8b 2d       	mov	r24, r11
    a10c:	88 1f       	adc	r24, r24
    a10e:	8f 3f       	cpi	r24, 0xFF	; 255
    a110:	49 f0       	breq	.+18     	; 0xa124 <__stack+0x125>
    a112:	20 e0       	ldi	r18, 0x00	; 0
    a114:	30 e0       	ldi	r19, 0x00	; 0
    a116:	a9 01       	movw	r20, r18
    a118:	c5 01       	movw	r24, r10
    a11a:	b4 01       	movw	r22, r8
    a11c:	0e 94 9a 43 	call	0x8734	; 0x8734 <__cmpsf2>
    a120:	81 11       	cpse	r24, r1
    a122:	06 c0       	rjmp	.+12     	; 0xa130 <__stack+0x131>
    a124:	82 e2       	ldi	r24, 0x22	; 34
    a126:	90 e0       	ldi	r25, 0x00	; 0
    a128:	80 93 e3 2d 	sts	0x2DE3, r24	; 0x802de3 <errno>
    a12c:	90 93 e4 2d 	sts	0x2DE4, r25	; 0x802de4 <errno+0x1>
    a130:	c5 01       	movw	r24, r10
    a132:	b4 01       	movw	r22, r8
    a134:	09 c0       	rjmp	.+18     	; 0xa148 <__stack+0x149>
    a136:	60 e0       	ldi	r22, 0x00	; 0
    a138:	70 e0       	ldi	r23, 0x00	; 0
    a13a:	80 e8       	ldi	r24, 0x80	; 128
    a13c:	9f ef       	ldi	r25, 0xFF	; 255
    a13e:	04 c0       	rjmp	.+8      	; 0xa148 <__stack+0x149>
    a140:	60 e0       	ldi	r22, 0x00	; 0
    a142:	70 e0       	ldi	r23, 0x00	; 0
    a144:	80 ec       	ldi	r24, 0xC0	; 192
    a146:	9f e7       	ldi	r25, 0x7F	; 127
    a148:	df 91       	pop	r29
    a14a:	cf 91       	pop	r28
    a14c:	1f 91       	pop	r17
    a14e:	0f 91       	pop	r16
    a150:	ff 90       	pop	r15
    a152:	ef 90       	pop	r14
    a154:	df 90       	pop	r13
    a156:	cf 90       	pop	r12
    a158:	bf 90       	pop	r11
    a15a:	af 90       	pop	r10
    a15c:	9f 90       	pop	r9
    a15e:	8f 90       	pop	r8
    a160:	08 95       	ret

0000a162 <isspace>:
    a162:	91 11       	cpse	r25, r1
    a164:	0c 94 10 51 	jmp	0xa220	; 0xa220 <__ctype_isfalse>
    a168:	80 32       	cpi	r24, 0x20	; 32
    a16a:	19 f0       	breq	.+6      	; 0xa172 <isspace+0x10>
    a16c:	89 50       	subi	r24, 0x09	; 9
    a16e:	85 50       	subi	r24, 0x05	; 5
    a170:	c8 f7       	brcc	.-14     	; 0xa164 <isspace+0x2>
    a172:	08 95       	ret

0000a174 <strncasecmp_P>:
    a174:	fb 01       	movw	r30, r22
    a176:	dc 01       	movw	r26, r24
    a178:	41 50       	subi	r20, 0x01	; 1
    a17a:	50 40       	sbci	r21, 0x00	; 0
    a17c:	88 f0       	brcs	.+34     	; 0xa1a0 <strncasecmp_P+0x2c>
    a17e:	8d 91       	ld	r24, X+
    a180:	81 34       	cpi	r24, 0x41	; 65
    a182:	1c f0       	brlt	.+6      	; 0xa18a <strncasecmp_P+0x16>
    a184:	8b 35       	cpi	r24, 0x5B	; 91
    a186:	0c f4       	brge	.+2      	; 0xa18a <strncasecmp_P+0x16>
    a188:	80 5e       	subi	r24, 0xE0	; 224
    a18a:	65 91       	lpm	r22, Z+
    a18c:	61 34       	cpi	r22, 0x41	; 65
    a18e:	1c f0       	brlt	.+6      	; 0xa196 <strncasecmp_P+0x22>
    a190:	6b 35       	cpi	r22, 0x5B	; 91
    a192:	0c f4       	brge	.+2      	; 0xa196 <strncasecmp_P+0x22>
    a194:	60 5e       	subi	r22, 0xE0	; 224
    a196:	86 1b       	sub	r24, r22
    a198:	61 11       	cpse	r22, r1
    a19a:	71 f3       	breq	.-36     	; 0xa178 <strncasecmp_P+0x4>
    a19c:	99 0b       	sbc	r25, r25
    a19e:	08 95       	ret
    a1a0:	88 1b       	sub	r24, r24
    a1a2:	fc cf       	rjmp	.-8      	; 0xa19c <strncasecmp_P+0x28>

0000a1a4 <fgetc>:
    a1a4:	cf 93       	push	r28
    a1a6:	df 93       	push	r29
    a1a8:	ec 01       	movw	r28, r24
    a1aa:	2b 81       	ldd	r18, Y+3	; 0x03
    a1ac:	20 ff       	sbrs	r18, 0
    a1ae:	33 c0       	rjmp	.+102    	; 0xa216 <fgetc+0x72>
    a1b0:	26 ff       	sbrs	r18, 6
    a1b2:	0a c0       	rjmp	.+20     	; 0xa1c8 <fgetc+0x24>
    a1b4:	2f 7b       	andi	r18, 0xBF	; 191
    a1b6:	2b 83       	std	Y+3, r18	; 0x03
    a1b8:	8e 81       	ldd	r24, Y+6	; 0x06
    a1ba:	9f 81       	ldd	r25, Y+7	; 0x07
    a1bc:	01 96       	adiw	r24, 0x01	; 1
    a1be:	8e 83       	std	Y+6, r24	; 0x06
    a1c0:	9f 83       	std	Y+7, r25	; 0x07
    a1c2:	8a 81       	ldd	r24, Y+2	; 0x02
    a1c4:	90 e0       	ldi	r25, 0x00	; 0
    a1c6:	29 c0       	rjmp	.+82     	; 0xa21a <fgetc+0x76>
    a1c8:	22 ff       	sbrs	r18, 2
    a1ca:	0f c0       	rjmp	.+30     	; 0xa1ea <fgetc+0x46>
    a1cc:	e8 81       	ld	r30, Y
    a1ce:	f9 81       	ldd	r31, Y+1	; 0x01
    a1d0:	80 81       	ld	r24, Z
    a1d2:	08 2e       	mov	r0, r24
    a1d4:	00 0c       	add	r0, r0
    a1d6:	99 0b       	sbc	r25, r25
    a1d8:	00 97       	sbiw	r24, 0x00	; 0
    a1da:	19 f4       	brne	.+6      	; 0xa1e2 <fgetc+0x3e>
    a1dc:	20 62       	ori	r18, 0x20	; 32
    a1de:	2b 83       	std	Y+3, r18	; 0x03
    a1e0:	1a c0       	rjmp	.+52     	; 0xa216 <fgetc+0x72>
    a1e2:	31 96       	adiw	r30, 0x01	; 1
    a1e4:	e8 83       	st	Y, r30
    a1e6:	f9 83       	std	Y+1, r31	; 0x01
    a1e8:	0e c0       	rjmp	.+28     	; 0xa206 <fgetc+0x62>
    a1ea:	ea 85       	ldd	r30, Y+10	; 0x0a
    a1ec:	fb 85       	ldd	r31, Y+11	; 0x0b
    a1ee:	19 95       	eicall
    a1f0:	97 ff       	sbrs	r25, 7
    a1f2:	09 c0       	rjmp	.+18     	; 0xa206 <fgetc+0x62>
    a1f4:	2b 81       	ldd	r18, Y+3	; 0x03
    a1f6:	01 96       	adiw	r24, 0x01	; 1
    a1f8:	11 f0       	breq	.+4      	; 0xa1fe <fgetc+0x5a>
    a1fa:	80 e2       	ldi	r24, 0x20	; 32
    a1fc:	01 c0       	rjmp	.+2      	; 0xa200 <fgetc+0x5c>
    a1fe:	80 e1       	ldi	r24, 0x10	; 16
    a200:	82 2b       	or	r24, r18
    a202:	8b 83       	std	Y+3, r24	; 0x03
    a204:	08 c0       	rjmp	.+16     	; 0xa216 <fgetc+0x72>
    a206:	2e 81       	ldd	r18, Y+6	; 0x06
    a208:	3f 81       	ldd	r19, Y+7	; 0x07
    a20a:	2f 5f       	subi	r18, 0xFF	; 255
    a20c:	3f 4f       	sbci	r19, 0xFF	; 255
    a20e:	2e 83       	std	Y+6, r18	; 0x06
    a210:	3f 83       	std	Y+7, r19	; 0x07
    a212:	99 27       	eor	r25, r25
    a214:	02 c0       	rjmp	.+4      	; 0xa21a <fgetc+0x76>
    a216:	8f ef       	ldi	r24, 0xFF	; 255
    a218:	9f ef       	ldi	r25, 0xFF	; 255
    a21a:	df 91       	pop	r29
    a21c:	cf 91       	pop	r28
    a21e:	08 95       	ret

0000a220 <__ctype_isfalse>:
    a220:	99 27       	eor	r25, r25
    a222:	88 27       	eor	r24, r24

0000a224 <__ctype_istrue>:
    a224:	08 95       	ret

0000a226 <_exit>:
    a226:	f8 94       	cli

0000a228 <__stop_program>:
    a228:	ff cf       	rjmp	.-2      	; 0xa228 <__stop_program>
