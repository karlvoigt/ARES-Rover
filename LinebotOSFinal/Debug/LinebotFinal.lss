
LinebotFinal.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000a016  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000826  00802000  0000a016  0000a0aa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000575  00802826  00802826  0000a8d0  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  0000a8d0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000a92c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000b38  00000000  00000000  0000a96c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001a384  00000000  00000000  0000b4a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000065a9  00000000  00000000  00025828  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000995b  00000000  00000000  0002bdd1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00002868  00000000  00000000  0003572c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005af8  00000000  00000000  00037f94  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00010ed9  00000000  00000000  0003da8c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000f40  00000000  00000000  0004e965  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 6e 03 	jmp	0x6dc	; 0x6dc <__ctors_end>
       4:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
       8:	0c 94 9b 07 	jmp	0xf36	; 0xf36 <__vector_2>
       c:	0c 94 22 08 	jmp	0x1044	; 0x1044 <__vector_3>
      10:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      14:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      18:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      1c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      20:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      24:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      28:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      2c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      30:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      34:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      38:	0c 94 fe 1d 	jmp	0x3bfc	; 0x3bfc <__vector_14>
      3c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      40:	0c 94 72 1e 	jmp	0x3ce4	; 0x3ce4 <__vector_16>
      44:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      48:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      4c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      50:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      54:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      58:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      5c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      60:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      64:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      68:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      6c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      70:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      74:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      78:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      7c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      80:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      84:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      88:	0c 94 5d 05 	jmp	0xaba	; 0xaba <__vector_34>
      8c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      90:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      94:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      98:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      9c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      a0:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      a4:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      a8:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      ac:	0c 94 a9 08 	jmp	0x1152	; 0x1152 <__vector_43>
      b0:	0c 94 30 09 	jmp	0x1260	; 0x1260 <__vector_44>
      b4:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      b8:	0c 94 1f 10 	jmp	0x203e	; 0x203e <__vector_46>
      bc:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      c0:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      c4:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      c8:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      cc:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      d0:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      d4:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      d8:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      dc:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      e0:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      e4:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      e8:	0c 94 3f 11 	jmp	0x227e	; 0x227e <__vector_58>
      ec:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      f0:	0c 94 f8 10 	jmp	0x21f0	; 0x21f0 <__vector_60>
      f4:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      f8:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
      fc:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     100:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     104:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     108:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     10c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     110:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     114:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     118:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     11c:	0c 94 0f 04 	jmp	0x81e	; 0x81e <__vector_71>
     120:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     124:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     128:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     12c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     130:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     134:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     138:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     13c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     140:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     144:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     148:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     14c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     150:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     154:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     158:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     15c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     160:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     164:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     168:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     16c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     170:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     174:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     178:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     17c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     180:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     184:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     188:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     18c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     190:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     194:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     198:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     19c:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1a0:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1a4:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1a8:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1ac:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1b0:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1b4:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1b8:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1bc:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1c0:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1c4:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1c8:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1cc:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1d0:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1d4:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1d8:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1dc:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1e0:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1e4:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1e8:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1ec:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1f0:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1f4:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>
     1f8:	0c 94 8f 03 	jmp	0x71e	; 0x71e <__bad_interrupt>

000001fc <__trampolines_start>:
     1fc:	0c 94 89 10 	jmp	0x2112	; 0x2112 <stdio_getchar>
     200:	0c 94 36 32 	jmp	0x646c	; 0x646c <WorkerLineFollowerDirect>
     204:	0c 94 9f 10 	jmp	0x213e	; 0x213e <stdio_putchar>
     208:	0c 94 8b 3e 	jmp	0x7d16	; 0x7d16 <WorkerRGB>
     20c:	0c 94 85 3f 	jmp	0x7f0a	; 0x7f0a <WorkerTerminal>
     210:	0c 94 2f 38 	jmp	0x705e	; 0x705e <WorkerMotorSpeed>
     214:	0c 94 71 36 	jmp	0x6ce2	; 0x6ce2 <WorkerMotorPos>
     218:	0c 94 3c 3f 	jmp	0x7e78	; 0x7e78 <WorkerStartup>
     21c:	0c 94 d5 32 	jmp	0x65aa	; 0x65aa <WorkerLineFollowerSpeed>
     220:	0c 94 29 30 	jmp	0x6052	; 0x6052 <cmpfunc>
     224:	0c 94 ac 2a 	jmp	0x5558	; 0x5558 <prvIdleTask>
     228:	0c 94 7c 31 	jmp	0x62f8	; 0x62f8 <WorkerADC>
     22c:	0c 94 ab 33 	jmp	0x6756	; 0x6756 <WorkerMotion>
     230:	0c 94 0d 3e 	jmp	0x7c1a	; 0x7c1a <WorkerOLEDMenu>

00000234 <__trampolines_end>:
     234:	6e 61       	ori	r22, 0x1E	; 30
     236:	6e 00       	.word	0x006e	; ????

00000238 <__c.2332>:
     238:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     248:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     258:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     268:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     278:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     288:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     298:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     2a8:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     2b8:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     2c8:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     2d8:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     2e8:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     2f8:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     308:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     318:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     328:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

00000336 <pstr_nan>:
     336:	4e 41 4e                                            NAN

00000339 <pstr_inity>:
     339:	49 4e 49 54 59                                      INITY

0000033e <pstr_inf>:
     33e:	49 4e 46                                            INF

00000341 <pwr_m10>:
     341:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     351:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

00000359 <pwr_p10>:
     359:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     369:	ca 1b 0e 5a ae c5 9d 74                             ...Z...t

00000371 <__c.4869>:
     371:	73 6c 65 65 70 20 3a 65 6e 74 65 72 20 73 6c 65     sleep :enter sle
     381:	65 70 20 6d 6f 64 65 0d 0a 00                       ep mode...

0000038b <__c.4867>:
     38b:	61 75 78 70 77 72 20 73 74 61 74 65 3a 27 73 74     auxpwr state:'st
     39b:	61 74 65 27 3d 31 3a 20 74 75 72 6e 20 6f 6e 20     ate'=1: turn on 
     3ab:	61 75 78 20 70 6f 77 65 72 20 6e 65 74 2c 20 27     aux power net, '
     3bb:	73 74 61 74 65 27 3d 30 3a 20 74 75 72 6e 20 6f     state'=0: turn o
     3cb:	66 66 20 61 75 78 20 70 6f 77 65 72 20 6e 65 74     ff aux power net
     3db:	0d 0a 00                                            ...

000003de <__c.4865>:
     3de:	67 65 74 61 64 63 20 3a 72 65 74 75 72 6e 73 20     getadc :returns 
     3ee:	41 6e 61 6c 6f 67 20 63 68 61 6e 6e 65 6c 73 20     Analog channels 
     3fe:	69 6e 20 66 6f 72 6d 61 74 20 27 6c 65 66 74 5f     in format 'left_
     40e:	6c 69 6e 65 5f 73 65 6e 73 6f 72 20 6d 69 64 5f     line_sensor mid_
     41e:	6c 69 6e 65 5f 73 65 6e 73 6f 72 20 72 69 67 68     line_sensor righ
     42e:	74 5f 6c 69 6e 65 5f 73 65 6e 73 6f 72 20 70 6f     t_line_sensor po
     43e:	74 65 6e 74 69 6f 6d 65 74 65 72 0d 0a 00           tentiometer...

0000044c <__c.4863>:
     44c:	67 65 74 67 79 72 20 3a 72 65 74 75 72 6e 73 20     getgyr :returns 
     45c:	67 79 72 6f 73 63 6f 70 65 20 69 6e 66 6f 20 69     gyroscope info i
     46c:	6e 20 66 6f 72 6d 61 74 20 27 79 61 77 72 61 74     n format 'yawrat
     47c:	65 20 28 64 65 67 2f 73 29 20 79 61 77 28 64 65     e (deg/s) yaw(de
     48c:	67 29 0d 0a 00                                      g)...

00000491 <__c.4861>:
     491:	67 65 74 72 67 62 20 3a 72 65 74 75 72 6e 73 20     getrgb :returns 
     4a1:	52 47 42 20 6c 69 67 68 74 20 73 65 6e 73 6f 72     RGB light sensor
     4b1:	20 76 61 6c 75 65 73 0d 0a 00                        values...

000004bb <__c.4859>:
     4bb:	67 65 74 65 6e 63 20 3a 67 65 74 20 6d 6f 74 6f     getenc :get moto
     4cb:	72 20 65 6e 63 6f 64 65 72 20 76 61 6c 75 65 73     r encoder values
     4db:	0d 0a 00                                            ...

000004de <__c.4857>:
     4de:	73 65 74 6d 6f 74 20 6c 65 66 74 6d 6f 74 6f 72     setmot leftmotor
     4ee:	5f 70 77 6d 20 72 69 67 68 74 6d 6f 74 6f 72 5f     _pwm rightmotor_
     4fe:	70 77 6d 20 3a 64 69 72 65 63 74 6c 79 20 63 6f     pwm :directly co
     50e:	6e 74 72 6f 6c 20 6d 6f 74 6f 72 20 70 77 6d 20     ntrol motor pwm 
     51e:	73 69 67 6e 61 6c 2e 20 50 77 6d 20 69 73 20 69     signal. Pwm is i
     52e:	6e 20 61 20 72 61 6e 67 65 20 6f 66 20 2d 34 30     n a range of -40
     53e:	39 35 20 74 6f 20 34 30 39 35 0d 0a 00              95 to 4095...

0000054b <__c.4855>:
     54b:	73 65 74 6c 65 64 20 65 66 66 65 63 74 20 3a 73     setled effect :s
     55b:	65 74 20 52 47 42 20 6c 65 64 20 65 66 66 65 63     et RGB led effec
     56b:	74 20 28 73 65 65 20 52 47 42 54 61 73 6b 2e 68     t (see RGBTask.h
     57b:	29 0d 0a 00                                         )...

0000057f <__c.4853>:
     57f:	64 72 76 73 65 67 20 73 70 65 65 64 20 3a 66 6f     drvseg speed :fo
     58f:	6c 6c 6f 77 20 6c 69 6e 65 20 73 65 67 6d 65 6e     llow line segmen
     59f:	74 20 75 6e 74 69 6c 20 65 6e 64 20 61 74 20 61     t until end at a
     5af:	20 73 70 65 65 64 20 6f 66 20 27 73 70 65 65 64      speed of 'speed
     5bf:	27 20 6d 6d 2f 73 0d 0a 00                          ' mm/s...

000005c8 <__c.4851>:
     5c8:	72 6f 74 63 74 72 20 61 6e 67 6c 65 20 73 70 65     rotctr angle spe
     5d8:	65 64 20 3a 72 6f 74 61 74 65 20 27 61 6e 67 6c     ed :rotate 'angl
     5e8:	65 27 20 64 65 67 72 65 65 73 20 61 72 6f 75 6e     e' degrees aroun
     5f8:	64 20 63 65 6e 74 65 72 20 6f 66 20 72 6f 62 6f     d center of robo
     608:	74 20 61 74 20 61 20 73 70 65 65 64 20 6f 66 20     t at a speed of 
     618:	27 73 70 65 65 64 27 20 6d 6d 2f 73 0d 0a 00        'speed' mm/s...

00000627 <__c.4849>:
     627:	64 72 76 73 74 72 20 64 69 73 74 61 6e 63 65 20     drvstr distance 
     637:	73 70 65 65 64 20 3a 44 72 69 76 65 20 73 74 72     speed :Drive str
     647:	61 69 67 68 74 20 6f 76 65 72 20 27 64 69 73 74     aight over 'dist
     657:	61 6e 63 65 27 20 6d 6d 20 61 74 20 61 20 73 70     ance' mm at a sp
     667:	65 65 64 20 6f 66 20 27 73 70 65 65 64 27 20 6d     eed of 'speed' m
     677:	6d 2f 73 0d 0a 00                                   m/s...

0000067d <__c.4847>:
     67d:	6d 65 6d 6d 61 70 20 3a 73 68 6f 77 20 6d 65 6d     memmap :show mem
     68d:	6f 72 79 20 6d 61 70 0d 0a 00                       ory map...

00000697 <__c.4845>:
     697:	74 73 6b 6c 73 74 20 3a 6c 69 73 74 20 46 72 65     tsklst :list Fre
     6a7:	65 52 54 4f 53 20 74 61 73 6b 73 0d 0a 00           eRTOS tasks...

000006b5 <__c.4843>:
     6b5:	68 65 6c 70 20 3a 74 68 69 73 20 68 65 6c 70 20     help :this help 
     6c5:	70 61 67 65 0d 0a 00                                page...

000006cc <__c.4841>:
     6cc:	43 6f 6d 6d 61 6e 64 20 6c 69 73 74 3a 0d 0a 00     Command list:...

000006dc <__ctors_end>:
     6dc:	11 24       	eor	r1, r1
     6de:	1f be       	out	0x3f, r1	; 63
     6e0:	cf ef       	ldi	r28, 0xFF	; 255
     6e2:	cd bf       	out	0x3d, r28	; 61
     6e4:	df e9       	ldi	r29, 0x9F	; 159
     6e6:	de bf       	out	0x3e, r29	; 62
     6e8:	00 e0       	ldi	r16, 0x00	; 0
     6ea:	0c bf       	out	0x3c, r16	; 60

000006ec <__do_copy_data>:
     6ec:	18 e2       	ldi	r17, 0x28	; 40
     6ee:	a0 e0       	ldi	r26, 0x00	; 0
     6f0:	b0 e2       	ldi	r27, 0x20	; 32
     6f2:	e6 e1       	ldi	r30, 0x16	; 22
     6f4:	f0 ea       	ldi	r31, 0xA0	; 160
     6f6:	00 e0       	ldi	r16, 0x00	; 0
     6f8:	0b bf       	out	0x3b, r16	; 59
     6fa:	02 c0       	rjmp	.+4      	; 0x700 <__do_copy_data+0x14>
     6fc:	07 90       	elpm	r0, Z+
     6fe:	0d 92       	st	X+, r0
     700:	a6 32       	cpi	r26, 0x26	; 38
     702:	b1 07       	cpc	r27, r17
     704:	d9 f7       	brne	.-10     	; 0x6fc <__do_copy_data+0x10>

00000706 <__do_clear_bss>:
     706:	2d e2       	ldi	r18, 0x2D	; 45
     708:	a6 e2       	ldi	r26, 0x26	; 38
     70a:	b8 e2       	ldi	r27, 0x28	; 40
     70c:	01 c0       	rjmp	.+2      	; 0x710 <.do_clear_bss_start>

0000070e <.do_clear_bss_loop>:
     70e:	1d 92       	st	X+, r1

00000710 <.do_clear_bss_start>:
     710:	ab 39       	cpi	r26, 0x9B	; 155
     712:	b2 07       	cpc	r27, r18
     714:	e1 f7       	brne	.-8      	; 0x70e <.do_clear_bss_loop>
     716:	0e 94 11 30 	call	0x6022	; 0x6022 <main>
     71a:	0c 94 09 50 	jmp	0xa012	; 0xa012 <_exit>

0000071e <__bad_interrupt>:
     71e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000722 <DriverAdcInit>:
SemaphoreHandle_t AdcBusySema;					//Semaphore is taken when an ADC acquisition is performed
SemaphoreHandle_t ConversionCompleteSema;	//Semaphore used to signal completion of an ADC conversion

void DriverAdcInit(void)
{
	ADCA.CTRLA=0b00000001; //Enable ADC
     722:	e0 e0       	ldi	r30, 0x00	; 0
     724:	f2 e0       	ldi	r31, 0x02	; 2
     726:	81 e0       	ldi	r24, 0x01	; 1
     728:	80 83       	st	Z, r24
	ADCA.CTRLB=0b00000110; //Manual mode, 12 bit right justified
     72a:	96 e0       	ldi	r25, 0x06	; 6
     72c:	91 83       	std	Z+1, r25	; 0x01
	ADCA.REFCTRL=0b00000010; //1.00V internal reference, enable bandgap
     72e:	92 e0       	ldi	r25, 0x02	; 2
     730:	92 83       	std	Z+2, r25	; 0x02
	ADCA.PRESCALER=0b00000011; //DIV32; 1MHz ADCClk. Should be lower than 1,8MHz per spec
     732:	93 e0       	ldi	r25, 0x03	; 3
     734:	94 83       	std	Z+4, r25	; 0x04
	ADCA.CH0.INTCTRL=0b01; //Lo pri int
     736:	82 a3       	std	Z+34, r24	; 0x22
	
	AdcBusySema=xSemaphoreCreateBinary();
     738:	43 e0       	ldi	r20, 0x03	; 3
     73a:	60 e0       	ldi	r22, 0x00	; 0
     73c:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <xQueueGenericCreate>
     740:	80 93 75 2d 	sts	0x2D75, r24	; 0x802d75 <AdcBusySema>
     744:	90 93 76 2d 	sts	0x2D76, r25	; 0x802d76 <AdcBusySema+0x1>
	ConversionCompleteSema=xSemaphoreCreateBinary();
     748:	43 e0       	ldi	r20, 0x03	; 3
     74a:	60 e0       	ldi	r22, 0x00	; 0
     74c:	81 e0       	ldi	r24, 0x01	; 1
     74e:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <xQueueGenericCreate>
     752:	80 93 73 2d 	sts	0x2D73, r24	; 0x802d73 <ConversionCompleteSema>
     756:	90 93 74 2d 	sts	0x2D74, r25	; 0x802d74 <ConversionCompleteSema+0x1>
	xSemaphoreGive(AdcBusySema);		
     75a:	20 e0       	ldi	r18, 0x00	; 0
     75c:	40 e0       	ldi	r20, 0x00	; 0
     75e:	50 e0       	ldi	r21, 0x00	; 0
     760:	60 e0       	ldi	r22, 0x00	; 0
     762:	70 e0       	ldi	r23, 0x00	; 0
     764:	80 91 75 2d 	lds	r24, 0x2D75	; 0x802d75 <AdcBusySema>
     768:	90 91 76 2d 	lds	r25, 0x2D76	; 0x802d76 <AdcBusySema+0x1>
     76c:	0c 94 27 20 	jmp	0x404e	; 0x404e <xQueueGenericSend>

00000770 <DriverAdcGetCh>:
}

int16_t DriverAdcGetCh(int8_t PinPos,int8_t PinNeg)
{
     770:	cf 93       	push	r28
     772:	df 93       	push	r29
     774:	c8 2f       	mov	r28, r24
     776:	d6 2f       	mov	r29, r22
	int16_t Res;
	
	xSemaphoreTake(AdcBusySema,portMAX_DELAY);
     778:	6f ef       	ldi	r22, 0xFF	; 255
     77a:	7f ef       	ldi	r23, 0xFF	; 255
     77c:	80 91 75 2d 	lds	r24, 0x2D75	; 0x802d75 <AdcBusySema>
     780:	90 91 76 2d 	lds	r25, 0x2D76	; 0x802d76 <AdcBusySema+0x1>
     784:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <xQueueSemaphoreTake>
	
	//Configure channels
	if (PinPos<16 && PinPos>=0)
     788:	c0 31       	cpi	r28, 0x10	; 16
     78a:	28 f0       	brcs	.+10     	; 0x796 <DriverAdcGetCh+0x26>
		ADCA.CH0.MUXCTRL=PinPos<<3;
	else
		return 10000; //Invalid settings
     78c:	80 e1       	ldi	r24, 0x10	; 16
     78e:	97 e2       	ldi	r25, 0x27	; 39
	
	xSemaphoreTake(ConversionCompleteSema,portMAX_DELAY);
	Res=ADCA.CH0.RES;
	xSemaphoreGive(AdcBusySema);
	return Res;
}
     790:	df 91       	pop	r29
     792:	cf 91       	pop	r28
     794:	08 95       	ret
	
	xSemaphoreTake(AdcBusySema,portMAX_DELAY);
	
	//Configure channels
	if (PinPos<16 && PinPos>=0)
		ADCA.CH0.MUXCTRL=PinPos<<3;
     796:	cc 0f       	add	r28, r28
     798:	cc 0f       	add	r28, r28
     79a:	cc 0f       	add	r28, r28
     79c:	c0 93 21 02 	sts	0x0221, r28	; 0x800221 <__TEXT_REGION_LENGTH__+0x700221>
	else
		return 10000; //Invalid settings

	if (PinNeg==-1) 
     7a0:	df 3f       	cpi	r29, 0xFF	; 255
     7a2:	a1 f1       	breq	.+104    	; 0x80c <DriverAdcGetCh+0x9c>
		{			
		ADCA.CH0.CTRL=0b00000001; //Single ended mode, no gain
		ADCA.CTRLB&=~0b00010000;  //Unsigned mode		
		}		
	else if (PinNeg>=0 && PinNeg<4)
     7a4:	d4 30       	cpi	r29, 0x04	; 4
     7a6:	68 f5       	brcc	.+90     	; 0x802 <DriverAdcGetCh+0x92>
		{			
		ADCA.CH0.CTRL=0b00000010; //Differential mode, no gain
     7a8:	82 e0       	ldi	r24, 0x02	; 2
		ADCA.CTRLB|=0b00010000;   //Signed mode
		ADCA.CH0.MUXCTRL|=PinNeg;
		}						
	else if (PinNeg>=4 && PinNeg<8)
		{
		ADCA.CH0.CTRL=0b00011111; //Differential mode, div 2
     7aa:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
		ADCA.CTRLB|=0b00010000;
     7ae:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
     7b2:	80 61       	ori	r24, 0x10	; 16
     7b4:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
		ADCA.CH0.MUXCTRL|=(PinNeg-4);	
     7b8:	80 91 21 02 	lds	r24, 0x0221	; 0x800221 <__TEXT_REGION_LENGTH__+0x700221>
     7bc:	d8 2b       	or	r29, r24
     7be:	d0 93 21 02 	sts	0x0221, r29	; 0x800221 <__TEXT_REGION_LENGTH__+0x700221>
		}
	else return 10000; //Invalid settings
	
	//Start measurement
	ADCA.CH0.CTRL|=0b10000000; //Start conversion
     7c2:	80 91 20 02 	lds	r24, 0x0220	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
     7c6:	80 68       	ori	r24, 0x80	; 128
     7c8:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
	
	xSemaphoreTake(ConversionCompleteSema,portMAX_DELAY);
     7cc:	6f ef       	ldi	r22, 0xFF	; 255
     7ce:	7f ef       	ldi	r23, 0xFF	; 255
     7d0:	80 91 73 2d 	lds	r24, 0x2D73	; 0x802d73 <ConversionCompleteSema>
     7d4:	90 91 74 2d 	lds	r25, 0x2D74	; 0x802d74 <ConversionCompleteSema+0x1>
     7d8:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <xQueueSemaphoreTake>
	Res=ADCA.CH0.RES;
     7dc:	c0 91 24 02 	lds	r28, 0x0224	; 0x800224 <__TEXT_REGION_LENGTH__+0x700224>
     7e0:	d0 91 25 02 	lds	r29, 0x0225	; 0x800225 <__TEXT_REGION_LENGTH__+0x700225>
	xSemaphoreGive(AdcBusySema);
     7e4:	20 e0       	ldi	r18, 0x00	; 0
     7e6:	40 e0       	ldi	r20, 0x00	; 0
     7e8:	50 e0       	ldi	r21, 0x00	; 0
     7ea:	60 e0       	ldi	r22, 0x00	; 0
     7ec:	70 e0       	ldi	r23, 0x00	; 0
     7ee:	80 91 75 2d 	lds	r24, 0x2D75	; 0x802d75 <AdcBusySema>
     7f2:	90 91 76 2d 	lds	r25, 0x2D76	; 0x802d76 <AdcBusySema+0x1>
     7f6:	0e 94 27 20 	call	0x404e	; 0x404e <xQueueGenericSend>
	return Res;
     7fa:	ce 01       	movw	r24, r28
}
     7fc:	df 91       	pop	r29
     7fe:	cf 91       	pop	r28
     800:	08 95       	ret
		{			
		ADCA.CH0.CTRL=0b00000010; //Differential mode, no gain
		ADCA.CTRLB|=0b00010000;   //Signed mode
		ADCA.CH0.MUXCTRL|=PinNeg;
		}						
	else if (PinNeg>=4 && PinNeg<8)
     802:	d4 50       	subi	r29, 0x04	; 4
     804:	d4 30       	cpi	r29, 0x04	; 4
     806:	10 f6       	brcc	.-124    	; 0x78c <DriverAdcGetCh+0x1c>
		{
		ADCA.CH0.CTRL=0b00011111; //Differential mode, div 2
     808:	8f e1       	ldi	r24, 0x1F	; 31
     80a:	cf cf       	rjmp	.-98     	; 0x7aa <DriverAdcGetCh+0x3a>
	else
		return 10000; //Invalid settings

	if (PinNeg==-1) 
		{			
		ADCA.CH0.CTRL=0b00000001; //Single ended mode, no gain
     80c:	81 e0       	ldi	r24, 0x01	; 1
     80e:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <__TEXT_REGION_LENGTH__+0x700220>
		ADCA.CTRLB&=~0b00010000;  //Unsigned mode		
     812:	80 91 01 02 	lds	r24, 0x0201	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
     816:	8f 7e       	andi	r24, 0xEF	; 239
     818:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <__TEXT_REGION_LENGTH__+0x700201>
     81c:	d2 cf       	rjmp	.-92     	; 0x7c2 <DriverAdcGetCh+0x52>

0000081e <__vector_71>:
	xSemaphoreGive(AdcBusySema);
	return Res;
}

ISR(ADCA_CH0_vect)
{
     81e:	1f 92       	push	r1
     820:	0f 92       	push	r0
     822:	0f b6       	in	r0, 0x3f	; 63
     824:	0f 92       	push	r0
     826:	11 24       	eor	r1, r1
     828:	0b b6       	in	r0, 0x3b	; 59
     82a:	0f 92       	push	r0
     82c:	2f 93       	push	r18
     82e:	3f 93       	push	r19
     830:	4f 93       	push	r20
     832:	5f 93       	push	r21
     834:	6f 93       	push	r22
     836:	7f 93       	push	r23
     838:	8f 93       	push	r24
     83a:	9f 93       	push	r25
     83c:	af 93       	push	r26
     83e:	bf 93       	push	r27
     840:	ef 93       	push	r30
     842:	ff 93       	push	r31
     844:	cf 93       	push	r28
     846:	df 93       	push	r29
     848:	1f 92       	push	r1
     84a:	cd b7       	in	r28, 0x3d	; 61
     84c:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
     84e:	19 82       	std	Y+1, r1	; 0x01
	xSemaphoreGiveFromISR(ConversionCompleteSema,&xHigherPriorityTaskWoken);
     850:	be 01       	movw	r22, r28
     852:	6f 5f       	subi	r22, 0xFF	; 255
     854:	7f 4f       	sbci	r23, 0xFF	; 255
     856:	80 91 73 2d 	lds	r24, 0x2D73	; 0x802d73 <ConversionCompleteSema>
     85a:	90 91 74 2d 	lds	r25, 0x2D74	; 0x802d74 <ConversionCompleteSema+0x1>
     85e:	0e 94 6b 21 	call	0x42d6	; 0x42d6 <xQueueGiveFromISR>
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     862:	89 81       	ldd	r24, Y+1	; 0x01
     864:	81 11       	cpse	r24, r1
     866:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <vPortYieldISR>
     86a:	0f 90       	pop	r0
     86c:	df 91       	pop	r29
     86e:	cf 91       	pop	r28
     870:	ff 91       	pop	r31
     872:	ef 91       	pop	r30
     874:	bf 91       	pop	r27
     876:	af 91       	pop	r26
     878:	9f 91       	pop	r25
     87a:	8f 91       	pop	r24
     87c:	7f 91       	pop	r23
     87e:	6f 91       	pop	r22
     880:	5f 91       	pop	r21
     882:	4f 91       	pop	r20
     884:	3f 91       	pop	r19
     886:	2f 91       	pop	r18
     888:	0f 90       	pop	r0
     88a:	0b be       	out	0x3b, r0	; 59
     88c:	0f 90       	pop	r0
     88e:	0f be       	out	0x3f, r0	; 63
     890:	0f 90       	pop	r0
     892:	1f 90       	pop	r1
     894:	18 95       	reti

00000896 <DriverAdps9960Init>:

#define REG_ID 0x92
#define ID 0xAB

void DriverAdps9960Init(void)
{
     896:	0f 93       	push	r16
     898:	cf 93       	push	r28
     89a:	df 93       	push	r29
     89c:	1f 92       	push	r1
     89e:	1f 92       	push	r1
     8a0:	cd b7       	in	r28, 0x3d	; 61
     8a2:	de b7       	in	r29, 0x3e	; 62
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=REG_ENABLE;
     8a4:	80 e8       	ldi	r24, 0x80	; 128
     8a6:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=(1<<REG_ENABLE_PON);
     8a8:	81 e0       	ldi	r24, 0x01	; 1
     8aa:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);
     8ac:	42 e0       	ldi	r20, 0x02	; 2
     8ae:	be 01       	movw	r22, r28
     8b0:	6f 5f       	subi	r22, 0xFF	; 255
     8b2:	7f 4f       	sbci	r23, 0xFF	; 255
     8b4:	89 e3       	ldi	r24, 0x39	; 57
     8b6:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
	//printf ("TwimWrite:%d\r\n",res);
	
	Buffer[0]=REG_ID;
     8ba:	82 e9       	ldi	r24, 0x92	; 146
     8bc:	89 83       	std	Y+1, r24	; 0x01
	res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,1);
     8be:	01 e0       	ldi	r16, 0x01	; 1
     8c0:	9e 01       	movw	r18, r28
     8c2:	2f 5f       	subi	r18, 0xFF	; 255
     8c4:	3f 4f       	sbci	r19, 0xFF	; 255
     8c6:	41 e0       	ldi	r20, 0x01	; 1
     8c8:	b9 01       	movw	r22, r18
     8ca:	89 e3       	ldi	r24, 0x39	; 57
     8cc:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
	if (Buffer[0]!=ID)
     8d0:	89 81       	ldd	r24, Y+1	; 0x01
     8d2:	8b 3a       	cpi	r24, 0xAB	; 171
     8d4:	61 f0       	breq	.+24     	; 0x8ee <DriverAdps9960Init+0x58>
		printf ("ADPS9960 ID readback fail: %d read\r\n",Buffer[0]);
     8d6:	1f 92       	push	r1
     8d8:	8f 93       	push	r24
     8da:	8e ed       	ldi	r24, 0xDE	; 222
     8dc:	90 e2       	ldi	r25, 0x20	; 32
     8de:	9f 93       	push	r25
     8e0:	8f 93       	push	r24
     8e2:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
     8e6:	0f 90       	pop	r0
     8e8:	0f 90       	pop	r0
     8ea:	0f 90       	pop	r0
     8ec:	0f 90       	pop	r0

	Buffer[0]=REG_ATIME;
     8ee:	81 e8       	ldi	r24, 0x81	; 129
     8f0:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=219; //100ms integration time
     8f2:	8b ed       	ldi	r24, 0xDB	; 219
     8f4:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);
     8f6:	42 e0       	ldi	r20, 0x02	; 2
     8f8:	be 01       	movw	r22, r28
     8fa:	6f 5f       	subi	r22, 0xFF	; 255
     8fc:	7f 4f       	sbci	r23, 0xFF	; 255
     8fe:	89 e3       	ldi	r24, 0x39	; 57
     900:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>

	Buffer[0]=REG_CTRL1;
     904:	8f e8       	ldi	r24, 0x8F	; 143
     906:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=0b11<<REG_CTRL1_AGAIN; //max gain
     908:	83 e0       	ldi	r24, 0x03	; 3
     90a:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);
     90c:	42 e0       	ldi	r20, 0x02	; 2
     90e:	be 01       	movw	r22, r28
     910:	6f 5f       	subi	r22, 0xFF	; 255
     912:	7f 4f       	sbci	r23, 0xFF	; 255
     914:	89 e3       	ldi	r24, 0x39	; 57
     916:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>

}
     91a:	0f 90       	pop	r0
     91c:	0f 90       	pop	r0
     91e:	df 91       	pop	r29
     920:	cf 91       	pop	r28
     922:	0f 91       	pop	r16
     924:	08 95       	ret

00000926 <DriverAdps9960Get>:

void DriverAdps9960Get(uint16_t *Clear,uint16_t *Red,uint16_t *Green, uint16_t *Blue)
{
     926:	8f 92       	push	r8
     928:	9f 92       	push	r9
     92a:	af 92       	push	r10
     92c:	bf 92       	push	r11
     92e:	cf 92       	push	r12
     930:	df 92       	push	r13
     932:	ef 92       	push	r14
     934:	ff 92       	push	r15
     936:	0f 93       	push	r16
     938:	1f 93       	push	r17
     93a:	cf 93       	push	r28
     93c:	df 93       	push	r29
     93e:	cd b7       	in	r28, 0x3d	; 61
     940:	de b7       	in	r29, 0x3e	; 62
     942:	29 97       	sbiw	r28, 0x09	; 9
     944:	cd bf       	out	0x3d, r28	; 61
     946:	de bf       	out	0x3e, r29	; 62
     948:	4c 01       	movw	r8, r24
     94a:	5b 01       	movw	r10, r22
     94c:	6a 01       	movw	r12, r20
     94e:	79 01       	movw	r14, r18
	uint8_t Buffer[9];
	uint16_t *C=(uint16_t *) &(Buffer[0]),*R=(uint16_t *) &(Buffer[2]),*G=(uint16_t *) &(Buffer[4]),*B=(uint16_t *) &(Buffer[6]);
	uint8_t *Status=&(Buffer[0]);


	Buffer[0]=REG_ENABLE;
     950:	80 e8       	ldi	r24, 0x80	; 128
     952:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=(1<<REG_ENABLE_PON) | (1<<REG_ENABLE_AEN);
     954:	83 e0       	ldi	r24, 0x03	; 3
     956:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);
     958:	42 e0       	ldi	r20, 0x02	; 2
     95a:	be 01       	movw	r22, r28
     95c:	6f 5f       	subi	r22, 0xFF	; 255
     95e:	7f 4f       	sbci	r23, 0xFF	; 255
     960:	89 e3       	ldi	r24, 0x39	; 57
     962:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>


	do 
	{
		Buffer[0]=REG_STATUS;
     966:	13 e9       	ldi	r17, 0x93	; 147
     968:	03 c0       	rjmp	.+6      	; 0x970 <DriverAdps9960Get+0x4a>
		res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,1);
		configASSERT(res);
		//printf ("STATUS:%d\r\n",Buffer[0]);
	} while (!(Buffer[0] & (1<<REG_STATUX_AVALID)) );
     96a:	89 81       	ldd	r24, Y+1	; 0x01
     96c:	80 fd       	sbrc	r24, 0
     96e:	15 c0       	rjmp	.+42     	; 0x99a <DriverAdps9960Get+0x74>
	res=TWIMWrite(ADPS9960_ADDR,Buffer,2);


	do 
	{
		Buffer[0]=REG_STATUS;
     970:	19 83       	std	Y+1, r17	; 0x01
		res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,1);
     972:	01 e0       	ldi	r16, 0x01	; 1
     974:	9e 01       	movw	r18, r28
     976:	2f 5f       	subi	r18, 0xFF	; 255
     978:	3f 4f       	sbci	r19, 0xFF	; 255
     97a:	41 e0       	ldi	r20, 0x01	; 1
     97c:	b9 01       	movw	r22, r18
     97e:	89 e3       	ldi	r24, 0x39	; 57
     980:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
		configASSERT(res);
     984:	81 11       	cpse	r24, r1
     986:	f1 cf       	rjmp	.-30     	; 0x96a <DriverAdps9960Get+0x44>
     988:	63 e4       	ldi	r22, 0x43	; 67
     98a:	70 e0       	ldi	r23, 0x00	; 0
     98c:	83 e0       	ldi	r24, 0x03	; 3
     98e:	91 e2       	ldi	r25, 0x21	; 33
     990:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
		//printf ("STATUS:%d\r\n",Buffer[0]);
	} while (!(Buffer[0] & (1<<REG_STATUX_AVALID)) );
     994:	89 81       	ldd	r24, Y+1	; 0x01
     996:	80 ff       	sbrs	r24, 0
     998:	eb cf       	rjmp	.-42     	; 0x970 <DriverAdps9960Get+0x4a>


	Buffer[0]=REG_CDATA;
     99a:	84 e9       	ldi	r24, 0x94	; 148
     99c:	89 83       	std	Y+1, r24	; 0x01
	res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,8);
     99e:	08 e0       	ldi	r16, 0x08	; 8
     9a0:	9e 01       	movw	r18, r28
     9a2:	2f 5f       	subi	r18, 0xFF	; 255
     9a4:	3f 4f       	sbci	r19, 0xFF	; 255
     9a6:	41 e0       	ldi	r20, 0x01	; 1
     9a8:	b9 01       	movw	r22, r18
     9aa:	89 e3       	ldi	r24, 0x39	; 57
     9ac:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
	configASSERT(res);
     9b0:	88 23       	and	r24, r24
     9b2:	81 f1       	breq	.+96     	; 0xa14 <DriverAdps9960Get+0xee>
	//printf ("TwimWriteRead:%d\r\n",res);

	if (Clear!=NULL) *Clear=*C;	
     9b4:	81 14       	cp	r8, r1
     9b6:	91 04       	cpc	r9, r1
     9b8:	29 f0       	breq	.+10     	; 0x9c4 <DriverAdps9960Get+0x9e>
     9ba:	89 81       	ldd	r24, Y+1	; 0x01
     9bc:	9a 81       	ldd	r25, Y+2	; 0x02
     9be:	f4 01       	movw	r30, r8
     9c0:	80 83       	st	Z, r24
     9c2:	91 83       	std	Z+1, r25	; 0x01
	if (Red!=NULL) *Red=*R;
     9c4:	a1 14       	cp	r10, r1
     9c6:	b1 04       	cpc	r11, r1
     9c8:	29 f0       	breq	.+10     	; 0x9d4 <DriverAdps9960Get+0xae>
     9ca:	8b 81       	ldd	r24, Y+3	; 0x03
     9cc:	9c 81       	ldd	r25, Y+4	; 0x04
     9ce:	f5 01       	movw	r30, r10
     9d0:	80 83       	st	Z, r24
     9d2:	91 83       	std	Z+1, r25	; 0x01
	if (Green!=NULL) *Green=*G;
     9d4:	c1 14       	cp	r12, r1
     9d6:	d1 04       	cpc	r13, r1
     9d8:	29 f0       	breq	.+10     	; 0x9e4 <DriverAdps9960Get+0xbe>
     9da:	8d 81       	ldd	r24, Y+5	; 0x05
     9dc:	9e 81       	ldd	r25, Y+6	; 0x06
     9de:	f6 01       	movw	r30, r12
     9e0:	80 83       	st	Z, r24
     9e2:	91 83       	std	Z+1, r25	; 0x01
	if (Blue!=NULL) *Blue=*B;
     9e4:	e1 14       	cp	r14, r1
     9e6:	f1 04       	cpc	r15, r1
     9e8:	29 f0       	breq	.+10     	; 0x9f4 <DriverAdps9960Get+0xce>
     9ea:	8f 81       	ldd	r24, Y+7	; 0x07
     9ec:	98 85       	ldd	r25, Y+8	; 0x08
     9ee:	f7 01       	movw	r30, r14
     9f0:	80 83       	st	Z, r24
     9f2:	91 83       	std	Z+1, r25	; 0x01

     9f4:	29 96       	adiw	r28, 0x09	; 9
     9f6:	cd bf       	out	0x3d, r28	; 61
     9f8:	de bf       	out	0x3e, r29	; 62
     9fa:	df 91       	pop	r29
     9fc:	cf 91       	pop	r28
     9fe:	1f 91       	pop	r17
     a00:	0f 91       	pop	r16
     a02:	ff 90       	pop	r15
     a04:	ef 90       	pop	r14
     a06:	df 90       	pop	r13
     a08:	cf 90       	pop	r12
     a0a:	bf 90       	pop	r11
     a0c:	af 90       	pop	r10
     a0e:	9f 90       	pop	r9
     a10:	8f 90       	pop	r8
     a12:	08 95       	ret
	} while (!(Buffer[0] & (1<<REG_STATUX_AVALID)) );


	Buffer[0]=REG_CDATA;
	res=TWIMWriteRead(ADPS9960_ADDR,Buffer,1,Buffer,8);
	configASSERT(res);
     a14:	6a e4       	ldi	r22, 0x4A	; 74
     a16:	70 e0       	ldi	r23, 0x00	; 0
     a18:	83 e0       	ldi	r24, 0x03	; 3
     a1a:	91 e2       	ldi	r25, 0x21	; 33
     a1c:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
     a20:	c9 cf       	rjmp	.-110    	; 0x9b4 <DriverAdps9960Get+0x8e>

00000a22 <DriverCursorstickInit>:

static QueueHandle_t CursorstickQueue;

void DriverCursorstickInit(void)
{
	PORTB.DIRCLR=0b11111000;
     a22:	e0 e2       	ldi	r30, 0x20	; 32
     a24:	f6 e0       	ldi	r31, 0x06	; 6
     a26:	98 ef       	ldi	r25, 0xF8	; 248
     a28:	92 83       	std	Z+2, r25	; 0x02
	PORTB.PIN3CTRL=0b01011001; //Pull up, inverted
     a2a:	89 e5       	ldi	r24, 0x59	; 89
     a2c:	83 8b       	std	Z+19, r24	; 0x13
	PORTB.PIN4CTRL=0b01011001; //Pull up, inverted	
     a2e:	84 8b       	std	Z+20, r24	; 0x14
	PORTB.PIN5CTRL=0b01011001; //Pull up, inverted
     a30:	85 8b       	std	Z+21, r24	; 0x15
	PORTB.PIN6CTRL=0b01011001; //Pull up, inverted
     a32:	86 8b       	std	Z+22, r24	; 0x16
	PORTB.PIN7CTRL=0b01011001; //Pull up, inverted
     a34:	87 8b       	std	Z+23, r24	; 0x17
	PORTB.INT0MASK=0b11111000; //Interrupt on all cursor stick lines
     a36:	92 87       	std	Z+10, r25	; 0x0a
	PORTB.INTCTRL=0b11;		   //Enable interrupt0 highest priority
     a38:	83 e0       	ldi	r24, 0x03	; 3
     a3a:	81 87       	std	Z+9, r24	; 0x09
	
	CursorstickQueue=xQueueCreate(CURSOR_FIFO_LENGTH,1);
     a3c:	40 e0       	ldi	r20, 0x00	; 0
     a3e:	61 e0       	ldi	r22, 0x01	; 1
     a40:	8a e0       	ldi	r24, 0x0A	; 10
     a42:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <xQueueGenericCreate>
     a46:	80 93 2c 28 	sts	0x282C, r24	; 0x80282c <CursorstickQueue>
     a4a:	90 93 2d 28 	sts	0x282D, r25	; 0x80282d <CursorstickQueue+0x1>
     a4e:	08 95       	ret

00000a50 <DriverCursorstickGet>:
}

uint8_t DriverCursorstickGet(void)
{
	uint8_t ret=0;
	if (PORTB.IN & (1<<3)) ret|=(1<<4);
     a50:	80 91 28 06 	lds	r24, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     a54:	83 ff       	sbrs	r24, 3
     a56:	12 c0       	rjmp	.+36     	; 0xa7c <DriverCursorstickGet+0x2c>
     a58:	80 e1       	ldi	r24, 0x10	; 16
	if (PORTB.IN & (1<<4)) ret|=(1<<3);
     a5a:	90 91 28 06 	lds	r25, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     a5e:	94 fd       	sbrc	r25, 4
     a60:	88 60       	ori	r24, 0x08	; 8
	if (PORTB.IN & (1<<5)) ret|=(1<<2);
     a62:	90 91 28 06 	lds	r25, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     a66:	95 fd       	sbrc	r25, 5
     a68:	84 60       	ori	r24, 0x04	; 4
	if (PORTB.IN & (1<<6)) ret|=(1<<1);
     a6a:	90 91 28 06 	lds	r25, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     a6e:	96 fd       	sbrc	r25, 6
     a70:	82 60       	ori	r24, 0x02	; 2
	if (PORTB.IN & (1<<7)) ret|=(1<<0);
     a72:	90 91 28 06 	lds	r25, 0x0628	; 0x800628 <__TEXT_REGION_LENGTH__+0x700628>
     a76:	97 fd       	sbrc	r25, 7
     a78:	03 c0       	rjmp	.+6      	; 0xa80 <DriverCursorstickGet+0x30>

	return ret;
}
     a7a:	08 95       	ret
	CursorstickQueue=xQueueCreate(CURSOR_FIFO_LENGTH,1);
}

uint8_t DriverCursorstickGet(void)
{
	uint8_t ret=0;
     a7c:	80 e0       	ldi	r24, 0x00	; 0
     a7e:	ed cf       	rjmp	.-38     	; 0xa5a <DriverCursorstickGet+0xa>
	if (PORTB.IN & (1<<3)) ret|=(1<<4);
	if (PORTB.IN & (1<<4)) ret|=(1<<3);
	if (PORTB.IN & (1<<5)) ret|=(1<<2);
	if (PORTB.IN & (1<<6)) ret|=(1<<1);
	if (PORTB.IN & (1<<7)) ret|=(1<<0);
     a80:	81 60       	ori	r24, 0x01	; 1

	return ret;
}
     a82:	08 95       	ret

00000a84 <DriverCursorStickGetFifo>:

uint8_t DriverCursorStickGetFifo(TickType_t BlockTime)
{
     a84:	cf 93       	push	r28
     a86:	df 93       	push	r29
     a88:	1f 92       	push	r1
     a8a:	cd b7       	in	r28, 0x3d	; 61
     a8c:	de b7       	in	r29, 0x3e	; 62
	uint8_t ButtonState;
	BaseType_t res;
	res=xQueueReceive(CursorstickQueue,&ButtonState,BlockTime);
     a8e:	ac 01       	movw	r20, r24
     a90:	be 01       	movw	r22, r28
     a92:	6f 5f       	subi	r22, 0xFF	; 255
     a94:	7f 4f       	sbci	r23, 0xFF	; 255
     a96:	80 91 2c 28 	lds	r24, 0x282C	; 0x80282c <CursorstickQueue>
     a9a:	90 91 2d 28 	lds	r25, 0x282D	; 0x80282d <CursorstickQueue+0x1>
     a9e:	0e 94 be 21 	call	0x437c	; 0x437c <xQueueReceive>
	if (res==pdTRUE) return ButtonState;
     aa2:	81 30       	cpi	r24, 0x01	; 1
     aa4:	29 f0       	breq	.+10     	; 0xab0 <DriverCursorStickGetFifo+0x2c>
	else return 0;
     aa6:	80 e0       	ldi	r24, 0x00	; 0

}
     aa8:	0f 90       	pop	r0
     aaa:	df 91       	pop	r29
     aac:	cf 91       	pop	r28
     aae:	08 95       	ret
uint8_t DriverCursorStickGetFifo(TickType_t BlockTime)
{
	uint8_t ButtonState;
	BaseType_t res;
	res=xQueueReceive(CursorstickQueue,&ButtonState,BlockTime);
	if (res==pdTRUE) return ButtonState;
     ab0:	89 81       	ldd	r24, Y+1	; 0x01
	else return 0;

}
     ab2:	0f 90       	pop	r0
     ab4:	df 91       	pop	r29
     ab6:	cf 91       	pop	r28
     ab8:	08 95       	ret

00000aba <__vector_34>:

ISR (PORTB_INT0_vect)
{
     aba:	1f 92       	push	r1
     abc:	0f 92       	push	r0
     abe:	0f b6       	in	r0, 0x3f	; 63
     ac0:	0f 92       	push	r0
     ac2:	11 24       	eor	r1, r1
     ac4:	0b b6       	in	r0, 0x3b	; 59
     ac6:	0f 92       	push	r0
     ac8:	cf 92       	push	r12
     aca:	df 92       	push	r13
     acc:	ef 92       	push	r14
     ace:	ff 92       	push	r15
     ad0:	0f 93       	push	r16
     ad2:	1f 93       	push	r17
     ad4:	2f 93       	push	r18
     ad6:	3f 93       	push	r19
     ad8:	4f 93       	push	r20
     ada:	5f 93       	push	r21
     adc:	6f 93       	push	r22
     ade:	7f 93       	push	r23
     ae0:	8f 93       	push	r24
     ae2:	9f 93       	push	r25
     ae4:	af 93       	push	r26
     ae6:	bf 93       	push	r27
     ae8:	ef 93       	push	r30
     aea:	ff 93       	push	r31
     aec:	cf 93       	push	r28
     aee:	df 93       	push	r29
     af0:	1f 92       	push	r1
     af2:	1f 92       	push	r1
     af4:	cd b7       	in	r28, 0x3d	; 61
     af6:	de b7       	in	r29, 0x3e	; 62
	printf("wakey wakey");
     af8:	8f e1       	ldi	r24, 0x1F	; 31
     afa:	91 e2       	ldi	r25, 0x21	; 33
     afc:	9f 93       	push	r25
     afe:	8f 93       	push	r24
     b00:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
	DriverPowerVccAuxSet(1);
     b04:	81 e0       	ldi	r24, 0x01	; 1
     b06:	90 e0       	ldi	r25, 0x00	; 0
     b08:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <DriverPowerVccAuxSet>
	PMIC.CTRL |= 0b111;
     b0c:	80 91 a2 00 	lds	r24, 0x00A2	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
     b10:	87 60       	ori	r24, 0x07	; 7
     b12:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	static uint32_t LastIntTime=0;
	uint32_t CurTime;
	uint8_t ButtonState;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
     b16:	19 82       	std	Y+1, r1	; 0x01
	
	CurTime=portGET_RUN_TIME_COUNTER_VALUE();
     b18:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
     b1c:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
     b20:	c0 90 85 2d 	lds	r12, 0x2D85	; 0x802d85 <StatsTimer>
     b24:	d0 90 86 2d 	lds	r13, 0x2D86	; 0x802d86 <StatsTimer+0x1>
     b28:	e0 90 87 2d 	lds	r14, 0x2D87	; 0x802d87 <StatsTimer+0x2>
     b2c:	f0 90 88 2d 	lds	r15, 0x2D88	; 0x802d88 <StatsTimer+0x3>
     b30:	c8 0e       	add	r12, r24
     b32:	d9 1e       	adc	r13, r25
     b34:	e1 1c       	adc	r14, r1
     b36:	f1 1c       	adc	r15, r1
	ButtonState=DriverCursorstickGet();
     b38:	0e 94 28 05 	call	0xa50	; 0xa50 <DriverCursorstickGet>
     b3c:	8a 83       	std	Y+2, r24	; 0x02
	
	if ((CurTime-LastIntTime)>CURSOR_MIN_INTERVAL) //debounce
     b3e:	40 91 28 28 	lds	r20, 0x2828	; 0x802828 <LastIntTime.4303>
     b42:	50 91 29 28 	lds	r21, 0x2829	; 0x802829 <LastIntTime.4303+0x1>
     b46:	60 91 2a 28 	lds	r22, 0x282A	; 0x80282a <LastIntTime.4303+0x2>
     b4a:	70 91 2b 28 	lds	r23, 0x282B	; 0x80282b <LastIntTime.4303+0x3>
     b4e:	97 01       	movw	r18, r14
     b50:	86 01       	movw	r16, r12
     b52:	04 1b       	sub	r16, r20
     b54:	15 0b       	sbc	r17, r21
     b56:	26 0b       	sbc	r18, r22
     b58:	37 0b       	sbc	r19, r23
     b5a:	b9 01       	movw	r22, r18
     b5c:	a8 01       	movw	r20, r16
     b5e:	0f 90       	pop	r0
     b60:	0f 90       	pop	r0
     b62:	41 30       	cpi	r20, 0x01	; 1
     b64:	58 4a       	sbci	r21, 0xA8	; 168
     b66:	61 46       	sbci	r22, 0x61	; 97
     b68:	71 05       	cpc	r23, r1
     b6a:	10 f0       	brcs	.+4      	; 0xb70 <__vector_34+0xb6>
		if (ButtonState>0) 
     b6c:	81 11       	cpse	r24, r1
     b6e:	21 c0       	rjmp	.+66     	; 0xbb2 <__vector_34+0xf8>
		{
			xQueueSendToBackFromISR(CursorstickQueue,&ButtonState,&xHigherPriorityTaskWoken);
			LastIntTime=CurTime;
		}
		
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     b70:	89 81       	ldd	r24, Y+1	; 0x01
     b72:	81 11       	cpse	r24, r1
     b74:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <vPortYieldISR>
     b78:	0f 90       	pop	r0
     b7a:	0f 90       	pop	r0
     b7c:	df 91       	pop	r29
     b7e:	cf 91       	pop	r28
     b80:	ff 91       	pop	r31
     b82:	ef 91       	pop	r30
     b84:	bf 91       	pop	r27
     b86:	af 91       	pop	r26
     b88:	9f 91       	pop	r25
     b8a:	8f 91       	pop	r24
     b8c:	7f 91       	pop	r23
     b8e:	6f 91       	pop	r22
     b90:	5f 91       	pop	r21
     b92:	4f 91       	pop	r20
     b94:	3f 91       	pop	r19
     b96:	2f 91       	pop	r18
     b98:	1f 91       	pop	r17
     b9a:	0f 91       	pop	r16
     b9c:	ff 90       	pop	r15
     b9e:	ef 90       	pop	r14
     ba0:	df 90       	pop	r13
     ba2:	cf 90       	pop	r12
     ba4:	0f 90       	pop	r0
     ba6:	0b be       	out	0x3b, r0	; 59
     ba8:	0f 90       	pop	r0
     baa:	0f be       	out	0x3f, r0	; 63
     bac:	0f 90       	pop	r0
     bae:	1f 90       	pop	r1
     bb0:	18 95       	reti
	ButtonState=DriverCursorstickGet();
	
	if ((CurTime-LastIntTime)>CURSOR_MIN_INTERVAL) //debounce
		if (ButtonState>0) 
		{
			xQueueSendToBackFromISR(CursorstickQueue,&ButtonState,&xHigherPriorityTaskWoken);
     bb2:	20 e0       	ldi	r18, 0x00	; 0
     bb4:	ae 01       	movw	r20, r28
     bb6:	4f 5f       	subi	r20, 0xFF	; 255
     bb8:	5f 4f       	sbci	r21, 0xFF	; 255
     bba:	be 01       	movw	r22, r28
     bbc:	6e 5f       	subi	r22, 0xFE	; 254
     bbe:	7f 4f       	sbci	r23, 0xFF	; 255
     bc0:	80 91 2c 28 	lds	r24, 0x282C	; 0x80282c <CursorstickQueue>
     bc4:	90 91 2d 28 	lds	r25, 0x282D	; 0x80282d <CursorstickQueue+0x1>
     bc8:	0e 94 10 21 	call	0x4220	; 0x4220 <xQueueGenericSendFromISR>
			LastIntTime=CurTime;
     bcc:	c0 92 28 28 	sts	0x2828, r12	; 0x802828 <LastIntTime.4303>
     bd0:	d0 92 29 28 	sts	0x2829, r13	; 0x802829 <LastIntTime.4303+0x1>
     bd4:	e0 92 2a 28 	sts	0x282A, r14	; 0x80282a <LastIntTime.4303+0x2>
     bd8:	f0 92 2b 28 	sts	0x282B, r15	; 0x80282b <LastIntTime.4303+0x3>
     bdc:	c9 cf       	rjmp	.-110    	; 0xb70 <__vector_34+0xb6>

00000bde <DbgPrint>:
#include "DriverDbgUSART.h"


void DbgPrint(char *Text)
{
     bde:	dc 01       	movw	r26, r24
}

void DbgPrintn(char *Text,int n)
{
	static int i;
	i=0;
     be0:	10 92 31 28 	sts	0x2831, r1	; 0x802831 <i.3624>
     be4:	10 92 32 28 	sts	0x2832, r1	; 0x802832 <i.3624+0x1>
	while (*Text!=0 && (i<n || n==0))
     be8:	9c 91       	ld	r25, X
     bea:	99 23       	and	r25, r25
     bec:	b1 f0       	breq	.+44     	; 0xc1a <DbgPrint+0x3c>
     bee:	fd 01       	movw	r30, r26
     bf0:	31 96       	adiw	r30, 0x01	; 1
	{
		USART.DATA = *Text;
		while (!(USART.STATUS & 0b01000000));
		USART.STATUS=0b01000000;
     bf2:	80 e4       	ldi	r24, 0x40	; 64
{
	static int i;
	i=0;
	while (*Text!=0 && (i<n || n==0))
	{
		USART.DATA = *Text;
     bf4:	90 93 a0 0a 	sts	0x0AA0, r25	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
		while (!(USART.STATUS & 0b01000000));
     bf8:	90 91 a1 0a 	lds	r25, 0x0AA1	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
     bfc:	96 ff       	sbrs	r25, 6
     bfe:	fc cf       	rjmp	.-8      	; 0xbf8 <DbgPrint+0x1a>
		USART.STATUS=0b01000000;
     c00:	80 93 a1 0a 	sts	0x0AA1, r24	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
     c04:	9f 01       	movw	r18, r30
     c06:	2a 1b       	sub	r18, r26
     c08:	3b 0b       	sbc	r19, r27

void DbgPrintn(char *Text,int n)
{
	static int i;
	i=0;
	while (*Text!=0 && (i<n || n==0))
     c0a:	91 91       	ld	r25, Z+
     c0c:	91 11       	cpse	r25, r1
     c0e:	f2 cf       	rjmp	.-28     	; 0xbf4 <DbgPrint+0x16>
     c10:	20 93 31 28 	sts	0x2831, r18	; 0x802831 <i.3624>
     c14:	30 93 32 28 	sts	0x2832, r19	; 0x802832 <i.3624+0x1>
     c18:	08 95       	ret
     c1a:	08 95       	ret

00000c1c <DbgPrintn>:
{
	DbgPrintn(Text,0);	
}

void DbgPrintn(char *Text,int n)
{
     c1c:	fc 01       	movw	r30, r24
	static int i;
	i=0;
     c1e:	10 92 31 28 	sts	0x2831, r1	; 0x802831 <i.3624>
     c22:	10 92 32 28 	sts	0x2832, r1	; 0x802832 <i.3624+0x1>
	while (*Text!=0 && (i<n || n==0))
     c26:	90 81       	ld	r25, Z
     c28:	99 23       	and	r25, r25
     c2a:	e1 f0       	breq	.+56     	; 0xc64 <DbgPrintn+0x48>
     c2c:	31 96       	adiw	r30, 0x01	; 1
     c2e:	20 e0       	ldi	r18, 0x00	; 0
     c30:	30 e0       	ldi	r19, 0x00	; 0
	{
		USART.DATA = *Text;
		while (!(USART.STATUS & 0b01000000));
		USART.STATUS=0b01000000;
     c32:	80 e4       	ldi	r24, 0x40	; 64

void DbgPrintn(char *Text,int n)
{
	static int i;
	i=0;
	while (*Text!=0 && (i<n || n==0))
     c34:	26 17       	cp	r18, r22
     c36:	37 07       	cpc	r19, r23
     c38:	1c f0       	brlt	.+6      	; 0xc40 <DbgPrintn+0x24>
     c3a:	61 15       	cp	r22, r1
     c3c:	71 05       	cpc	r23, r1
     c3e:	69 f4       	brne	.+26     	; 0xc5a <DbgPrintn+0x3e>
	{
		USART.DATA = *Text;
     c40:	90 93 a0 0a 	sts	0x0AA0, r25	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
		while (!(USART.STATUS & 0b01000000));
     c44:	90 91 a1 0a 	lds	r25, 0x0AA1	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
     c48:	96 ff       	sbrs	r25, 6
     c4a:	fc cf       	rjmp	.-8      	; 0xc44 <DbgPrintn+0x28>
		USART.STATUS=0b01000000;
     c4c:	80 93 a1 0a 	sts	0x0AA1, r24	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
		Text++;
		i++;
     c50:	2f 5f       	subi	r18, 0xFF	; 255
     c52:	3f 4f       	sbci	r19, 0xFF	; 255

void DbgPrintn(char *Text,int n)
{
	static int i;
	i=0;
	while (*Text!=0 && (i<n || n==0))
     c54:	91 91       	ld	r25, Z+
     c56:	91 11       	cpse	r25, r1
     c58:	ed cf       	rjmp	.-38     	; 0xc34 <DbgPrintn+0x18>
     c5a:	20 93 31 28 	sts	0x2831, r18	; 0x802831 <i.3624>
     c5e:	30 93 32 28 	sts	0x2832, r19	; 0x802832 <i.3624+0x1>
     c62:	08 95       	ret
     c64:	08 95       	ret

00000c66 <DbgPrintInt>:
		i++;
	}
}

void DbgPrintInt(uint16_t Data)
{
     c66:	cf 92       	push	r12
     c68:	df 92       	push	r13
     c6a:	ef 92       	push	r14
     c6c:	ff 92       	push	r15
     c6e:	0f 93       	push	r16
     c70:	1f 93       	push	r17
     c72:	cf 93       	push	r28
     c74:	df 93       	push	r29
     c76:	7c 01       	movw	r14, r24
	//Use statics to minimize stack usage
	static int i;
	static uint8_t pf;
	
	i=10000;
     c78:	80 e1       	ldi	r24, 0x10	; 16
     c7a:	97 e2       	ldi	r25, 0x27	; 39
     c7c:	80 93 2f 28 	sts	0x282F, r24	; 0x80282f <i.3634>
     c80:	90 93 30 28 	sts	0x2830, r25	; 0x802830 <i.3634+0x1>
	pf=0;
     c84:	10 92 2e 28 	sts	0x282E, r1	; 0x80282e <pf.3635>
     c88:	c5 e0       	ldi	r28, 0x05	; 5
     c8a:	d0 e0       	ldi	r29, 0x00	; 0
     c8c:	c1 2c       	mov	r12, r1
     c8e:	e0 e1       	ldi	r30, 0x10	; 16
     c90:	f7 e2       	ldi	r31, 0x27	; 39
	{
		if (((Data/i)%10)!=0 || pf) //Trim leading 0's
		{
			USART.DATA = '0'+ ((Data/i)%10);
			while (!(USART.STATUS & 0b01000000));
			USART.STATUS=0b01000000;
     c92:	a0 e4       	ldi	r26, 0x40	; 64
     c94:	da 2e       	mov	r13, r26
			pf=1;		
		}
		i/=10;
     c96:	0a e0       	ldi	r16, 0x0A	; 10
     c98:	10 e0       	ldi	r17, 0x00	; 0
	
	i=10000;
	pf=0;
	while (i>0)
	{
		if (((Data/i)%10)!=0 || pf) //Trim leading 0's
     c9a:	c7 01       	movw	r24, r14
     c9c:	bf 01       	movw	r22, r30
     c9e:	0e 94 01 48 	call	0x9002	; 0x9002 <__udivmodhi4>
     ca2:	ab 01       	movw	r20, r22
     ca4:	9b 01       	movw	r18, r22
     ca6:	ad ec       	ldi	r26, 0xCD	; 205
     ca8:	bc ec       	ldi	r27, 0xCC	; 204
     caa:	0e 94 4b 48 	call	0x9096	; 0x9096 <__umulhisi3>
     cae:	96 95       	lsr	r25
     cb0:	87 95       	ror	r24
     cb2:	96 95       	lsr	r25
     cb4:	87 95       	ror	r24
     cb6:	96 95       	lsr	r25
     cb8:	87 95       	ror	r24
     cba:	9c 01       	movw	r18, r24
     cbc:	22 0f       	add	r18, r18
     cbe:	33 1f       	adc	r19, r19
     cc0:	88 0f       	add	r24, r24
     cc2:	99 1f       	adc	r25, r25
     cc4:	88 0f       	add	r24, r24
     cc6:	99 1f       	adc	r25, r25
     cc8:	88 0f       	add	r24, r24
     cca:	99 1f       	adc	r25, r25
     ccc:	82 0f       	add	r24, r18
     cce:	93 1f       	adc	r25, r19
     cd0:	9a 01       	movw	r18, r20
     cd2:	28 1b       	sub	r18, r24
     cd4:	39 0b       	sbc	r19, r25
     cd6:	c9 01       	movw	r24, r18
     cd8:	00 97       	sbiw	r24, 0x00	; 0
     cda:	11 f4       	brne	.+4      	; 0xce0 <DbgPrintInt+0x7a>
     cdc:	cc 20       	and	r12, r12
     cde:	59 f0       	breq	.+22     	; 0xcf6 <DbgPrintInt+0x90>
		{
			USART.DATA = '0'+ ((Data/i)%10);
     ce0:	80 5d       	subi	r24, 0xD0	; 208
     ce2:	80 93 a0 0a 	sts	0x0AA0, r24	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
			while (!(USART.STATUS & 0b01000000));
     ce6:	80 91 a1 0a 	lds	r24, 0x0AA1	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
     cea:	86 ff       	sbrs	r24, 6
     cec:	fc cf       	rjmp	.-8      	; 0xce6 <DbgPrintInt+0x80>
			USART.STATUS=0b01000000;
     cee:	d0 92 a1 0a 	sts	0x0AA1, r13	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
			pf=1;		
     cf2:	cc 24       	eor	r12, r12
     cf4:	c3 94       	inc	r12
		}
		i/=10;
     cf6:	cf 01       	movw	r24, r30
     cf8:	b8 01       	movw	r22, r16
     cfa:	0e 94 15 48 	call	0x902a	; 0x902a <__divmodhi4>
     cfe:	fb 01       	movw	r30, r22
     d00:	21 97       	sbiw	r28, 0x01	; 1
	static int i;
	static uint8_t pf;
	
	i=10000;
	pf=0;
	while (i>0)
     d02:	59 f6       	brne	.-106    	; 0xc9a <DbgPrintInt+0x34>
     d04:	c0 92 2e 28 	sts	0x282E, r12	; 0x80282e <pf.3635>
     d08:	60 93 2f 28 	sts	0x282F, r22	; 0x80282f <i.3634>
     d0c:	70 93 30 28 	sts	0x2830, r23	; 0x802830 <i.3634+0x1>
			USART.STATUS=0b01000000;
			pf=1;		
		}
		i/=10;
	}
}
     d10:	df 91       	pop	r29
     d12:	cf 91       	pop	r28
     d14:	1f 91       	pop	r17
     d16:	0f 91       	pop	r16
     d18:	ff 90       	pop	r15
     d1a:	ef 90       	pop	r14
     d1c:	df 90       	pop	r13
     d1e:	cf 90       	pop	r12
     d20:	08 95       	ret

00000d22 <DriverLedInit>:
}

void DriverLedWrite(uint8_t LedData)
{
	PORTB.OUT=(PORTB.OUT & 0b11111000) | (LedData & 0b00000111);
	PORTA.OUT=(PORTA.OUT & 0b01111111) | ((LedData & 0b00001000) << 4); 
     d22:	e0 e2       	ldi	r30, 0x20	; 32
     d24:	f6 e0       	ldi	r31, 0x06	; 6
     d26:	87 e0       	ldi	r24, 0x07	; 7
     d28:	81 83       	std	Z+1, r24	; 0x01
     d2a:	80 e4       	ldi	r24, 0x40	; 64
     d2c:	80 8b       	std	Z+16, r24	; 0x10
     d2e:	81 8b       	std	Z+17, r24	; 0x11
     d30:	82 8b       	std	Z+18, r24	; 0x12
     d32:	e0 e0       	ldi	r30, 0x00	; 0
     d34:	f6 e0       	ldi	r31, 0x06	; 6
     d36:	90 e8       	ldi	r25, 0x80	; 128
     d38:	91 83       	std	Z+1, r25	; 0x01
     d3a:	87 8b       	std	Z+23, r24	; 0x17
     d3c:	08 95       	ret

00000d3e <DriverLedSet>:
}

void DriverLedSet(uint8_t LedData)
{
	PORTB.OUT=PORTB.OUT | (LedData & 0b00000111);
     d3e:	e0 e2       	ldi	r30, 0x20	; 32
     d40:	f6 e0       	ldi	r31, 0x06	; 6
     d42:	94 81       	ldd	r25, Z+4	; 0x04
     d44:	28 2f       	mov	r18, r24
     d46:	27 70       	andi	r18, 0x07	; 7
     d48:	92 2b       	or	r25, r18
     d4a:	94 83       	std	Z+4, r25	; 0x04
	PORTA.OUT=PORTA.OUT | ((LedData & 0b00001000) << 4);
     d4c:	e0 e0       	ldi	r30, 0x00	; 0
     d4e:	f6 e0       	ldi	r31, 0x06	; 6
     d50:	94 81       	ldd	r25, Z+4	; 0x04
     d52:	88 70       	andi	r24, 0x08	; 8
     d54:	82 95       	swap	r24
     d56:	80 7f       	andi	r24, 0xF0	; 240
     d58:	89 2b       	or	r24, r25
     d5a:	84 83       	std	Z+4, r24	; 0x04
     d5c:	08 95       	ret

00000d5e <DriverLedClear>:
}

void DriverLedClear(uint8_t LedData)
{
	PORTB.OUT=PORTB.OUT & ~(LedData & 0b00000111);
     d5e:	e0 e2       	ldi	r30, 0x20	; 32
     d60:	f6 e0       	ldi	r31, 0x06	; 6
     d62:	24 81       	ldd	r18, Z+4	; 0x04
     d64:	98 2f       	mov	r25, r24
     d66:	97 70       	andi	r25, 0x07	; 7
     d68:	90 95       	com	r25
     d6a:	92 23       	and	r25, r18
     d6c:	94 83       	std	Z+4, r25	; 0x04
	PORTA.OUT=PORTA.OUT & ~((LedData & 0b00001000) << 4);
     d6e:	e0 e0       	ldi	r30, 0x00	; 0
     d70:	f6 e0       	ldi	r31, 0x06	; 6
     d72:	94 81       	ldd	r25, Z+4	; 0x04
     d74:	88 70       	andi	r24, 0x08	; 8
     d76:	82 95       	swap	r24
     d78:	80 7f       	andi	r24, 0xF0	; 240
     d7a:	80 95       	com	r24
     d7c:	89 23       	and	r24, r25
     d7e:	84 83       	std	Z+4, r24	; 0x04
     d80:	08 95       	ret

00000d82 <DriverMotorInit>:


void DriverMotorInit(void)
{
	//GPIO init
	PORTF.DIRSET=0b11111;
     d82:	e0 ea       	ldi	r30, 0xA0	; 160
     d84:	f6 e0       	ldi	r31, 0x06	; 6
     d86:	8f e1       	ldi	r24, 0x1F	; 31
     d88:	81 83       	std	Z+1, r24	; 0x01
	PORTF.PIN4CTRL=0b01000000; //Invert
     d8a:	80 e4       	ldi	r24, 0x40	; 64
     d8c:	84 8b       	std	Z+20, r24	; 0x14
	PORTF.OUTSET=0b10000; //Sleep enable
     d8e:	20 e1       	ldi	r18, 0x10	; 16
     d90:	25 83       	std	Z+5, r18	; 0x05
	
	//Timer init, hbridge
	TCF0.CTRLA=0b00000001; //DIV1
     d92:	e0 e0       	ldi	r30, 0x00	; 0
     d94:	fb e0       	ldi	r31, 0x0B	; 11
     d96:	91 e0       	ldi	r25, 0x01	; 1
     d98:	90 83       	st	Z, r25
	TCF0.CTRLB=0b11110011; //OCA,OCB,OCC,OCD enable, SS PWM
     d9a:	93 ef       	ldi	r25, 0xF3	; 243
     d9c:	91 83       	std	Z+1, r25	; 0x01
	TCF0.PER=4096; //7812 Hz PWM
     d9e:	40 e0       	ldi	r20, 0x00	; 0
     da0:	50 e1       	ldi	r21, 0x10	; 16
     da2:	46 a3       	std	Z+38, r20	; 0x26
     da4:	57 a3       	std	Z+39, r21	; 0x27
	
	//Encoder 1A, 1B
	PORTC.DIRCLR=0b11000000; 
     da6:	e0 e4       	ldi	r30, 0x40	; 64
     da8:	f6 e0       	ldi	r31, 0x06	; 6
     daa:	90 ec       	ldi	r25, 0xC0	; 192
     dac:	92 83       	std	Z+2, r25	; 0x02
	PORTC.PIN6CTRL=0b01000000; //any edge detect
     dae:	86 8b       	std	Z+22, r24	; 0x16
	PORTC.PIN7CTRL=0b01000000; //any edge detect
     db0:	87 8b       	std	Z+23, r24	; 0x17
	PORTC.INT0MASK=1<<6;
     db2:	82 87       	std	Z+10, r24	; 0x0a
	PORTC.INT1MASK=1<<7;
     db4:	90 e8       	ldi	r25, 0x80	; 128
     db6:	93 87       	std	Z+11, r25	; 0x0b
	PORTC.INTCTRL=0b0101;
     db8:	95 e0       	ldi	r25, 0x05	; 5
     dba:	91 87       	std	Z+9, r25	; 0x09

	//Encoder 2A, 2B
	PORTE.DIRCLR=0b00110000;
     dbc:	e0 e8       	ldi	r30, 0x80	; 128
     dbe:	f6 e0       	ldi	r31, 0x06	; 6
     dc0:	30 e3       	ldi	r19, 0x30	; 48
     dc2:	32 83       	std	Z+2, r19	; 0x02
	PORTE.PIN4CTRL=0b01000000; //any edge detect
     dc4:	84 8b       	std	Z+20, r24	; 0x14
	PORTE.PIN5CTRL=0b01000000; //any edge detect
     dc6:	85 8b       	std	Z+21, r24	; 0x15
	PORTE.INT0MASK=1<<4;
     dc8:	22 87       	std	Z+10, r18	; 0x0a
	PORTE.INT1MASK=1<<5;
     dca:	80 e2       	ldi	r24, 0x20	; 32
     dcc:	83 87       	std	Z+11, r24	; 0x0b
	PORTE.INTCTRL=0b0101;
     dce:	91 87       	std	Z+9, r25	; 0x09
	
	EncoderEventQueue=xQueueCreate(ENCODER_EVENT_QUEUE_LENGTH,sizeof(EncoderEventStruct));
     dd0:	40 e0       	ldi	r20, 0x00	; 0
     dd2:	65 e0       	ldi	r22, 0x05	; 5
     dd4:	84 e1       	ldi	r24, 0x14	; 20
     dd6:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <xQueueGenericCreate>
     dda:	80 93 7b 2d 	sts	0x2D7B, r24	; 0x802d7b <EncoderEventQueue>
     dde:	90 93 7c 2d 	sts	0x2D7C, r25	; 0x802d7c <EncoderEventQueue+0x1>
     de2:	08 95       	ret

00000de4 <DriverMotorSet>:

void DriverMotorSet(int16_t MotorLeft,int16_t MotorRight)
{
	//Sleep mode handling
	if (MotorLeft==0 && MotorRight==0)
		PORTF.OUTSET=0b10000; //DRV8833 in sleep mode
     de4:	20 e1       	ldi	r18, 0x10	; 16


void DriverMotorSet(int16_t MotorLeft,int16_t MotorRight)
{
	//Sleep mode handling
	if (MotorLeft==0 && MotorRight==0)
     de6:	00 97       	sbiw	r24, 0x00	; 0
     de8:	69 f5       	brne	.+90     	; 0xe44 <DriverMotorSet+0x60>
     dea:	61 15       	cp	r22, r1
     dec:	71 05       	cpc	r23, r1
     dee:	09 f4       	brne	.+2      	; 0xdf2 <DriverMotorSet+0xe>
     df0:	57 c0       	rjmp	.+174    	; 0xea0 <DriverMotorSet+0xbc>
		PORTF.OUTSET=0b10000; //DRV8833 in sleep mode
	else
		PORTF.OUTCLR=0b10000; //DRV8833 in active mode
     df2:	20 93 a6 06 	sts	0x06A6, r18	; 0x8006a6 <__TEXT_REGION_LENGTH__+0x7006a6>
		TCF0.CCB=MotorLeft;
	}
	else
	{
		if (MotorLeft<-4095) MotorLeft=-4095;
		TCF0.CCA=-MotorLeft;	
     df6:	81 30       	cpi	r24, 0x01	; 1
     df8:	20 ef       	ldi	r18, 0xF0	; 240
     dfa:	92 07       	cpc	r25, r18
     dfc:	0c f4       	brge	.+2      	; 0xe00 <DriverMotorSet+0x1c>
     dfe:	57 c0       	rjmp	.+174    	; 0xeae <DriverMotorSet+0xca>
     e00:	91 95       	neg	r25
     e02:	81 95       	neg	r24
     e04:	91 09       	sbc	r25, r1
     e06:	80 93 28 0b 	sts	0x0B28, r24	; 0x800b28 <__TEXT_REGION_LENGTH__+0x700b28>
     e0a:	90 93 29 0b 	sts	0x0B29, r25	; 0x800b29 <__TEXT_REGION_LENGTH__+0x700b29>
		TCF0.CCB=0;
     e0e:	10 92 2a 0b 	sts	0x0B2A, r1	; 0x800b2a <__TEXT_REGION_LENGTH__+0x700b2a>
     e12:	10 92 2b 0b 	sts	0x0B2B, r1	; 0x800b2b <__TEXT_REGION_LENGTH__+0x700b2b>
	}

	//Right motor
	if (MOTOR_RIGHT_INVERT==1) MotorRight=-MotorRight;
     e16:	71 95       	neg	r23
     e18:	61 95       	neg	r22
     e1a:	71 09       	sbc	r23, r1
	if (MotorRight>0)
     e1c:	16 16       	cp	r1, r22
     e1e:	17 06       	cpc	r1, r23
     e20:	44 f1       	brlt	.+80     	; 0xe72 <DriverMotorSet+0x8e>
		TCF0.CCD=MotorRight;
	}
	else
	{
		if (MotorRight<-4095) MotorRight=-4095;
		TCF0.CCC=-MotorRight;
     e22:	61 30       	cpi	r22, 0x01	; 1
     e24:	20 ef       	ldi	r18, 0xF0	; 240
     e26:	72 07       	cpc	r23, r18
     e28:	0c f4       	brge	.+2      	; 0xe2c <DriverMotorSet+0x48>
     e2a:	44 c0       	rjmp	.+136    	; 0xeb4 <DriverMotorSet+0xd0>
     e2c:	71 95       	neg	r23
     e2e:	61 95       	neg	r22
     e30:	71 09       	sbc	r23, r1
     e32:	60 93 2c 0b 	sts	0x0B2C, r22	; 0x800b2c <__TEXT_REGION_LENGTH__+0x700b2c>
     e36:	70 93 2d 0b 	sts	0x0B2D, r23	; 0x800b2d <__TEXT_REGION_LENGTH__+0x700b2d>
		TCF0.CCD=0;
     e3a:	10 92 2e 0b 	sts	0x0B2E, r1	; 0x800b2e <__TEXT_REGION_LENGTH__+0x700b2e>
     e3e:	10 92 2f 0b 	sts	0x0B2F, r1	; 0x800b2f <__TEXT_REGION_LENGTH__+0x700b2f>
	}
	
}
     e42:	08 95       	ret
{
	//Sleep mode handling
	if (MotorLeft==0 && MotorRight==0)
		PORTF.OUTSET=0b10000; //DRV8833 in sleep mode
	else
		PORTF.OUTCLR=0b10000; //DRV8833 in active mode
     e44:	20 93 a6 06 	sts	0x06A6, r18	; 0x8006a6 <__TEXT_REGION_LENGTH__+0x7006a6>
	
	//Left motor
	if (MOTOR_LEFT_INVERT==1) MotorLeft=-MotorLeft;
	if (MotorLeft>0)
     e48:	18 16       	cp	r1, r24
     e4a:	19 06       	cpc	r1, r25
     e4c:	a4 f6       	brge	.-88     	; 0xdf6 <DriverMotorSet+0x12>
	{
		if (MotorLeft>4095) MotorLeft=4095;
		TCF0.CCA=0;
     e4e:	10 92 28 0b 	sts	0x0B28, r1	; 0x800b28 <__TEXT_REGION_LENGTH__+0x700b28>
     e52:	10 92 29 0b 	sts	0x0B29, r1	; 0x800b29 <__TEXT_REGION_LENGTH__+0x700b29>
		TCF0.CCB=MotorLeft;
     e56:	81 15       	cp	r24, r1
     e58:	20 e1       	ldi	r18, 0x10	; 16
     e5a:	92 07       	cpc	r25, r18
     e5c:	f4 f4       	brge	.+60     	; 0xe9a <DriverMotorSet+0xb6>
     e5e:	80 93 2a 0b 	sts	0x0B2A, r24	; 0x800b2a <__TEXT_REGION_LENGTH__+0x700b2a>
     e62:	90 93 2b 0b 	sts	0x0B2B, r25	; 0x800b2b <__TEXT_REGION_LENGTH__+0x700b2b>
		TCF0.CCA=-MotorLeft;	
		TCF0.CCB=0;
	}

	//Right motor
	if (MOTOR_RIGHT_INVERT==1) MotorRight=-MotorRight;
     e66:	71 95       	neg	r23
     e68:	61 95       	neg	r22
     e6a:	71 09       	sbc	r23, r1
	if (MotorRight>0)
     e6c:	16 16       	cp	r1, r22
     e6e:	17 06       	cpc	r1, r23
     e70:	c4 f6       	brge	.-80     	; 0xe22 <DriverMotorSet+0x3e>
	{
		if (MotorRight>4095) MotorRight=4095;
		TCF0.CCC=0;
     e72:	10 92 2c 0b 	sts	0x0B2C, r1	; 0x800b2c <__TEXT_REGION_LENGTH__+0x700b2c>
     e76:	10 92 2d 0b 	sts	0x0B2D, r1	; 0x800b2d <__TEXT_REGION_LENGTH__+0x700b2d>
		TCF0.CCD=MotorRight;
     e7a:	61 15       	cp	r22, r1
     e7c:	80 e1       	ldi	r24, 0x10	; 16
     e7e:	78 07       	cpc	r23, r24
     e80:	2c f4       	brge	.+10     	; 0xe8c <DriverMotorSet+0xa8>
     e82:	60 93 2e 0b 	sts	0x0B2E, r22	; 0x800b2e <__TEXT_REGION_LENGTH__+0x700b2e>
     e86:	70 93 2f 0b 	sts	0x0B2F, r23	; 0x800b2f <__TEXT_REGION_LENGTH__+0x700b2f>
     e8a:	08 95       	ret
     e8c:	6f ef       	ldi	r22, 0xFF	; 255
     e8e:	7f e0       	ldi	r23, 0x0F	; 15
     e90:	60 93 2e 0b 	sts	0x0B2E, r22	; 0x800b2e <__TEXT_REGION_LENGTH__+0x700b2e>
     e94:	70 93 2f 0b 	sts	0x0B2F, r23	; 0x800b2f <__TEXT_REGION_LENGTH__+0x700b2f>
     e98:	08 95       	ret
	if (MOTOR_LEFT_INVERT==1) MotorLeft=-MotorLeft;
	if (MotorLeft>0)
	{
		if (MotorLeft>4095) MotorLeft=4095;
		TCF0.CCA=0;
		TCF0.CCB=MotorLeft;
     e9a:	8f ef       	ldi	r24, 0xFF	; 255
     e9c:	9f e0       	ldi	r25, 0x0F	; 15
     e9e:	df cf       	rjmp	.-66     	; 0xe5e <DriverMotorSet+0x7a>

void DriverMotorSet(int16_t MotorLeft,int16_t MotorRight)
{
	//Sleep mode handling
	if (MotorLeft==0 && MotorRight==0)
		PORTF.OUTSET=0b10000; //DRV8833 in sleep mode
     ea0:	20 93 a5 06 	sts	0x06A5, r18	; 0x8006a5 <__TEXT_REGION_LENGTH__+0x7006a5>
		TCF0.CCB=MotorLeft;
	}
	else
	{
		if (MotorLeft<-4095) MotorLeft=-4095;
		TCF0.CCA=-MotorLeft;	
     ea4:	81 30       	cpi	r24, 0x01	; 1
     ea6:	20 ef       	ldi	r18, 0xF0	; 240
     ea8:	92 07       	cpc	r25, r18
     eaa:	0c f0       	brlt	.+2      	; 0xeae <DriverMotorSet+0xca>
     eac:	a9 cf       	rjmp	.-174    	; 0xe00 <DriverMotorSet+0x1c>
     eae:	81 e0       	ldi	r24, 0x01	; 1
     eb0:	90 ef       	ldi	r25, 0xF0	; 240
     eb2:	a6 cf       	rjmp	.-180    	; 0xe00 <DriverMotorSet+0x1c>
		TCF0.CCD=MotorRight;
	}
	else
	{
		if (MotorRight<-4095) MotorRight=-4095;
		TCF0.CCC=-MotorRight;
     eb4:	61 e0       	ldi	r22, 0x01	; 1
     eb6:	70 ef       	ldi	r23, 0xF0	; 240
     eb8:	b9 cf       	rjmp	.-142    	; 0xe2c <DriverMotorSet+0x48>

00000eba <DriverMotorGetEncoder>:

EncoderStruct DriverMotorGetEncoder(void)
{
	EncoderStruct EncoderInfo;

	portENTER_CRITICAL();
     eba:	0f b6       	in	r0, 0x3f	; 63
     ebc:	f8 94       	cli
     ebe:	0f 92       	push	r0
	if (!ENCODER_LEFT_INVERT)
		EncoderInfo.Cnt1=Cnt1;
     ec0:	40 91 77 2d 	lds	r20, 0x2D77	; 0x802d77 <Cnt1>
     ec4:	50 91 78 2d 	lds	r21, 0x2D78	; 0x802d78 <Cnt1+0x1>
	else
		EncoderInfo.Cnt1=-Cnt1;
	
	if (!ENCODER_RIGHT_INVERT)
		EncoderInfo.Cnt2=Cnt2;
     ec8:	20 91 79 2d 	lds	r18, 0x2D79	; 0x802d79 <Cnt2>
     ecc:	30 91 7a 2d 	lds	r19, 0x2D7A	; 0x802d7a <Cnt2+0x1>
	else
		EncoderInfo.Cnt2=-Cnt2;
	portEXIT_CRITICAL();
     ed0:	0f 90       	pop	r0
     ed2:	0f be       	out	0x3f, r0	; 63
	return EncoderInfo;
     ed4:	ba 01       	movw	r22, r20
     ed6:	c9 01       	movw	r24, r18
}
     ed8:	08 95       	ret

00000eda <DriverMotorGetEncoderEvent>:

EncoderEventStruct DriverMotorGetEncoderEvent(void)
{
     eda:	cf 93       	push	r28
     edc:	df 93       	push	r29
     ede:	cd b7       	in	r28, 0x3d	; 61
     ee0:	de b7       	in	r29, 0x3e	; 62
     ee2:	2a 97       	sbiw	r28, 0x0a	; 10
     ee4:	cd bf       	out	0x3d, r28	; 61
     ee6:	de bf       	out	0x3e, r29	; 62
	EncoderEventStruct Event={0,NONE};
     ee8:	1e 82       	std	Y+6, r1	; 0x06
     eea:	1f 82       	std	Y+7, r1	; 0x07
     eec:	18 86       	std	Y+8, r1	; 0x08
     eee:	19 86       	std	Y+9, r1	; 0x09
     ef0:	1a 86       	std	Y+10, r1	; 0x0a
	int res;
	res=xQueueReceive(EncoderEventQueue,&Event,0);
     ef2:	40 e0       	ldi	r20, 0x00	; 0
     ef4:	50 e0       	ldi	r21, 0x00	; 0
     ef6:	be 01       	movw	r22, r28
     ef8:	6a 5f       	subi	r22, 0xFA	; 250
     efa:	7f 4f       	sbci	r23, 0xFF	; 255
     efc:	80 91 7b 2d 	lds	r24, 0x2D7B	; 0x802d7b <EncoderEventQueue>
     f00:	90 91 7c 2d 	lds	r25, 0x2D7C	; 0x802d7c <EncoderEventQueue+0x1>
     f04:	0e 94 be 21 	call	0x437c	; 0x437c <xQueueReceive>
	return Event;
     f08:	85 e0       	ldi	r24, 0x05	; 5
     f0a:	fe 01       	movw	r30, r28
     f0c:	36 96       	adiw	r30, 0x06	; 6
     f0e:	de 01       	movw	r26, r28
     f10:	11 96       	adiw	r26, 0x01	; 1
     f12:	01 90       	ld	r0, Z+
     f14:	0d 92       	st	X+, r0
     f16:	8a 95       	dec	r24
     f18:	e1 f7       	brne	.-8      	; 0xf12 <DriverMotorGetEncoderEvent+0x38>
     f1a:	29 81       	ldd	r18, Y+1	; 0x01
     f1c:	3a 81       	ldd	r19, Y+2	; 0x02
     f1e:	4b 81       	ldd	r20, Y+3	; 0x03
     f20:	5c 81       	ldd	r21, Y+4	; 0x04
     f22:	6d 81       	ldd	r22, Y+5	; 0x05
}
     f24:	70 e0       	ldi	r23, 0x00	; 0
     f26:	80 e0       	ldi	r24, 0x00	; 0
     f28:	90 e0       	ldi	r25, 0x00	; 0
     f2a:	2a 96       	adiw	r28, 0x0a	; 10
     f2c:	cd bf       	out	0x3d, r28	; 61
     f2e:	de bf       	out	0x3e, r29	; 62
     f30:	df 91       	pop	r29
     f32:	cf 91       	pop	r28
     f34:	08 95       	ret

00000f36 <__vector_2>:

//Encoder 1 ISR's
ISR (PORTC_INT0_vect)
{	
     f36:	1f 92       	push	r1
     f38:	0f 92       	push	r0
     f3a:	0f b6       	in	r0, 0x3f	; 63
     f3c:	0f 92       	push	r0
     f3e:	11 24       	eor	r1, r1
     f40:	0b b6       	in	r0, 0x3b	; 59
     f42:	0f 92       	push	r0
     f44:	1f 93       	push	r17
     f46:	2f 93       	push	r18
     f48:	3f 93       	push	r19
     f4a:	4f 93       	push	r20
     f4c:	5f 93       	push	r21
     f4e:	6f 93       	push	r22
     f50:	7f 93       	push	r23
     f52:	8f 93       	push	r24
     f54:	9f 93       	push	r25
     f56:	af 93       	push	r26
     f58:	bf 93       	push	r27
     f5a:	ef 93       	push	r30
     f5c:	ff 93       	push	r31
     f5e:	cf 93       	push	r28
     f60:	df 93       	push	r29
     f62:	00 d0       	rcall	.+0      	; 0xf64 <__vector_2+0x2e>
     f64:	00 d0       	rcall	.+0      	; 0xf66 <__vector_2+0x30>
     f66:	cd b7       	in	r28, 0x3d	; 61
     f68:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastTriggerTime=0;
	uint8_t Data,l0,l1;
	EncoderEventStruct Event;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
     f6a:	1e 82       	std	Y+6, r1	; 0x06
	Event.Time=portGET_RUN_TIME_COUNTER_VALUE();
     f6c:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
     f70:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
     f74:	80 91 85 2d 	lds	r24, 0x2D85	; 0x802d85 <StatsTimer>
     f78:	90 91 86 2d 	lds	r25, 0x2D86	; 0x802d86 <StatsTimer+0x1>
     f7c:	a0 91 87 2d 	lds	r26, 0x2D87	; 0x802d87 <StatsTimer+0x2>
     f80:	b0 91 88 2d 	lds	r27, 0x2D88	; 0x802d88 <StatsTimer+0x3>
     f84:	82 0f       	add	r24, r18
     f86:	93 1f       	adc	r25, r19
     f88:	a1 1d       	adc	r26, r1
     f8a:	b1 1d       	adc	r27, r1
     f8c:	89 83       	std	Y+1, r24	; 0x01
     f8e:	9a 83       	std	Y+2, r25	; 0x02
     f90:	ab 83       	std	Y+3, r26	; 0x03
     f92:	bc 83       	std	Y+4, r27	; 0x04
	#ifdef ENCODER_FILTER_ENABLE
		if ((Event.Time-LastTriggerTime)<ENCODER_FILTER_TIME) return;
	#endif

	Data=PORTC.IN;
     f94:	80 91 48 06 	lds	r24, 0x0648	; 0x800648 <__TEXT_REGION_LENGTH__+0x700648>
	l0=Data & (1<<6);
	l1=Data & (1<<7);
     f98:	18 2f       	mov	r17, r24
     f9a:	10 78       	andi	r17, 0x80	; 128
		
	//Process events
	if (l0) 
     f9c:	86 ff       	sbrs	r24, 6
     f9e:	37 c0       	rjmp	.+110    	; 0x100e <__vector_2+0xd8>
		Event.Event=RISING_1A;
     fa0:	81 e0       	ldi	r24, 0x01	; 1
     fa2:	8d 83       	std	Y+5, r24	; 0x05
	else
		Event.Event=FALLING_1A;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
     fa4:	20 e0       	ldi	r18, 0x00	; 0
     fa6:	ae 01       	movw	r20, r28
     fa8:	4a 5f       	subi	r20, 0xFA	; 250
     faa:	5f 4f       	sbci	r21, 0xFF	; 255
     fac:	be 01       	movw	r22, r28
     fae:	6f 5f       	subi	r22, 0xFF	; 255
     fb0:	7f 4f       	sbci	r23, 0xFF	; 255
     fb2:	80 91 7b 2d 	lds	r24, 0x2D7B	; 0x802d7b <EncoderEventQueue>
     fb6:	90 91 7c 2d 	lds	r25, 0x2D7C	; 0x802d7c <EncoderEventQueue+0x1>
     fba:	0e 94 10 21 	call	0x4220	; 0x4220 <xQueueGenericSendFromISR>
	//Process counter
	if ( l0 && !l1) Cnt1--; //Rising edge on Line0, Line1 low
     fbe:	11 23       	and	r17, r17
     fc0:	b9 f1       	breq	.+110    	; 0x1030 <__vector_2+0xfa>
	if ( l0 &&  l1) Cnt1++; //Rising edge on Line0, Line1 high	
	if (!l0 &&  l1) Cnt1--; //Falling edge on Line0, Line1 high
	if (!l0 && !l1) Cnt1++;//Falling edge on Line1, Line1 low
     fc2:	80 91 77 2d 	lds	r24, 0x2D77	; 0x802d77 <Cnt1>
     fc6:	90 91 78 2d 	lds	r25, 0x2D78	; 0x802d78 <Cnt1+0x1>
     fca:	01 96       	adiw	r24, 0x01	; 1
     fcc:	80 93 77 2d 	sts	0x2D77, r24	; 0x802d77 <Cnt1>
     fd0:	90 93 78 2d 	sts	0x2D78, r25	; 0x802d78 <Cnt1+0x1>

	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
     fd4:	8e 81       	ldd	r24, Y+6	; 0x06
     fd6:	81 11       	cpse	r24, r1
     fd8:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <vPortYieldISR>
	LastTriggerTime=Event.Time;
}
     fdc:	26 96       	adiw	r28, 0x06	; 6
     fde:	cd bf       	out	0x3d, r28	; 61
     fe0:	de bf       	out	0x3e, r29	; 62
     fe2:	df 91       	pop	r29
     fe4:	cf 91       	pop	r28
     fe6:	ff 91       	pop	r31
     fe8:	ef 91       	pop	r30
     fea:	bf 91       	pop	r27
     fec:	af 91       	pop	r26
     fee:	9f 91       	pop	r25
     ff0:	8f 91       	pop	r24
     ff2:	7f 91       	pop	r23
     ff4:	6f 91       	pop	r22
     ff6:	5f 91       	pop	r21
     ff8:	4f 91       	pop	r20
     ffa:	3f 91       	pop	r19
     ffc:	2f 91       	pop	r18
     ffe:	1f 91       	pop	r17
    1000:	0f 90       	pop	r0
    1002:	0b be       	out	0x3b, r0	; 59
    1004:	0f 90       	pop	r0
    1006:	0f be       	out	0x3f, r0	; 63
    1008:	0f 90       	pop	r0
    100a:	1f 90       	pop	r1
    100c:	18 95       	reti
		
	//Process events
	if (l0) 
		Event.Event=RISING_1A;
	else
		Event.Event=FALLING_1A;
    100e:	85 e0       	ldi	r24, 0x05	; 5
    1010:	8d 83       	std	Y+5, r24	; 0x05

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    1012:	20 e0       	ldi	r18, 0x00	; 0
    1014:	ae 01       	movw	r20, r28
    1016:	4a 5f       	subi	r20, 0xFA	; 250
    1018:	5f 4f       	sbci	r21, 0xFF	; 255
    101a:	be 01       	movw	r22, r28
    101c:	6f 5f       	subi	r22, 0xFF	; 255
    101e:	7f 4f       	sbci	r23, 0xFF	; 255
    1020:	80 91 7b 2d 	lds	r24, 0x2D7B	; 0x802d7b <EncoderEventQueue>
    1024:	90 91 7c 2d 	lds	r25, 0x2D7C	; 0x802d7c <EncoderEventQueue+0x1>
    1028:	0e 94 10 21 	call	0x4220	; 0x4220 <xQueueGenericSendFromISR>
	//Process counter
	if ( l0 && !l1) Cnt1--; //Rising edge on Line0, Line1 low
	if ( l0 &&  l1) Cnt1++; //Rising edge on Line0, Line1 high	
	if (!l0 &&  l1) Cnt1--; //Falling edge on Line0, Line1 high
    102c:	11 23       	and	r17, r17
    102e:	49 f2       	breq	.-110    	; 0xfc2 <__vector_2+0x8c>
    1030:	80 91 77 2d 	lds	r24, 0x2D77	; 0x802d77 <Cnt1>
    1034:	90 91 78 2d 	lds	r25, 0x2D78	; 0x802d78 <Cnt1+0x1>
    1038:	01 97       	sbiw	r24, 0x01	; 1
    103a:	80 93 77 2d 	sts	0x2D77, r24	; 0x802d77 <Cnt1>
    103e:	90 93 78 2d 	sts	0x2D78, r25	; 0x802d78 <Cnt1+0x1>
    1042:	c8 cf       	rjmp	.-112    	; 0xfd4 <__vector_2+0x9e>

00001044 <__vector_3>:
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	LastTriggerTime=Event.Time;
}

ISR (PORTC_INT1_vect)
{
    1044:	1f 92       	push	r1
    1046:	0f 92       	push	r0
    1048:	0f b6       	in	r0, 0x3f	; 63
    104a:	0f 92       	push	r0
    104c:	11 24       	eor	r1, r1
    104e:	0b b6       	in	r0, 0x3b	; 59
    1050:	0f 92       	push	r0
    1052:	1f 93       	push	r17
    1054:	2f 93       	push	r18
    1056:	3f 93       	push	r19
    1058:	4f 93       	push	r20
    105a:	5f 93       	push	r21
    105c:	6f 93       	push	r22
    105e:	7f 93       	push	r23
    1060:	8f 93       	push	r24
    1062:	9f 93       	push	r25
    1064:	af 93       	push	r26
    1066:	bf 93       	push	r27
    1068:	ef 93       	push	r30
    106a:	ff 93       	push	r31
    106c:	cf 93       	push	r28
    106e:	df 93       	push	r29
    1070:	00 d0       	rcall	.+0      	; 0x1072 <__vector_3+0x2e>
    1072:	00 d0       	rcall	.+0      	; 0x1074 <__vector_3+0x30>
    1074:	cd b7       	in	r28, 0x3d	; 61
    1076:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastTriggerTime=0;
	uint8_t Data,l0,l1;
	EncoderEventStruct Event;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    1078:	1e 82       	std	Y+6, r1	; 0x06
	Event.Time=portGET_RUN_TIME_COUNTER_VALUE();
    107a:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    107e:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    1082:	80 91 85 2d 	lds	r24, 0x2D85	; 0x802d85 <StatsTimer>
    1086:	90 91 86 2d 	lds	r25, 0x2D86	; 0x802d86 <StatsTimer+0x1>
    108a:	a0 91 87 2d 	lds	r26, 0x2D87	; 0x802d87 <StatsTimer+0x2>
    108e:	b0 91 88 2d 	lds	r27, 0x2D88	; 0x802d88 <StatsTimer+0x3>
    1092:	82 0f       	add	r24, r18
    1094:	93 1f       	adc	r25, r19
    1096:	a1 1d       	adc	r26, r1
    1098:	b1 1d       	adc	r27, r1
    109a:	89 83       	std	Y+1, r24	; 0x01
    109c:	9a 83       	std	Y+2, r25	; 0x02
    109e:	ab 83       	std	Y+3, r26	; 0x03
    10a0:	bc 83       	std	Y+4, r27	; 0x04
	#ifdef ENCODER_FILTER_ENABLE
		if ((Event.Time-LastTriggerTime)<ENCODER_FILTER_TIME) return;
	#endif
	
	Data=PORTC.IN;
    10a2:	80 91 48 06 	lds	r24, 0x0648	; 0x800648 <__TEXT_REGION_LENGTH__+0x700648>
	l0=Data & (1<<6);
    10a6:	18 2f       	mov	r17, r24
    10a8:	10 74       	andi	r17, 0x40	; 64
	l1=Data & (1<<7);
	
	//Process events
	if (l1)
    10aa:	87 ff       	sbrs	r24, 7
    10ac:	37 c0       	rjmp	.+110    	; 0x111c <__vector_3+0xd8>
		Event.Event=RISING_1B;
    10ae:	82 e0       	ldi	r24, 0x02	; 2
    10b0:	8d 83       	std	Y+5, r24	; 0x05
	else
		Event.Event=FALLING_1B;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    10b2:	20 e0       	ldi	r18, 0x00	; 0
    10b4:	ae 01       	movw	r20, r28
    10b6:	4a 5f       	subi	r20, 0xFA	; 250
    10b8:	5f 4f       	sbci	r21, 0xFF	; 255
    10ba:	be 01       	movw	r22, r28
    10bc:	6f 5f       	subi	r22, 0xFF	; 255
    10be:	7f 4f       	sbci	r23, 0xFF	; 255
    10c0:	80 91 7b 2d 	lds	r24, 0x2D7B	; 0x802d7b <EncoderEventQueue>
    10c4:	90 91 7c 2d 	lds	r25, 0x2D7C	; 0x802d7c <EncoderEventQueue+0x1>
    10c8:	0e 94 10 21 	call	0x4220	; 0x4220 <xQueueGenericSendFromISR>
	//Process counter
	if ( l1 && !l0) Cnt1++;//Rising edge on Line1, Line0 low
    10cc:	11 23       	and	r17, r17
    10ce:	b9 f1       	breq	.+110    	; 0x113e <__vector_3+0xfa>
	if ( l1 &&  l0) Cnt1--;//Rising edge on Line1, Line0 high
	if (!l1 &&  l0) Cnt1++;//Falling edge on Line1, Line0 high
	if (!l1 && !l0) Cnt1--;//Falling edge on Line1, Line0 low
    10d0:	80 91 77 2d 	lds	r24, 0x2D77	; 0x802d77 <Cnt1>
    10d4:	90 91 78 2d 	lds	r25, 0x2D78	; 0x802d78 <Cnt1+0x1>
    10d8:	01 97       	sbiw	r24, 0x01	; 1
    10da:	80 93 77 2d 	sts	0x2D77, r24	; 0x802d77 <Cnt1>
    10de:	90 93 78 2d 	sts	0x2D78, r25	; 0x802d78 <Cnt1+0x1>

	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    10e2:	8e 81       	ldd	r24, Y+6	; 0x06
    10e4:	81 11       	cpse	r24, r1
    10e6:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <vPortYieldISR>
	LastTriggerTime=Event.Time;
}
    10ea:	26 96       	adiw	r28, 0x06	; 6
    10ec:	cd bf       	out	0x3d, r28	; 61
    10ee:	de bf       	out	0x3e, r29	; 62
    10f0:	df 91       	pop	r29
    10f2:	cf 91       	pop	r28
    10f4:	ff 91       	pop	r31
    10f6:	ef 91       	pop	r30
    10f8:	bf 91       	pop	r27
    10fa:	af 91       	pop	r26
    10fc:	9f 91       	pop	r25
    10fe:	8f 91       	pop	r24
    1100:	7f 91       	pop	r23
    1102:	6f 91       	pop	r22
    1104:	5f 91       	pop	r21
    1106:	4f 91       	pop	r20
    1108:	3f 91       	pop	r19
    110a:	2f 91       	pop	r18
    110c:	1f 91       	pop	r17
    110e:	0f 90       	pop	r0
    1110:	0b be       	out	0x3b, r0	; 59
    1112:	0f 90       	pop	r0
    1114:	0f be       	out	0x3f, r0	; 63
    1116:	0f 90       	pop	r0
    1118:	1f 90       	pop	r1
    111a:	18 95       	reti
	
	//Process events
	if (l1)
		Event.Event=RISING_1B;
	else
		Event.Event=FALLING_1B;
    111c:	86 e0       	ldi	r24, 0x06	; 6
    111e:	8d 83       	std	Y+5, r24	; 0x05

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    1120:	20 e0       	ldi	r18, 0x00	; 0
    1122:	ae 01       	movw	r20, r28
    1124:	4a 5f       	subi	r20, 0xFA	; 250
    1126:	5f 4f       	sbci	r21, 0xFF	; 255
    1128:	be 01       	movw	r22, r28
    112a:	6f 5f       	subi	r22, 0xFF	; 255
    112c:	7f 4f       	sbci	r23, 0xFF	; 255
    112e:	80 91 7b 2d 	lds	r24, 0x2D7B	; 0x802d7b <EncoderEventQueue>
    1132:	90 91 7c 2d 	lds	r25, 0x2D7C	; 0x802d7c <EncoderEventQueue+0x1>
    1136:	0e 94 10 21 	call	0x4220	; 0x4220 <xQueueGenericSendFromISR>
	//Process counter
	if ( l1 && !l0) Cnt1++;//Rising edge on Line1, Line0 low
	if ( l1 &&  l0) Cnt1--;//Rising edge on Line1, Line0 high
	if (!l1 &&  l0) Cnt1++;//Falling edge on Line1, Line0 high
    113a:	11 23       	and	r17, r17
    113c:	49 f2       	breq	.-110    	; 0x10d0 <__vector_3+0x8c>
    113e:	80 91 77 2d 	lds	r24, 0x2D77	; 0x802d77 <Cnt1>
    1142:	90 91 78 2d 	lds	r25, 0x2D78	; 0x802d78 <Cnt1+0x1>
    1146:	01 96       	adiw	r24, 0x01	; 1
    1148:	80 93 77 2d 	sts	0x2D77, r24	; 0x802d77 <Cnt1>
    114c:	90 93 78 2d 	sts	0x2D78, r25	; 0x802d78 <Cnt1+0x1>
    1150:	c8 cf       	rjmp	.-112    	; 0x10e2 <__vector_3+0x9e>

00001152 <__vector_43>:
	LastTriggerTime=Event.Time;
}

//Encoder 2 ISR's
ISR (PORTE_INT0_vect)
{
    1152:	1f 92       	push	r1
    1154:	0f 92       	push	r0
    1156:	0f b6       	in	r0, 0x3f	; 63
    1158:	0f 92       	push	r0
    115a:	11 24       	eor	r1, r1
    115c:	0b b6       	in	r0, 0x3b	; 59
    115e:	0f 92       	push	r0
    1160:	1f 93       	push	r17
    1162:	2f 93       	push	r18
    1164:	3f 93       	push	r19
    1166:	4f 93       	push	r20
    1168:	5f 93       	push	r21
    116a:	6f 93       	push	r22
    116c:	7f 93       	push	r23
    116e:	8f 93       	push	r24
    1170:	9f 93       	push	r25
    1172:	af 93       	push	r26
    1174:	bf 93       	push	r27
    1176:	ef 93       	push	r30
    1178:	ff 93       	push	r31
    117a:	cf 93       	push	r28
    117c:	df 93       	push	r29
    117e:	00 d0       	rcall	.+0      	; 0x1180 <__vector_43+0x2e>
    1180:	00 d0       	rcall	.+0      	; 0x1182 <__vector_43+0x30>
    1182:	cd b7       	in	r28, 0x3d	; 61
    1184:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastTriggerTime=0;
	uint8_t Data,l0,l1;
	EncoderEventStruct Event;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    1186:	1e 82       	std	Y+6, r1	; 0x06
	Event.Time=portGET_RUN_TIME_COUNTER_VALUE();
    1188:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    118c:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    1190:	80 91 85 2d 	lds	r24, 0x2D85	; 0x802d85 <StatsTimer>
    1194:	90 91 86 2d 	lds	r25, 0x2D86	; 0x802d86 <StatsTimer+0x1>
    1198:	a0 91 87 2d 	lds	r26, 0x2D87	; 0x802d87 <StatsTimer+0x2>
    119c:	b0 91 88 2d 	lds	r27, 0x2D88	; 0x802d88 <StatsTimer+0x3>
    11a0:	82 0f       	add	r24, r18
    11a2:	93 1f       	adc	r25, r19
    11a4:	a1 1d       	adc	r26, r1
    11a6:	b1 1d       	adc	r27, r1
    11a8:	89 83       	std	Y+1, r24	; 0x01
    11aa:	9a 83       	std	Y+2, r25	; 0x02
    11ac:	ab 83       	std	Y+3, r26	; 0x03
    11ae:	bc 83       	std	Y+4, r27	; 0x04
	#ifdef ENCODER_FILTER_ENABLE
		if ((Event.Time-LastTriggerTime)<ENCODER_FILTER_TIME) return;
	#endif
	
	Data=PORTE.IN;
    11b0:	80 91 88 06 	lds	r24, 0x0688	; 0x800688 <__TEXT_REGION_LENGTH__+0x700688>
	l0=Data & (1<<4);
	l1=Data & (1<<5);
    11b4:	18 2f       	mov	r17, r24
    11b6:	10 72       	andi	r17, 0x20	; 32
	
	//Process events
	if (l0)
    11b8:	84 ff       	sbrs	r24, 4
    11ba:	37 c0       	rjmp	.+110    	; 0x122a <__vector_43+0xd8>
		Event.Event=RISING_2A;
    11bc:	83 e0       	ldi	r24, 0x03	; 3
    11be:	8d 83       	std	Y+5, r24	; 0x05
	else
		Event.Event=FALLING_2A;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    11c0:	20 e0       	ldi	r18, 0x00	; 0
    11c2:	ae 01       	movw	r20, r28
    11c4:	4a 5f       	subi	r20, 0xFA	; 250
    11c6:	5f 4f       	sbci	r21, 0xFF	; 255
    11c8:	be 01       	movw	r22, r28
    11ca:	6f 5f       	subi	r22, 0xFF	; 255
    11cc:	7f 4f       	sbci	r23, 0xFF	; 255
    11ce:	80 91 7b 2d 	lds	r24, 0x2D7B	; 0x802d7b <EncoderEventQueue>
    11d2:	90 91 7c 2d 	lds	r25, 0x2D7C	; 0x802d7c <EncoderEventQueue+0x1>
    11d6:	0e 94 10 21 	call	0x4220	; 0x4220 <xQueueGenericSendFromISR>
	//Process counter
	if ( l0 && !l1) Cnt2--; //Rising edge on Line0, Line1 low
    11da:	11 23       	and	r17, r17
    11dc:	b9 f1       	breq	.+110    	; 0x124c <__vector_43+0xfa>
	if ( l0 &&  l1) Cnt2++; //Rising edge on Line0, Line1 high
	if (!l0 &&  l1) Cnt2--; //Falling edge on Line0, Line1 high
	if (!l0 && !l1) Cnt2++;//Falling edge on Line1, Line1 low
    11de:	80 91 79 2d 	lds	r24, 0x2D79	; 0x802d79 <Cnt2>
    11e2:	90 91 7a 2d 	lds	r25, 0x2D7A	; 0x802d7a <Cnt2+0x1>
    11e6:	01 96       	adiw	r24, 0x01	; 1
    11e8:	80 93 79 2d 	sts	0x2D79, r24	; 0x802d79 <Cnt2>
    11ec:	90 93 7a 2d 	sts	0x2D7A, r25	; 0x802d7a <Cnt2+0x1>
	
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    11f0:	8e 81       	ldd	r24, Y+6	; 0x06
    11f2:	81 11       	cpse	r24, r1
    11f4:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <vPortYieldISR>
	LastTriggerTime=Event.Time;
}
    11f8:	26 96       	adiw	r28, 0x06	; 6
    11fa:	cd bf       	out	0x3d, r28	; 61
    11fc:	de bf       	out	0x3e, r29	; 62
    11fe:	df 91       	pop	r29
    1200:	cf 91       	pop	r28
    1202:	ff 91       	pop	r31
    1204:	ef 91       	pop	r30
    1206:	bf 91       	pop	r27
    1208:	af 91       	pop	r26
    120a:	9f 91       	pop	r25
    120c:	8f 91       	pop	r24
    120e:	7f 91       	pop	r23
    1210:	6f 91       	pop	r22
    1212:	5f 91       	pop	r21
    1214:	4f 91       	pop	r20
    1216:	3f 91       	pop	r19
    1218:	2f 91       	pop	r18
    121a:	1f 91       	pop	r17
    121c:	0f 90       	pop	r0
    121e:	0b be       	out	0x3b, r0	; 59
    1220:	0f 90       	pop	r0
    1222:	0f be       	out	0x3f, r0	; 63
    1224:	0f 90       	pop	r0
    1226:	1f 90       	pop	r1
    1228:	18 95       	reti
	
	//Process events
	if (l0)
		Event.Event=RISING_2A;
	else
		Event.Event=FALLING_2A;
    122a:	87 e0       	ldi	r24, 0x07	; 7
    122c:	8d 83       	std	Y+5, r24	; 0x05

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    122e:	20 e0       	ldi	r18, 0x00	; 0
    1230:	ae 01       	movw	r20, r28
    1232:	4a 5f       	subi	r20, 0xFA	; 250
    1234:	5f 4f       	sbci	r21, 0xFF	; 255
    1236:	be 01       	movw	r22, r28
    1238:	6f 5f       	subi	r22, 0xFF	; 255
    123a:	7f 4f       	sbci	r23, 0xFF	; 255
    123c:	80 91 7b 2d 	lds	r24, 0x2D7B	; 0x802d7b <EncoderEventQueue>
    1240:	90 91 7c 2d 	lds	r25, 0x2D7C	; 0x802d7c <EncoderEventQueue+0x1>
    1244:	0e 94 10 21 	call	0x4220	; 0x4220 <xQueueGenericSendFromISR>
	//Process counter
	if ( l0 && !l1) Cnt2--; //Rising edge on Line0, Line1 low
	if ( l0 &&  l1) Cnt2++; //Rising edge on Line0, Line1 high
	if (!l0 &&  l1) Cnt2--; //Falling edge on Line0, Line1 high
    1248:	11 23       	and	r17, r17
    124a:	49 f2       	breq	.-110    	; 0x11de <__vector_43+0x8c>
    124c:	80 91 79 2d 	lds	r24, 0x2D79	; 0x802d79 <Cnt2>
    1250:	90 91 7a 2d 	lds	r25, 0x2D7A	; 0x802d7a <Cnt2+0x1>
    1254:	01 97       	sbiw	r24, 0x01	; 1
    1256:	80 93 79 2d 	sts	0x2D79, r24	; 0x802d79 <Cnt2>
    125a:	90 93 7a 2d 	sts	0x2D7A, r25	; 0x802d7a <Cnt2+0x1>
    125e:	c8 cf       	rjmp	.-112    	; 0x11f0 <__vector_43+0x9e>

00001260 <__vector_44>:
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	LastTriggerTime=Event.Time;
}

ISR (PORTE_INT1_vect)
{
    1260:	1f 92       	push	r1
    1262:	0f 92       	push	r0
    1264:	0f b6       	in	r0, 0x3f	; 63
    1266:	0f 92       	push	r0
    1268:	11 24       	eor	r1, r1
    126a:	0b b6       	in	r0, 0x3b	; 59
    126c:	0f 92       	push	r0
    126e:	1f 93       	push	r17
    1270:	2f 93       	push	r18
    1272:	3f 93       	push	r19
    1274:	4f 93       	push	r20
    1276:	5f 93       	push	r21
    1278:	6f 93       	push	r22
    127a:	7f 93       	push	r23
    127c:	8f 93       	push	r24
    127e:	9f 93       	push	r25
    1280:	af 93       	push	r26
    1282:	bf 93       	push	r27
    1284:	ef 93       	push	r30
    1286:	ff 93       	push	r31
    1288:	cf 93       	push	r28
    128a:	df 93       	push	r29
    128c:	00 d0       	rcall	.+0      	; 0x128e <__vector_44+0x2e>
    128e:	00 d0       	rcall	.+0      	; 0x1290 <__vector_44+0x30>
    1290:	cd b7       	in	r28, 0x3d	; 61
    1292:	de b7       	in	r29, 0x3e	; 62
	static uint32_t LastTriggerTime=0;
	uint8_t Data,l0,l1;
	EncoderEventStruct Event;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    1294:	1e 82       	std	Y+6, r1	; 0x06
	Event.Time=portGET_RUN_TIME_COUNTER_VALUE();
    1296:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    129a:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    129e:	80 91 85 2d 	lds	r24, 0x2D85	; 0x802d85 <StatsTimer>
    12a2:	90 91 86 2d 	lds	r25, 0x2D86	; 0x802d86 <StatsTimer+0x1>
    12a6:	a0 91 87 2d 	lds	r26, 0x2D87	; 0x802d87 <StatsTimer+0x2>
    12aa:	b0 91 88 2d 	lds	r27, 0x2D88	; 0x802d88 <StatsTimer+0x3>
    12ae:	82 0f       	add	r24, r18
    12b0:	93 1f       	adc	r25, r19
    12b2:	a1 1d       	adc	r26, r1
    12b4:	b1 1d       	adc	r27, r1
    12b6:	89 83       	std	Y+1, r24	; 0x01
    12b8:	9a 83       	std	Y+2, r25	; 0x02
    12ba:	ab 83       	std	Y+3, r26	; 0x03
    12bc:	bc 83       	std	Y+4, r27	; 0x04
	#ifdef ENCODER_FILTER_ENABLE
		if ((Event.Time-LastTriggerTime)<ENCODER_FILTER_TIME) return;
	#endif
	
	Data=PORTE.IN;
    12be:	80 91 88 06 	lds	r24, 0x0688	; 0x800688 <__TEXT_REGION_LENGTH__+0x700688>
	l0=Data & (1<<4);
	l1=Data & (1<<5);
    12c2:	18 2f       	mov	r17, r24
    12c4:	10 72       	andi	r17, 0x20	; 32
	
	//Process events
	if (l0)
    12c6:	84 ff       	sbrs	r24, 4
    12c8:	1c c0       	rjmp	.+56     	; 0x1302 <__vector_44+0xa2>
	Event.Event=RISING_2B;
    12ca:	84 e0       	ldi	r24, 0x04	; 4
    12cc:	8d 83       	std	Y+5, r24	; 0x05
	else
	Event.Event=FALLING_2B;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    12ce:	20 e0       	ldi	r18, 0x00	; 0
    12d0:	ae 01       	movw	r20, r28
    12d2:	4a 5f       	subi	r20, 0xFA	; 250
    12d4:	5f 4f       	sbci	r21, 0xFF	; 255
    12d6:	be 01       	movw	r22, r28
    12d8:	6f 5f       	subi	r22, 0xFF	; 255
    12da:	7f 4f       	sbci	r23, 0xFF	; 255
    12dc:	80 91 7b 2d 	lds	r24, 0x2D7B	; 0x802d7b <EncoderEventQueue>
    12e0:	90 91 7c 2d 	lds	r25, 0x2D7C	; 0x802d7c <EncoderEventQueue+0x1>
    12e4:	0e 94 10 21 	call	0x4220	; 0x4220 <xQueueGenericSendFromISR>
	//Process counter
	if ( l1 && !l0) Cnt2++;//Rising edge on Line1, Line0 low
    12e8:	11 23       	and	r17, r17
    12ea:	09 f4       	brne	.+2      	; 0x12ee <__vector_44+0x8e>
    12ec:	47 c0       	rjmp	.+142    	; 0x137c <__vector_44+0x11c>
	if ( l1 &&  l0) Cnt2--;//Rising edge on Line1, Line0 high
    12ee:	80 91 79 2d 	lds	r24, 0x2D79	; 0x802d79 <Cnt2>
    12f2:	90 91 7a 2d 	lds	r25, 0x2D7A	; 0x802d7a <Cnt2+0x1>
    12f6:	01 97       	sbiw	r24, 0x01	; 1
    12f8:	80 93 79 2d 	sts	0x2D79, r24	; 0x802d79 <Cnt2>
    12fc:	90 93 7a 2d 	sts	0x2D7A, r25	; 0x802d7a <Cnt2+0x1>
    1300:	1a c0       	rjmp	.+52     	; 0x1336 <__vector_44+0xd6>
	
	//Process events
	if (l0)
	Event.Event=RISING_2B;
	else
	Event.Event=FALLING_2B;
    1302:	88 e0       	ldi	r24, 0x08	; 8
    1304:	8d 83       	std	Y+5, r24	; 0x05

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
    1306:	20 e0       	ldi	r18, 0x00	; 0
    1308:	ae 01       	movw	r20, r28
    130a:	4a 5f       	subi	r20, 0xFA	; 250
    130c:	5f 4f       	sbci	r21, 0xFF	; 255
    130e:	be 01       	movw	r22, r28
    1310:	6f 5f       	subi	r22, 0xFF	; 255
    1312:	7f 4f       	sbci	r23, 0xFF	; 255
    1314:	80 91 7b 2d 	lds	r24, 0x2D7B	; 0x802d7b <EncoderEventQueue>
    1318:	90 91 7c 2d 	lds	r25, 0x2D7C	; 0x802d7c <EncoderEventQueue+0x1>
    131c:	0e 94 10 21 	call	0x4220	; 0x4220 <xQueueGenericSendFromISR>
	//Process counter
	if ( l1 && !l0) Cnt2++;//Rising edge on Line1, Line0 low
    1320:	80 91 79 2d 	lds	r24, 0x2D79	; 0x802d79 <Cnt2>
    1324:	90 91 7a 2d 	lds	r25, 0x2D7A	; 0x802d7a <Cnt2+0x1>
    1328:	11 11       	cpse	r17, r1
    132a:	22 c0       	rjmp	.+68     	; 0x1370 <__vector_44+0x110>
	if ( l1 &&  l0) Cnt2--;//Rising edge on Line1, Line0 high
	if (!l1 &&  l0) Cnt2++;//Falling edge on Line1, Line0 high
	if (!l1 && !l0) Cnt2--;//Falling edge on Line1, Line0 low
    132c:	01 97       	sbiw	r24, 0x01	; 1
    132e:	80 93 79 2d 	sts	0x2D79, r24	; 0x802d79 <Cnt2>
    1332:	90 93 7a 2d 	sts	0x2D7A, r25	; 0x802d7a <Cnt2+0x1>

	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    1336:	8e 81       	ldd	r24, Y+6	; 0x06
    1338:	81 11       	cpse	r24, r1
    133a:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <vPortYieldISR>
	LastTriggerTime=Event.Time;
}
    133e:	26 96       	adiw	r28, 0x06	; 6
    1340:	cd bf       	out	0x3d, r28	; 61
    1342:	de bf       	out	0x3e, r29	; 62
    1344:	df 91       	pop	r29
    1346:	cf 91       	pop	r28
    1348:	ff 91       	pop	r31
    134a:	ef 91       	pop	r30
    134c:	bf 91       	pop	r27
    134e:	af 91       	pop	r26
    1350:	9f 91       	pop	r25
    1352:	8f 91       	pop	r24
    1354:	7f 91       	pop	r23
    1356:	6f 91       	pop	r22
    1358:	5f 91       	pop	r21
    135a:	4f 91       	pop	r20
    135c:	3f 91       	pop	r19
    135e:	2f 91       	pop	r18
    1360:	1f 91       	pop	r17
    1362:	0f 90       	pop	r0
    1364:	0b be       	out	0x3b, r0	; 59
    1366:	0f 90       	pop	r0
    1368:	0f be       	out	0x3f, r0	; 63
    136a:	0f 90       	pop	r0
    136c:	1f 90       	pop	r1
    136e:	18 95       	reti
	else
	Event.Event=FALLING_2B;

	xQueueSendFromISR(EncoderEventQueue,&Event,&xHigherPriorityTaskWoken);
	//Process counter
	if ( l1 && !l0) Cnt2++;//Rising edge on Line1, Line0 low
    1370:	01 96       	adiw	r24, 0x01	; 1
    1372:	80 93 79 2d 	sts	0x2D79, r24	; 0x802d79 <Cnt2>
    1376:	90 93 7a 2d 	sts	0x2D7A, r25	; 0x802d7a <Cnt2+0x1>
    137a:	dd cf       	rjmp	.-70     	; 0x1336 <__vector_44+0xd6>
	if ( l1 &&  l0) Cnt2--;//Rising edge on Line1, Line0 high
	if (!l1 &&  l0) Cnt2++;//Falling edge on Line1, Line0 high
    137c:	80 91 79 2d 	lds	r24, 0x2D79	; 0x802d79 <Cnt2>
    1380:	90 91 7a 2d 	lds	r25, 0x2D7A	; 0x802d7a <Cnt2+0x1>
    1384:	01 96       	adiw	r24, 0x01	; 1
    1386:	80 93 79 2d 	sts	0x2D79, r24	; 0x802d79 <Cnt2>
    138a:	90 93 7a 2d 	sts	0x2D7A, r25	; 0x802d7a <Cnt2+0x1>
    138e:	d3 cf       	rjmp	.-90     	; 0x1336 <__vector_44+0xd6>

00001390 <DriverMotorResetEncoder>:
}


void DriverMotorResetEncoder(void)
{
	portENTER_CRITICAL();	
    1390:	0f b6       	in	r0, 0x3f	; 63
    1392:	f8 94       	cli
    1394:	0f 92       	push	r0
	Cnt1=0;
    1396:	10 92 77 2d 	sts	0x2D77, r1	; 0x802d77 <Cnt1>
    139a:	10 92 78 2d 	sts	0x2D78, r1	; 0x802d78 <Cnt1+0x1>
	Cnt2=0;
    139e:	10 92 79 2d 	sts	0x2D79, r1	; 0x802d79 <Cnt2>
    13a2:	10 92 7a 2d 	sts	0x2D7A, r1	; 0x802d7a <Cnt2+0x1>
	portEXIT_CRITICAL();
    13a6:	0f 90       	pop	r0
    13a8:	0f be       	out	0x3f, r0	; 63
    13aa:	08 95       	ret

000013ac <set_page_address.part.0>:

void DriverOLEDWake()
{
	if (!DriverOLEDInitialized) return;
	send_command(0xAF);
}
    13ac:	1f 93       	push	r17
    13ae:	cf 93       	push	r28
    13b0:	df 93       	push	r29
    13b2:	1f 92       	push	r1
    13b4:	1f 92       	push	r1
    13b6:	cd b7       	in	r28, 0x3d	; 61
    13b8:	de b7       	in	r29, 0x3e	; 62
    13ba:	10 e8       	ldi	r17, 0x80	; 128
    13bc:	19 83       	std	Y+1, r17	; 0x01
    13be:	82 e2       	ldi	r24, 0x22	; 34
    13c0:	8a 83       	std	Y+2, r24	; 0x02
    13c2:	42 e0       	ldi	r20, 0x02	; 2
    13c4:	be 01       	movw	r22, r28
    13c6:	6f 5f       	subi	r22, 0xFF	; 255
    13c8:	7f 4f       	sbci	r23, 0xFF	; 255
    13ca:	8c e3       	ldi	r24, 0x3C	; 60
    13cc:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
    13d0:	19 83       	std	Y+1, r17	; 0x01
    13d2:	1a 82       	std	Y+2, r1	; 0x02
    13d4:	42 e0       	ldi	r20, 0x02	; 2
    13d6:	be 01       	movw	r22, r28
    13d8:	6f 5f       	subi	r22, 0xFF	; 255
    13da:	7f 4f       	sbci	r23, 0xFF	; 255
    13dc:	8c e3       	ldi	r24, 0x3C	; 60
    13de:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
    13e2:	19 83       	std	Y+1, r17	; 0x01
    13e4:	87 e0       	ldi	r24, 0x07	; 7
    13e6:	8a 83       	std	Y+2, r24	; 0x02
    13e8:	42 e0       	ldi	r20, 0x02	; 2
    13ea:	be 01       	movw	r22, r28
    13ec:	6f 5f       	subi	r22, 0xFF	; 255
    13ee:	7f 4f       	sbci	r23, 0xFF	; 255
    13f0:	8c e3       	ldi	r24, 0x3C	; 60
    13f2:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
    13f6:	0f 90       	pop	r0
    13f8:	0f 90       	pop	r0
    13fa:	df 91       	pop	r29
    13fc:	cf 91       	pop	r28
    13fe:	1f 91       	pop	r17
    1400:	08 95       	ret

00001402 <set_column_address.part.1>:
    1402:	1f 93       	push	r17
    1404:	cf 93       	push	r28
    1406:	df 93       	push	r29
    1408:	1f 92       	push	r1
    140a:	1f 92       	push	r1
    140c:	cd b7       	in	r28, 0x3d	; 61
    140e:	de b7       	in	r29, 0x3e	; 62
    1410:	10 e8       	ldi	r17, 0x80	; 128
    1412:	19 83       	std	Y+1, r17	; 0x01
    1414:	81 e2       	ldi	r24, 0x21	; 33
    1416:	8a 83       	std	Y+2, r24	; 0x02
    1418:	42 e0       	ldi	r20, 0x02	; 2
    141a:	be 01       	movw	r22, r28
    141c:	6f 5f       	subi	r22, 0xFF	; 255
    141e:	7f 4f       	sbci	r23, 0xFF	; 255
    1420:	8c e3       	ldi	r24, 0x3C	; 60
    1422:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
    1426:	19 83       	std	Y+1, r17	; 0x01
    1428:	1a 82       	std	Y+2, r1	; 0x02
    142a:	42 e0       	ldi	r20, 0x02	; 2
    142c:	be 01       	movw	r22, r28
    142e:	6f 5f       	subi	r22, 0xFF	; 255
    1430:	7f 4f       	sbci	r23, 0xFF	; 255
    1432:	8c e3       	ldi	r24, 0x3C	; 60
    1434:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
    1438:	19 83       	std	Y+1, r17	; 0x01
    143a:	8f e7       	ldi	r24, 0x7F	; 127
    143c:	8a 83       	std	Y+2, r24	; 0x02
    143e:	42 e0       	ldi	r20, 0x02	; 2
    1440:	be 01       	movw	r22, r28
    1442:	6f 5f       	subi	r22, 0xFF	; 255
    1444:	7f 4f       	sbci	r23, 0xFF	; 255
    1446:	8c e3       	ldi	r24, 0x3C	; 60
    1448:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
    144c:	0f 90       	pop	r0
    144e:	0f 90       	pop	r0
    1450:	df 91       	pop	r29
    1452:	cf 91       	pop	r28
    1454:	1f 91       	pop	r17
    1456:	08 95       	ret

00001458 <DriverOLEDDrawPixel.part.3>:
    1458:	90 91 34 28 	lds	r25, 0x2834	; 0x802834 <GlobOrientation>
    145c:	91 11       	cpse	r25, r1
    145e:	1c c0       	rjmp	.+56     	; 0x1498 <DriverOLEDDrawPixel.part.3+0x40>
    1460:	87 fd       	sbrc	r24, 7
    1462:	19 c0       	rjmp	.+50     	; 0x1496 <DriverOLEDDrawPixel.part.3+0x3e>
    1464:	60 34       	cpi	r22, 0x40	; 64
    1466:	b8 f4       	brcc	.+46     	; 0x1496 <DriverOLEDDrawPixel.part.3+0x3e>
    1468:	96 2f       	mov	r25, r22
    146a:	96 95       	lsr	r25
    146c:	96 95       	lsr	r25
    146e:	96 95       	lsr	r25
    1470:	e8 2f       	mov	r30, r24
    1472:	f0 e0       	ldi	r31, 0x00	; 0
    1474:	20 e8       	ldi	r18, 0x80	; 128
    1476:	92 9f       	mul	r25, r18
    1478:	e0 0d       	add	r30, r0
    147a:	f1 1d       	adc	r31, r1
    147c:	11 24       	eor	r1, r1
    147e:	eb 5c       	subi	r30, 0xCB	; 203
    1480:	f7 4d       	sbci	r31, 0xD7	; 215
    1482:	67 70       	andi	r22, 0x07	; 7
    1484:	81 e0       	ldi	r24, 0x01	; 1
    1486:	90 e0       	ldi	r25, 0x00	; 0
    1488:	01 c0       	rjmp	.+2      	; 0x148c <DriverOLEDDrawPixel.part.3+0x34>
    148a:	88 0f       	add	r24, r24
    148c:	6a 95       	dec	r22
    148e:	ea f7       	brpl	.-6      	; 0x148a <DriverOLEDDrawPixel.part.3+0x32>
    1490:	90 81       	ld	r25, Z
    1492:	89 2b       	or	r24, r25
    1494:	80 83       	st	Z, r24
    1496:	08 95       	ret
    1498:	91 30       	cpi	r25, 0x01	; 1
    149a:	21 f1       	breq	.+72     	; 0x14e4 <DriverOLEDDrawPixel.part.3+0x8c>
    149c:	92 30       	cpi	r25, 0x02	; 2
    149e:	d9 f7       	brne	.-10     	; 0x1496 <DriverOLEDDrawPixel.part.3+0x3e>
    14a0:	87 fd       	sbrc	r24, 7
    14a2:	f9 cf       	rjmp	.-14     	; 0x1496 <DriverOLEDDrawPixel.part.3+0x3e>
    14a4:	60 34       	cpi	r22, 0x40	; 64
    14a6:	b8 f7       	brcc	.-18     	; 0x1496 <DriverOLEDDrawPixel.part.3+0x3e>
    14a8:	70 e0       	ldi	r23, 0x00	; 0
    14aa:	ef e3       	ldi	r30, 0x3F	; 63
    14ac:	f0 e0       	ldi	r31, 0x00	; 0
    14ae:	e6 1b       	sub	r30, r22
    14b0:	f7 0b       	sbc	r31, r23
    14b2:	f5 95       	asr	r31
    14b4:	e7 95       	ror	r30
    14b6:	f5 95       	asr	r31
    14b8:	e7 95       	ror	r30
    14ba:	f5 95       	asr	r31
    14bc:	e7 95       	ror	r30
    14be:	f6 95       	lsr	r31
    14c0:	fe 2f       	mov	r31, r30
    14c2:	ee 27       	eor	r30, r30
    14c4:	f7 95       	ror	r31
    14c6:	e7 95       	ror	r30
    14c8:	2f e7       	ldi	r18, 0x7F	; 127
    14ca:	30 e0       	ldi	r19, 0x00	; 0
    14cc:	a9 01       	movw	r20, r18
    14ce:	48 1b       	sub	r20, r24
    14d0:	51 09       	sbc	r21, r1
    14d2:	e4 0f       	add	r30, r20
    14d4:	f5 1f       	adc	r31, r21
    14d6:	eb 5c       	subi	r30, 0xCB	; 203
    14d8:	f7 4d       	sbci	r31, 0xD7	; 215
    14da:	60 95       	com	r22
    14dc:	70 95       	com	r23
    14de:	67 70       	andi	r22, 0x07	; 7
    14e0:	77 27       	eor	r23, r23
    14e2:	d0 cf       	rjmp	.-96     	; 0x1484 <DriverOLEDDrawPixel.part.3+0x2c>
    14e4:	80 34       	cpi	r24, 0x40	; 64
    14e6:	b8 f6       	brcc	.-82     	; 0x1496 <DriverOLEDDrawPixel.part.3+0x3e>
    14e8:	67 fd       	sbrc	r22, 7
    14ea:	d5 cf       	rjmp	.-86     	; 0x1496 <DriverOLEDDrawPixel.part.3+0x3e>
    14ec:	98 2f       	mov	r25, r24
    14ee:	96 95       	lsr	r25
    14f0:	96 95       	lsr	r25
    14f2:	96 95       	lsr	r25
    14f4:	af e7       	ldi	r26, 0x7F	; 127
    14f6:	b0 e0       	ldi	r27, 0x00	; 0
    14f8:	a6 1b       	sub	r26, r22
    14fa:	b1 09       	sbc	r27, r1
    14fc:	40 e8       	ldi	r20, 0x80	; 128
    14fe:	94 9f       	mul	r25, r20
    1500:	a0 0d       	add	r26, r0
    1502:	b1 1d       	adc	r27, r1
    1504:	11 24       	eor	r1, r1
    1506:	ab 5c       	subi	r26, 0xCB	; 203
    1508:	b7 4d       	sbci	r27, 0xD7	; 215
    150a:	e8 2f       	mov	r30, r24
    150c:	e7 70       	andi	r30, 0x07	; 7
    150e:	81 e0       	ldi	r24, 0x01	; 1
    1510:	90 e0       	ldi	r25, 0x00	; 0
    1512:	01 c0       	rjmp	.+2      	; 0x1516 <DriverOLEDDrawPixel.part.3+0xbe>
    1514:	88 0f       	add	r24, r24
    1516:	ea 95       	dec	r30
    1518:	ea f7       	brpl	.-6      	; 0x1514 <DriverOLEDDrawPixel.part.3+0xbc>
    151a:	9c 91       	ld	r25, X
    151c:	89 2b       	or	r24, r25
    151e:	8c 93       	st	X, r24
    1520:	08 95       	ret

00001522 <DriverOLEDClearPixel.part.4>:
    1522:	90 91 34 28 	lds	r25, 0x2834	; 0x802834 <GlobOrientation>
    1526:	91 11       	cpse	r25, r1
    1528:	1d c0       	rjmp	.+58     	; 0x1564 <DriverOLEDClearPixel.part.4+0x42>
    152a:	87 fd       	sbrc	r24, 7
    152c:	1a c0       	rjmp	.+52     	; 0x1562 <DriverOLEDClearPixel.part.4+0x40>
    152e:	60 34       	cpi	r22, 0x40	; 64
    1530:	c0 f4       	brcc	.+48     	; 0x1562 <DriverOLEDClearPixel.part.4+0x40>
    1532:	96 2f       	mov	r25, r22
    1534:	96 95       	lsr	r25
    1536:	96 95       	lsr	r25
    1538:	96 95       	lsr	r25
    153a:	e8 2f       	mov	r30, r24
    153c:	f0 e0       	ldi	r31, 0x00	; 0
    153e:	20 e8       	ldi	r18, 0x80	; 128
    1540:	92 9f       	mul	r25, r18
    1542:	e0 0d       	add	r30, r0
    1544:	f1 1d       	adc	r31, r1
    1546:	11 24       	eor	r1, r1
    1548:	eb 5c       	subi	r30, 0xCB	; 203
    154a:	f7 4d       	sbci	r31, 0xD7	; 215
    154c:	67 70       	andi	r22, 0x07	; 7
    154e:	81 e0       	ldi	r24, 0x01	; 1
    1550:	90 e0       	ldi	r25, 0x00	; 0
    1552:	01 c0       	rjmp	.+2      	; 0x1556 <DriverOLEDClearPixel.part.4+0x34>
    1554:	88 0f       	add	r24, r24
    1556:	6a 95       	dec	r22
    1558:	ea f7       	brpl	.-6      	; 0x1554 <DriverOLEDClearPixel.part.4+0x32>
    155a:	80 95       	com	r24
    155c:	90 81       	ld	r25, Z
    155e:	89 23       	and	r24, r25
    1560:	80 83       	st	Z, r24
    1562:	08 95       	ret
    1564:	91 30       	cpi	r25, 0x01	; 1
    1566:	21 f1       	breq	.+72     	; 0x15b0 <DriverOLEDClearPixel.part.4+0x8e>
    1568:	92 30       	cpi	r25, 0x02	; 2
    156a:	d9 f7       	brne	.-10     	; 0x1562 <DriverOLEDClearPixel.part.4+0x40>
    156c:	87 fd       	sbrc	r24, 7
    156e:	f9 cf       	rjmp	.-14     	; 0x1562 <DriverOLEDClearPixel.part.4+0x40>
    1570:	60 34       	cpi	r22, 0x40	; 64
    1572:	b8 f7       	brcc	.-18     	; 0x1562 <DriverOLEDClearPixel.part.4+0x40>
    1574:	70 e0       	ldi	r23, 0x00	; 0
    1576:	ef e3       	ldi	r30, 0x3F	; 63
    1578:	f0 e0       	ldi	r31, 0x00	; 0
    157a:	e6 1b       	sub	r30, r22
    157c:	f7 0b       	sbc	r31, r23
    157e:	f5 95       	asr	r31
    1580:	e7 95       	ror	r30
    1582:	f5 95       	asr	r31
    1584:	e7 95       	ror	r30
    1586:	f5 95       	asr	r31
    1588:	e7 95       	ror	r30
    158a:	f6 95       	lsr	r31
    158c:	fe 2f       	mov	r31, r30
    158e:	ee 27       	eor	r30, r30
    1590:	f7 95       	ror	r31
    1592:	e7 95       	ror	r30
    1594:	2f e7       	ldi	r18, 0x7F	; 127
    1596:	30 e0       	ldi	r19, 0x00	; 0
    1598:	a9 01       	movw	r20, r18
    159a:	48 1b       	sub	r20, r24
    159c:	51 09       	sbc	r21, r1
    159e:	e4 0f       	add	r30, r20
    15a0:	f5 1f       	adc	r31, r21
    15a2:	eb 5c       	subi	r30, 0xCB	; 203
    15a4:	f7 4d       	sbci	r31, 0xD7	; 215
    15a6:	60 95       	com	r22
    15a8:	70 95       	com	r23
    15aa:	67 70       	andi	r22, 0x07	; 7
    15ac:	77 27       	eor	r23, r23
    15ae:	cf cf       	rjmp	.-98     	; 0x154e <DriverOLEDClearPixel.part.4+0x2c>
    15b0:	80 34       	cpi	r24, 0x40	; 64
    15b2:	b8 f6       	brcc	.-82     	; 0x1562 <DriverOLEDClearPixel.part.4+0x40>
    15b4:	67 fd       	sbrc	r22, 7
    15b6:	d5 cf       	rjmp	.-86     	; 0x1562 <DriverOLEDClearPixel.part.4+0x40>
    15b8:	98 2f       	mov	r25, r24
    15ba:	96 95       	lsr	r25
    15bc:	96 95       	lsr	r25
    15be:	96 95       	lsr	r25
    15c0:	af e7       	ldi	r26, 0x7F	; 127
    15c2:	b0 e0       	ldi	r27, 0x00	; 0
    15c4:	a6 1b       	sub	r26, r22
    15c6:	b1 09       	sbc	r27, r1
    15c8:	40 e8       	ldi	r20, 0x80	; 128
    15ca:	94 9f       	mul	r25, r20
    15cc:	a0 0d       	add	r26, r0
    15ce:	b1 1d       	adc	r27, r1
    15d0:	11 24       	eor	r1, r1
    15d2:	ab 5c       	subi	r26, 0xCB	; 203
    15d4:	b7 4d       	sbci	r27, 0xD7	; 215
    15d6:	e8 2f       	mov	r30, r24
    15d8:	e7 70       	andi	r30, 0x07	; 7
    15da:	81 e0       	ldi	r24, 0x01	; 1
    15dc:	90 e0       	ldi	r25, 0x00	; 0
    15de:	01 c0       	rjmp	.+2      	; 0x15e2 <DriverOLEDClearPixel.part.4+0xc0>
    15e0:	88 0f       	add	r24, r24
    15e2:	ea 95       	dec	r30
    15e4:	ea f7       	brpl	.-6      	; 0x15e0 <DriverOLEDClearPixel.part.4+0xbe>
    15e6:	80 95       	com	r24
    15e8:	9c 91       	ld	r25, X
    15ea:	89 23       	and	r24, r25
    15ec:	8c 93       	st	X, r24
    15ee:	08 95       	ret

000015f0 <DriverOLEDPrintSmChar.part.5>:
    15f0:	6f 92       	push	r6
    15f2:	7f 92       	push	r7
    15f4:	8f 92       	push	r8
    15f6:	9f 92       	push	r9
    15f8:	af 92       	push	r10
    15fa:	bf 92       	push	r11
    15fc:	cf 92       	push	r12
    15fe:	df 92       	push	r13
    1600:	ef 92       	push	r14
    1602:	ff 92       	push	r15
    1604:	0f 93       	push	r16
    1606:	1f 93       	push	r17
    1608:	cf 93       	push	r28
    160a:	df 93       	push	r29
    160c:	90 91 34 28 	lds	r25, 0x2834	; 0x802834 <GlobOrientation>
    1610:	91 11       	cpse	r25, r1
    1612:	28 c0       	rjmp	.+80     	; 0x1664 <DriverOLEDPrintSmChar.part.5+0x74>
    1614:	22 23       	and	r18, r18
    1616:	d1 f1       	breq	.+116    	; 0x168c <DriverOLEDPrintSmChar.part.5+0x9c>
    1618:	26 e0       	ldi	r18, 0x06	; 6
    161a:	82 9f       	mul	r24, r18
    161c:	c0 01       	movw	r24, r0
    161e:	11 24       	eor	r1, r1
    1620:	20 e8       	ldi	r18, 0x80	; 128
    1622:	62 9f       	mul	r22, r18
    1624:	80 0d       	add	r24, r0
    1626:	91 1d       	adc	r25, r1
    1628:	11 24       	eor	r1, r1
    162a:	50 e0       	ldi	r21, 0x00	; 0
    162c:	40 52       	subi	r20, 0x20	; 32
    162e:	51 09       	sbc	r21, r1
    1630:	fa 01       	movw	r30, r20
    1632:	ee 0f       	add	r30, r30
    1634:	ff 1f       	adc	r31, r31
    1636:	ee 0f       	add	r30, r30
    1638:	ff 1f       	adc	r31, r31
    163a:	e4 0f       	add	r30, r20
    163c:	f5 1f       	adc	r31, r21
    163e:	e5 5d       	subi	r30, 0xD5	; 213
    1640:	fe 4d       	sbci	r31, 0xDE	; 222
    1642:	dc 01       	movw	r26, r24
    1644:	ab 5c       	subi	r26, 0xCB	; 203
    1646:	b7 4d       	sbci	r27, 0xD7	; 215
    1648:	ac 01       	movw	r20, r24
    164a:	4b 5f       	subi	r20, 0xFB	; 251
    164c:	5f 4f       	sbci	r21, 0xFF	; 255
    164e:	01 96       	adiw	r24, 0x01	; 1
    1650:	21 91       	ld	r18, Z+
    1652:	2d 93       	st	X+, r18
    1654:	84 17       	cp	r24, r20
    1656:	95 07       	cpc	r25, r21
    1658:	d1 f7       	brne	.-12     	; 0x164e <DriverOLEDPrintSmChar.part.5+0x5e>
    165a:	fc 01       	movw	r30, r24
    165c:	eb 5c       	subi	r30, 0xCB	; 203
    165e:	f7 4d       	sbci	r31, 0xD7	; 215
    1660:	10 82       	st	Z, r1
    1662:	05 c0       	rjmp	.+10     	; 0x166e <DriverOLEDPrintSmChar.part.5+0x7e>
    1664:	91 30       	cpi	r25, 0x01	; 1
    1666:	e9 f0       	breq	.+58     	; 0x16a2 <DriverOLEDPrintSmChar.part.5+0xb2>
    1668:	92 30       	cpi	r25, 0x02	; 2
    166a:	09 f4       	brne	.+2      	; 0x166e <DriverOLEDPrintSmChar.part.5+0x7e>
    166c:	77 c0       	rjmp	.+238    	; 0x175c <DriverOLEDPrintSmChar.part.5+0x16c>
    166e:	df 91       	pop	r29
    1670:	cf 91       	pop	r28
    1672:	1f 91       	pop	r17
    1674:	0f 91       	pop	r16
    1676:	ff 90       	pop	r15
    1678:	ef 90       	pop	r14
    167a:	df 90       	pop	r13
    167c:	cf 90       	pop	r12
    167e:	bf 90       	pop	r11
    1680:	af 90       	pop	r10
    1682:	9f 90       	pop	r9
    1684:	8f 90       	pop	r8
    1686:	7f 90       	pop	r7
    1688:	6f 90       	pop	r6
    168a:	08 95       	ret
    168c:	26 e0       	ldi	r18, 0x06	; 6
    168e:	82 9f       	mul	r24, r18
    1690:	c0 01       	movw	r24, r0
    1692:	11 24       	eor	r1, r1
    1694:	8b 37       	cpi	r24, 0x7B	; 123
    1696:	91 05       	cpc	r25, r1
    1698:	1c f2       	brlt	.-122    	; 0x1620 <DriverOLEDPrintSmChar.part.5+0x30>
    169a:	6f 5f       	subi	r22, 0xFF	; 255
    169c:	80 e0       	ldi	r24, 0x00	; 0
    169e:	90 e0       	ldi	r25, 0x00	; 0
    16a0:	bf cf       	rjmp	.-130    	; 0x1620 <DriverOLEDPrintSmChar.part.5+0x30>
    16a2:	88 2e       	mov	r8, r24
    16a4:	88 0c       	add	r8, r8
    16a6:	88 0d       	add	r24, r8
    16a8:	88 2e       	mov	r8, r24
    16aa:	88 0c       	add	r8, r8
    16ac:	66 2e       	mov	r6, r22
    16ae:	66 0c       	add	r6, r6
    16b0:	66 0c       	add	r6, r6
    16b2:	66 0c       	add	r6, r6
    16b4:	e6 2c       	mov	r14, r6
    16b6:	f1 2c       	mov	r15, r1
    16b8:	87 e0       	ldi	r24, 0x07	; 7
    16ba:	e8 0e       	add	r14, r24
    16bc:	f1 1c       	adc	r15, r1
    16be:	a8 2c       	mov	r10, r8
    16c0:	b1 2c       	mov	r11, r1
    16c2:	24 e0       	ldi	r18, 0x04	; 4
    16c4:	a2 0e       	add	r10, r18
    16c6:	b1 1c       	adc	r11, r1
    16c8:	76 2c       	mov	r7, r6
    16ca:	50 e0       	ldi	r21, 0x00	; 0
    16cc:	40 52       	subi	r20, 0x20	; 32
    16ce:	51 09       	sbc	r21, r1
    16d0:	cc 24       	eor	r12, r12
    16d2:	c3 94       	inc	r12
    16d4:	d1 2c       	mov	r13, r1
    16d6:	ea 01       	movw	r28, r20
    16d8:	cc 0f       	add	r28, r28
    16da:	dd 1f       	adc	r29, r29
    16dc:	cc 0f       	add	r28, r28
    16de:	dd 1f       	adc	r29, r29
    16e0:	4c 0f       	add	r20, r28
    16e2:	5d 1f       	adc	r21, r29
    16e4:	ea 01       	movw	r28, r20
    16e6:	c5 5d       	subi	r28, 0xD5	; 213
    16e8:	de 4d       	sbci	r29, 0xDE	; 222
    16ea:	87 2d       	mov	r24, r7
    16ec:	86 19       	sub	r24, r6
    16ee:	86 01       	movw	r16, r12
    16f0:	02 c0       	rjmp	.+4      	; 0x16f6 <DriverOLEDPrintSmChar.part.5+0x106>
    16f2:	00 0f       	add	r16, r16
    16f4:	11 1f       	adc	r17, r17
    16f6:	8a 95       	dec	r24
    16f8:	e2 f7       	brpl	.-8      	; 0x16f2 <DriverOLEDPrintSmChar.part.5+0x102>
    16fa:	98 2c       	mov	r9, r8
    16fc:	0a c0       	rjmp	.+20     	; 0x1712 <DriverOLEDPrintSmChar.part.5+0x122>
    16fe:	80 91 33 28 	lds	r24, 0x2833	; 0x802833 <DriverOLEDInitialized>
    1702:	81 11       	cpse	r24, r1
    1704:	26 c0       	rjmp	.+76     	; 0x1752 <DriverOLEDPrintSmChar.part.5+0x162>
    1706:	93 94       	inc	r9
    1708:	89 2d       	mov	r24, r9
    170a:	90 e0       	ldi	r25, 0x00	; 0
    170c:	a8 16       	cp	r10, r24
    170e:	b9 06       	cpc	r11, r25
    1710:	cc f0       	brlt	.+50     	; 0x1744 <DriverOLEDPrintSmChar.part.5+0x154>
    1712:	89 2d       	mov	r24, r9
    1714:	88 19       	sub	r24, r8
    1716:	fe 01       	movw	r30, r28
    1718:	e8 0f       	add	r30, r24
    171a:	f1 1d       	adc	r31, r1
    171c:	80 81       	ld	r24, Z
    171e:	90 e0       	ldi	r25, 0x00	; 0
    1720:	80 23       	and	r24, r16
    1722:	91 23       	and	r25, r17
    1724:	89 2b       	or	r24, r25
    1726:	59 f7       	brne	.-42     	; 0x16fe <DriverOLEDPrintSmChar.part.5+0x10e>
    1728:	80 91 33 28 	lds	r24, 0x2833	; 0x802833 <DriverOLEDInitialized>
    172c:	88 23       	and	r24, r24
    172e:	59 f3       	breq	.-42     	; 0x1706 <DriverOLEDPrintSmChar.part.5+0x116>
    1730:	67 2d       	mov	r22, r7
    1732:	89 2d       	mov	r24, r9
    1734:	0e 94 91 0a 	call	0x1522	; 0x1522 <DriverOLEDClearPixel.part.4>
    1738:	93 94       	inc	r9
    173a:	89 2d       	mov	r24, r9
    173c:	90 e0       	ldi	r25, 0x00	; 0
    173e:	a8 16       	cp	r10, r24
    1740:	b9 06       	cpc	r11, r25
    1742:	3c f7       	brge	.-50     	; 0x1712 <DriverOLEDPrintSmChar.part.5+0x122>
    1744:	73 94       	inc	r7
    1746:	87 2d       	mov	r24, r7
    1748:	90 e0       	ldi	r25, 0x00	; 0
    174a:	e8 16       	cp	r14, r24
    174c:	f9 06       	cpc	r15, r25
    174e:	6c f6       	brge	.-102    	; 0x16ea <DriverOLEDPrintSmChar.part.5+0xfa>
    1750:	8e cf       	rjmp	.-228    	; 0x166e <DriverOLEDPrintSmChar.part.5+0x7e>
    1752:	67 2d       	mov	r22, r7
    1754:	89 2d       	mov	r24, r9
    1756:	0e 94 2c 0a 	call	0x1458	; 0x1458 <DriverOLEDDrawPixel.part.3>
    175a:	d5 cf       	rjmp	.-86     	; 0x1706 <DriverOLEDPrintSmChar.part.5+0x116>
    175c:	88 2e       	mov	r8, r24
    175e:	88 0c       	add	r8, r8
    1760:	88 0d       	add	r24, r8
    1762:	88 2e       	mov	r8, r24
    1764:	88 0c       	add	r8, r8
    1766:	66 2e       	mov	r6, r22
    1768:	66 0c       	add	r6, r6
    176a:	66 0c       	add	r6, r6
    176c:	66 0c       	add	r6, r6
    176e:	e6 2c       	mov	r14, r6
    1770:	f1 2c       	mov	r15, r1
    1772:	87 e0       	ldi	r24, 0x07	; 7
    1774:	e8 0e       	add	r14, r24
    1776:	f1 1c       	adc	r15, r1
    1778:	a8 2c       	mov	r10, r8
    177a:	b1 2c       	mov	r11, r1
    177c:	24 e0       	ldi	r18, 0x04	; 4
    177e:	a2 0e       	add	r10, r18
    1780:	b1 1c       	adc	r11, r1
    1782:	76 2c       	mov	r7, r6
    1784:	50 e0       	ldi	r21, 0x00	; 0
    1786:	40 52       	subi	r20, 0x20	; 32
    1788:	51 09       	sbc	r21, r1
    178a:	cc 24       	eor	r12, r12
    178c:	c3 94       	inc	r12
    178e:	d1 2c       	mov	r13, r1
    1790:	ea 01       	movw	r28, r20
    1792:	cc 0f       	add	r28, r28
    1794:	dd 1f       	adc	r29, r29
    1796:	cc 0f       	add	r28, r28
    1798:	dd 1f       	adc	r29, r29
    179a:	4c 0f       	add	r20, r28
    179c:	5d 1f       	adc	r21, r29
    179e:	ea 01       	movw	r28, r20
    17a0:	c5 5d       	subi	r28, 0xD5	; 213
    17a2:	de 4d       	sbci	r29, 0xDE	; 222
    17a4:	87 2d       	mov	r24, r7
    17a6:	86 19       	sub	r24, r6
    17a8:	86 01       	movw	r16, r12
    17aa:	02 c0       	rjmp	.+4      	; 0x17b0 <DriverOLEDPrintSmChar.part.5+0x1c0>
    17ac:	00 0f       	add	r16, r16
    17ae:	11 1f       	adc	r17, r17
    17b0:	8a 95       	dec	r24
    17b2:	e2 f7       	brpl	.-8      	; 0x17ac <DriverOLEDPrintSmChar.part.5+0x1bc>
    17b4:	98 2c       	mov	r9, r8
    17b6:	0a c0       	rjmp	.+20     	; 0x17cc <DriverOLEDPrintSmChar.part.5+0x1dc>
    17b8:	80 91 33 28 	lds	r24, 0x2833	; 0x802833 <DriverOLEDInitialized>
    17bc:	81 11       	cpse	r24, r1
    17be:	26 c0       	rjmp	.+76     	; 0x180c <DriverOLEDPrintSmChar.part.5+0x21c>
    17c0:	93 94       	inc	r9
    17c2:	89 2d       	mov	r24, r9
    17c4:	90 e0       	ldi	r25, 0x00	; 0
    17c6:	a8 16       	cp	r10, r24
    17c8:	b9 06       	cpc	r11, r25
    17ca:	cc f0       	brlt	.+50     	; 0x17fe <DriverOLEDPrintSmChar.part.5+0x20e>
    17cc:	89 2d       	mov	r24, r9
    17ce:	88 19       	sub	r24, r8
    17d0:	fe 01       	movw	r30, r28
    17d2:	e8 0f       	add	r30, r24
    17d4:	f1 1d       	adc	r31, r1
    17d6:	80 81       	ld	r24, Z
    17d8:	90 e0       	ldi	r25, 0x00	; 0
    17da:	80 23       	and	r24, r16
    17dc:	91 23       	and	r25, r17
    17de:	89 2b       	or	r24, r25
    17e0:	59 f7       	brne	.-42     	; 0x17b8 <DriverOLEDPrintSmChar.part.5+0x1c8>
    17e2:	80 91 33 28 	lds	r24, 0x2833	; 0x802833 <DriverOLEDInitialized>
    17e6:	88 23       	and	r24, r24
    17e8:	59 f3       	breq	.-42     	; 0x17c0 <DriverOLEDPrintSmChar.part.5+0x1d0>
    17ea:	67 2d       	mov	r22, r7
    17ec:	89 2d       	mov	r24, r9
    17ee:	0e 94 91 0a 	call	0x1522	; 0x1522 <DriverOLEDClearPixel.part.4>
    17f2:	93 94       	inc	r9
    17f4:	89 2d       	mov	r24, r9
    17f6:	90 e0       	ldi	r25, 0x00	; 0
    17f8:	a8 16       	cp	r10, r24
    17fa:	b9 06       	cpc	r11, r25
    17fc:	3c f7       	brge	.-50     	; 0x17cc <DriverOLEDPrintSmChar.part.5+0x1dc>
    17fe:	73 94       	inc	r7
    1800:	87 2d       	mov	r24, r7
    1802:	90 e0       	ldi	r25, 0x00	; 0
    1804:	e8 16       	cp	r14, r24
    1806:	f9 06       	cpc	r15, r25
    1808:	6c f6       	brge	.-102    	; 0x17a4 <DriverOLEDPrintSmChar.part.5+0x1b4>
    180a:	31 cf       	rjmp	.-414    	; 0x166e <DriverOLEDPrintSmChar.part.5+0x7e>
    180c:	67 2d       	mov	r22, r7
    180e:	89 2d       	mov	r24, r9
    1810:	0e 94 2c 0a 	call	0x1458	; 0x1458 <DriverOLEDDrawPixel.part.3>
    1814:	d5 cf       	rjmp	.-86     	; 0x17c0 <DriverOLEDPrintSmChar.part.5+0x1d0>

00001816 <DriverOLEDUpdate>:
    1816:	bf 92       	push	r11
    1818:	cf 92       	push	r12
    181a:	df 92       	push	r13
    181c:	ef 92       	push	r14
    181e:	ff 92       	push	r15
    1820:	0f 93       	push	r16
    1822:	1f 93       	push	r17
    1824:	cf 93       	push	r28
    1826:	df 93       	push	r29
    1828:	cd b7       	in	r28, 0x3d	; 61
    182a:	de b7       	in	r29, 0x3e	; 62
    182c:	61 97       	sbiw	r28, 0x11	; 17
    182e:	cd bf       	out	0x3d, r28	; 61
    1830:	de bf       	out	0x3e, r29	; 62
    1832:	80 91 33 28 	lds	r24, 0x2833	; 0x802833 <DriverOLEDInitialized>
    1836:	88 23       	and	r24, r24
    1838:	49 f1       	breq	.+82     	; 0x188c <DriverOLEDUpdate+0x76>
    183a:	0e 94 01 0a 	call	0x1402	; 0x1402 <set_column_address.part.1>
    183e:	80 91 33 28 	lds	r24, 0x2833	; 0x802833 <DriverOLEDInitialized>
    1842:	81 11       	cpse	r24, r1
    1844:	30 c0       	rjmp	.+96     	; 0x18a6 <DriverOLEDUpdate+0x90>
    1846:	85 e3       	ldi	r24, 0x35	; 53
    1848:	c8 2e       	mov	r12, r24
    184a:	88 e2       	ldi	r24, 0x28	; 40
    184c:	d8 2e       	mov	r13, r24
    184e:	95 e3       	ldi	r25, 0x35	; 53
    1850:	e9 2e       	mov	r14, r25
    1852:	9c e2       	ldi	r25, 0x2C	; 44
    1854:	f9 2e       	mov	r15, r25
    1856:	8e 01       	movw	r16, r28
    1858:	0e 5e       	subi	r16, 0xEE	; 238
    185a:	1f 4f       	sbci	r17, 0xFF	; 255
    185c:	20 e4       	ldi	r18, 0x40	; 64
    185e:	b2 2e       	mov	r11, r18
    1860:	b9 82       	std	Y+1, r11	; 0x01
    1862:	fe 01       	movw	r30, r28
    1864:	32 96       	adiw	r30, 0x02	; 2
    1866:	d6 01       	movw	r26, r12
    1868:	8d 91       	ld	r24, X+
    186a:	81 93       	st	Z+, r24
    186c:	e0 17       	cp	r30, r16
    186e:	f1 07       	cpc	r31, r17
    1870:	d9 f7       	brne	.-10     	; 0x1868 <DriverOLEDUpdate+0x52>
    1872:	41 e1       	ldi	r20, 0x11	; 17
    1874:	be 01       	movw	r22, r28
    1876:	6f 5f       	subi	r22, 0xFF	; 255
    1878:	7f 4f       	sbci	r23, 0xFF	; 255
    187a:	8c e3       	ldi	r24, 0x3C	; 60
    187c:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
    1880:	80 e1       	ldi	r24, 0x10	; 16
    1882:	c8 0e       	add	r12, r24
    1884:	d1 1c       	adc	r13, r1
    1886:	ec 14       	cp	r14, r12
    1888:	fd 04       	cpc	r15, r13
    188a:	51 f7       	brne	.-44     	; 0x1860 <DriverOLEDUpdate+0x4a>
    188c:	61 96       	adiw	r28, 0x11	; 17
    188e:	cd bf       	out	0x3d, r28	; 61
    1890:	de bf       	out	0x3e, r29	; 62
    1892:	df 91       	pop	r29
    1894:	cf 91       	pop	r28
    1896:	1f 91       	pop	r17
    1898:	0f 91       	pop	r16
    189a:	ff 90       	pop	r15
    189c:	ef 90       	pop	r14
    189e:	df 90       	pop	r13
    18a0:	cf 90       	pop	r12
    18a2:	bf 90       	pop	r11
    18a4:	08 95       	ret
    18a6:	0e 94 d6 09 	call	0x13ac	; 0x13ac <set_page_address.part.0>
    18aa:	cd cf       	rjmp	.-102    	; 0x1846 <DriverOLEDUpdate+0x30>

000018ac <DriverOLEDPrintSmChar>:
    18ac:	90 91 33 28 	lds	r25, 0x2833	; 0x802833 <DriverOLEDInitialized>
    18b0:	99 23       	and	r25, r25
    18b2:	31 f0       	breq	.+12     	; 0x18c0 <DriverOLEDPrintSmChar+0x14>
    18b4:	81 38       	cpi	r24, 0x81	; 129
    18b6:	20 f4       	brcc	.+8      	; 0x18c0 <DriverOLEDPrintSmChar+0x14>
    18b8:	61 34       	cpi	r22, 0x41	; 65
    18ba:	10 f4       	brcc	.+4      	; 0x18c0 <DriverOLEDPrintSmChar+0x14>
    18bc:	0c 94 f8 0a 	jmp	0x15f0	; 0x15f0 <DriverOLEDPrintSmChar.part.5>
    18c0:	08 95       	ret

000018c2 <DriverOLEDPrintSmText>:
    18c2:	ff 92       	push	r15
    18c4:	0f 93       	push	r16
    18c6:	1f 93       	push	r17
    18c8:	cf 93       	push	r28
    18ca:	df 93       	push	r29
    18cc:	f8 2e       	mov	r15, r24
    18ce:	04 2f       	mov	r16, r20
    18d0:	80 91 33 28 	lds	r24, 0x2833	; 0x802833 <DriverOLEDInitialized>
    18d4:	88 23       	and	r24, r24
    18d6:	39 f1       	breq	.+78     	; 0x1926 <DriverOLEDPrintSmText+0x64>
    18d8:	80 91 34 28 	lds	r24, 0x2834	; 0x802834 <GlobOrientation>
    18dc:	98 2f       	mov	r25, r24
    18de:	9d 7f       	andi	r25, 0xFD	; 253
    18e0:	41 f5       	brne	.+80     	; 0x1932 <DriverOLEDPrintSmText+0x70>
    18e2:	27 e0       	ldi	r18, 0x07	; 7
    18e4:	2f 15       	cp	r18, r15
    18e6:	f8 f0       	brcs	.+62     	; 0x1926 <DriverOLEDPrintSmText+0x64>
    18e8:	fb 01       	movw	r30, r22
    18ea:	40 81       	ld	r20, Z
    18ec:	44 23       	and	r20, r20
    18ee:	d9 f0       	breq	.+54     	; 0x1926 <DriverOLEDPrintSmText+0x64>
    18f0:	eb 01       	movw	r28, r22
    18f2:	21 96       	adiw	r28, 0x01	; 1
    18f4:	10 e0       	ldi	r17, 0x00	; 0
    18f6:	0c c0       	rjmp	.+24     	; 0x1910 <DriverOLEDPrintSmText+0x4e>
    18f8:	26 e0       	ldi	r18, 0x06	; 6
    18fa:	12 9f       	mul	r17, r18
    18fc:	c0 01       	movw	r24, r0
    18fe:	11 24       	eor	r1, r1
    1900:	8b 37       	cpi	r24, 0x7B	; 123
    1902:	91 05       	cpc	r25, r1
    1904:	64 f0       	brlt	.+24     	; 0x191e <DriverOLEDPrintSmText+0x5c>
    1906:	f3 94       	inc	r15
    1908:	11 e0       	ldi	r17, 0x01	; 1
    190a:	49 91       	ld	r20, Y+
    190c:	44 23       	and	r20, r20
    190e:	59 f0       	breq	.+22     	; 0x1926 <DriverOLEDPrintSmText+0x64>
    1910:	11 38       	cpi	r17, 0x81	; 129
    1912:	18 f4       	brcc	.+6      	; 0x191a <DriverOLEDPrintSmText+0x58>
    1914:	f0 e4       	ldi	r31, 0x40	; 64
    1916:	ff 15       	cp	r31, r15
    1918:	68 f5       	brcc	.+90     	; 0x1974 <DriverOLEDPrintSmText+0xb2>
    191a:	00 23       	and	r16, r16
    191c:	69 f3       	breq	.-38     	; 0x18f8 <DriverOLEDPrintSmText+0x36>
    191e:	1f 5f       	subi	r17, 0xFF	; 255
    1920:	49 91       	ld	r20, Y+
    1922:	41 11       	cpse	r20, r1
    1924:	f5 cf       	rjmp	.-22     	; 0x1910 <DriverOLEDPrintSmText+0x4e>
    1926:	df 91       	pop	r29
    1928:	cf 91       	pop	r28
    192a:	1f 91       	pop	r17
    192c:	0f 91       	pop	r16
    192e:	ff 90       	pop	r15
    1930:	08 95       	ret
    1932:	81 30       	cpi	r24, 0x01	; 1
    1934:	c1 f7       	brne	.-16     	; 0x1926 <DriverOLEDPrintSmText+0x64>
    1936:	8f e0       	ldi	r24, 0x0F	; 15
    1938:	8f 15       	cp	r24, r15
    193a:	a8 f3       	brcs	.-22     	; 0x1926 <DriverOLEDPrintSmText+0x64>
    193c:	fb 01       	movw	r30, r22
    193e:	40 81       	ld	r20, Z
    1940:	44 23       	and	r20, r20
    1942:	89 f3       	breq	.-30     	; 0x1926 <DriverOLEDPrintSmText+0x64>
    1944:	eb 01       	movw	r28, r22
    1946:	21 96       	adiw	r28, 0x01	; 1
    1948:	10 e0       	ldi	r17, 0x00	; 0
    194a:	0b c0       	rjmp	.+22     	; 0x1962 <DriverOLEDPrintSmText+0xa0>
    194c:	26 e0       	ldi	r18, 0x06	; 6
    194e:	12 9f       	mul	r17, r18
    1950:	c0 01       	movw	r24, r0
    1952:	11 24       	eor	r1, r1
    1954:	cb 97       	sbiw	r24, 0x3b	; 59
    1956:	64 f0       	brlt	.+24     	; 0x1970 <DriverOLEDPrintSmText+0xae>
    1958:	f3 94       	inc	r15
    195a:	11 e0       	ldi	r17, 0x01	; 1
    195c:	49 91       	ld	r20, Y+
    195e:	44 23       	and	r20, r20
    1960:	11 f3       	breq	.-60     	; 0x1926 <DriverOLEDPrintSmText+0x64>
    1962:	11 38       	cpi	r17, 0x81	; 129
    1964:	18 f4       	brcc	.+6      	; 0x196c <DriverOLEDPrintSmText+0xaa>
    1966:	f0 e4       	ldi	r31, 0x40	; 64
    1968:	ff 15       	cp	r31, r15
    196a:	50 f4       	brcc	.+20     	; 0x1980 <DriverOLEDPrintSmText+0xbe>
    196c:	00 23       	and	r16, r16
    196e:	71 f3       	breq	.-36     	; 0x194c <DriverOLEDPrintSmText+0x8a>
    1970:	1f 5f       	subi	r17, 0xFF	; 255
    1972:	f4 cf       	rjmp	.-24     	; 0x195c <DriverOLEDPrintSmText+0x9a>
    1974:	20 2f       	mov	r18, r16
    1976:	6f 2d       	mov	r22, r15
    1978:	81 2f       	mov	r24, r17
    197a:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <DriverOLEDPrintSmChar.part.5>
    197e:	cd cf       	rjmp	.-102    	; 0x191a <DriverOLEDPrintSmText+0x58>
    1980:	20 2f       	mov	r18, r16
    1982:	6f 2d       	mov	r22, r15
    1984:	81 2f       	mov	r24, r17
    1986:	0e 94 f8 0a 	call	0x15f0	; 0x15f0 <DriverOLEDPrintSmChar.part.5>
    198a:	f0 cf       	rjmp	.-32     	; 0x196c <DriverOLEDPrintSmText+0xaa>

0000198c <DriverOLEDClearScreen>:
    198c:	80 e0       	ldi	r24, 0x00	; 0
    198e:	94 e0       	ldi	r25, 0x04	; 4
    1990:	e5 e3       	ldi	r30, 0x35	; 53
    1992:	f8 e2       	ldi	r31, 0x28	; 40
    1994:	df 01       	movw	r26, r30
    1996:	9c 01       	movw	r18, r24
    1998:	1d 92       	st	X+, r1
    199a:	21 50       	subi	r18, 0x01	; 1
    199c:	30 40       	sbci	r19, 0x00	; 0
    199e:	e1 f7       	brne	.-8      	; 0x1998 <DriverOLEDClearScreen+0xc>
    19a0:	08 95       	ret

000019a2 <DriverOLEDInit>:

void DriverOLEDInit(uint8_t Orientation)
{
    19a2:	0f 93       	push	r16
    19a4:	1f 93       	push	r17
    19a6:	cf 93       	push	r28
    19a8:	df 93       	push	r29
    19aa:	00 d0       	rcall	.+0      	; 0x19ac <DriverOLEDInit+0xa>
    19ac:	1f 92       	push	r1
    19ae:	cd b7       	in	r28, 0x3d	; 61
    19b0:	de b7       	in	r29, 0x3e	; 62
	uint8_t res;
	DriverOLEDInitialized=0;
    19b2:	10 92 33 28 	sts	0x2833, r1	; 0x802833 <DriverOLEDInitialized>
	GlobOrientation=Orientation;
    19b6:	80 93 34 28 	sts	0x2834, r24	; 0x802834 <GlobOrientation>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    19ba:	10 e8       	ldi	r17, 0x80	; 128
    19bc:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    19be:	8e ea       	ldi	r24, 0xAE	; 174
    19c0:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    19c2:	42 e0       	ldi	r20, 0x02	; 2
    19c4:	be 01       	movw	r22, r28
    19c6:	6f 5f       	subi	r22, 0xFF	; 255
    19c8:	7f 4f       	sbci	r23, 0xFF	; 255
    19ca:	8c e3       	ldi	r24, 0x3C	; 60
    19cc:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
	DriverOLEDInitialized=0;
	GlobOrientation=Orientation;

	
	res=send_command(0xAE);
	if (!res) return;
    19d0:	88 23       	and	r24, r24
    19d2:	09 f4       	brne	.+2      	; 0x19d6 <DriverOLEDInit+0x34>
    19d4:	c3 c0       	rjmp	.+390    	; 0x1b5c <DriverOLEDInit+0x1ba>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    19d6:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    19d8:	85 ed       	ldi	r24, 0xD5	; 213
    19da:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    19dc:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    19de:	1c 83       	std	Y+4, r17	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    19e0:	44 e0       	ldi	r20, 0x04	; 4
    19e2:	be 01       	movw	r22, r28
    19e4:	6f 5f       	subi	r22, 0xFF	; 255
    19e6:	7f 4f       	sbci	r23, 0xFF	; 255
    19e8:	8c e3       	ldi	r24, 0x3C	; 60
    19ea:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    19ee:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    19f0:	88 ea       	ldi	r24, 0xA8	; 168
    19f2:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    19f4:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    19f6:	8f e3       	ldi	r24, 0x3F	; 63
    19f8:	8c 83       	std	Y+4, r24	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    19fa:	44 e0       	ldi	r20, 0x04	; 4
    19fc:	be 01       	movw	r22, r28
    19fe:	6f 5f       	subi	r22, 0xFF	; 255
    1a00:	7f 4f       	sbci	r23, 0xFF	; 255
    1a02:	8c e3       	ldi	r24, 0x3C	; 60
    1a04:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1a08:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1a0a:	83 ed       	ldi	r24, 0xD3	; 211
    1a0c:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1a0e:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1a10:	1c 82       	std	Y+4, r1	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1a12:	44 e0       	ldi	r20, 0x04	; 4
    1a14:	be 01       	movw	r22, r28
    1a16:	6f 5f       	subi	r22, 0xFF	; 255
    1a18:	7f 4f       	sbci	r23, 0xFF	; 255
    1a1a:	8c e3       	ldi	r24, 0x3C	; 60
    1a1c:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1a20:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1a22:	8d e8       	ldi	r24, 0x8D	; 141
    1a24:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1a26:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1a28:	84 e1       	ldi	r24, 0x14	; 20
    1a2a:	8c 83       	std	Y+4, r24	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1a2c:	44 e0       	ldi	r20, 0x04	; 4
    1a2e:	be 01       	movw	r22, r28
    1a30:	6f 5f       	subi	r22, 0xFF	; 255
    1a32:	7f 4f       	sbci	r23, 0xFF	; 255
    1a34:	8c e3       	ldi	r24, 0x3C	; 60
    1a36:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1a3a:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1a3c:	00 e4       	ldi	r16, 0x40	; 64
    1a3e:	0a 83       	std	Y+2, r16	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1a40:	42 e0       	ldi	r20, 0x02	; 2
    1a42:	be 01       	movw	r22, r28
    1a44:	6f 5f       	subi	r22, 0xFF	; 255
    1a46:	7f 4f       	sbci	r23, 0xFF	; 255
    1a48:	8c e3       	ldi	r24, 0x3C	; 60
    1a4a:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1a4e:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1a50:	86 ea       	ldi	r24, 0xA6	; 166
    1a52:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1a54:	42 e0       	ldi	r20, 0x02	; 2
    1a56:	be 01       	movw	r22, r28
    1a58:	6f 5f       	subi	r22, 0xFF	; 255
    1a5a:	7f 4f       	sbci	r23, 0xFF	; 255
    1a5c:	8c e3       	ldi	r24, 0x3C	; 60
    1a5e:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1a62:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1a64:	84 ea       	ldi	r24, 0xA4	; 164
    1a66:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1a68:	42 e0       	ldi	r20, 0x02	; 2
    1a6a:	be 01       	movw	r22, r28
    1a6c:	6f 5f       	subi	r22, 0xFF	; 255
    1a6e:	7f 4f       	sbci	r23, 0xFF	; 255
    1a70:	8c e3       	ldi	r24, 0x3C	; 60
    1a72:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1a76:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1a78:	81 ea       	ldi	r24, 0xA1	; 161
    1a7a:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1a7c:	42 e0       	ldi	r20, 0x02	; 2
    1a7e:	be 01       	movw	r22, r28
    1a80:	6f 5f       	subi	r22, 0xFF	; 255
    1a82:	7f 4f       	sbci	r23, 0xFF	; 255
    1a84:	8c e3       	ldi	r24, 0x3C	; 60
    1a86:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1a8a:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1a8c:	88 ec       	ldi	r24, 0xC8	; 200
    1a8e:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1a90:	42 e0       	ldi	r20, 0x02	; 2
    1a92:	be 01       	movw	r22, r28
    1a94:	6f 5f       	subi	r22, 0xFF	; 255
    1a96:	7f 4f       	sbci	r23, 0xFF	; 255
    1a98:	8c e3       	ldi	r24, 0x3C	; 60
    1a9a:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1a9e:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1aa0:	80 e2       	ldi	r24, 0x20	; 32
    1aa2:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1aa4:	42 e0       	ldi	r20, 0x02	; 2
    1aa6:	be 01       	movw	r22, r28
    1aa8:	6f 5f       	subi	r22, 0xFF	; 255
    1aaa:	7f 4f       	sbci	r23, 0xFF	; 255
    1aac:	8c e3       	ldi	r24, 0x3C	; 60
    1aae:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1ab2:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1ab4:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1ab6:	42 e0       	ldi	r20, 0x02	; 2
    1ab8:	be 01       	movw	r22, r28
    1aba:	6f 5f       	subi	r22, 0xFF	; 255
    1abc:	7f 4f       	sbci	r23, 0xFF	; 255
    1abe:	8c e3       	ldi	r24, 0x3C	; 60
    1ac0:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1ac4:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1ac6:	8a ed       	ldi	r24, 0xDA	; 218
    1ac8:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1aca:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1acc:	82 e1       	ldi	r24, 0x12	; 18
    1ace:	8c 83       	std	Y+4, r24	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1ad0:	44 e0       	ldi	r20, 0x04	; 4
    1ad2:	be 01       	movw	r22, r28
    1ad4:	6f 5f       	subi	r22, 0xFF	; 255
    1ad6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ad8:	8c e3       	ldi	r24, 0x3C	; 60
    1ada:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1ade:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1ae0:	81 e8       	ldi	r24, 0x81	; 129
    1ae2:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1ae4:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1ae6:	8f e8       	ldi	r24, 0x8F	; 143
    1ae8:	8c 83       	std	Y+4, r24	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1aea:	44 e0       	ldi	r20, 0x04	; 4
    1aec:	be 01       	movw	r22, r28
    1aee:	6f 5f       	subi	r22, 0xFF	; 255
    1af0:	7f 4f       	sbci	r23, 0xFF	; 255
    1af2:	8c e3       	ldi	r24, 0x3C	; 60
    1af4:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1af8:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1afa:	89 ed       	ldi	r24, 0xD9	; 217
    1afc:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1afe:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1b00:	81 ef       	ldi	r24, 0xF1	; 241
    1b02:	8c 83       	std	Y+4, r24	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1b04:	44 e0       	ldi	r20, 0x04	; 4
    1b06:	be 01       	movw	r22, r28
    1b08:	6f 5f       	subi	r22, 0xFF	; 255
    1b0a:	7f 4f       	sbci	r23, 0xFF	; 255
    1b0c:	8c e3       	ldi	r24, 0x3C	; 60
    1b0e:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
}

uint8_t send_command_data(uint8_t command, uint8_t data) {
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=0x80;
    1b12:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1b14:	8b ed       	ldi	r24, 0xDB	; 219
    1b16:	8a 83       	std	Y+2, r24	; 0x02
	Buffer[2]=COMMAND;
    1b18:	1b 83       	std	Y+3, r17	; 0x03
	Buffer[3]=data;
    1b1a:	0c 83       	std	Y+4, r16	; 0x04
	res=TWIMWrite(ADDRESS,Buffer,4);
    1b1c:	44 e0       	ldi	r20, 0x04	; 4
    1b1e:	be 01       	movw	r22, r28
    1b20:	6f 5f       	subi	r22, 0xFF	; 255
    1b22:	7f 4f       	sbci	r23, 0xFF	; 255
    1b24:	8c e3       	ldi	r24, 0x3C	; 60
    1b26:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
}

uint8_t send_command(uint8_t command) {
	uint8_t res;
	uint8_t Buffer[2];
	Buffer[0]=COMMAND;
    1b2a:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=command;
    1b2c:	8f ea       	ldi	r24, 0xAF	; 175
    1b2e:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(ADDRESS,Buffer,2);
    1b30:	42 e0       	ldi	r20, 0x02	; 2
    1b32:	be 01       	movw	r22, r28
    1b34:	6f 5f       	subi	r22, 0xFF	; 255
    1b36:	7f 4f       	sbci	r23, 0xFF	; 255
    1b38:	8c e3       	ldi	r24, 0x3C	; 60
    1b3a:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
		return;
	}
}

void DriverOLEDClearScreen() {
	memset(buffer, 0, BUFFER_SIZE);
    1b3e:	80 e0       	ldi	r24, 0x00	; 0
    1b40:	94 e0       	ldi	r25, 0x04	; 4
    1b42:	e5 e3       	ldi	r30, 0x35	; 53
    1b44:	f8 e2       	ldi	r31, 0x28	; 40
    1b46:	df 01       	movw	r26, r30
    1b48:	9c 01       	movw	r18, r24
    1b4a:	1d 92       	st	X+, r1
    1b4c:	21 50       	subi	r18, 0x01	; 1
    1b4e:	30 40       	sbci	r19, 0x00	; 0
    1b50:	e1 f7       	brne	.-8      	; 0x1b4a <DriverOLEDInit+0x1a8>
	send_command_data(0xdb, 0x40);
	send_command(0xaf);


	DriverOLEDClearScreen();
	DriverOLEDUpdate();
    1b52:	0e 94 0b 0c 	call	0x1816	; 0x1816 <DriverOLEDUpdate>
	DriverOLEDInitialized=1;
    1b56:	81 e0       	ldi	r24, 0x01	; 1
    1b58:	80 93 33 28 	sts	0x2833, r24	; 0x802833 <DriverOLEDInitialized>
    1b5c:	24 96       	adiw	r28, 0x04	; 4
    1b5e:	cd bf       	out	0x3d, r28	; 61
    1b60:	de bf       	out	0x3e, r29	; 62
    1b62:	df 91       	pop	r29
    1b64:	cf 91       	pop	r28
    1b66:	1f 91       	pop	r17
    1b68:	0f 91       	pop	r16
    1b6a:	08 95       	ret

00001b6c <ShiftInBit>:
	PORTD.DIRSET=1<<3;
	PORTD.PIN3CTRL=0b01000000;
	USARTD0.CTRLA=0b00000000;
	USARTD0.CTRLB=0b1000;
	USARTD0.CTRLC=0b11000000;
	USARTD0.BAUDCTRLA=5; //0.375s per bit, 
    1b6c:	cf 93       	push	r28
    1b6e:	c8 2f       	mov	r28, r24
    1b70:	80 91 84 2c 	lds	r24, 0x2C84	; 0x802c84 <ByteIdx>
    1b74:	8e 34       	cpi	r24, 0x4E	; 78
    1b76:	50 f5       	brcc	.+84     	; 0x1bcc <ShiftInBit+0x60>
    1b78:	90 91 85 2c 	lds	r25, 0x2C85	; 0x802c85 <BitIdx>
    1b7c:	91 11       	cpse	r25, r1
    1b7e:	06 c0       	rjmp	.+12     	; 0x1b8c <ShiftInBit+0x20>
    1b80:	e8 2f       	mov	r30, r24
    1b82:	f0 e0       	ldi	r31, 0x00	; 0
    1b84:	ea 5c       	subi	r30, 0xCA	; 202
    1b86:	f3 4d       	sbci	r31, 0xD3	; 211
    1b88:	2f ef       	ldi	r18, 0xFF	; 255
    1b8a:	20 83       	st	Z, r18
    1b8c:	c1 11       	cpse	r28, r1
    1b8e:	10 c0       	rjmp	.+32     	; 0x1bb0 <ShiftInBit+0x44>
    1b90:	e8 2f       	mov	r30, r24
    1b92:	f0 e0       	ldi	r31, 0x00	; 0
    1b94:	ea 5c       	subi	r30, 0xCA	; 202
    1b96:	f3 4d       	sbci	r31, 0xD3	; 211
    1b98:	20 e8       	ldi	r18, 0x80	; 128
    1b9a:	30 e0       	ldi	r19, 0x00	; 0
    1b9c:	09 2e       	mov	r0, r25
    1b9e:	02 c0       	rjmp	.+4      	; 0x1ba4 <ShiftInBit+0x38>
    1ba0:	35 95       	asr	r19
    1ba2:	27 95       	ror	r18
    1ba4:	0a 94       	dec	r0
    1ba6:	e2 f7       	brpl	.-8      	; 0x1ba0 <ShiftInBit+0x34>
    1ba8:	20 95       	com	r18
    1baa:	30 81       	ld	r19, Z
    1bac:	23 23       	and	r18, r19
    1bae:	20 83       	st	Z, r18
    1bb0:	9f 5f       	subi	r25, 0xFF	; 255
    1bb2:	98 30       	cpi	r25, 0x08	; 8
    1bb4:	39 f4       	brne	.+14     	; 0x1bc4 <ShiftInBit+0x58>
    1bb6:	10 92 85 2c 	sts	0x2C85, r1	; 0x802c85 <BitIdx>
    1bba:	8f 5f       	subi	r24, 0xFF	; 255
    1bbc:	80 93 84 2c 	sts	0x2C84, r24	; 0x802c84 <ByteIdx>
    1bc0:	cf 91       	pop	r28
    1bc2:	08 95       	ret
    1bc4:	90 93 85 2c 	sts	0x2C85, r25	; 0x802c85 <BitIdx>
    1bc8:	cf 91       	pop	r28
    1bca:	08 95       	ret
    1bcc:	67 e2       	ldi	r22, 0x27	; 39
    1bce:	70 e0       	ldi	r23, 0x00	; 0
    1bd0:	81 e0       	ldi	r24, 0x01	; 1
    1bd2:	93 e2       	ldi	r25, 0x23	; 35
    1bd4:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    1bd8:	90 91 85 2c 	lds	r25, 0x2C85	; 0x802c85 <BitIdx>
    1bdc:	80 91 84 2c 	lds	r24, 0x2C84	; 0x802c84 <ByteIdx>
    1be0:	91 11       	cpse	r25, r1
    1be2:	0d c0       	rjmp	.+26     	; 0x1bfe <ShiftInBit+0x92>
    1be4:	e8 2f       	mov	r30, r24
    1be6:	f0 e0       	ldi	r31, 0x00	; 0
    1be8:	ea 5c       	subi	r30, 0xCA	; 202
    1bea:	f3 4d       	sbci	r31, 0xD3	; 211
    1bec:	2f ef       	ldi	r18, 0xFF	; 255
    1bee:	20 83       	st	Z, r18
    1bf0:	8e 34       	cpi	r24, 0x4E	; 78
    1bf2:	60 f2       	brcs	.-104    	; 0x1b8c <ShiftInBit+0x20>
    1bf4:	81 e0       	ldi	r24, 0x01	; 1
    1bf6:	80 93 85 2c 	sts	0x2C85, r24	; 0x802c85 <BitIdx>
    1bfa:	cf 91       	pop	r28
    1bfc:	08 95       	ret
    1bfe:	8e 34       	cpi	r24, 0x4E	; 78
    1c00:	28 f2       	brcs	.-118    	; 0x1b8c <ShiftInBit+0x20>
    1c02:	9f 5f       	subi	r25, 0xFF	; 255
    1c04:	98 30       	cpi	r25, 0x08	; 8
    1c06:	b9 f2       	breq	.-82     	; 0x1bb6 <ShiftInBit+0x4a>
    1c08:	dd cf       	rjmp	.-70     	; 0x1bc4 <ShiftInBit+0x58>

00001c0a <ShiftIn0>:
    1c0a:	80 e0       	ldi	r24, 0x00	; 0
    1c0c:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <ShiftInBit>
    1c10:	81 e0       	ldi	r24, 0x01	; 1
    1c12:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <ShiftInBit>
    1c16:	81 e0       	ldi	r24, 0x01	; 1
    1c18:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <ShiftInBit>
    1c1c:	81 e0       	ldi	r24, 0x01	; 1
    1c1e:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <ShiftInBit>
    1c22:	81 e0       	ldi	r24, 0x01	; 1
    1c24:	0c 94 b6 0d 	jmp	0x1b6c	; 0x1b6c <ShiftInBit>

00001c28 <ShiftIn1>:
    1c28:	80 e0       	ldi	r24, 0x00	; 0
    1c2a:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <ShiftInBit>
    1c2e:	80 e0       	ldi	r24, 0x00	; 0
    1c30:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <ShiftInBit>
    1c34:	80 e0       	ldi	r24, 0x00	; 0
    1c36:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <ShiftInBit>
    1c3a:	80 e0       	ldi	r24, 0x00	; 0
    1c3c:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <ShiftInBit>
    1c40:	81 e0       	ldi	r24, 0x01	; 1
    1c42:	0c 94 b6 0d 	jmp	0x1b6c	; 0x1b6c <ShiftInBit>

00001c46 <ShiftInByte>:
    1c46:	cf 93       	push	r28
    1c48:	df 93       	push	r29
    1c4a:	d8 2f       	mov	r29, r24
    1c4c:	c8 e0       	ldi	r28, 0x08	; 8
    1c4e:	05 c0       	rjmp	.+10     	; 0x1c5a <ShiftInByte+0x14>
    1c50:	0e 94 05 0e 	call	0x1c0a	; 0x1c0a <ShiftIn0>
    1c54:	dd 0f       	add	r29, r29
    1c56:	c1 50       	subi	r28, 0x01	; 1
    1c58:	39 f0       	breq	.+14     	; 0x1c68 <ShiftInByte+0x22>
    1c5a:	d7 ff       	sbrs	r29, 7
    1c5c:	f9 cf       	rjmp	.-14     	; 0x1c50 <ShiftInByte+0xa>
    1c5e:	0e 94 14 0e 	call	0x1c28	; 0x1c28 <ShiftIn1>
    1c62:	dd 0f       	add	r29, r29
    1c64:	c1 50       	subi	r28, 0x01	; 1
    1c66:	c9 f7       	brne	.-14     	; 0x1c5a <ShiftInByte+0x14>
    1c68:	df 91       	pop	r29
    1c6a:	cf 91       	pop	r28
    1c6c:	08 95       	ret

00001c6e <DriverPL9823Init>:
}

void DriverPL9823Init()
{
	//CS init
	PORTA.DIRSET=1<<6;
    1c6e:	e0 e0       	ldi	r30, 0x00	; 0
    1c70:	f6 e0       	ldi	r31, 0x06	; 6
    1c72:	80 e4       	ldi	r24, 0x40	; 64
    1c74:	81 83       	std	Z+1, r24	; 0x01
	PORTA.OUTCLR=1<<6;
    1c76:	86 83       	std	Z+6, r24	; 0x06
    1c78:	08 95       	ret

00001c7a <DriverPL9823Set>:
}

void DriverPL9823Set(uint32_t FrontLeft,uint32_t FrontRight,uint32_t RearRight,uint32_t RearLeft)
{
    1c7a:	3f 92       	push	r3
    1c7c:	4f 92       	push	r4
    1c7e:	5f 92       	push	r5
    1c80:	6f 92       	push	r6
    1c82:	7f 92       	push	r7
    1c84:	8f 92       	push	r8
    1c86:	9f 92       	push	r9
    1c88:	af 92       	push	r10
    1c8a:	bf 92       	push	r11
    1c8c:	cf 92       	push	r12
    1c8e:	df 92       	push	r13
    1c90:	ef 92       	push	r14
    1c92:	ff 92       	push	r15
    1c94:	0f 93       	push	r16
    1c96:	1f 93       	push	r17
    1c98:	cf 93       	push	r28
    1c9a:	df 93       	push	r29
    1c9c:	36 2e       	mov	r3, r22
    1c9e:	47 2e       	mov	r4, r23
    1ca0:	58 2e       	mov	r5, r24
    1ca2:	d2 2e       	mov	r13, r18
    1ca4:	13 2f       	mov	r17, r19
    1ca6:	d4 2f       	mov	r29, r20
}

void PortSetup(void)
{
	//Data init
	PORTD.DIRSET=1<<3;
    1ca8:	88 e0       	ldi	r24, 0x08	; 8
    1caa:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <__TEXT_REGION_LENGTH__+0x700661>
	PORTD.PIN3CTRL=0b01000000;
    1cae:	90 e4       	ldi	r25, 0x40	; 64
    1cb0:	90 93 73 06 	sts	0x0673, r25	; 0x800673 <__TEXT_REGION_LENGTH__+0x700673>
	USARTD0.CTRLA=0b00000000;
    1cb4:	10 92 a3 09 	sts	0x09A3, r1	; 0x8009a3 <__TEXT_REGION_LENGTH__+0x7009a3>
	USARTD0.CTRLB=0b1000;
    1cb8:	80 93 a4 09 	sts	0x09A4, r24	; 0x8009a4 <__TEXT_REGION_LENGTH__+0x7009a4>
	USARTD0.CTRLC=0b11000000;
    1cbc:	80 ec       	ldi	r24, 0xC0	; 192
    1cbe:	80 93 a5 09 	sts	0x09A5, r24	; 0x8009a5 <__TEXT_REGION_LENGTH__+0x7009a5>
	USARTD0.BAUDCTRLA=5; //0.375s per bit, 
    1cc2:	85 e0       	ldi	r24, 0x05	; 5
    1cc4:	80 93 a6 09 	sts	0x09A6, r24	; 0x8009a6 <__TEXT_REGION_LENGTH__+0x7009a6>
    1cc8:	86 e3       	ldi	r24, 0x36	; 54
    1cca:	88 2e       	mov	r8, r24
    1ccc:	8c e2       	ldi	r24, 0x2C	; 44
    1cce:	98 2e       	mov	r9, r24
    1cd0:	94 e8       	ldi	r25, 0x84	; 132
    1cd2:	69 2e       	mov	r6, r25
    1cd4:	9c e2       	ldi	r25, 0x2C	; 44
    1cd6:	79 2e       	mov	r7, r25
    1cd8:	f4 01       	movw	r30, r8

void ShiftReset()
{
	uint8_t a;
	for (a=0;a<BUFFER_SIZE;a++)
		DataBuffer[a]=255;	
    1cda:	8f ef       	ldi	r24, 0xFF	; 255
    1cdc:	81 93       	st	Z+, r24
}

void ShiftReset()
{
	uint8_t a;
	for (a=0;a<BUFFER_SIZE;a++)
    1cde:	6e 16       	cp	r6, r30
    1ce0:	7f 06       	cpc	r7, r31
    1ce2:	e1 f7       	brne	.-8      	; 0x1cdc <DriverPL9823Set+0x62>
		DataBuffer[a]=255;	
	ByteIdx=0;	
    1ce4:	10 92 84 2c 	sts	0x2C84, r1	; 0x802c84 <ByteIdx>
    1ce8:	c5 e8       	ldi	r28, 0x85	; 133
}
void ShiftInReset()
{
	uint8_t a;
	for (a=0;a<133;a++) ShiftInBit(1);
    1cea:	81 e0       	ldi	r24, 0x01	; 1
    1cec:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <ShiftInBit>
    1cf0:	c1 50       	subi	r28, 0x01	; 1
    1cf2:	d9 f7       	brne	.-10     	; 0x1cea <DriverPL9823Set+0x70>
	
	ShiftReset();

	ShiftInReset();
	
	ShiftInByte((uint8_t) ((FrontLeft>>0) & 0xFF));
    1cf4:	83 2d       	mov	r24, r3
    1cf6:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <ShiftInByte>
	ShiftInByte((uint8_t) ((FrontLeft>>8) & 0xFF));
    1cfa:	84 2d       	mov	r24, r4
    1cfc:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <ShiftInByte>
	ShiftInByte((uint8_t) ((FrontLeft>>16) & 0xFF));
    1d00:	85 2d       	mov	r24, r5
    1d02:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <ShiftInByte>

	ShiftInByte((uint8_t) ((FrontRight>>0) & 0xFF));
    1d06:	8d 2d       	mov	r24, r13
    1d08:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <ShiftInByte>
	ShiftInByte((uint8_t) ((FrontRight>>8) & 0xFF));
    1d0c:	81 2f       	mov	r24, r17
    1d0e:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <ShiftInByte>
	ShiftInByte((uint8_t) ((FrontRight>>16) & 0xFF));
    1d12:	8d 2f       	mov	r24, r29
    1d14:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <ShiftInByte>
	
	ShiftInByte((uint8_t) ((RearRight>>0) & 0xFF));
    1d18:	8e 2d       	mov	r24, r14
    1d1a:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <ShiftInByte>
	ShiftInByte((uint8_t) ((RearRight>>8) & 0xFF));
    1d1e:	8f 2d       	mov	r24, r15
    1d20:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <ShiftInByte>
	ShiftInByte((uint8_t) ((RearRight>>16) & 0xFF));
    1d24:	80 2f       	mov	r24, r16
    1d26:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <ShiftInByte>
	
	ShiftInByte((uint8_t) ((RearLeft>>0) & 0xFF));
    1d2a:	8a 2d       	mov	r24, r10
    1d2c:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <ShiftInByte>
	ShiftInByte((uint8_t) ((RearLeft>>8) & 0xFF));
    1d30:	8b 2d       	mov	r24, r11
    1d32:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <ShiftInByte>
	ShiftInByte((uint8_t) ((RearLeft>>16) & 0xFF));
    1d36:	8c 2d       	mov	r24, r12
    1d38:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <ShiftInByte>
	
	portENTER_CRITICAL();
    1d3c:	0f b6       	in	r0, 0x3f	; 63
    1d3e:	f8 94       	cli
    1d40:	0f 92       	push	r0


void SendBuffer()
{
	uint8_t a;
	TxIdx=0;
    1d42:	10 92 35 2c 	sts	0x2C35, r1	; 0x802c35 <TxIdx>
	
	PORTA.OUTSET=1<<6; //CS enable
    1d46:	80 e4       	ldi	r24, 0x40	; 64
    1d48:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>


void SendByte(uint8_t Data)
{
	while (!(USARTD0.STATUS&(1<<5)));
	USARTD0.STATUS=(1<<6); //Clear TXCIF
    1d4c:	20 e4       	ldi	r18, 0x40	; 64
	uint8_t a;
	TxIdx=0;
	
	PORTA.OUTSET=1<<6; //CS enable
	for (a=0;a<BUFFER_SIZE;a++)
		SendByte(DataBuffer[a]);
    1d4e:	f4 01       	movw	r30, r8
    1d50:	91 91       	ld	r25, Z+
    1d52:	4f 01       	movw	r8, r30
static volatile uint8_t TxIdx;


void SendByte(uint8_t Data)
{
	while (!(USARTD0.STATUS&(1<<5)));
    1d54:	80 91 a1 09 	lds	r24, 0x09A1	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
    1d58:	85 ff       	sbrs	r24, 5
    1d5a:	fc cf       	rjmp	.-8      	; 0x1d54 <DriverPL9823Set+0xda>
	USARTD0.STATUS=(1<<6); //Clear TXCIF
    1d5c:	20 93 a1 09 	sts	0x09A1, r18	; 0x8009a1 <__TEXT_REGION_LENGTH__+0x7009a1>
	USARTD0.DATA=Data;
    1d60:	90 93 a0 09 	sts	0x09A0, r25	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
{
	uint8_t a;
	TxIdx=0;
	
	PORTA.OUTSET=1<<6; //CS enable
	for (a=0;a<BUFFER_SIZE;a++)
    1d64:	68 14       	cp	r6, r8
    1d66:	79 04       	cpc	r7, r9
    1d68:	91 f7       	brne	.-28     	; 0x1d4e <DriverPL9823Set+0xd4>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1d6a:	8f ee       	ldi	r24, 0xEF	; 239
    1d6c:	90 e0       	ldi	r25, 0x00	; 0
    1d6e:	01 97       	sbiw	r24, 0x01	; 1
    1d70:	f1 f7       	brne	.-4      	; 0x1d6e <DriverPL9823Set+0xf4>
    1d72:	00 c0       	rjmp	.+0      	; 0x1d74 <DriverPL9823Set+0xfa>
    1d74:	00 00       	nop
		SendByte(DataBuffer[a]);
	_delay_us(30);	
	PORTA.OUTCLR=1<<6; //CS disable
    1d76:	80 e4       	ldi	r24, 0x40	; 64
    1d78:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
	ShiftInByte((uint8_t) ((RearLeft>>8) & 0xFF));
	ShiftInByte((uint8_t) ((RearLeft>>16) & 0xFF));
	
	portENTER_CRITICAL();
	SendBuffer(); //Approx 260 s for entire buffer
	portEXIT_CRITICAL();
    1d7c:	0f 90       	pop	r0
    1d7e:	0f be       	out	0x3f, r0	; 63
}
    1d80:	df 91       	pop	r29
    1d82:	cf 91       	pop	r28
    1d84:	1f 91       	pop	r17
    1d86:	0f 91       	pop	r16
    1d88:	ff 90       	pop	r15
    1d8a:	ef 90       	pop	r14
    1d8c:	df 90       	pop	r13
    1d8e:	cf 90       	pop	r12
    1d90:	bf 90       	pop	r11
    1d92:	af 90       	pop	r10
    1d94:	9f 90       	pop	r9
    1d96:	8f 90       	pop	r8
    1d98:	7f 90       	pop	r7
    1d9a:	6f 90       	pop	r6
    1d9c:	5f 90       	pop	r5
    1d9e:	4f 90       	pop	r4
    1da0:	3f 90       	pop	r3
    1da2:	08 95       	ret

00001da4 <DriverPowerInit>:
#include "DriverPower.h"

void DriverPowerInit(void)
{
	//Aux Vcc GPIO setup
	PORTC.DIRSET=1<<5;
    1da4:	80 e2       	ldi	r24, 0x20	; 32
    1da6:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
    1daa:	08 95       	ret

00001dac <DriverPowerVccAuxSet>:
}


void DriverPowerVccAuxSet(uint8_t State)
{
	if (State)
    1dac:	81 11       	cpse	r24, r1
    1dae:	04 c0       	rjmp	.+8      	; 0x1db8 <DriverPowerVccAuxSet+0xc>
		PORTC.OUTSET=1<<5;
	else
		PORTC.OUTCLR=1<<5;
    1db0:	80 e2       	ldi	r24, 0x20	; 32
    1db2:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
    1db6:	08 95       	ret


void DriverPowerVccAuxSet(uint8_t State)
{
	if (State)
		PORTC.OUTSET=1<<5;
    1db8:	80 e2       	ldi	r24, 0x20	; 32
    1dba:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
    1dbe:	08 95       	ret

00001dc0 <DriverSysClkXtalInit>:
    // Clock setup          
    if (F_XTAL<400E3) return -1; //Invalid frequency
    if (F_XTAL<=2E6) OSC.XOSCCTRL=0b00001011; //Select <2 Mhz XTAL osc, max startup time
    else if(F_XTAL<=9E6) OSC.XOSCCTRL=0b01001011; //Select <2 Mhz XTAL osc, max startup time 
    else if(F_XTAL<=12E6) OSC.XOSCCTRL=0b10001011; //Select <2 Mhz XTAL osc, max startup time 
    else if(F_XTAL<=16E6) OSC.XOSCCTRL=0b11001011; //Select <2 Mhz XTAL osc, max startup time 
    1dc0:	8b ec       	ldi	r24, 0xCB	; 203
    1dc2:	80 93 52 00 	sts	0x0052, r24	; 0x800052 <__TEXT_REGION_LENGTH__+0x700052>
    else return -1; //Invalid frequency
    OSC.CTRL=0b01000; //Enable oscillator
    1dc6:	88 e0       	ldi	r24, 0x08	; 8
    1dc8:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
    
	//Wait until XTAL osc is ready
    while (!(OSC.STATUS&0b1000)); 
    1dcc:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
    1dd0:	83 ff       	sbrs	r24, 3
    1dd2:	fc cf       	rjmp	.-8      	; 0x1dcc <DriverSysClkXtalInit+0xc>
	{
		//Configure PLL
		Mult=F_CPU/F_XTAL;
		if (Mult>31) return -1; //Invalid frequency; too high
		if (F_XTAL * (uint32_t) Mult !=F_CPU) return -1; //Only supports whole dividers
		OSC.PLLCTRL=0b11000000 | (Mult);
    1dd4:	82 ec       	ldi	r24, 0xC2	; 194
    1dd6:	80 93 55 00 	sts	0x0055, r24	; 0x800055 <__TEXT_REGION_LENGTH__+0x700055>
		OSC.CTRL=0b00011000; //Enable PLL
    1dda:	88 e1       	ldi	r24, 0x18	; 24
    1ddc:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x700050>
		
		//Wait until PLL is ready
		while (!(OSC.STATUS & 0b00010000));
    1de0:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x700051>
    1de4:	84 ff       	sbrs	r24, 4
    1de6:	fc cf       	rjmp	.-8      	; 0x1de0 <DriverSysClkXtalInit+0x20>
		
		//Select PLL as system CLK source
		CCP=0xd8;
    1de8:	88 ed       	ldi	r24, 0xD8	; 216
    1dea:	84 bf       	out	0x34, r24	; 52
		CLK.CTRL=0b100;
    1dec:	84 e0       	ldi	r24, 0x04	; 4
    1dee:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x700040>
	}
	return 0;
}
    1df2:	80 e0       	ldi	r24, 0x00	; 0
    1df4:	08 95       	ret

00001df6 <DriverTWIMInit>:
}

void TWIMTransactionFinished( uint8_t result)
{
	Twim_result = result;
	Twim_status = TWIM_STATUS_READY;
    1df6:	10 92 8b 2c 	sts	0x2C8B, r1	; 0x802c8b <Twim_status>
    1dfa:	e0 e8       	ldi	r30, 0x80	; 128
    1dfc:	f6 e0       	ldi	r31, 0x06	; 6
    1dfe:	88 e1       	ldi	r24, 0x18	; 24
    1e00:	80 8b       	std	Z+16, r24	; 0x10
    1e02:	81 8b       	std	Z+17, r24	; 0x11
    1e04:	e0 ea       	ldi	r30, 0xA0	; 160
    1e06:	f4 e0       	ldi	r31, 0x04	; 4
    1e08:	88 e7       	ldi	r24, 0x78	; 120
    1e0a:	81 83       	std	Z+1, r24	; 0x01
    1e0c:	83 e2       	ldi	r24, 0x23	; 35
    1e0e:	85 83       	std	Z+5, r24	; 0x05
    1e10:	81 e0       	ldi	r24, 0x01	; 1
    1e12:	84 83       	std	Z+4, r24	; 0x04
    1e14:	0e 94 f6 20 	call	0x41ec	; 0x41ec <xQueueCreateMutex>
    1e18:	80 93 88 2c 	sts	0x2C88, r24	; 0x802c88 <SemaBus>
    1e1c:	90 93 89 2c 	sts	0x2C89, r25	; 0x802c89 <SemaBus+0x1>
    1e20:	43 e0       	ldi	r20, 0x03	; 3
    1e22:	60 e0       	ldi	r22, 0x00	; 0
    1e24:	81 e0       	ldi	r24, 0x01	; 1
    1e26:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <xQueueGenericCreate>
    1e2a:	80 93 86 2c 	sts	0x2C86, r24	; 0x802c86 <SemaRx>
    1e2e:	90 93 87 2c 	sts	0x2C87, r25	; 0x802c87 <SemaRx+0x1>
    1e32:	08 95       	ret

00001e34 <TWIMWriteRead>:
    1e34:	cf 92       	push	r12
    1e36:	df 92       	push	r13
    1e38:	ef 92       	push	r14
    1e3a:	ff 92       	push	r15
    1e3c:	0f 93       	push	r16
    1e3e:	1f 93       	push	r17
    1e40:	cf 93       	push	r28
    1e42:	df 93       	push	r29
    1e44:	d8 2f       	mov	r29, r24
    1e46:	6b 01       	movw	r12, r22
    1e48:	14 2f       	mov	r17, r20
    1e4a:	79 01       	movw	r14, r18
    1e4c:	6f ef       	ldi	r22, 0xFF	; 255
    1e4e:	7f ef       	ldi	r23, 0xFF	; 255
    1e50:	80 91 88 2c 	lds	r24, 0x2C88	; 0x802c88 <SemaBus>
    1e54:	90 91 89 2c 	lds	r25, 0x2C89	; 0x802c89 <SemaBus+0x1>
    1e58:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <xQueueSemaphoreTake>
    1e5c:	c0 92 92 2c 	sts	0x2C92, r12	; 0x802c92 <Twim_writeData>
    1e60:	d0 92 93 2c 	sts	0x2C93, r13	; 0x802c93 <Twim_writeData+0x1>
    1e64:	e0 92 90 2c 	sts	0x2C90, r14	; 0x802c90 <Twim_readData>
    1e68:	f0 92 91 2c 	sts	0x2C91, r15	; 0x802c91 <Twim_readData+0x1>
    1e6c:	c0 91 8b 2c 	lds	r28, 0x2C8B	; 0x802c8b <Twim_status>
    1e70:	c1 11       	cpse	r28, r1
    1e72:	55 c0       	rjmp	.+170    	; 0x1f1e <TWIMWriteRead+0xea>
    1e74:	81 e0       	ldi	r24, 0x01	; 1
    1e76:	80 93 8b 2c 	sts	0x2C8B, r24	; 0x802c8b <Twim_status>
    1e7a:	10 92 8a 2c 	sts	0x2C8A, r1	; 0x802c8a <Twim_result>
    1e7e:	8d 2f       	mov	r24, r29
    1e80:	88 0f       	add	r24, r24
    1e82:	80 93 94 2c 	sts	0x2C94, r24	; 0x802c94 <Twim_address>
    1e86:	10 93 8f 2c 	sts	0x2C8F, r17	; 0x802c8f <Twim_bytesToWrite>
    1e8a:	00 93 8e 2c 	sts	0x2C8E, r16	; 0x802c8e <Twim_bytesToRead>
    1e8e:	10 92 8d 2c 	sts	0x2C8D, r1	; 0x802c8d <Twim_bytesWritten>
    1e92:	10 92 8c 2c 	sts	0x2C8C, r1	; 0x802c8c <Twim_bytesRead>
    1e96:	80 91 8f 2c 	lds	r24, 0x2C8F	; 0x802c8f <Twim_bytesToWrite>
    1e9a:	88 23       	and	r24, r24
    1e9c:	b1 f1       	breq	.+108    	; 0x1f0a <TWIMWriteRead+0xd6>
    1e9e:	80 91 94 2c 	lds	r24, 0x2C94	; 0x802c94 <Twim_address>
    1ea2:	8e 7f       	andi	r24, 0xFE	; 254
    1ea4:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <__TEXT_REGION_LENGTH__+0x7004a6>
    1ea8:	6f ef       	ldi	r22, 0xFF	; 255
    1eaa:	7f ef       	ldi	r23, 0xFF	; 255
    1eac:	80 91 86 2c 	lds	r24, 0x2C86	; 0x802c86 <SemaRx>
    1eb0:	90 91 87 2c 	lds	r25, 0x2C87	; 0x802c87 <SemaRx+0x1>
    1eb4:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <xQueueSemaphoreTake>
    1eb8:	80 91 8a 2c 	lds	r24, 0x2C8A	; 0x802c8a <Twim_result>
    1ebc:	81 30       	cpi	r24, 0x01	; 1
    1ebe:	e1 f1       	breq	.+120    	; 0x1f38 <TWIMWriteRead+0x104>
    1ec0:	1f 92       	push	r1
    1ec2:	8f 93       	push	r24
    1ec4:	1f 92       	push	r1
    1ec6:	df 93       	push	r29
    1ec8:	80 e2       	ldi	r24, 0x20	; 32
    1eca:	93 e2       	ldi	r25, 0x23	; 35
    1ecc:	9f 93       	push	r25
    1ece:	8f 93       	push	r24
    1ed0:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
    1ed4:	20 e0       	ldi	r18, 0x00	; 0
    1ed6:	40 e0       	ldi	r20, 0x00	; 0
    1ed8:	50 e0       	ldi	r21, 0x00	; 0
    1eda:	60 e0       	ldi	r22, 0x00	; 0
    1edc:	70 e0       	ldi	r23, 0x00	; 0
    1ede:	80 91 88 2c 	lds	r24, 0x2C88	; 0x802c88 <SemaBus>
    1ee2:	90 91 89 2c 	lds	r25, 0x2C89	; 0x802c89 <SemaBus+0x1>
    1ee6:	0e 94 27 20 	call	0x404e	; 0x404e <xQueueGenericSend>
    1eea:	0f 90       	pop	r0
    1eec:	0f 90       	pop	r0
    1eee:	0f 90       	pop	r0
    1ef0:	0f 90       	pop	r0
    1ef2:	0f 90       	pop	r0
    1ef4:	0f 90       	pop	r0
    1ef6:	8c 2f       	mov	r24, r28
    1ef8:	df 91       	pop	r29
    1efa:	cf 91       	pop	r28
    1efc:	1f 91       	pop	r17
    1efe:	0f 91       	pop	r16
    1f00:	ff 90       	pop	r15
    1f02:	ef 90       	pop	r14
    1f04:	df 90       	pop	r13
    1f06:	cf 90       	pop	r12
    1f08:	08 95       	ret
    1f0a:	80 91 8e 2c 	lds	r24, 0x2C8E	; 0x802c8e <Twim_bytesToRead>
    1f0e:	88 23       	and	r24, r24
    1f10:	59 f2       	breq	.-106    	; 0x1ea8 <TWIMWriteRead+0x74>
    1f12:	80 91 94 2c 	lds	r24, 0x2C94	; 0x802c94 <Twim_address>
    1f16:	81 60       	ori	r24, 0x01	; 1
    1f18:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <__TEXT_REGION_LENGTH__+0x7004a6>
    1f1c:	c5 cf       	rjmp	.-118    	; 0x1ea8 <TWIMWriteRead+0x74>
    1f1e:	20 e0       	ldi	r18, 0x00	; 0
    1f20:	40 e0       	ldi	r20, 0x00	; 0
    1f22:	50 e0       	ldi	r21, 0x00	; 0
    1f24:	60 e0       	ldi	r22, 0x00	; 0
    1f26:	70 e0       	ldi	r23, 0x00	; 0
    1f28:	80 91 88 2c 	lds	r24, 0x2C88	; 0x802c88 <SemaBus>
    1f2c:	90 91 89 2c 	lds	r25, 0x2C89	; 0x802c89 <SemaBus+0x1>
    1f30:	0e 94 27 20 	call	0x404e	; 0x404e <xQueueGenericSend>
    1f34:	c0 e0       	ldi	r28, 0x00	; 0
    1f36:	df cf       	rjmp	.-66     	; 0x1ef6 <TWIMWriteRead+0xc2>
    1f38:	20 e0       	ldi	r18, 0x00	; 0
    1f3a:	40 e0       	ldi	r20, 0x00	; 0
    1f3c:	50 e0       	ldi	r21, 0x00	; 0
    1f3e:	60 e0       	ldi	r22, 0x00	; 0
    1f40:	70 e0       	ldi	r23, 0x00	; 0
    1f42:	80 91 88 2c 	lds	r24, 0x2C88	; 0x802c88 <SemaBus>
    1f46:	90 91 89 2c 	lds	r25, 0x2C89	; 0x802c89 <SemaBus+0x1>
    1f4a:	0e 94 27 20 	call	0x404e	; 0x404e <xQueueGenericSend>
    1f4e:	c1 e0       	ldi	r28, 0x01	; 1
    1f50:	d2 cf       	rjmp	.-92     	; 0x1ef6 <TWIMWriteRead+0xc2>

00001f52 <TWIMWrite>:
    1f52:	0f 93       	push	r16
    1f54:	00 e0       	ldi	r16, 0x00	; 0
    1f56:	20 e0       	ldi	r18, 0x00	; 0
    1f58:	30 e0       	ldi	r19, 0x00	; 0
    1f5a:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
    1f5e:	0f 91       	pop	r16
    1f60:	08 95       	ret

00001f62 <TWIMWriteHandler>:
    1f62:	90 91 8f 2c 	lds	r25, 0x2C8F	; 0x802c8f <Twim_bytesToWrite>
    1f66:	20 91 8e 2c 	lds	r18, 0x2C8E	; 0x802c8e <Twim_bytesToRead>
    1f6a:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>
    1f6e:	84 fd       	sbrc	r24, 4
    1f70:	22 c0       	rjmp	.+68     	; 0x1fb6 <TWIMWriteHandler+0x54>
    1f72:	80 91 8d 2c 	lds	r24, 0x2C8D	; 0x802c8d <Twim_bytesWritten>
    1f76:	89 17       	cp	r24, r25
    1f78:	68 f0       	brcs	.+26     	; 0x1f94 <TWIMWriteHandler+0x32>
    1f7a:	80 91 8c 2c 	lds	r24, 0x2C8C	; 0x802c8c <Twim_bytesRead>
    1f7e:	82 17       	cp	r24, r18
    1f80:	18 f1       	brcs	.+70     	; 0x1fc8 <TWIMWriteHandler+0x66>
    1f82:	83 e0       	ldi	r24, 0x03	; 3
    1f84:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    1f88:	81 e0       	ldi	r24, 0x01	; 1
    1f8a:	80 93 8a 2c 	sts	0x2C8A, r24	; 0x802c8a <Twim_result>
    1f8e:	10 92 8b 2c 	sts	0x2C8B, r1	; 0x802c8b <Twim_status>
    1f92:	08 95       	ret
    1f94:	80 91 8d 2c 	lds	r24, 0x2C8D	; 0x802c8d <Twim_bytesWritten>
    1f98:	e0 91 92 2c 	lds	r30, 0x2C92	; 0x802c92 <Twim_writeData>
    1f9c:	f0 91 93 2c 	lds	r31, 0x2C93	; 0x802c93 <Twim_writeData+0x1>
    1fa0:	e8 0f       	add	r30, r24
    1fa2:	f1 1d       	adc	r31, r1
    1fa4:	80 81       	ld	r24, Z
    1fa6:	80 93 a7 04 	sts	0x04A7, r24	; 0x8004a7 <__TEXT_REGION_LENGTH__+0x7004a7>
    1faa:	80 91 8d 2c 	lds	r24, 0x2C8D	; 0x802c8d <Twim_bytesWritten>
    1fae:	8f 5f       	subi	r24, 0xFF	; 255
    1fb0:	80 93 8d 2c 	sts	0x2C8D, r24	; 0x802c8d <Twim_bytesWritten>
    1fb4:	08 95       	ret
    1fb6:	83 e0       	ldi	r24, 0x03	; 3
    1fb8:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    1fbc:	85 e0       	ldi	r24, 0x05	; 5
    1fbe:	80 93 8a 2c 	sts	0x2C8A, r24	; 0x802c8a <Twim_result>
    1fc2:	10 92 8b 2c 	sts	0x2C8B, r1	; 0x802c8b <Twim_status>
    1fc6:	08 95       	ret
    1fc8:	80 91 94 2c 	lds	r24, 0x2C94	; 0x802c94 <Twim_address>
    1fcc:	81 60       	ori	r24, 0x01	; 1
    1fce:	80 93 a6 04 	sts	0x04A6, r24	; 0x8004a6 <__TEXT_REGION_LENGTH__+0x7004a6>
    1fd2:	08 95       	ret

00001fd4 <TWIMReadHandler>:
    1fd4:	80 91 8c 2c 	lds	r24, 0x2C8C	; 0x802c8c <Twim_bytesRead>
    1fd8:	80 32       	cpi	r24, 0x20	; 32
    1fda:	f8 f4       	brcc	.+62     	; 0x201a <TWIMReadHandler+0x46>
    1fdc:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <__TEXT_REGION_LENGTH__+0x7004a7>
    1fe0:	90 91 8c 2c 	lds	r25, 0x2C8C	; 0x802c8c <Twim_bytesRead>
    1fe4:	e0 91 90 2c 	lds	r30, 0x2C90	; 0x802c90 <Twim_readData>
    1fe8:	f0 91 91 2c 	lds	r31, 0x2C91	; 0x802c91 <Twim_readData+0x1>
    1fec:	e9 0f       	add	r30, r25
    1fee:	f1 1d       	adc	r31, r1
    1ff0:	80 83       	st	Z, r24
    1ff2:	80 91 8c 2c 	lds	r24, 0x2C8C	; 0x802c8c <Twim_bytesRead>
    1ff6:	8f 5f       	subi	r24, 0xFF	; 255
    1ff8:	80 93 8c 2c 	sts	0x2C8C, r24	; 0x802c8c <Twim_bytesRead>
    1ffc:	90 91 8e 2c 	lds	r25, 0x2C8E	; 0x802c8e <Twim_bytesToRead>
    2000:	80 91 8c 2c 	lds	r24, 0x2C8C	; 0x802c8c <Twim_bytesRead>
    2004:	89 17       	cp	r24, r25
    2006:	b8 f0       	brcs	.+46     	; 0x2036 <TWIMReadHandler+0x62>
    2008:	87 e0       	ldi	r24, 0x07	; 7
    200a:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    200e:	81 e0       	ldi	r24, 0x01	; 1
    2010:	80 93 8a 2c 	sts	0x2C8A, r24	; 0x802c8a <Twim_result>
    2014:	10 92 8b 2c 	sts	0x2C8B, r1	; 0x802c8b <Twim_status>
    2018:	08 95       	ret
    201a:	83 e0       	ldi	r24, 0x03	; 3
    201c:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    2020:	82 e0       	ldi	r24, 0x02	; 2
    2022:	80 93 8a 2c 	sts	0x2C8A, r24	; 0x802c8a <Twim_result>
    2026:	10 92 8b 2c 	sts	0x2C8B, r1	; 0x802c8b <Twim_status>
    202a:	90 91 8e 2c 	lds	r25, 0x2C8E	; 0x802c8e <Twim_bytesToRead>
    202e:	80 91 8c 2c 	lds	r24, 0x2C8C	; 0x802c8c <Twim_bytesRead>
    2032:	89 17       	cp	r24, r25
    2034:	48 f7       	brcc	.-46     	; 0x2008 <TWIMReadHandler+0x34>
    2036:	82 e0       	ldi	r24, 0x02	; 2
    2038:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <__TEXT_REGION_LENGTH__+0x7004a3>
    203c:	08 95       	ret

0000203e <__vector_46>:
}

ISR (TWIM_BUS_vect)
{
    203e:	1f 92       	push	r1
    2040:	0f 92       	push	r0
    2042:	0f b6       	in	r0, 0x3f	; 63
    2044:	0f 92       	push	r0
    2046:	11 24       	eor	r1, r1
    2048:	0b b6       	in	r0, 0x3b	; 59
    204a:	0f 92       	push	r0
    204c:	2f 93       	push	r18
    204e:	3f 93       	push	r19
    2050:	4f 93       	push	r20
    2052:	5f 93       	push	r21
    2054:	6f 93       	push	r22
    2056:	7f 93       	push	r23
    2058:	8f 93       	push	r24
    205a:	9f 93       	push	r25
    205c:	af 93       	push	r26
    205e:	bf 93       	push	r27
    2060:	ef 93       	push	r30
    2062:	ff 93       	push	r31
    2064:	cf 93       	push	r28
    2066:	df 93       	push	r29
    2068:	1f 92       	push	r1
    206a:	cd b7       	in	r28, 0x3d	; 61
    206c:	de b7       	in	r29, 0x3e	; 62
	BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    206e:	19 82       	std	Y+1, r1	; 0x01
	uint8_t currentStatus = TWIM_BUS.MASTER.STATUS;
    2070:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>

	/* If arbitration lost or bus error. */
	if ((currentStatus & TWI_MASTER_ARBLOST_bm) ||
    2074:	98 2f       	mov	r25, r24
    2076:	9c 70       	andi	r25, 0x0C	; 12
    2078:	e1 f4       	brne	.+56     	; 0x20b2 <__vector_46+0x74>

		TWIMArbitrationLostBusErrorHandler();
	}

	/* If master write interrupt. */
	else if (currentStatus & TWI_MASTER_WIF_bm) {
    207a:	86 fd       	sbrc	r24, 6
    207c:	44 c0       	rjmp	.+136    	; 0x2106 <__vector_46+0xc8>
		TWIMWriteHandler();
	}

	/* If master read interrupt. */
	else if (currentStatus & TWI_MASTER_RIF_bm) {
    207e:	87 fd       	sbrc	r24, 7
    2080:	45 c0       	rjmp	.+138    	; 0x210c <__vector_46+0xce>
	}
}

void TWIMTransactionFinished( uint8_t result)
{
	Twim_result = result;
    2082:	86 e0       	ldi	r24, 0x06	; 6
    2084:	80 93 8a 2c 	sts	0x2C8A, r24	; 0x802c8a <Twim_result>
	Twim_status = TWIM_STATUS_READY;
    2088:	10 92 8b 2c 	sts	0x2C8B, r1	; 0x802c8b <Twim_status>
	/* If unexpected state. */
	else {
		TWIMTransactionFinished(TWIM_RESULT_FAIL);
	}
	
	if (Twim_status == TWIM_STATUS_READY) //Transaction finished
    208c:	80 91 8b 2c 	lds	r24, 0x2C8B	; 0x802c8b <Twim_status>
    2090:	81 11       	cpse	r24, r1
    2092:	1f c0       	rjmp	.+62     	; 0x20d2 <__vector_46+0x94>
	{
		BaseType_t res=xSemaphoreGiveFromISR( SemaRx, &xHigherPriorityTaskWoken );
    2094:	be 01       	movw	r22, r28
    2096:	6f 5f       	subi	r22, 0xFF	; 255
    2098:	7f 4f       	sbci	r23, 0xFF	; 255
    209a:	80 91 86 2c 	lds	r24, 0x2C86	; 0x802c86 <SemaRx>
    209e:	90 91 87 2c 	lds	r25, 0x2C87	; 0x802c87 <SemaRx+0x1>
    20a2:	0e 94 6b 21 	call	0x42d6	; 0x42d6 <xQueueGiveFromISR>

		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );		
    20a6:	89 81       	ldd	r24, Y+1	; 0x01
    20a8:	88 23       	and	r24, r24
    20aa:	99 f0       	breq	.+38     	; 0x20d2 <__vector_46+0x94>
    20ac:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <vPortYieldISR>
	}
}
    20b0:	10 c0       	rjmp	.+32     	; 0x20d2 <__vector_46+0x94>
	}
}

void TWIMArbitrationLostBusErrorHandler()
{
	uint8_t currentStatus = TWIM_BUS.MASTER.STATUS;
    20b2:	80 91 a4 04 	lds	r24, 0x04A4	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>

	/* If bus error. */
	if (currentStatus & TWI_MASTER_BUSERR_bm) {
    20b6:	82 fd       	sbrc	r24, 2
    20b8:	22 c0       	rjmp	.+68     	; 0x20fe <__vector_46+0xc0>
		Twim_result = TWIM_RESULT_BUS_ERROR;
	}
	/* If arbitration lost. */
	else {
		Twim_result = TWIM_RESULT_ARBITRATION_LOST;
    20ba:	93 e0       	ldi	r25, 0x03	; 3
    20bc:	90 93 8a 2c 	sts	0x2C8A, r25	; 0x802c8a <Twim_result>
	}

	/* Clear interrupt flag. */
	TWIM_BUS.MASTER.STATUS = currentStatus | TWI_MASTER_ARBLOST_bm;
    20c0:	88 60       	ori	r24, 0x08	; 8
    20c2:	80 93 a4 04 	sts	0x04A4, r24	; 0x8004a4 <__TEXT_REGION_LENGTH__+0x7004a4>

	Twim_status = TWIM_STATUS_READY;
    20c6:	10 92 8b 2c 	sts	0x2C8B, r1	; 0x802c8b <Twim_status>
	/* If unexpected state. */
	else {
		TWIMTransactionFinished(TWIM_RESULT_FAIL);
	}
	
	if (Twim_status == TWIM_STATUS_READY) //Transaction finished
    20ca:	80 91 8b 2c 	lds	r24, 0x2C8B	; 0x802c8b <Twim_status>
    20ce:	88 23       	and	r24, r24
    20d0:	09 f3       	breq	.-62     	; 0x2094 <__vector_46+0x56>
	{
		BaseType_t res=xSemaphoreGiveFromISR( SemaRx, &xHigherPriorityTaskWoken );

		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );		
	}
}
    20d2:	0f 90       	pop	r0
    20d4:	df 91       	pop	r29
    20d6:	cf 91       	pop	r28
    20d8:	ff 91       	pop	r31
    20da:	ef 91       	pop	r30
    20dc:	bf 91       	pop	r27
    20de:	af 91       	pop	r26
    20e0:	9f 91       	pop	r25
    20e2:	8f 91       	pop	r24
    20e4:	7f 91       	pop	r23
    20e6:	6f 91       	pop	r22
    20e8:	5f 91       	pop	r21
    20ea:	4f 91       	pop	r20
    20ec:	3f 91       	pop	r19
    20ee:	2f 91       	pop	r18
    20f0:	0f 90       	pop	r0
    20f2:	0b be       	out	0x3b, r0	; 59
    20f4:	0f 90       	pop	r0
    20f6:	0f be       	out	0x3f, r0	; 63
    20f8:	0f 90       	pop	r0
    20fa:	1f 90       	pop	r1
    20fc:	18 95       	reti
{
	uint8_t currentStatus = TWIM_BUS.MASTER.STATUS;

	/* If bus error. */
	if (currentStatus & TWI_MASTER_BUSERR_bm) {
		Twim_result = TWIM_RESULT_BUS_ERROR;
    20fe:	94 e0       	ldi	r25, 0x04	; 4
    2100:	90 93 8a 2c 	sts	0x2C8A, r25	; 0x802c8a <Twim_result>
    2104:	dd cf       	rjmp	.-70     	; 0x20c0 <__vector_46+0x82>
		TWIMArbitrationLostBusErrorHandler();
	}

	/* If master write interrupt. */
	else if (currentStatus & TWI_MASTER_WIF_bm) {
		TWIMWriteHandler();
    2106:	0e 94 b1 0f 	call	0x1f62	; 0x1f62 <TWIMWriteHandler>
    210a:	df cf       	rjmp	.-66     	; 0x20ca <__vector_46+0x8c>
	}

	/* If master read interrupt. */
	else if (currentStatus & TWI_MASTER_RIF_bm) {
		TWIMReadHandler();
    210c:	0e 94 ea 0f 	call	0x1fd4	; 0x1fd4 <TWIMReadHandler>
    2110:	dc cf       	rjmp	.-72     	; 0x20ca <__vector_46+0x8c>

00002112 <stdio_getchar>:
		
	return 0;
}
	
static int stdio_getchar(FILE *stream)
{
    2112:	cf 93       	push	r28
    2114:	df 93       	push	r29
    2116:	1f 92       	push	r1
    2118:	cd b7       	in	r28, 0x3d	; 61
    211a:	de b7       	in	r29, 0x3e	; 62
	char c;
	xQueueReceive(UsartRxQueue,&c,portMAX_DELAY);
    211c:	4f ef       	ldi	r20, 0xFF	; 255
    211e:	5f ef       	ldi	r21, 0xFF	; 255
    2120:	be 01       	movw	r22, r28
    2122:	6f 5f       	subi	r22, 0xFF	; 255
    2124:	7f 4f       	sbci	r23, 0xFF	; 255
    2126:	80 91 7d 2d 	lds	r24, 0x2D7D	; 0x802d7d <UsartRxQueue>
    212a:	90 91 7e 2d 	lds	r25, 0x2D7E	; 0x802d7e <UsartRxQueue+0x1>
    212e:	0e 94 be 21 	call	0x437c	; 0x437c <xQueueReceive>
	return c;
    2132:	89 81       	ldd	r24, Y+1	; 0x01
}
    2134:	90 e0       	ldi	r25, 0x00	; 0
    2136:	0f 90       	pop	r0
    2138:	df 91       	pop	r29
    213a:	cf 91       	pop	r28
    213c:	08 95       	ret

0000213e <stdio_putchar>:

}


static int stdio_putchar(char c, FILE * stream)
{
    213e:	cf 93       	push	r28
    2140:	df 93       	push	r29
    2142:	1f 92       	push	r1
    2144:	1f 92       	push	r1
    2146:	cd b7       	in	r28, 0x3d	; 61
    2148:	de b7       	in	r29, 0x3e	; 62
    214a:	8a 83       	std	Y+2, r24	; 0x02
	int res;
	char cbuf;

	xQueueSend(UsartTxQueue,&c,portMAX_DELAY);
    214c:	20 e0       	ldi	r18, 0x00	; 0
    214e:	4f ef       	ldi	r20, 0xFF	; 255
    2150:	5f ef       	ldi	r21, 0xFF	; 255
    2152:	be 01       	movw	r22, r28
    2154:	6e 5f       	subi	r22, 0xFE	; 254
    2156:	7f 4f       	sbci	r23, 0xFF	; 255
    2158:	80 91 7f 2d 	lds	r24, 0x2D7F	; 0x802d7f <UsartTxQueue>
    215c:	90 91 80 2d 	lds	r25, 0x2D80	; 0x802d80 <UsartTxQueue+0x1>
    2160:	0e 94 27 20 	call	0x404e	; 0x404e <xQueueGenericSend>

	if (USART.STATUS & (1<<5))
    2164:	80 91 a1 0a 	lds	r24, 0x0AA1	; 0x800aa1 <__TEXT_REGION_LENGTH__+0x700aa1>
    2168:	85 ff       	sbrs	r24, 5
    216a:	0e c0       	rjmp	.+28     	; 0x2188 <stdio_putchar+0x4a>
	{
		xQueueReceive(UsartTxQueue,&cbuf,0);
    216c:	40 e0       	ldi	r20, 0x00	; 0
    216e:	50 e0       	ldi	r21, 0x00	; 0
    2170:	be 01       	movw	r22, r28
    2172:	6f 5f       	subi	r22, 0xFF	; 255
    2174:	7f 4f       	sbci	r23, 0xFF	; 255
    2176:	80 91 7f 2d 	lds	r24, 0x2D7F	; 0x802d7f <UsartTxQueue>
    217a:	90 91 80 2d 	lds	r25, 0x2D80	; 0x802d80 <UsartTxQueue+0x1>
    217e:	0e 94 be 21 	call	0x437c	; 0x437c <xQueueReceive>
		USART.DATA=cbuf;
    2182:	89 81       	ldd	r24, Y+1	; 0x01
    2184:	80 93 a0 0a 	sts	0x0AA0, r24	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
	}
		
	return 0;
}
    2188:	80 e0       	ldi	r24, 0x00	; 0
    218a:	90 e0       	ldi	r25, 0x00	; 0
    218c:	0f 90       	pop	r0
    218e:	0f 90       	pop	r0
    2190:	df 91       	pop	r29
    2192:	cf 91       	pop	r28
    2194:	08 95       	ret

00002196 <DriverUSARTInit>:
QueueHandle_t UsartTxQueue;
QueueHandle_t UsartRxQueue;

void DriverUSARTInit(void)
{
	UsartTxQueue=xQueueCreate(UART_QUEUE_LENGTH,sizeof(char));
    2196:	40 e0       	ldi	r20, 0x00	; 0
    2198:	61 e0       	ldi	r22, 0x01	; 1
    219a:	80 e8       	ldi	r24, 0x80	; 128
    219c:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <xQueueGenericCreate>
    21a0:	80 93 7f 2d 	sts	0x2D7F, r24	; 0x802d7f <UsartTxQueue>
    21a4:	90 93 80 2d 	sts	0x2D80, r25	; 0x802d80 <UsartTxQueue+0x1>
	UsartRxQueue=xQueueCreate(UART_QUEUE_LENGTH,sizeof(char));
    21a8:	40 e0       	ldi	r20, 0x00	; 0
    21aa:	61 e0       	ldi	r22, 0x01	; 1
    21ac:	80 e8       	ldi	r24, 0x80	; 128
    21ae:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <xQueueGenericCreate>
    21b2:	80 93 7d 2d 	sts	0x2D7D, r24	; 0x802d7d <UsartRxQueue>
    21b6:	90 93 7e 2d 	sts	0x2D7E, r25	; 0x802d7e <UsartRxQueue+0x1>
		
	USART_PORT.DIRSET=0b00001000;	
    21ba:	e0 e8       	ldi	r30, 0x80	; 128
    21bc:	f6 e0       	ldi	r31, 0x06	; 6
    21be:	88 e0       	ldi	r24, 0x08	; 8
    21c0:	81 83       	std	Z+1, r24	; 0x01
	USART_PORT.DIRCLR=0b00000100;
    21c2:	84 e0       	ldi	r24, 0x04	; 4
    21c4:	82 83       	std	Z+2, r24	; 0x02
	
	USART.CTRLA=0b00111000;
    21c6:	e0 ea       	ldi	r30, 0xA0	; 160
    21c8:	fa e0       	ldi	r31, 0x0A	; 10
    21ca:	88 e3       	ldi	r24, 0x38	; 56
    21cc:	83 83       	std	Z+3, r24	; 0x03
	USART.CTRLB=0b00011000; 
    21ce:	88 e1       	ldi	r24, 0x18	; 24
    21d0:	84 83       	std	Z+4, r24	; 0x04
	USART.CTRLC=0b00000011;
    21d2:	83 e0       	ldi	r24, 0x03	; 3
    21d4:	85 83       	std	Z+5, r24	; 0x05
	
	
	USART.BAUDCTRLA=0xE5; //BSEL=3301, BSCALE=-5 19200 baud
    21d6:	85 ee       	ldi	r24, 0xE5	; 229
    21d8:	86 83       	std	Z+6, r24	; 0x06
	USART.BAUDCTRLB=0xBC; 
    21da:	8c eb       	ldi	r24, 0xBC	; 188
    21dc:	87 83       	std	Z+7, r24	; 0x07
	
	stdout=&UsartStdio;
    21de:	e3 e9       	ldi	r30, 0x93	; 147
    21e0:	fd e2       	ldi	r31, 0x2D	; 45
    21e2:	86 e0       	ldi	r24, 0x06	; 6
    21e4:	90 e2       	ldi	r25, 0x20	; 32
    21e6:	82 83       	std	Z+2, r24	; 0x02
    21e8:	93 83       	std	Z+3, r25	; 0x03
	stdin=&UsartStdio;
    21ea:	80 83       	st	Z, r24
    21ec:	91 83       	std	Z+1, r25	; 0x01
    21ee:	08 95       	ret

000021f0 <__vector_60>:
}



ISR(USART_TXC_vect)
{
    21f0:	1f 92       	push	r1
    21f2:	0f 92       	push	r0
    21f4:	0f b6       	in	r0, 0x3f	; 63
    21f6:	0f 92       	push	r0
    21f8:	11 24       	eor	r1, r1
    21fa:	0b b6       	in	r0, 0x3b	; 59
    21fc:	0f 92       	push	r0
    21fe:	2f 93       	push	r18
    2200:	3f 93       	push	r19
    2202:	4f 93       	push	r20
    2204:	5f 93       	push	r21
    2206:	6f 93       	push	r22
    2208:	7f 93       	push	r23
    220a:	8f 93       	push	r24
    220c:	9f 93       	push	r25
    220e:	af 93       	push	r26
    2210:	bf 93       	push	r27
    2212:	ef 93       	push	r30
    2214:	ff 93       	push	r31
    2216:	cf 93       	push	r28
    2218:	df 93       	push	r29
    221a:	1f 92       	push	r1
    221c:	1f 92       	push	r1
    221e:	cd b7       	in	r28, 0x3d	; 61
    2220:	de b7       	in	r29, 0x3e	; 62
	char c;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    2222:	19 82       	std	Y+1, r1	; 0x01
	if (xQueueReceiveFromISR(UsartTxQueue,&c,&xHigherPriorityTaskWoken)==pdPASS)
    2224:	ae 01       	movw	r20, r28
    2226:	4f 5f       	subi	r20, 0xFF	; 255
    2228:	5f 4f       	sbci	r21, 0xFF	; 255
    222a:	be 01       	movw	r22, r28
    222c:	6e 5f       	subi	r22, 0xFE	; 254
    222e:	7f 4f       	sbci	r23, 0xFF	; 255
    2230:	80 91 7f 2d 	lds	r24, 0x2D7F	; 0x802d7f <UsartTxQueue>
    2234:	90 91 80 2d 	lds	r25, 0x2D80	; 0x802d80 <UsartTxQueue+0x1>
    2238:	0e 94 32 24 	call	0x4864	; 0x4864 <xQueueReceiveFromISR>
    223c:	81 30       	cpi	r24, 0x01	; 1
    223e:	d9 f0       	breq	.+54     	; 0x2276 <__vector_60+0x86>
	{
		USART.DATA=c;	
	}
	
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    2240:	89 81       	ldd	r24, Y+1	; 0x01
    2242:	81 11       	cpse	r24, r1
    2244:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <vPortYieldISR>
}
    2248:	0f 90       	pop	r0
    224a:	0f 90       	pop	r0
    224c:	df 91       	pop	r29
    224e:	cf 91       	pop	r28
    2250:	ff 91       	pop	r31
    2252:	ef 91       	pop	r30
    2254:	bf 91       	pop	r27
    2256:	af 91       	pop	r26
    2258:	9f 91       	pop	r25
    225a:	8f 91       	pop	r24
    225c:	7f 91       	pop	r23
    225e:	6f 91       	pop	r22
    2260:	5f 91       	pop	r21
    2262:	4f 91       	pop	r20
    2264:	3f 91       	pop	r19
    2266:	2f 91       	pop	r18
    2268:	0f 90       	pop	r0
    226a:	0b be       	out	0x3b, r0	; 59
    226c:	0f 90       	pop	r0
    226e:	0f be       	out	0x3f, r0	; 63
    2270:	0f 90       	pop	r0
    2272:	1f 90       	pop	r1
    2274:	18 95       	reti
{
	char c;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
	if (xQueueReceiveFromISR(UsartTxQueue,&c,&xHigherPriorityTaskWoken)==pdPASS)
	{
		USART.DATA=c;	
    2276:	8a 81       	ldd	r24, Y+2	; 0x02
    2278:	80 93 a0 0a 	sts	0x0AA0, r24	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    227c:	e1 cf       	rjmp	.-62     	; 0x2240 <__vector_60+0x50>

0000227e <__vector_58>:
	
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

ISR(USART_RXC_vect)
{
    227e:	1f 92       	push	r1
    2280:	0f 92       	push	r0
    2282:	0f b6       	in	r0, 0x3f	; 63
    2284:	0f 92       	push	r0
    2286:	11 24       	eor	r1, r1
    2288:	0b b6       	in	r0, 0x3b	; 59
    228a:	0f 92       	push	r0
    228c:	2f 93       	push	r18
    228e:	3f 93       	push	r19
    2290:	4f 93       	push	r20
    2292:	5f 93       	push	r21
    2294:	6f 93       	push	r22
    2296:	7f 93       	push	r23
    2298:	8f 93       	push	r24
    229a:	9f 93       	push	r25
    229c:	af 93       	push	r26
    229e:	bf 93       	push	r27
    22a0:	ef 93       	push	r30
    22a2:	ff 93       	push	r31
    22a4:	cf 93       	push	r28
    22a6:	df 93       	push	r29
    22a8:	1f 92       	push	r1
    22aa:	1f 92       	push	r1
    22ac:	cd b7       	in	r28, 0x3d	; 61
    22ae:	de b7       	in	r29, 0x3e	; 62
	char c;
	BaseType_t xHigherPriorityTaskWoken=pdFALSE;
    22b0:	19 82       	std	Y+1, r1	; 0x01
	
	c=USART.DATA;
    22b2:	80 91 a0 0a 	lds	r24, 0x0AA0	; 0x800aa0 <__TEXT_REGION_LENGTH__+0x700aa0>
    22b6:	8a 83       	std	Y+2, r24	; 0x02
	xQueueSendToBackFromISR(UsartRxQueue,&c,&xHigherPriorityTaskWoken);
    22b8:	20 e0       	ldi	r18, 0x00	; 0
    22ba:	ae 01       	movw	r20, r28
    22bc:	4f 5f       	subi	r20, 0xFF	; 255
    22be:	5f 4f       	sbci	r21, 0xFF	; 255
    22c0:	be 01       	movw	r22, r28
    22c2:	6e 5f       	subi	r22, 0xFE	; 254
    22c4:	7f 4f       	sbci	r23, 0xFF	; 255
    22c6:	80 91 7d 2d 	lds	r24, 0x2D7D	; 0x802d7d <UsartRxQueue>
    22ca:	90 91 7e 2d 	lds	r25, 0x2D7E	; 0x802d7e <UsartRxQueue+0x1>
    22ce:	0e 94 10 21 	call	0x4220	; 0x4220 <xQueueGenericSendFromISR>
	portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    22d2:	89 81       	ldd	r24, Y+1	; 0x01
    22d4:	81 11       	cpse	r24, r1
    22d6:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <vPortYieldISR>
	
    22da:	0f 90       	pop	r0
    22dc:	0f 90       	pop	r0
    22de:	df 91       	pop	r29
    22e0:	cf 91       	pop	r28
    22e2:	ff 91       	pop	r31
    22e4:	ef 91       	pop	r30
    22e6:	bf 91       	pop	r27
    22e8:	af 91       	pop	r26
    22ea:	9f 91       	pop	r25
    22ec:	8f 91       	pop	r24
    22ee:	7f 91       	pop	r23
    22f0:	6f 91       	pop	r22
    22f2:	5f 91       	pop	r21
    22f4:	4f 91       	pop	r20
    22f6:	3f 91       	pop	r19
    22f8:	2f 91       	pop	r18
    22fa:	0f 90       	pop	r0
    22fc:	0b be       	out	0x3b, r0	; 59
    22fe:	0f 90       	pop	r0
    2300:	0f be       	out	0x3f, r0	; 63
    2302:	0f 90       	pop	r0
    2304:	1f 90       	pop	r1
    2306:	18 95       	reti

00002308 <getSequenceStepEnables>:
	#ifdef VL53L0X_ASSERT_COMMS_ERROR
		configASSERT(res);
	#endif
	
	return res;
}
    2308:	ef 92       	push	r14
    230a:	ff 92       	push	r15
    230c:	0f 93       	push	r16
    230e:	cf 93       	push	r28
    2310:	df 93       	push	r29
    2312:	00 d0       	rcall	.+0      	; 0x2314 <getSequenceStepEnables+0xc>
    2314:	1f 92       	push	r1
    2316:	cd b7       	in	r28, 0x3d	; 61
    2318:	de b7       	in	r29, 0x3e	; 62
    231a:	7c 01       	movw	r14, r24
    231c:	81 e0       	ldi	r24, 0x01	; 1
    231e:	89 83       	std	Y+1, r24	; 0x01
    2320:	01 e0       	ldi	r16, 0x01	; 1
    2322:	9e 01       	movw	r18, r28
    2324:	2f 5f       	subi	r18, 0xFF	; 255
    2326:	3f 4f       	sbci	r19, 0xFF	; 255
    2328:	41 e0       	ldi	r20, 0x01	; 1
    232a:	b9 01       	movw	r22, r18
    232c:	89 e2       	ldi	r24, 0x29	; 41
    232e:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
    2332:	89 81       	ldd	r24, Y+1	; 0x01
    2334:	84 fb       	bst	r24, 4
    2336:	99 27       	eor	r25, r25
    2338:	90 f9       	bld	r25, 0
    233a:	f7 01       	movw	r30, r14
    233c:	90 83       	st	Z, r25
    233e:	83 fb       	bst	r24, 3
    2340:	99 27       	eor	r25, r25
    2342:	90 f9       	bld	r25, 0
    2344:	92 83       	std	Z+2, r25	; 0x02
    2346:	82 fb       	bst	r24, 2
    2348:	99 27       	eor	r25, r25
    234a:	90 f9       	bld	r25, 0
    234c:	91 83       	std	Z+1, r25	; 0x01
    234e:	86 fb       	bst	r24, 6
    2350:	99 27       	eor	r25, r25
    2352:	90 f9       	bld	r25, 0
    2354:	93 83       	std	Z+3, r25	; 0x03
    2356:	88 1f       	adc	r24, r24
    2358:	88 27       	eor	r24, r24
    235a:	88 1f       	adc	r24, r24
    235c:	84 83       	std	Z+4, r24	; 0x04
    235e:	24 96       	adiw	r28, 0x04	; 4
    2360:	cd bf       	out	0x3d, r28	; 61
    2362:	de bf       	out	0x3e, r29	; 62
    2364:	df 91       	pop	r29
    2366:	cf 91       	pop	r28
    2368:	0f 91       	pop	r16
    236a:	ff 90       	pop	r15
    236c:	ef 90       	pop	r14
    236e:	08 95       	ret

00002370 <performSingleRefCalibration>:
    2370:	0f 93       	push	r16
    2372:	1f 93       	push	r17
    2374:	cf 93       	push	r28
    2376:	df 93       	push	r29
    2378:	00 d0       	rcall	.+0      	; 0x237a <performSingleRefCalibration+0xa>
    237a:	1f 92       	push	r1
    237c:	cd b7       	in	r28, 0x3d	; 61
    237e:	de b7       	in	r29, 0x3e	; 62
    2380:	19 82       	std	Y+1, r1	; 0x01
    2382:	81 60       	ori	r24, 0x01	; 1
    2384:	8a 83       	std	Y+2, r24	; 0x02
    2386:	42 e0       	ldi	r20, 0x02	; 2
    2388:	be 01       	movw	r22, r28
    238a:	6f 5f       	subi	r22, 0xFF	; 255
    238c:	7f 4f       	sbci	r23, 0xFF	; 255
    238e:	89 e2       	ldi	r24, 0x29	; 41
    2390:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
    2394:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2398:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    239c:	80 91 85 2d 	lds	r24, 0x2D85	; 0x802d85 <StatsTimer>
    23a0:	90 91 86 2d 	lds	r25, 0x2D86	; 0x802d86 <StatsTimer+0x1>
    23a4:	a0 91 87 2d 	lds	r26, 0x2D87	; 0x802d87 <StatsTimer+0x2>
    23a8:	b0 91 88 2d 	lds	r27, 0x2D88	; 0x802d88 <StatsTimer+0x3>
    23ac:	82 0f       	add	r24, r18
    23ae:	93 1f       	adc	r25, r19
    23b0:	a1 1d       	adc	r26, r1
    23b2:	b1 1d       	adc	r27, r1
    23b4:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <timeout_start_ticks>
    23b8:	90 93 96 2c 	sts	0x2C96, r25	; 0x802c96 <timeout_start_ticks+0x1>
    23bc:	a0 93 97 2c 	sts	0x2C97, r26	; 0x802c97 <timeout_start_ticks+0x2>
    23c0:	b0 93 98 2c 	sts	0x2C98, r27	; 0x802c98 <timeout_start_ticks+0x3>
    23c4:	13 e1       	ldi	r17, 0x13	; 19
    23c6:	19 83       	std	Y+1, r17	; 0x01
    23c8:	01 e0       	ldi	r16, 0x01	; 1
    23ca:	9e 01       	movw	r18, r28
    23cc:	2f 5f       	subi	r18, 0xFF	; 255
    23ce:	3f 4f       	sbci	r19, 0xFF	; 255
    23d0:	41 e0       	ldi	r20, 0x01	; 1
    23d2:	b9 01       	movw	r22, r18
    23d4:	89 e2       	ldi	r24, 0x29	; 41
    23d6:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
    23da:	89 81       	ldd	r24, Y+1	; 0x01
    23dc:	87 70       	andi	r24, 0x07	; 7
    23de:	99 f3       	breq	.-26     	; 0x23c6 <performSingleRefCalibration+0x56>
    23e0:	8b e0       	ldi	r24, 0x0B	; 11
    23e2:	89 83       	std	Y+1, r24	; 0x01
    23e4:	81 e0       	ldi	r24, 0x01	; 1
    23e6:	8a 83       	std	Y+2, r24	; 0x02
    23e8:	42 e0       	ldi	r20, 0x02	; 2
    23ea:	be 01       	movw	r22, r28
    23ec:	6f 5f       	subi	r22, 0xFF	; 255
    23ee:	7f 4f       	sbci	r23, 0xFF	; 255
    23f0:	89 e2       	ldi	r24, 0x29	; 41
    23f2:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
    23f6:	19 82       	std	Y+1, r1	; 0x01
    23f8:	1a 82       	std	Y+2, r1	; 0x02
    23fa:	42 e0       	ldi	r20, 0x02	; 2
    23fc:	be 01       	movw	r22, r28
    23fe:	6f 5f       	subi	r22, 0xFF	; 255
    2400:	7f 4f       	sbci	r23, 0xFF	; 255
    2402:	89 e2       	ldi	r24, 0x29	; 41
    2404:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
    2408:	81 e0       	ldi	r24, 0x01	; 1
    240a:	24 96       	adiw	r28, 0x04	; 4
    240c:	cd bf       	out	0x3d, r28	; 61
    240e:	de bf       	out	0x3e, r29	; 62
    2410:	df 91       	pop	r29
    2412:	cf 91       	pop	r28
    2414:	1f 91       	pop	r17
    2416:	0f 91       	pop	r16
    2418:	08 95       	ret

0000241a <readReg16Bit>:
    241a:	ef 92       	push	r14
    241c:	ff 92       	push	r15
    241e:	0f 93       	push	r16
    2420:	cf 93       	push	r28
    2422:	df 93       	push	r29
    2424:	00 d0       	rcall	.+0      	; 0x2426 <readReg16Bit+0xc>
    2426:	1f 92       	push	r1
    2428:	cd b7       	in	r28, 0x3d	; 61
    242a:	de b7       	in	r29, 0x3e	; 62
    242c:	7b 01       	movw	r14, r22
    242e:	89 83       	std	Y+1, r24	; 0x01
    2430:	02 e0       	ldi	r16, 0x02	; 2
    2432:	9e 01       	movw	r18, r28
    2434:	2f 5f       	subi	r18, 0xFF	; 255
    2436:	3f 4f       	sbci	r19, 0xFF	; 255
    2438:	41 e0       	ldi	r20, 0x01	; 1
    243a:	b9 01       	movw	r22, r18
    243c:	89 e2       	ldi	r24, 0x29	; 41
    243e:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
    2442:	e1 14       	cp	r14, r1
    2444:	f1 04       	cpc	r15, r1
    2446:	61 f0       	breq	.+24     	; 0x2460 <readReg16Bit+0x46>
    2448:	29 81       	ldd	r18, Y+1	; 0x01
    244a:	30 e0       	ldi	r19, 0x00	; 0
    244c:	9a 81       	ldd	r25, Y+2	; 0x02
    244e:	98 5f       	subi	r25, 0xF8	; 248
    2450:	02 c0       	rjmp	.+4      	; 0x2456 <readReg16Bit+0x3c>
    2452:	22 0f       	add	r18, r18
    2454:	33 1f       	adc	r19, r19
    2456:	9a 95       	dec	r25
    2458:	e2 f7       	brpl	.-8      	; 0x2452 <readReg16Bit+0x38>
    245a:	f7 01       	movw	r30, r14
    245c:	20 83       	st	Z, r18
    245e:	31 83       	std	Z+1, r19	; 0x01
    2460:	24 96       	adiw	r28, 0x04	; 4
    2462:	cd bf       	out	0x3d, r28	; 61
    2464:	de bf       	out	0x3e, r29	; 62
    2466:	df 91       	pop	r29
    2468:	cf 91       	pop	r28
    246a:	0f 91       	pop	r16
    246c:	ff 90       	pop	r15
    246e:	ef 90       	pop	r14
    2470:	08 95       	ret

00002472 <getSequenceStepTimeouts.isra.1>:
    2472:	8f 92       	push	r8
    2474:	9f 92       	push	r9
    2476:	af 92       	push	r10
    2478:	bf 92       	push	r11
    247a:	cf 92       	push	r12
    247c:	df 92       	push	r13
    247e:	ef 92       	push	r14
    2480:	ff 92       	push	r15
    2482:	0f 93       	push	r16
    2484:	1f 93       	push	r17
    2486:	cf 93       	push	r28
    2488:	df 93       	push	r29
    248a:	00 d0       	rcall	.+0      	; 0x248c <getSequenceStepTimeouts.isra.1+0x1a>
    248c:	00 d0       	rcall	.+0      	; 0x248e <getSequenceStepTimeouts.isra.1+0x1c>
    248e:	cd b7       	in	r28, 0x3d	; 61
    2490:	de b7       	in	r29, 0x3e	; 62
    2492:	6c 01       	movw	r12, r24
    2494:	7b 01       	movw	r14, r22
    2496:	80 e5       	ldi	r24, 0x50	; 80
    2498:	89 83       	std	Y+1, r24	; 0x01
    249a:	01 e0       	ldi	r16, 0x01	; 1
    249c:	9e 01       	movw	r18, r28
    249e:	2f 5f       	subi	r18, 0xFF	; 255
    24a0:	3f 4f       	sbci	r19, 0xFF	; 255
    24a2:	41 e0       	ldi	r20, 0x01	; 1
    24a4:	b9 01       	movw	r22, r18
    24a6:	89 e2       	ldi	r24, 0x29	; 41
    24a8:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
    24ac:	89 81       	ldd	r24, Y+1	; 0x01
    24ae:	8f 5f       	subi	r24, 0xFF	; 255
    24b0:	88 0f       	add	r24, r24
    24b2:	90 e0       	ldi	r25, 0x00	; 0
    24b4:	f7 01       	movw	r30, r14
    24b6:	80 83       	st	Z, r24
    24b8:	91 83       	std	Z+1, r25	; 0x01
    24ba:	86 e4       	ldi	r24, 0x46	; 70
    24bc:	89 83       	std	Y+1, r24	; 0x01
    24be:	9e 01       	movw	r18, r28
    24c0:	2f 5f       	subi	r18, 0xFF	; 255
    24c2:	3f 4f       	sbci	r19, 0xFF	; 255
    24c4:	41 e0       	ldi	r20, 0x01	; 1
    24c6:	b9 01       	movw	r22, r18
    24c8:	89 e2       	ldi	r24, 0x29	; 41
    24ca:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
    24ce:	09 81       	ldd	r16, Y+1	; 0x01
    24d0:	10 e0       	ldi	r17, 0x00	; 0
    24d2:	0f 5f       	subi	r16, 0xFF	; 255
    24d4:	1f 4f       	sbci	r17, 0xFF	; 255
    24d6:	f7 01       	movw	r30, r14
    24d8:	04 83       	std	Z+4, r16	; 0x04
    24da:	15 83       	std	Z+5, r17	; 0x05
    24dc:	a0 81       	ld	r26, Z
    24de:	b0 e0       	ldi	r27, 0x00	; 0
    24e0:	20 e0       	ldi	r18, 0x00	; 0
    24e2:	3f e2       	ldi	r19, 0x2F	; 47
    24e4:	4a e3       	ldi	r20, 0x3A	; 58
    24e6:	50 e0       	ldi	r21, 0x00	; 0
    24e8:	0e 94 5a 48 	call	0x90b4	; 0x90b4 <__muluhisi3>
    24ec:	6c 50       	subi	r22, 0x0C	; 12
    24ee:	7e 4f       	sbci	r23, 0xFE	; 254
    24f0:	8f 4f       	sbci	r24, 0xFF	; 255
    24f2:	9f 4f       	sbci	r25, 0xFF	; 255
    24f4:	38 ee       	ldi	r19, 0xE8	; 232
    24f6:	83 2e       	mov	r8, r19
    24f8:	33 e0       	ldi	r19, 0x03	; 3
    24fa:	93 2e       	mov	r9, r19
    24fc:	a1 2c       	mov	r10, r1
    24fe:	b1 2c       	mov	r11, r1
    2500:	a5 01       	movw	r20, r10
    2502:	94 01       	movw	r18, r8
    2504:	0e 94 29 48 	call	0x9052	; 0x9052 <__udivmodsi4>
    2508:	d8 01       	movw	r26, r16
    250a:	0e 94 65 48 	call	0x90ca	; 0x90ca <__mulshisi3>
    250e:	6c 50       	subi	r22, 0x0C	; 12
    2510:	7e 4f       	sbci	r23, 0xFE	; 254
    2512:	8f 4f       	sbci	r24, 0xFF	; 255
    2514:	9f 4f       	sbci	r25, 0xFF	; 255
    2516:	a5 01       	movw	r20, r10
    2518:	94 01       	movw	r18, r8
    251a:	0e 94 29 48 	call	0x9052	; 0x9052 <__udivmodsi4>
    251e:	f7 01       	movw	r30, r14
    2520:	22 87       	std	Z+10, r18	; 0x0a
    2522:	33 87       	std	Z+11, r19	; 0x0b
    2524:	44 87       	std	Z+12, r20	; 0x0c
    2526:	55 87       	std	Z+13, r21	; 0x0d
    2528:	be 01       	movw	r22, r28
    252a:	6b 5f       	subi	r22, 0xFB	; 251
    252c:	7f 4f       	sbci	r23, 0xFF	; 255
    252e:	81 e5       	ldi	r24, 0x51	; 81
    2530:	0e 94 0d 12 	call	0x241a	; 0x241a <readReg16Bit>
    2534:	8d 81       	ldd	r24, Y+5	; 0x05
    2536:	9e 81       	ldd	r25, Y+6	; 0x06
    2538:	8c 01       	movw	r16, r24
    253a:	11 27       	eor	r17, r17
    253c:	02 c0       	rjmp	.+4      	; 0x2542 <getSequenceStepTimeouts.isra.1+0xd0>
    253e:	00 0f       	add	r16, r16
    2540:	11 1f       	adc	r17, r17
    2542:	9a 95       	dec	r25
    2544:	e2 f7       	brpl	.-8      	; 0x253e <getSequenceStepTimeouts.isra.1+0xcc>
    2546:	0f 5f       	subi	r16, 0xFF	; 255
    2548:	1f 4f       	sbci	r17, 0xFF	; 255
    254a:	f7 01       	movw	r30, r14
    254c:	06 83       	std	Z+6, r16	; 0x06
    254e:	17 83       	std	Z+7, r17	; 0x07
    2550:	a0 81       	ld	r26, Z
    2552:	b0 e0       	ldi	r27, 0x00	; 0
    2554:	20 e0       	ldi	r18, 0x00	; 0
    2556:	3f e2       	ldi	r19, 0x2F	; 47
    2558:	4a e3       	ldi	r20, 0x3A	; 58
    255a:	50 e0       	ldi	r21, 0x00	; 0
    255c:	0e 94 5a 48 	call	0x90b4	; 0x90b4 <__muluhisi3>
    2560:	6c 50       	subi	r22, 0x0C	; 12
    2562:	7e 4f       	sbci	r23, 0xFE	; 254
    2564:	8f 4f       	sbci	r24, 0xFF	; 255
    2566:	9f 4f       	sbci	r25, 0xFF	; 255
    2568:	a5 01       	movw	r20, r10
    256a:	94 01       	movw	r18, r8
    256c:	0e 94 29 48 	call	0x9052	; 0x9052 <__udivmodsi4>
    2570:	d8 01       	movw	r26, r16
    2572:	0e 94 5a 48 	call	0x90b4	; 0x90b4 <__muluhisi3>
    2576:	6c 50       	subi	r22, 0x0C	; 12
    2578:	7e 4f       	sbci	r23, 0xFE	; 254
    257a:	8f 4f       	sbci	r24, 0xFF	; 255
    257c:	9f 4f       	sbci	r25, 0xFF	; 255
    257e:	a5 01       	movw	r20, r10
    2580:	94 01       	movw	r18, r8
    2582:	0e 94 29 48 	call	0x9052	; 0x9052 <__udivmodsi4>
    2586:	f7 01       	movw	r30, r14
    2588:	26 87       	std	Z+14, r18	; 0x0e
    258a:	37 87       	std	Z+15, r19	; 0x0f
    258c:	40 8b       	std	Z+16, r20	; 0x10
    258e:	51 8b       	std	Z+17, r21	; 0x11
    2590:	80 e7       	ldi	r24, 0x70	; 112
    2592:	89 83       	std	Y+1, r24	; 0x01
    2594:	01 e0       	ldi	r16, 0x01	; 1
    2596:	9e 01       	movw	r18, r28
    2598:	2f 5f       	subi	r18, 0xFF	; 255
    259a:	3f 4f       	sbci	r19, 0xFF	; 255
    259c:	41 e0       	ldi	r20, 0x01	; 1
    259e:	b9 01       	movw	r22, r18
    25a0:	89 e2       	ldi	r24, 0x29	; 41
    25a2:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
    25a6:	89 81       	ldd	r24, Y+1	; 0x01
    25a8:	8f 5f       	subi	r24, 0xFF	; 255
    25aa:	88 0f       	add	r24, r24
    25ac:	90 e0       	ldi	r25, 0x00	; 0
    25ae:	f7 01       	movw	r30, r14
    25b0:	82 83       	std	Z+2, r24	; 0x02
    25b2:	93 83       	std	Z+3, r25	; 0x03
    25b4:	be 01       	movw	r22, r28
    25b6:	6b 5f       	subi	r22, 0xFB	; 251
    25b8:	7f 4f       	sbci	r23, 0xFF	; 255
    25ba:	81 e7       	ldi	r24, 0x71	; 113
    25bc:	0e 94 0d 12 	call	0x241a	; 0x241a <readReg16Bit>
    25c0:	8d 81       	ldd	r24, Y+5	; 0x05
    25c2:	9e 81       	ldd	r25, Y+6	; 0x06
    25c4:	8c 01       	movw	r16, r24
    25c6:	11 27       	eor	r17, r17
    25c8:	02 c0       	rjmp	.+4      	; 0x25ce <getSequenceStepTimeouts.isra.1+0x15c>
    25ca:	00 0f       	add	r16, r16
    25cc:	11 1f       	adc	r17, r17
    25ce:	9a 95       	dec	r25
    25d0:	e2 f7       	brpl	.-8      	; 0x25ca <getSequenceStepTimeouts.isra.1+0x158>
    25d2:	0f 5f       	subi	r16, 0xFF	; 255
    25d4:	1f 4f       	sbci	r17, 0xFF	; 255
    25d6:	f7 01       	movw	r30, r14
    25d8:	00 87       	std	Z+8, r16	; 0x08
    25da:	11 87       	std	Z+9, r17	; 0x09
    25dc:	f6 01       	movw	r30, r12
    25de:	80 81       	ld	r24, Z
    25e0:	88 23       	and	r24, r24
    25e2:	39 f0       	breq	.+14     	; 0x25f2 <getSequenceStepTimeouts.isra.1+0x180>
    25e4:	f7 01       	movw	r30, r14
    25e6:	86 81       	ldd	r24, Z+6	; 0x06
    25e8:	97 81       	ldd	r25, Z+7	; 0x07
    25ea:	08 1b       	sub	r16, r24
    25ec:	19 0b       	sbc	r17, r25
    25ee:	00 87       	std	Z+8, r16	; 0x08
    25f0:	11 87       	std	Z+9, r17	; 0x09
    25f2:	f7 01       	movw	r30, r14
    25f4:	a2 81       	ldd	r26, Z+2	; 0x02
    25f6:	b0 e0       	ldi	r27, 0x00	; 0
    25f8:	20 e0       	ldi	r18, 0x00	; 0
    25fa:	3f e2       	ldi	r19, 0x2F	; 47
    25fc:	4a e3       	ldi	r20, 0x3A	; 58
    25fe:	50 e0       	ldi	r21, 0x00	; 0
    2600:	0e 94 5a 48 	call	0x90b4	; 0x90b4 <__muluhisi3>
    2604:	6c 50       	subi	r22, 0x0C	; 12
    2606:	7e 4f       	sbci	r23, 0xFE	; 254
    2608:	8f 4f       	sbci	r24, 0xFF	; 255
    260a:	9f 4f       	sbci	r25, 0xFF	; 255
    260c:	28 ee       	ldi	r18, 0xE8	; 232
    260e:	82 2e       	mov	r8, r18
    2610:	23 e0       	ldi	r18, 0x03	; 3
    2612:	92 2e       	mov	r9, r18
    2614:	a1 2c       	mov	r10, r1
    2616:	b1 2c       	mov	r11, r1
    2618:	a5 01       	movw	r20, r10
    261a:	94 01       	movw	r18, r8
    261c:	0e 94 29 48 	call	0x9052	; 0x9052 <__udivmodsi4>
    2620:	d8 01       	movw	r26, r16
    2622:	0e 94 5a 48 	call	0x90b4	; 0x90b4 <__muluhisi3>
    2626:	6c 50       	subi	r22, 0x0C	; 12
    2628:	7e 4f       	sbci	r23, 0xFE	; 254
    262a:	8f 4f       	sbci	r24, 0xFF	; 255
    262c:	9f 4f       	sbci	r25, 0xFF	; 255
    262e:	a5 01       	movw	r20, r10
    2630:	94 01       	movw	r18, r8
    2632:	0e 94 29 48 	call	0x9052	; 0x9052 <__udivmodsi4>
    2636:	f7 01       	movw	r30, r14
    2638:	22 8b       	std	Z+18, r18	; 0x12
    263a:	33 8b       	std	Z+19, r19	; 0x13
    263c:	44 8b       	std	Z+20, r20	; 0x14
    263e:	55 8b       	std	Z+21, r21	; 0x15
    2640:	26 96       	adiw	r28, 0x06	; 6
    2642:	cd bf       	out	0x3d, r28	; 61
    2644:	de bf       	out	0x3e, r29	; 62
    2646:	df 91       	pop	r29
    2648:	cf 91       	pop	r28
    264a:	1f 91       	pop	r17
    264c:	0f 91       	pop	r16
    264e:	ff 90       	pop	r15
    2650:	ef 90       	pop	r14
    2652:	df 90       	pop	r13
    2654:	cf 90       	pop	r12
    2656:	bf 90       	pop	r11
    2658:	af 90       	pop	r10
    265a:	9f 90       	pop	r9
    265c:	8f 90       	pop	r8
    265e:	08 95       	ret

00002660 <setMeasurementTimingBudget.part.4>:
    2660:	4f 92       	push	r4
    2662:	5f 92       	push	r5
    2664:	6f 92       	push	r6
    2666:	7f 92       	push	r7
    2668:	8f 92       	push	r8
    266a:	9f 92       	push	r9
    266c:	af 92       	push	r10
    266e:	bf 92       	push	r11
    2670:	cf 92       	push	r12
    2672:	df 92       	push	r13
    2674:	ef 92       	push	r14
    2676:	ff 92       	push	r15
    2678:	1f 93       	push	r17
    267a:	cf 93       	push	r28
    267c:	df 93       	push	r29
    267e:	cd b7       	in	r28, 0x3d	; 61
    2680:	de b7       	in	r29, 0x3e	; 62
    2682:	6f 97       	sbiw	r28, 0x1f	; 31
    2684:	cd bf       	out	0x3d, r28	; 61
    2686:	de bf       	out	0x3e, r29	; 62
    2688:	6b 01       	movw	r12, r22
    268a:	7c 01       	movw	r14, r24
    268c:	ce 01       	movw	r24, r28
    268e:	47 96       	adiw	r24, 0x17	; 23
    2690:	0e 94 84 11 	call	0x2308	; 0x2308 <getSequenceStepEnables>
    2694:	be 01       	movw	r22, r28
    2696:	6f 5f       	subi	r22, 0xFF	; 255
    2698:	7f 4f       	sbci	r23, 0xFF	; 255
    269a:	ce 01       	movw	r24, r28
    269c:	4a 96       	adiw	r24, 0x1a	; 26
    269e:	0e 94 39 12 	call	0x2472	; 0x2472 <getSequenceStepTimeouts.isra.1>
    26a2:	8f 89       	ldd	r24, Y+23	; 0x17
    26a4:	88 23       	and	r24, r24
    26a6:	09 f4       	brne	.+2      	; 0x26aa <setMeasurementTimingBudget.part.4+0x4a>
    26a8:	b0 c0       	rjmp	.+352    	; 0x280a <setMeasurementTimingBudget.part.4+0x1aa>
    26aa:	8b 85       	ldd	r24, Y+11	; 0x0b
    26ac:	9c 85       	ldd	r25, Y+12	; 0x0c
    26ae:	ad 85       	ldd	r26, Y+13	; 0x0d
    26b0:	be 85       	ldd	r27, Y+14	; 0x0e
    26b2:	8c 57       	subi	r24, 0x7C	; 124
    26b4:	92 4f       	sbci	r25, 0xF2	; 242
    26b6:	af 4f       	sbci	r26, 0xFF	; 255
    26b8:	bf 4f       	sbci	r27, 0xFF	; 255
    26ba:	29 8d       	ldd	r18, Y+25	; 0x19
    26bc:	22 23       	and	r18, r18
    26be:	09 f4       	brne	.+2      	; 0x26c2 <setMeasurementTimingBudget.part.4+0x62>
    26c0:	93 c0       	rjmp	.+294    	; 0x27e8 <setMeasurementTimingBudget.part.4+0x188>
    26c2:	4b 85       	ldd	r20, Y+11	; 0x0b
    26c4:	5c 85       	ldd	r21, Y+12	; 0x0c
    26c6:	6d 85       	ldd	r22, Y+13	; 0x0d
    26c8:	7e 85       	ldd	r23, Y+14	; 0x0e
    26ca:	4e 54       	subi	r20, 0x4E	; 78
    26cc:	5d 4f       	sbci	r21, 0xFD	; 253
    26ce:	6f 4f       	sbci	r22, 0xFF	; 255
    26d0:	7f 4f       	sbci	r23, 0xFF	; 255
    26d2:	44 0f       	add	r20, r20
    26d4:	55 1f       	adc	r21, r21
    26d6:	66 1f       	adc	r22, r22
    26d8:	77 1f       	adc	r23, r23
    26da:	84 0f       	add	r24, r20
    26dc:	95 1f       	adc	r25, r21
    26de:	a6 1f       	adc	r26, r22
    26e0:	b7 1f       	adc	r27, r23
    26e2:	1a 8d       	ldd	r17, Y+26	; 0x1a
    26e4:	11 23       	and	r17, r17
    26e6:	61 f0       	breq	.+24     	; 0x2700 <setMeasurementTimingBudget.part.4+0xa0>
    26e8:	4f 85       	ldd	r20, Y+15	; 0x0f
    26ea:	58 89       	ldd	r21, Y+16	; 0x10
    26ec:	69 89       	ldd	r22, Y+17	; 0x11
    26ee:	7a 89       	ldd	r23, Y+18	; 0x12
    26f0:	4c 56       	subi	r20, 0x6C	; 108
    26f2:	5d 4f       	sbci	r21, 0xFD	; 253
    26f4:	6f 4f       	sbci	r22, 0xFF	; 255
    26f6:	7f 4f       	sbci	r23, 0xFF	; 255
    26f8:	84 0f       	add	r24, r20
    26fa:	95 1f       	adc	r25, r21
    26fc:	a6 1f       	adc	r26, r22
    26fe:	b7 1f       	adc	r27, r23
    2700:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2702:	22 23       	and	r18, r18
    2704:	09 f4       	brne	.+2      	; 0x2708 <setMeasurementTimingBudget.part.4+0xa8>
    2706:	9a c0       	rjmp	.+308    	; 0x283c <setMeasurementTimingBudget.part.4+0x1dc>
    2708:	2c 01       	movw	r4, r24
    270a:	3d 01       	movw	r6, r26
    270c:	26 e2       	ldi	r18, 0x26	; 38
    270e:	42 0e       	add	r4, r18
    2710:	22 e0       	ldi	r18, 0x02	; 2
    2712:	52 1e       	adc	r5, r18
    2714:	61 1c       	adc	r6, r1
    2716:	71 1c       	adc	r7, r1
    2718:	c4 14       	cp	r12, r4
    271a:	d5 04       	cpc	r13, r5
    271c:	e6 04       	cpc	r14, r6
    271e:	f7 04       	cpc	r15, r7
    2720:	08 f4       	brcc	.+2      	; 0x2724 <setMeasurementTimingBudget.part.4+0xc4>
    2722:	78 c0       	rjmp	.+240    	; 0x2814 <setMeasurementTimingBudget.part.4+0x1b4>
    2724:	ab 81       	ldd	r26, Y+3	; 0x03
    2726:	b0 e0       	ldi	r27, 0x00	; 0
    2728:	20 e0       	ldi	r18, 0x00	; 0
    272a:	3f e2       	ldi	r19, 0x2F	; 47
    272c:	4a e3       	ldi	r20, 0x3A	; 58
    272e:	50 e0       	ldi	r21, 0x00	; 0
    2730:	0e 94 5a 48 	call	0x90b4	; 0x90b4 <__muluhisi3>
    2734:	4b 01       	movw	r8, r22
    2736:	5c 01       	movw	r10, r24
    2738:	24 ef       	ldi	r18, 0xF4	; 244
    273a:	82 0e       	add	r8, r18
    273c:	21 e0       	ldi	r18, 0x01	; 1
    273e:	92 1e       	adc	r9, r18
    2740:	a1 1c       	adc	r10, r1
    2742:	b1 1c       	adc	r11, r1
    2744:	a7 01       	movw	r20, r14
    2746:	96 01       	movw	r18, r12
    2748:	24 19       	sub	r18, r4
    274a:	35 09       	sbc	r19, r5
    274c:	46 09       	sbc	r20, r6
    274e:	57 09       	sbc	r21, r7
    2750:	a8 ee       	ldi	r26, 0xE8	; 232
    2752:	b3 e0       	ldi	r27, 0x03	; 3
    2754:	0e 94 5a 48 	call	0x90b4	; 0x90b4 <__muluhisi3>
    2758:	2b 01       	movw	r4, r22
    275a:	3c 01       	movw	r6, r24
    275c:	c5 01       	movw	r24, r10
    275e:	b4 01       	movw	r22, r8
    2760:	20 ed       	ldi	r18, 0xD0	; 208
    2762:	37 e0       	ldi	r19, 0x07	; 7
    2764:	40 e0       	ldi	r20, 0x00	; 0
    2766:	50 e0       	ldi	r21, 0x00	; 0
    2768:	0e 94 29 48 	call	0x9052	; 0x9052 <__udivmodsi4>
    276c:	42 0e       	add	r4, r18
    276e:	53 1e       	adc	r5, r19
    2770:	64 1e       	adc	r6, r20
    2772:	75 1e       	adc	r7, r21
    2774:	c5 01       	movw	r24, r10
    2776:	b4 01       	movw	r22, r8
    2778:	28 ee       	ldi	r18, 0xE8	; 232
    277a:	33 e0       	ldi	r19, 0x03	; 3
    277c:	40 e0       	ldi	r20, 0x00	; 0
    277e:	50 e0       	ldi	r21, 0x00	; 0
    2780:	0e 94 29 48 	call	0x9052	; 0x9052 <__udivmodsi4>
    2784:	c3 01       	movw	r24, r6
    2786:	b2 01       	movw	r22, r4
    2788:	0e 94 29 48 	call	0x9052	; 0x9052 <__udivmodsi4>
    278c:	11 23       	and	r17, r17
    278e:	31 f0       	breq	.+12     	; 0x279c <setMeasurementTimingBudget.part.4+0x13c>
    2790:	8f 81       	ldd	r24, Y+7	; 0x07
    2792:	98 85       	ldd	r25, Y+8	; 0x08
    2794:	28 0f       	add	r18, r24
    2796:	39 1f       	adc	r19, r25
    2798:	41 1d       	adc	r20, r1
    279a:	51 1d       	adc	r21, r1
    279c:	21 15       	cp	r18, r1
    279e:	31 05       	cpc	r19, r1
    27a0:	41 05       	cpc	r20, r1
    27a2:	51 05       	cpc	r21, r1
    27a4:	09 f4       	brne	.+2      	; 0x27a8 <setMeasurementTimingBudget.part.4+0x148>
    27a6:	4c c0       	rjmp	.+152    	; 0x2840 <setMeasurementTimingBudget.part.4+0x1e0>
    27a8:	da 01       	movw	r26, r20
    27aa:	c9 01       	movw	r24, r18
    27ac:	01 97       	sbiw	r24, 0x01	; 1
    27ae:	a1 09       	sbc	r26, r1
    27b0:	b1 09       	sbc	r27, r1
    27b2:	ac 01       	movw	r20, r24
    27b4:	bd 01       	movw	r22, r26
    27b6:	44 27       	eor	r20, r20
    27b8:	20 e0       	ldi	r18, 0x00	; 0
    27ba:	30 e0       	ldi	r19, 0x00	; 0
    27bc:	45 2b       	or	r20, r21
    27be:	46 2b       	or	r20, r22
    27c0:	47 2b       	or	r20, r23
    27c2:	79 f0       	breq	.+30     	; 0x27e2 <setMeasurementTimingBudget.part.4+0x182>
    27c4:	b6 95       	lsr	r27
    27c6:	a7 95       	ror	r26
    27c8:	97 95       	ror	r25
    27ca:	87 95       	ror	r24
    27cc:	2f 5f       	subi	r18, 0xFF	; 255
    27ce:	3f 4f       	sbci	r19, 0xFF	; 255
    27d0:	ac 01       	movw	r20, r24
    27d2:	bd 01       	movw	r22, r26
    27d4:	44 27       	eor	r20, r20
    27d6:	45 2b       	or	r20, r21
    27d8:	46 2b       	or	r20, r22
    27da:	47 2b       	or	r20, r23
    27dc:	99 f7       	brne	.-26     	; 0x27c4 <setMeasurementTimingBudget.part.4+0x164>
    27de:	32 2f       	mov	r19, r18
    27e0:	22 27       	eor	r18, r18
    27e2:	82 2b       	or	r24, r18
    27e4:	93 2b       	or	r25, r19
    27e6:	2e c0       	rjmp	.+92     	; 0x2844 <setMeasurementTimingBudget.part.4+0x1e4>
    27e8:	28 8d       	ldd	r18, Y+24	; 0x18
    27ea:	22 23       	and	r18, r18
    27ec:	09 f4       	brne	.+2      	; 0x27f0 <setMeasurementTimingBudget.part.4+0x190>
    27ee:	79 cf       	rjmp	.-270    	; 0x26e2 <setMeasurementTimingBudget.part.4+0x82>
    27f0:	4b 85       	ldd	r20, Y+11	; 0x0b
    27f2:	5c 85       	ldd	r21, Y+12	; 0x0c
    27f4:	6d 85       	ldd	r22, Y+13	; 0x0d
    27f6:	7e 85       	ldd	r23, Y+14	; 0x0e
    27f8:	4c 56       	subi	r20, 0x6C	; 108
    27fa:	5d 4f       	sbci	r21, 0xFD	; 253
    27fc:	6f 4f       	sbci	r22, 0xFF	; 255
    27fe:	7f 4f       	sbci	r23, 0xFF	; 255
    2800:	84 0f       	add	r24, r20
    2802:	95 1f       	adc	r25, r21
    2804:	a6 1f       	adc	r26, r22
    2806:	b7 1f       	adc	r27, r23
    2808:	6c cf       	rjmp	.-296    	; 0x26e2 <setMeasurementTimingBudget.part.4+0x82>
    280a:	86 e3       	ldi	r24, 0x36	; 54
    280c:	9b e0       	ldi	r25, 0x0B	; 11
    280e:	a0 e0       	ldi	r26, 0x00	; 0
    2810:	b0 e0       	ldi	r27, 0x00	; 0
    2812:	53 cf       	rjmp	.-346    	; 0x26ba <setMeasurementTimingBudget.part.4+0x5a>
    2814:	80 e0       	ldi	r24, 0x00	; 0
    2816:	6f 96       	adiw	r28, 0x1f	; 31
    2818:	cd bf       	out	0x3d, r28	; 61
    281a:	de bf       	out	0x3e, r29	; 62
    281c:	df 91       	pop	r29
    281e:	cf 91       	pop	r28
    2820:	1f 91       	pop	r17
    2822:	ff 90       	pop	r15
    2824:	ef 90       	pop	r14
    2826:	df 90       	pop	r13
    2828:	cf 90       	pop	r12
    282a:	bf 90       	pop	r11
    282c:	af 90       	pop	r10
    282e:	9f 90       	pop	r9
    2830:	8f 90       	pop	r8
    2832:	7f 90       	pop	r7
    2834:	6f 90       	pop	r6
    2836:	5f 90       	pop	r5
    2838:	4f 90       	pop	r4
    283a:	08 95       	ret
    283c:	81 e0       	ldi	r24, 0x01	; 1
    283e:	eb cf       	rjmp	.-42     	; 0x2816 <setMeasurementTimingBudget.part.4+0x1b6>
    2840:	80 e0       	ldi	r24, 0x00	; 0
    2842:	90 e0       	ldi	r25, 0x00	; 0
    2844:	21 e7       	ldi	r18, 0x71	; 113
    2846:	2c 8f       	std	Y+28, r18	; 0x1c
    2848:	9d 8f       	std	Y+29, r25	; 0x1d
    284a:	8e 8f       	std	Y+30, r24	; 0x1e
    284c:	43 e0       	ldi	r20, 0x03	; 3
    284e:	be 01       	movw	r22, r28
    2850:	64 5e       	subi	r22, 0xE4	; 228
    2852:	7f 4f       	sbci	r23, 0xFF	; 255
    2854:	89 e2       	ldi	r24, 0x29	; 41
    2856:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
    285a:	c0 92 81 2d 	sts	0x2D81, r12	; 0x802d81 <measurement_timing_budget_us>
    285e:	d0 92 82 2d 	sts	0x2D82, r13	; 0x802d82 <measurement_timing_budget_us+0x1>
    2862:	e0 92 83 2d 	sts	0x2D83, r14	; 0x802d83 <measurement_timing_budget_us+0x2>
    2866:	f0 92 84 2d 	sts	0x2D84, r15	; 0x802d84 <measurement_timing_budget_us+0x3>
    286a:	81 e0       	ldi	r24, 0x01	; 1
    286c:	d4 cf       	rjmp	.-88     	; 0x2816 <setMeasurementTimingBudget.part.4+0x1b6>

0000286e <DriverVL53L0XInit>:


uint8_t DriverVL53L0XInit(void)
{
    286e:	2f 92       	push	r2
    2870:	3f 92       	push	r3
    2872:	4f 92       	push	r4
    2874:	5f 92       	push	r5
    2876:	6f 92       	push	r6
    2878:	7f 92       	push	r7
    287a:	8f 92       	push	r8
    287c:	9f 92       	push	r9
    287e:	af 92       	push	r10
    2880:	bf 92       	push	r11
    2882:	cf 92       	push	r12
    2884:	df 92       	push	r13
    2886:	ef 92       	push	r14
    2888:	ff 92       	push	r15
    288a:	0f 93       	push	r16
    288c:	1f 93       	push	r17
    288e:	cf 93       	push	r28
    2890:	df 93       	push	r29
    2892:	cd b7       	in	r28, 0x3d	; 61
    2894:	de b7       	in	r29, 0x3e	; 62
    2896:	a1 97       	sbiw	r28, 0x21	; 33
    2898:	cd bf       	out	0x3d, r28	; 61
    289a:	de bf       	out	0x3e, r29	; 62
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    289c:	80 ec       	ldi	r24, 0xC0	; 192
    289e:	89 83       	std	Y+1, r24	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    28a0:	01 e0       	ldi	r16, 0x01	; 1
    28a2:	9e 01       	movw	r18, r28
    28a4:	2f 5f       	subi	r18, 0xFF	; 255
    28a6:	3f 4f       	sbci	r19, 0xFF	; 255
    28a8:	41 e0       	ldi	r20, 0x01	; 1
    28aa:	b9 01       	movw	r22, r18
    28ac:	89 e2       	ldi	r24, 0x29	; 41
    28ae:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    28b2:	99 81       	ldd	r25, Y+1	; 0x01
	uint8_t res;
	int a;
	
	//Check Model ID
	res=readReg(IDENTIFICATION_MODEL_ID,&Data);
	if (!res)
    28b4:	88 23       	and	r24, r24
    28b6:	09 f4       	brne	.+2      	; 0x28ba <DriverVL53L0XInit+0x4c>
    28b8:	ef c5       	rjmp	.+3038   	; 0x3498 <DriverVL53L0XInit+0xc2a>
		#ifdef VL53L0X_DEBUG
			printf ("VL53L0X:Cannot access.\r\n");
		#endif
		return false;
	}
	if (Data != 0xEE)
    28ba:	9e 3e       	cpi	r25, 0xEE	; 238
    28bc:	d9 f0       	breq	.+54     	; 0x28f4 <DriverVL53L0XInit+0x86>
	{
		#ifdef VL53L0X_DEBUG
			printf ("VL53L0X:Incorrect ID_MODEL_ID\r\n");
    28be:	80 e5       	ldi	r24, 0x50	; 80
    28c0:	93 e2       	ldi	r25, 0x23	; 35
    28c2:	0e 94 94 4d 	call	0x9b28	; 0x9b28 <puts>
		#endif
		return false;
    28c6:	80 e0       	ldi	r24, 0x00	; 0
	writeReg(SYSTEM_SEQUENCE_CONFIG, 0xE8);

	// VL53L0X_PerformRefCalibration() end

	return true;
}
    28c8:	a1 96       	adiw	r28, 0x21	; 33
    28ca:	cd bf       	out	0x3d, r28	; 61
    28cc:	de bf       	out	0x3e, r29	; 62
    28ce:	df 91       	pop	r29
    28d0:	cf 91       	pop	r28
    28d2:	1f 91       	pop	r17
    28d4:	0f 91       	pop	r16
    28d6:	ff 90       	pop	r15
    28d8:	ef 90       	pop	r14
    28da:	df 90       	pop	r13
    28dc:	cf 90       	pop	r12
    28de:	bf 90       	pop	r11
    28e0:	af 90       	pop	r10
    28e2:	9f 90       	pop	r9
    28e4:	8f 90       	pop	r8
    28e6:	7f 90       	pop	r7
    28e8:	6f 90       	pop	r6
    28ea:	5f 90       	pop	r5
    28ec:	4f 90       	pop	r4
    28ee:	3f 90       	pop	r3
    28f0:	2f 90       	pop	r2
    28f2:	08 95       	ret
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    28f4:	88 e8       	ldi	r24, 0x88	; 136
    28f6:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    28f8:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    28fa:	42 e0       	ldi	r20, 0x02	; 2
    28fc:	be 01       	movw	r22, r28
    28fe:	6f 5f       	subi	r22, 0xFF	; 255
    2900:	7f 4f       	sbci	r23, 0xFF	; 255
    2902:	89 e2       	ldi	r24, 0x29	; 41
    2904:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2908:	e0 e8       	ldi	r30, 0x80	; 128
    290a:	ee 2e       	mov	r14, r30
    290c:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    290e:	11 e0       	ldi	r17, 0x01	; 1
    2910:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2912:	42 e0       	ldi	r20, 0x02	; 2
    2914:	be 01       	movw	r22, r28
    2916:	6f 5f       	subi	r22, 0xFF	; 255
    2918:	7f 4f       	sbci	r23, 0xFF	; 255
    291a:	89 e2       	ldi	r24, 0x29	; 41
    291c:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2920:	ff 24       	eor	r15, r15
    2922:	fa 94       	dec	r15
    2924:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    2926:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2928:	42 e0       	ldi	r20, 0x02	; 2
    292a:	be 01       	movw	r22, r28
    292c:	6f 5f       	subi	r22, 0xFF	; 255
    292e:	7f 4f       	sbci	r23, 0xFF	; 255
    2930:	89 e2       	ldi	r24, 0x29	; 41
    2932:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2936:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    2938:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    293a:	42 e0       	ldi	r20, 0x02	; 2
    293c:	be 01       	movw	r22, r28
    293e:	6f 5f       	subi	r22, 0xFF	; 255
    2940:	7f 4f       	sbci	r23, 0xFF	; 255
    2942:	89 e2       	ldi	r24, 0x29	; 41
    2944:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2948:	81 e9       	ldi	r24, 0x91	; 145
    294a:	89 83       	std	Y+1, r24	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    294c:	01 e0       	ldi	r16, 0x01	; 1
    294e:	9e 01       	movw	r18, r28
    2950:	2f 5f       	subi	r18, 0xFF	; 255
    2952:	3f 4f       	sbci	r19, 0xFF	; 255
    2954:	41 e0       	ldi	r20, 0x01	; 1
    2956:	b9 01       	movw	r22, r18
    2958:	89 e2       	ldi	r24, 0x29	; 41
    295a:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    295e:	89 81       	ldd	r24, Y+1	; 0x01
    2960:	80 93 99 2c 	sts	0x2C99, r24	; 0x802c99 <stop_variable>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2964:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    2966:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2968:	42 e0       	ldi	r20, 0x02	; 2
    296a:	be 01       	movw	r22, r28
    296c:	6f 5f       	subi	r22, 0xFF	; 255
    296e:	7f 4f       	sbci	r23, 0xFF	; 255
    2970:	89 e2       	ldi	r24, 0x29	; 41
    2972:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2976:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    2978:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    297a:	42 e0       	ldi	r20, 0x02	; 2
    297c:	be 01       	movw	r22, r28
    297e:	6f 5f       	subi	r22, 0xFF	; 255
    2980:	7f 4f       	sbci	r23, 0xFF	; 255
    2982:	89 e2       	ldi	r24, 0x29	; 41
    2984:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2988:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    298a:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    298c:	42 e0       	ldi	r20, 0x02	; 2
    298e:	be 01       	movw	r22, r28
    2990:	6f 5f       	subi	r22, 0xFF	; 255
    2992:	7f 4f       	sbci	r23, 0xFF	; 255
    2994:	89 e2       	ldi	r24, 0x29	; 41
    2996:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    299a:	f0 e6       	ldi	r31, 0x60	; 96
    299c:	df 2e       	mov	r13, r31
    299e:	d9 82       	std	Y+1, r13	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    29a0:	9e 01       	movw	r18, r28
    29a2:	2f 5f       	subi	r18, 0xFF	; 255
    29a4:	3f 4f       	sbci	r19, 0xFF	; 255
    29a6:	41 e0       	ldi	r20, 0x01	; 1
    29a8:	b9 01       	movw	r22, r18
    29aa:	89 e2       	ldi	r24, 0x29	; 41
    29ac:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    29b0:	89 81       	ldd	r24, Y+1	; 0x01
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    29b2:	d9 82       	std	Y+1, r13	; 0x01
	Buffer[1]=value;
    29b4:	82 61       	ori	r24, 0x12	; 18
    29b6:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    29b8:	42 e0       	ldi	r20, 0x02	; 2
    29ba:	be 01       	movw	r22, r28
    29bc:	6f 5f       	subi	r22, 0xFF	; 255
    29be:	7f 4f       	sbci	r23, 0xFF	; 255
    29c0:	89 e2       	ldi	r24, 0x29	; 41
    29c2:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write a 16-bit register
uint8_t writeReg16Bit(uint8_t reg, uint16_t value)
{
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg,
    29c6:	84 e4       	ldi	r24, 0x44	; 68
    29c8:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value>>8;
    29ca:	1a 82       	std	Y+2, r1	; 0x02
	Buffer[2]=value;
    29cc:	80 e2       	ldi	r24, 0x20	; 32
    29ce:	8b 83       	std	Y+3, r24	; 0x03
	res=TWIMWrite(VL53L0X_ADDR,Buffer,3);
    29d0:	43 e0       	ldi	r20, 0x03	; 3
    29d2:	be 01       	movw	r22, r28
    29d4:	6f 5f       	subi	r22, 0xFF	; 255
    29d6:	7f 4f       	sbci	r23, 0xFF	; 255
    29d8:	89 e2       	ldi	r24, 0x29	; 41
    29da:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    29de:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    29e0:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    29e2:	42 e0       	ldi	r20, 0x02	; 2
    29e4:	be 01       	movw	r22, r28
    29e6:	6f 5f       	subi	r22, 0xFF	; 255
    29e8:	7f 4f       	sbci	r23, 0xFF	; 255
    29ea:	89 e2       	ldi	r24, 0x29	; 41
    29ec:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    29f0:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    29f2:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    29f4:	42 e0       	ldi	r20, 0x02	; 2
    29f6:	be 01       	movw	r22, r28
    29f8:	6f 5f       	subi	r22, 0xFF	; 255
    29fa:	7f 4f       	sbci	r23, 0xFF	; 255
    29fc:	89 e2       	ldi	r24, 0x29	; 41
    29fe:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2a02:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    2a04:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2a06:	42 e0       	ldi	r20, 0x02	; 2
    2a08:	be 01       	movw	r22, r28
    2a0a:	6f 5f       	subi	r22, 0xFF	; 255
    2a0c:	7f 4f       	sbci	r23, 0xFF	; 255
    2a0e:	89 e2       	ldi	r24, 0x29	; 41
    2a10:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2a14:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    2a16:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2a18:	42 e0       	ldi	r20, 0x02	; 2
    2a1a:	be 01       	movw	r22, r28
    2a1c:	6f 5f       	subi	r22, 0xFF	; 255
    2a1e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a20:	89 e2       	ldi	r24, 0x29	; 41
    2a22:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2a26:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    2a28:	86 e0       	ldi	r24, 0x06	; 6
    2a2a:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2a2c:	42 e0       	ldi	r20, 0x02	; 2
    2a2e:	be 01       	movw	r22, r28
    2a30:	6f 5f       	subi	r22, 0xFF	; 255
    2a32:	7f 4f       	sbci	r23, 0xFF	; 255
    2a34:	89 e2       	ldi	r24, 0x29	; 41
    2a36:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2a3a:	a3 e8       	ldi	r26, 0x83	; 131
    2a3c:	da 2e       	mov	r13, r26
    2a3e:	d9 82       	std	Y+1, r13	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2a40:	9e 01       	movw	r18, r28
    2a42:	2f 5f       	subi	r18, 0xFF	; 255
    2a44:	3f 4f       	sbci	r19, 0xFF	; 255
    2a46:	41 e0       	ldi	r20, 0x01	; 1
    2a48:	b9 01       	movw	r22, r18
    2a4a:	89 e2       	ldi	r24, 0x29	; 41
    2a4c:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2a50:	89 81       	ldd	r24, Y+1	; 0x01
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2a52:	d9 82       	std	Y+1, r13	; 0x01
	Buffer[1]=value;
    2a54:	84 60       	ori	r24, 0x04	; 4
    2a56:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2a58:	42 e0       	ldi	r20, 0x02	; 2
    2a5a:	be 01       	movw	r22, r28
    2a5c:	6f 5f       	subi	r22, 0xFF	; 255
    2a5e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a60:	89 e2       	ldi	r24, 0x29	; 41
    2a62:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2a66:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    2a68:	87 e0       	ldi	r24, 0x07	; 7
    2a6a:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2a6c:	42 e0       	ldi	r20, 0x02	; 2
    2a6e:	be 01       	movw	r22, r28
    2a70:	6f 5f       	subi	r22, 0xFF	; 255
    2a72:	7f 4f       	sbci	r23, 0xFF	; 255
    2a74:	89 e2       	ldi	r24, 0x29	; 41
    2a76:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2a7a:	81 e8       	ldi	r24, 0x81	; 129
    2a7c:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2a7e:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2a80:	42 e0       	ldi	r20, 0x02	; 2
    2a82:	be 01       	movw	r22, r28
    2a84:	6f 5f       	subi	r22, 0xFF	; 255
    2a86:	7f 4f       	sbci	r23, 0xFF	; 255
    2a88:	89 e2       	ldi	r24, 0x29	; 41
    2a8a:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2a8e:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2a90:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2a92:	42 e0       	ldi	r20, 0x02	; 2
    2a94:	be 01       	movw	r22, r28
    2a96:	6f 5f       	subi	r22, 0xFF	; 255
    2a98:	7f 4f       	sbci	r23, 0xFF	; 255
    2a9a:	89 e2       	ldi	r24, 0x29	; 41
    2a9c:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2aa0:	84 e9       	ldi	r24, 0x94	; 148
    2aa2:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2aa4:	8b e6       	ldi	r24, 0x6B	; 107
    2aa6:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2aa8:	42 e0       	ldi	r20, 0x02	; 2
    2aaa:	be 01       	movw	r22, r28
    2aac:	6f 5f       	subi	r22, 0xFF	; 255
    2aae:	7f 4f       	sbci	r23, 0xFF	; 255
    2ab0:	89 e2       	ldi	r24, 0x29	; 41
    2ab2:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2ab6:	d9 82       	std	Y+1, r13	; 0x01
	Buffer[1]=value;
    2ab8:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2aba:	42 e0       	ldi	r20, 0x02	; 2
    2abc:	be 01       	movw	r22, r28
    2abe:	6f 5f       	subi	r22, 0xFF	; 255
    2ac0:	7f 4f       	sbci	r23, 0xFF	; 255
    2ac2:	89 e2       	ldi	r24, 0x29	; 41
    2ac4:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
	return true;
}

static void startTimeout(void)
{
	timeout_start_ticks=portGET_RUN_TIME_COUNTER_VALUE();
    2ac8:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    2acc:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    2ad0:	80 91 85 2d 	lds	r24, 0x2D85	; 0x802d85 <StatsTimer>
    2ad4:	90 91 86 2d 	lds	r25, 0x2D86	; 0x802d86 <StatsTimer+0x1>
    2ad8:	a0 91 87 2d 	lds	r26, 0x2D87	; 0x802d87 <StatsTimer+0x2>
    2adc:	b0 91 88 2d 	lds	r27, 0x2D88	; 0x802d88 <StatsTimer+0x3>
    2ae0:	82 0f       	add	r24, r18
    2ae2:	93 1f       	adc	r25, r19
    2ae4:	a1 1d       	adc	r26, r1
    2ae6:	b1 1d       	adc	r27, r1
    2ae8:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <timeout_start_ticks>
    2aec:	90 93 96 2c 	sts	0x2C96, r25	; 0x802c96 <timeout_start_ticks+0x1>
    2af0:	a0 93 97 2c 	sts	0x2C97, r26	; 0x802c97 <timeout_start_ticks+0x2>
    2af4:	b0 93 98 2c 	sts	0x2C98, r27	; 0x802c98 <timeout_start_ticks+0x3>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2af8:	b3 e8       	ldi	r27, 0x83	; 131
    2afa:	fb 2e       	mov	r15, r27
    2afc:	13 e8       	ldi	r17, 0x83	; 131
    2afe:	f9 82       	std	Y+1, r15	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2b00:	01 e0       	ldi	r16, 0x01	; 1
    2b02:	9e 01       	movw	r18, r28
    2b04:	2f 5f       	subi	r18, 0xFF	; 255
    2b06:	3f 4f       	sbci	r19, 0xFF	; 255
    2b08:	41 e0       	ldi	r20, 0x01	; 1
    2b0a:	b9 01       	movw	r22, r18
    2b0c:	89 e2       	ldi	r24, 0x29	; 41
    2b0e:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2b12:	89 81       	ldd	r24, Y+1	; 0x01
	startTimeout();
	
	while (1)
	{
		readReg(0x83,&Data);
		if (Data!=0x00) break;
    2b14:	88 23       	and	r24, r24
    2b16:	91 f3       	breq	.-28     	; 0x2afc <DriverVL53L0XInit+0x28e>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2b18:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2b1a:	dd 24       	eor	r13, r13
    2b1c:	d3 94       	inc	r13
    2b1e:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2b20:	42 e0       	ldi	r20, 0x02	; 2
    2b22:	be 01       	movw	r22, r28
    2b24:	6f 5f       	subi	r22, 0xFF	; 255
    2b26:	7f 4f       	sbci	r23, 0xFF	; 255
    2b28:	89 e2       	ldi	r24, 0x29	; 41
    2b2a:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2b2e:	82 e9       	ldi	r24, 0x92	; 146
    2b30:	89 83       	std	Y+1, r24	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2b32:	9e 01       	movw	r18, r28
    2b34:	2f 5f       	subi	r18, 0xFF	; 255
    2b36:	3f 4f       	sbci	r19, 0xFF	; 255
    2b38:	41 e0       	ldi	r20, 0x01	; 1
    2b3a:	b9 01       	movw	r22, r18
    2b3c:	89 e2       	ldi	r24, 0x29	; 41
    2b3e:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2b42:	f9 80       	ldd	r15, Y+1	; 0x01
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2b44:	81 e8       	ldi	r24, 0x81	; 129
    2b46:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2b48:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2b4a:	42 e0       	ldi	r20, 0x02	; 2
    2b4c:	be 01       	movw	r22, r28
    2b4e:	6f 5f       	subi	r22, 0xFF	; 255
    2b50:	7f 4f       	sbci	r23, 0xFF	; 255
    2b52:	89 e2       	ldi	r24, 0x29	; 41
    2b54:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2b58:	ee 24       	eor	r14, r14
    2b5a:	ea 94       	dec	r14
    2b5c:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2b5e:	86 e0       	ldi	r24, 0x06	; 6
    2b60:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2b62:	42 e0       	ldi	r20, 0x02	; 2
    2b64:	be 01       	movw	r22, r28
    2b66:	6f 5f       	subi	r22, 0xFF	; 255
    2b68:	7f 4f       	sbci	r23, 0xFF	; 255
    2b6a:	89 e2       	ldi	r24, 0x29	; 41
    2b6c:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    2b70:	19 83       	std	Y+1, r17	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    2b72:	9e 01       	movw	r18, r28
    2b74:	2f 5f       	subi	r18, 0xFF	; 255
    2b76:	3f 4f       	sbci	r19, 0xFF	; 255
    2b78:	41 e0       	ldi	r20, 0x01	; 1
    2b7a:	b9 01       	movw	r22, r18
    2b7c:	89 e2       	ldi	r24, 0x29	; 41
    2b7e:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    2b82:	89 81       	ldd	r24, Y+1	; 0x01
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2b84:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2b86:	8b 7f       	andi	r24, 0xFB	; 251
    2b88:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2b8a:	42 e0       	ldi	r20, 0x02	; 2
    2b8c:	be 01       	movw	r22, r28
    2b8e:	6f 5f       	subi	r22, 0xFF	; 255
    2b90:	7f 4f       	sbci	r23, 0xFF	; 255
    2b92:	89 e2       	ldi	r24, 0x29	; 41
    2b94:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2b98:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2b9a:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2b9c:	42 e0       	ldi	r20, 0x02	; 2
    2b9e:	be 01       	movw	r22, r28
    2ba0:	6f 5f       	subi	r22, 0xFF	; 255
    2ba2:	7f 4f       	sbci	r23, 0xFF	; 255
    2ba4:	89 e2       	ldi	r24, 0x29	; 41
    2ba6:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2baa:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    2bac:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2bae:	42 e0       	ldi	r20, 0x02	; 2
    2bb0:	be 01       	movw	r22, r28
    2bb2:	6f 5f       	subi	r22, 0xFF	; 255
    2bb4:	7f 4f       	sbci	r23, 0xFF	; 255
    2bb6:	89 e2       	ldi	r24, 0x29	; 41
    2bb8:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2bbc:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2bbe:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2bc0:	42 e0       	ldi	r20, 0x02	; 2
    2bc2:	be 01       	movw	r22, r28
    2bc4:	6f 5f       	subi	r22, 0xFF	; 255
    2bc6:	7f 4f       	sbci	r23, 0xFF	; 255
    2bc8:	89 e2       	ldi	r24, 0x29	; 41
    2bca:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2bce:	80 e8       	ldi	r24, 0x80	; 128
    2bd0:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2bd2:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2bd4:	42 e0       	ldi	r20, 0x02	; 2
    2bd6:	be 01       	movw	r22, r28
    2bd8:	6f 5f       	subi	r22, 0xFF	; 255
    2bda:	7f 4f       	sbci	r23, 0xFF	; 255
    2bdc:	89 e2       	ldi	r24, 0x29	; 41
    2bde:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// register, into the given array
uint8_t readMulti(uint8_t reg, uint8_t * dst, uint8_t count)
{
	uint8_t res;
	uint8_t Buffer[1];
	Buffer[0]=reg;
    2be2:	80 eb       	ldi	r24, 0xB0	; 176
    2be4:	89 83       	std	Y+1, r24	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,dst,count);
    2be6:	06 e0       	ldi	r16, 0x06	; 6
    2be8:	9e 01       	movw	r18, r28
    2bea:	29 5e       	subi	r18, 0xE9	; 233
    2bec:	3f 4f       	sbci	r19, 0xFF	; 255
    2bee:	41 e0       	ldi	r20, 0x01	; 1
    2bf0:	be 01       	movw	r22, r28
    2bf2:	6f 5f       	subi	r22, 0xFF	; 255
    2bf4:	7f 4f       	sbci	r23, 0xFF	; 255
    2bf6:	89 e2       	ldi	r24, 0x29	; 41
    2bf8:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2bfc:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2bfe:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2c00:	42 e0       	ldi	r20, 0x02	; 2
    2c02:	be 01       	movw	r22, r28
    2c04:	6f 5f       	subi	r22, 0xFF	; 255
    2c06:	7f 4f       	sbci	r23, 0xFF	; 255
    2c08:	89 e2       	ldi	r24, 0x29	; 41
    2c0a:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2c0e:	8f e4       	ldi	r24, 0x4F	; 79
    2c10:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2c12:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2c14:	42 e0       	ldi	r20, 0x02	; 2
    2c16:	be 01       	movw	r22, r28
    2c18:	6f 5f       	subi	r22, 0xFF	; 255
    2c1a:	7f 4f       	sbci	r23, 0xFF	; 255
    2c1c:	89 e2       	ldi	r24, 0x29	; 41
    2c1e:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2c22:	8e e4       	ldi	r24, 0x4E	; 78
    2c24:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2c26:	8c e2       	ldi	r24, 0x2C	; 44
    2c28:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2c2a:	42 e0       	ldi	r20, 0x02	; 2
    2c2c:	be 01       	movw	r22, r28
    2c2e:	6f 5f       	subi	r22, 0xFF	; 255
    2c30:	7f 4f       	sbci	r23, 0xFF	; 255
    2c32:	89 e2       	ldi	r24, 0x29	; 41
    2c34:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2c38:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2c3a:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2c3c:	42 e0       	ldi	r20, 0x02	; 2
    2c3e:	be 01       	movw	r22, r28
    2c40:	6f 5f       	subi	r22, 0xFF	; 255
    2c42:	7f 4f       	sbci	r23, 0xFF	; 255
    2c44:	89 e2       	ldi	r24, 0x29	; 41
    2c46:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2c4a:	86 eb       	ldi	r24, 0xB6	; 182
    2c4c:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2c4e:	84 eb       	ldi	r24, 0xB4	; 180
    2c50:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2c52:	42 e0       	ldi	r20, 0x02	; 2
    2c54:	be 01       	movw	r22, r28
    2c56:	6f 5f       	subi	r22, 0xFF	; 255
    2c58:	7f 4f       	sbci	r23, 0xFF	; 255
    2c5a:	89 e2       	ldi	r24, 0x29	; 41
    2c5c:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
	writeReg(DYNAMIC_SPAD_REF_EN_START_OFFSET, 0x00);
	writeReg(DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);
	writeReg(0xFF, 0x00);
	writeReg(GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);

	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
    2c60:	f7 fc       	sbrc	r15, 7
    2c62:	20 c4       	rjmp	.+2112   	; 0x34a4 <DriverVL53L0XInit+0xc36>
    2c64:	40 e0       	ldi	r20, 0x00	; 0
	uint8_t spads_enabled = 0;

	for (uint8_t i = 0; i < 48; i++)
    2c66:	00 e0       	ldi	r16, 0x00	; 0
	writeReg(DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);
	writeReg(0xFF, 0x00);
	writeReg(GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);

	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
	uint8_t spads_enabled = 0;
    2c68:	50 e0       	ldi	r21, 0x00	; 0
	{
		if (i < first_spad_to_enable || spads_enabled == spad_count)
		{
			// This bit is lower than the first one that should be enabled, or
			// (reference_spad_count) bits have already been enabled, so zero this bit
			ref_spad_map[i / 8] &= ~(1 << (i % 8));
    2c6a:	21 e0       	ldi	r18, 0x01	; 1
    2c6c:	30 e0       	ldi	r19, 0x00	; 0
	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
	uint8_t spads_enabled = 0;

	for (uint8_t i = 0; i < 48; i++)
	{
		if (i < first_spad_to_enable || spads_enabled == spad_count)
    2c6e:	7f 2d       	mov	r23, r15
    2c70:	7f 77       	andi	r23, 0x7F	; 127
    2c72:	10 c0       	rjmp	.+32     	; 0x2c94 <DriverVL53L0XInit+0x426>
    2c74:	57 17       	cp	r21, r23
    2c76:	d1 f0       	breq	.+52     	; 0x2cac <DriverVL53L0XInit+0x43e>
		{
			// This bit is lower than the first one that should be enabled, or
			// (reference_spad_count) bits have already been enabled, so zero this bit
			ref_spad_map[i / 8] &= ~(1 << (i % 8));
		}
		else if ((ref_spad_map[i / 8] >> (i % 8)) & 0x1)
    2c78:	80 81       	ld	r24, Z
    2c7a:	90 e0       	ldi	r25, 0x00	; 0
    2c7c:	60 2f       	mov	r22, r16
    2c7e:	67 70       	andi	r22, 0x07	; 7
    2c80:	02 c0       	rjmp	.+4      	; 0x2c86 <DriverVL53L0XInit+0x418>
    2c82:	95 95       	asr	r25
    2c84:	87 95       	ror	r24
    2c86:	6a 95       	dec	r22
    2c88:	e2 f7       	brpl	.-8      	; 0x2c82 <DriverVL53L0XInit+0x414>
    2c8a:	80 fd       	sbrc	r24, 0
		{
			spads_enabled++;
    2c8c:	5f 5f       	subi	r21, 0xFF	; 255
	writeReg(GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);

	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
	uint8_t spads_enabled = 0;

	for (uint8_t i = 0; i < 48; i++)
    2c8e:	0f 5f       	subi	r16, 0xFF	; 255
    2c90:	00 33       	cpi	r16, 0x30	; 48
    2c92:	e1 f0       	breq	.+56     	; 0x2ccc <DriverVL53L0XInit+0x45e>
	{
		if (i < first_spad_to_enable || spads_enabled == spad_count)
		{
			// This bit is lower than the first one that should be enabled, or
			// (reference_spad_count) bits have already been enabled, so zero this bit
			ref_spad_map[i / 8] &= ~(1 << (i % 8));
    2c94:	80 2f       	mov	r24, r16
    2c96:	86 95       	lsr	r24
    2c98:	86 95       	lsr	r24
    2c9a:	86 95       	lsr	r24
    2c9c:	e7 e1       	ldi	r30, 0x17	; 23
    2c9e:	f0 e0       	ldi	r31, 0x00	; 0
    2ca0:	ec 0f       	add	r30, r28
    2ca2:	fd 1f       	adc	r31, r29
    2ca4:	e8 0f       	add	r30, r24
    2ca6:	f1 1d       	adc	r31, r1
	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
	uint8_t spads_enabled = 0;

	for (uint8_t i = 0; i < 48; i++)
	{
		if (i < first_spad_to_enable || spads_enabled == spad_count)
    2ca8:	04 17       	cp	r16, r20
    2caa:	20 f7       	brcc	.-56     	; 0x2c74 <DriverVL53L0XInit+0x406>
		{
			// This bit is lower than the first one that should be enabled, or
			// (reference_spad_count) bits have already been enabled, so zero this bit
			ref_spad_map[i / 8] &= ~(1 << (i % 8));
    2cac:	80 2f       	mov	r24, r16
    2cae:	87 70       	andi	r24, 0x07	; 7
    2cb0:	d9 01       	movw	r26, r18
    2cb2:	02 c0       	rjmp	.+4      	; 0x2cb8 <DriverVL53L0XInit+0x44a>
    2cb4:	aa 0f       	add	r26, r26
    2cb6:	bb 1f       	adc	r27, r27
    2cb8:	8a 95       	dec	r24
    2cba:	e2 f7       	brpl	.-8      	; 0x2cb4 <DriverVL53L0XInit+0x446>
    2cbc:	cd 01       	movw	r24, r26
    2cbe:	80 95       	com	r24
    2cc0:	90 81       	ld	r25, Z
    2cc2:	89 23       	and	r24, r25
    2cc4:	80 83       	st	Z, r24
	writeReg(GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);

	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
	uint8_t spads_enabled = 0;

	for (uint8_t i = 0; i < 48; i++)
    2cc6:	0f 5f       	subi	r16, 0xFF	; 255
    2cc8:	00 33       	cpi	r16, 0x30	; 48
    2cca:	21 f7       	brne	.-56     	; 0x2c94 <DriverVL53L0XInit+0x426>
	uint8_t res;
	uint8_t Buffer[16];
	
	if (count>15) return -2;
	
	Buffer[0]=reg;
    2ccc:	80 eb       	ldi	r24, 0xB0	; 176
    2cce:	89 83       	std	Y+1, r24	; 0x01
	memcpy(&Buffer[1],src,count);
    2cd0:	86 e0       	ldi	r24, 0x06	; 6
    2cd2:	fe 01       	movw	r30, r28
    2cd4:	77 96       	adiw	r30, 0x17	; 23
    2cd6:	de 01       	movw	r26, r28
    2cd8:	12 96       	adiw	r26, 0x02	; 2
    2cda:	01 90       	ld	r0, Z+
    2cdc:	0d 92       	st	X+, r0
    2cde:	8a 95       	dec	r24
    2ce0:	e1 f7       	brne	.-8      	; 0x2cda <DriverVL53L0XInit+0x46c>
	
	res=TWIMWrite(VL53L0X_ADDR,Buffer,count+1);
    2ce2:	47 e0       	ldi	r20, 0x07	; 7
    2ce4:	be 01       	movw	r22, r28
    2ce6:	6f 5f       	subi	r22, 0xFF	; 255
    2ce8:	7f 4f       	sbci	r23, 0xFF	; 255
    2cea:	89 e2       	ldi	r24, 0x29	; 41
    2cec:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2cf0:	1f ef       	ldi	r17, 0xFF	; 255
    2cf2:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2cf4:	ff 24       	eor	r15, r15
    2cf6:	f3 94       	inc	r15
    2cf8:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2cfa:	42 e0       	ldi	r20, 0x02	; 2
    2cfc:	be 01       	movw	r22, r28
    2cfe:	6f 5f       	subi	r22, 0xFF	; 255
    2d00:	7f 4f       	sbci	r23, 0xFF	; 255
    2d02:	89 e2       	ldi	r24, 0x29	; 41
    2d04:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d08:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    2d0a:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d0c:	42 e0       	ldi	r20, 0x02	; 2
    2d0e:	be 01       	movw	r22, r28
    2d10:	6f 5f       	subi	r22, 0xFF	; 255
    2d12:	7f 4f       	sbci	r23, 0xFF	; 255
    2d14:	89 e2       	ldi	r24, 0x29	; 41
    2d16:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d1a:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2d1c:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d1e:	42 e0       	ldi	r20, 0x02	; 2
    2d20:	be 01       	movw	r22, r28
    2d22:	6f 5f       	subi	r22, 0xFF	; 255
    2d24:	7f 4f       	sbci	r23, 0xFF	; 255
    2d26:	89 e2       	ldi	r24, 0x29	; 41
    2d28:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d2c:	39 e0       	ldi	r19, 0x09	; 9
    2d2e:	b3 2e       	mov	r11, r19
    2d30:	b9 82       	std	Y+1, r11	; 0x01
	Buffer[1]=value;
    2d32:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d34:	42 e0       	ldi	r20, 0x02	; 2
    2d36:	be 01       	movw	r22, r28
    2d38:	6f 5f       	subi	r22, 0xFF	; 255
    2d3a:	7f 4f       	sbci	r23, 0xFF	; 255
    2d3c:	89 e2       	ldi	r24, 0x29	; 41
    2d3e:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d42:	80 e1       	ldi	r24, 0x10	; 16
    2d44:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2d46:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d48:	42 e0       	ldi	r20, 0x02	; 2
    2d4a:	be 01       	movw	r22, r28
    2d4c:	6f 5f       	subi	r22, 0xFF	; 255
    2d4e:	7f 4f       	sbci	r23, 0xFF	; 255
    2d50:	89 e2       	ldi	r24, 0x29	; 41
    2d52:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d56:	81 e1       	ldi	r24, 0x11	; 17
    2d58:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2d5a:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d5c:	42 e0       	ldi	r20, 0x02	; 2
    2d5e:	be 01       	movw	r22, r28
    2d60:	6f 5f       	subi	r22, 0xFF	; 255
    2d62:	7f 4f       	sbci	r23, 0xFF	; 255
    2d64:	89 e2       	ldi	r24, 0x29	; 41
    2d66:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d6a:	84 e2       	ldi	r24, 0x24	; 36
    2d6c:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2d6e:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d70:	42 e0       	ldi	r20, 0x02	; 2
    2d72:	be 01       	movw	r22, r28
    2d74:	6f 5f       	subi	r22, 0xFF	; 255
    2d76:	7f 4f       	sbci	r23, 0xFF	; 255
    2d78:	89 e2       	ldi	r24, 0x29	; 41
    2d7a:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d7e:	45 e2       	ldi	r20, 0x25	; 37
    2d80:	94 2e       	mov	r9, r20
    2d82:	99 82       	std	Y+1, r9	; 0x01
	Buffer[1]=value;
    2d84:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d86:	42 e0       	ldi	r20, 0x02	; 2
    2d88:	be 01       	movw	r22, r28
    2d8a:	6f 5f       	subi	r22, 0xFF	; 255
    2d8c:	7f 4f       	sbci	r23, 0xFF	; 255
    2d8e:	89 e2       	ldi	r24, 0x29	; 41
    2d90:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2d94:	85 e7       	ldi	r24, 0x75	; 117
    2d96:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2d98:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2d9a:	42 e0       	ldi	r20, 0x02	; 2
    2d9c:	be 01       	movw	r22, r28
    2d9e:	6f 5f       	subi	r22, 0xFF	; 255
    2da0:	7f 4f       	sbci	r23, 0xFF	; 255
    2da2:	89 e2       	ldi	r24, 0x29	; 41
    2da4:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2da8:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2daa:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2dac:	42 e0       	ldi	r20, 0x02	; 2
    2dae:	be 01       	movw	r22, r28
    2db0:	6f 5f       	subi	r22, 0xFF	; 255
    2db2:	7f 4f       	sbci	r23, 0xFF	; 255
    2db4:	89 e2       	ldi	r24, 0x29	; 41
    2db6:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2dba:	8e e4       	ldi	r24, 0x4E	; 78
    2dbc:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2dbe:	8c e2       	ldi	r24, 0x2C	; 44
    2dc0:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2dc2:	42 e0       	ldi	r20, 0x02	; 2
    2dc4:	be 01       	movw	r22, r28
    2dc6:	6f 5f       	subi	r22, 0xFF	; 255
    2dc8:	7f 4f       	sbci	r23, 0xFF	; 255
    2dca:	89 e2       	ldi	r24, 0x29	; 41
    2dcc:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2dd0:	58 e4       	ldi	r21, 0x48	; 72
    2dd2:	a5 2e       	mov	r10, r21
    2dd4:	a9 82       	std	Y+1, r10	; 0x01
	Buffer[1]=value;
    2dd6:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2dd8:	42 e0       	ldi	r20, 0x02	; 2
    2dda:	be 01       	movw	r22, r28
    2ddc:	6f 5f       	subi	r22, 0xFF	; 255
    2dde:	7f 4f       	sbci	r23, 0xFF	; 255
    2de0:	89 e2       	ldi	r24, 0x29	; 41
    2de2:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2de6:	09 83       	std	Y+1, r16	; 0x01
	Buffer[1]=value;
    2de8:	60 e2       	ldi	r22, 0x20	; 32
    2dea:	d6 2e       	mov	r13, r22
    2dec:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2dee:	42 e0       	ldi	r20, 0x02	; 2
    2df0:	be 01       	movw	r22, r28
    2df2:	6f 5f       	subi	r22, 0xFF	; 255
    2df4:	7f 4f       	sbci	r23, 0xFF	; 255
    2df6:	89 e2       	ldi	r24, 0x29	; 41
    2df8:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2dfc:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2dfe:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2e00:	42 e0       	ldi	r20, 0x02	; 2
    2e02:	be 01       	movw	r22, r28
    2e04:	6f 5f       	subi	r22, 0xFF	; 255
    2e06:	7f 4f       	sbci	r23, 0xFF	; 255
    2e08:	89 e2       	ldi	r24, 0x29	; 41
    2e0a:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2e0e:	09 83       	std	Y+1, r16	; 0x01
	Buffer[1]=value;
    2e10:	ba 82       	std	Y+2, r11	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2e12:	42 e0       	ldi	r20, 0x02	; 2
    2e14:	be 01       	movw	r22, r28
    2e16:	6f 5f       	subi	r22, 0xFF	; 255
    2e18:	7f 4f       	sbci	r23, 0xFF	; 255
    2e1a:	89 e2       	ldi	r24, 0x29	; 41
    2e1c:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2e20:	84 e5       	ldi	r24, 0x54	; 84
    2e22:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2e24:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2e26:	42 e0       	ldi	r20, 0x02	; 2
    2e28:	be 01       	movw	r22, r28
    2e2a:	6f 5f       	subi	r22, 0xFF	; 255
    2e2c:	7f 4f       	sbci	r23, 0xFF	; 255
    2e2e:	89 e2       	ldi	r24, 0x29	; 41
    2e30:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2e34:	71 e3       	ldi	r23, 0x31	; 49
    2e36:	57 2e       	mov	r5, r23
    2e38:	59 82       	std	Y+1, r5	; 0x01
	Buffer[1]=value;
    2e3a:	b4 e0       	ldi	r27, 0x04	; 4
    2e3c:	ba 83       	std	Y+2, r27	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2e3e:	42 e0       	ldi	r20, 0x02	; 2
    2e40:	be 01       	movw	r22, r28
    2e42:	6f 5f       	subi	r22, 0xFF	; 255
    2e44:	7f 4f       	sbci	r23, 0xFF	; 255
    2e46:	89 e2       	ldi	r24, 0x29	; 41
    2e48:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2e4c:	e2 e3       	ldi	r30, 0x32	; 50
    2e4e:	8e 2e       	mov	r8, r30
    2e50:	89 82       	std	Y+1, r8	; 0x01
	Buffer[1]=value;
    2e52:	f3 e0       	ldi	r31, 0x03	; 3
    2e54:	4f 2e       	mov	r4, r31
    2e56:	4a 82       	std	Y+2, r4	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2e58:	42 e0       	ldi	r20, 0x02	; 2
    2e5a:	be 01       	movw	r22, r28
    2e5c:	6f 5f       	subi	r22, 0xFF	; 255
    2e5e:	7f 4f       	sbci	r23, 0xFF	; 255
    2e60:	89 e2       	ldi	r24, 0x29	; 41
    2e62:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2e66:	a0 e4       	ldi	r26, 0x40	; 64
    2e68:	ea 2e       	mov	r14, r26
    2e6a:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    2e6c:	83 e8       	ldi	r24, 0x83	; 131
    2e6e:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2e70:	42 e0       	ldi	r20, 0x02	; 2
    2e72:	be 01       	movw	r22, r28
    2e74:	6f 5f       	subi	r22, 0xFF	; 255
    2e76:	7f 4f       	sbci	r23, 0xFF	; 255
    2e78:	89 e2       	ldi	r24, 0x29	; 41
    2e7a:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2e7e:	b6 e4       	ldi	r27, 0x46	; 70
    2e80:	6b 2e       	mov	r6, r27
    2e82:	69 82       	std	Y+1, r6	; 0x01
	Buffer[1]=value;
    2e84:	9a 82       	std	Y+2, r9	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2e86:	42 e0       	ldi	r20, 0x02	; 2
    2e88:	be 01       	movw	r22, r28
    2e8a:	6f 5f       	subi	r22, 0xFF	; 255
    2e8c:	7f 4f       	sbci	r23, 0xFF	; 255
    2e8e:	89 e2       	ldi	r24, 0x29	; 41
    2e90:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2e94:	80 e6       	ldi	r24, 0x60	; 96
    2e96:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2e98:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2e9a:	42 e0       	ldi	r20, 0x02	; 2
    2e9c:	be 01       	movw	r22, r28
    2e9e:	6f 5f       	subi	r22, 0xFF	; 255
    2ea0:	7f 4f       	sbci	r23, 0xFF	; 255
    2ea2:	89 e2       	ldi	r24, 0x29	; 41
    2ea4:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2ea8:	87 e2       	ldi	r24, 0x27	; 39
    2eaa:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2eac:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2eae:	42 e0       	ldi	r20, 0x02	; 2
    2eb0:	be 01       	movw	r22, r28
    2eb2:	6f 5f       	subi	r22, 0xFF	; 255
    2eb4:	7f 4f       	sbci	r23, 0xFF	; 255
    2eb6:	89 e2       	ldi	r24, 0x29	; 41
    2eb8:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2ebc:	80 e5       	ldi	r24, 0x50	; 80
    2ebe:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2ec0:	86 e0       	ldi	r24, 0x06	; 6
    2ec2:	28 2e       	mov	r2, r24
    2ec4:	2a 82       	std	Y+2, r2	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2ec6:	42 e0       	ldi	r20, 0x02	; 2
    2ec8:	be 01       	movw	r22, r28
    2eca:	6f 5f       	subi	r22, 0xFF	; 255
    2ecc:	7f 4f       	sbci	r23, 0xFF	; 255
    2ece:	89 e2       	ldi	r24, 0x29	; 41
    2ed0:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2ed4:	81 e5       	ldi	r24, 0x51	; 81
    2ed6:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2ed8:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2eda:	42 e0       	ldi	r20, 0x02	; 2
    2edc:	be 01       	movw	r22, r28
    2ede:	6f 5f       	subi	r22, 0xFF	; 255
    2ee0:	7f 4f       	sbci	r23, 0xFF	; 255
    2ee2:	89 e2       	ldi	r24, 0x29	; 41
    2ee4:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2ee8:	82 e5       	ldi	r24, 0x52	; 82
    2eea:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2eec:	86 e9       	ldi	r24, 0x96	; 150
    2eee:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2ef0:	42 e0       	ldi	r20, 0x02	; 2
    2ef2:	be 01       	movw	r22, r28
    2ef4:	6f 5f       	subi	r22, 0xFF	; 255
    2ef6:	7f 4f       	sbci	r23, 0xFF	; 255
    2ef8:	89 e2       	ldi	r24, 0x29	; 41
    2efa:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2efe:	86 e5       	ldi	r24, 0x56	; 86
    2f00:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2f02:	98 e0       	ldi	r25, 0x08	; 8
    2f04:	99 2e       	mov	r9, r25
    2f06:	9a 82       	std	Y+2, r9	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f08:	42 e0       	ldi	r20, 0x02	; 2
    2f0a:	be 01       	movw	r22, r28
    2f0c:	6f 5f       	subi	r22, 0xFF	; 255
    2f0e:	7f 4f       	sbci	r23, 0xFF	; 255
    2f10:	89 e2       	ldi	r24, 0x29	; 41
    2f12:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f16:	87 e5       	ldi	r24, 0x57	; 87
    2f18:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2f1a:	0a 83       	std	Y+2, r16	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f1c:	42 e0       	ldi	r20, 0x02	; 2
    2f1e:	be 01       	movw	r22, r28
    2f20:	6f 5f       	subi	r22, 0xFF	; 255
    2f22:	7f 4f       	sbci	r23, 0xFF	; 255
    2f24:	89 e2       	ldi	r24, 0x29	; 41
    2f26:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f2a:	81 e6       	ldi	r24, 0x61	; 97
    2f2c:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2f2e:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f30:	42 e0       	ldi	r20, 0x02	; 2
    2f32:	be 01       	movw	r22, r28
    2f34:	6f 5f       	subi	r22, 0xFF	; 255
    2f36:	7f 4f       	sbci	r23, 0xFF	; 255
    2f38:	89 e2       	ldi	r24, 0x29	; 41
    2f3a:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f3e:	82 e6       	ldi	r24, 0x62	; 98
    2f40:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2f42:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f44:	42 e0       	ldi	r20, 0x02	; 2
    2f46:	be 01       	movw	r22, r28
    2f48:	6f 5f       	subi	r22, 0xFF	; 255
    2f4a:	7f 4f       	sbci	r23, 0xFF	; 255
    2f4c:	89 e2       	ldi	r24, 0x29	; 41
    2f4e:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f52:	84 e6       	ldi	r24, 0x64	; 100
    2f54:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2f56:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f58:	42 e0       	ldi	r20, 0x02	; 2
    2f5a:	be 01       	movw	r22, r28
    2f5c:	6f 5f       	subi	r22, 0xFF	; 255
    2f5e:	7f 4f       	sbci	r23, 0xFF	; 255
    2f60:	89 e2       	ldi	r24, 0x29	; 41
    2f62:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f66:	85 e6       	ldi	r24, 0x65	; 101
    2f68:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2f6a:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f6c:	42 e0       	ldi	r20, 0x02	; 2
    2f6e:	be 01       	movw	r22, r28
    2f70:	6f 5f       	subi	r22, 0xFF	; 255
    2f72:	7f 4f       	sbci	r23, 0xFF	; 255
    2f74:	89 e2       	ldi	r24, 0x29	; 41
    2f76:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f7a:	86 e6       	ldi	r24, 0x66	; 102
    2f7c:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2f7e:	80 ea       	ldi	r24, 0xA0	; 160
    2f80:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f82:	42 e0       	ldi	r20, 0x02	; 2
    2f84:	be 01       	movw	r22, r28
    2f86:	6f 5f       	subi	r22, 0xFF	; 255
    2f88:	7f 4f       	sbci	r23, 0xFF	; 255
    2f8a:	89 e2       	ldi	r24, 0x29	; 41
    2f8c:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2f90:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2f92:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2f94:	42 e0       	ldi	r20, 0x02	; 2
    2f96:	be 01       	movw	r22, r28
    2f98:	6f 5f       	subi	r22, 0xFF	; 255
    2f9a:	7f 4f       	sbci	r23, 0xFF	; 255
    2f9c:	89 e2       	ldi	r24, 0x29	; 41
    2f9e:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2fa2:	82 e2       	ldi	r24, 0x22	; 34
    2fa4:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2fa6:	8a 82       	std	Y+2, r8	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2fa8:	42 e0       	ldi	r20, 0x02	; 2
    2faa:	be 01       	movw	r22, r28
    2fac:	6f 5f       	subi	r22, 0xFF	; 255
    2fae:	7f 4f       	sbci	r23, 0xFF	; 255
    2fb0:	89 e2       	ldi	r24, 0x29	; 41
    2fb2:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2fb6:	27 e4       	ldi	r18, 0x47	; 71
    2fb8:	82 2e       	mov	r8, r18
    2fba:	89 82       	std	Y+1, r8	; 0x01
	Buffer[1]=value;
    2fbc:	84 e1       	ldi	r24, 0x14	; 20
    2fbe:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2fc0:	42 e0       	ldi	r20, 0x02	; 2
    2fc2:	be 01       	movw	r22, r28
    2fc4:	6f 5f       	subi	r22, 0xFF	; 255
    2fc6:	7f 4f       	sbci	r23, 0xFF	; 255
    2fc8:	89 e2       	ldi	r24, 0x29	; 41
    2fca:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2fce:	89 e4       	ldi	r24, 0x49	; 73
    2fd0:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2fd2:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2fd4:	42 e0       	ldi	r20, 0x02	; 2
    2fd6:	be 01       	movw	r22, r28
    2fd8:	6f 5f       	subi	r22, 0xFF	; 255
    2fda:	7f 4f       	sbci	r23, 0xFF	; 255
    2fdc:	89 e2       	ldi	r24, 0x29	; 41
    2fde:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2fe2:	8a e4       	ldi	r24, 0x4A	; 74
    2fe4:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    2fe6:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2fe8:	42 e0       	ldi	r20, 0x02	; 2
    2fea:	be 01       	movw	r22, r28
    2fec:	6f 5f       	subi	r22, 0xFF	; 255
    2fee:	7f 4f       	sbci	r23, 0xFF	; 255
    2ff0:	89 e2       	ldi	r24, 0x29	; 41
    2ff2:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    2ff6:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    2ff8:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    2ffa:	42 e0       	ldi	r20, 0x02	; 2
    2ffc:	be 01       	movw	r22, r28
    2ffe:	6f 5f       	subi	r22, 0xFF	; 255
    3000:	7f 4f       	sbci	r23, 0xFF	; 255
    3002:	89 e2       	ldi	r24, 0x29	; 41
    3004:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3008:	8a e7       	ldi	r24, 0x7A	; 122
    300a:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    300c:	2a e0       	ldi	r18, 0x0A	; 10
    300e:	2a 83       	std	Y+2, r18	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3010:	42 e0       	ldi	r20, 0x02	; 2
    3012:	be 01       	movw	r22, r28
    3014:	6f 5f       	subi	r22, 0xFF	; 255
    3016:	7f 4f       	sbci	r23, 0xFF	; 255
    3018:	89 e2       	ldi	r24, 0x29	; 41
    301a:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    301e:	8b e7       	ldi	r24, 0x7B	; 123
    3020:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3022:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3024:	42 e0       	ldi	r20, 0x02	; 2
    3026:	be 01       	movw	r22, r28
    3028:	6f 5f       	subi	r22, 0xFF	; 255
    302a:	7f 4f       	sbci	r23, 0xFF	; 255
    302c:	89 e2       	ldi	r24, 0x29	; 41
    302e:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3032:	88 e7       	ldi	r24, 0x78	; 120
    3034:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3036:	81 e2       	ldi	r24, 0x21	; 33
    3038:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    303a:	42 e0       	ldi	r20, 0x02	; 2
    303c:	be 01       	movw	r22, r28
    303e:	6f 5f       	subi	r22, 0xFF	; 255
    3040:	7f 4f       	sbci	r23, 0xFF	; 255
    3042:	89 e2       	ldi	r24, 0x29	; 41
    3044:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3048:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    304a:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    304c:	42 e0       	ldi	r20, 0x02	; 2
    304e:	be 01       	movw	r22, r28
    3050:	6f 5f       	subi	r22, 0xFF	; 255
    3052:	7f 4f       	sbci	r23, 0xFF	; 255
    3054:	89 e2       	ldi	r24, 0x29	; 41
    3056:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    305a:	83 e2       	ldi	r24, 0x23	; 35
    305c:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    305e:	34 e3       	ldi	r19, 0x34	; 52
    3060:	33 2e       	mov	r3, r19
    3062:	3a 82       	std	Y+2, r3	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3064:	42 e0       	ldi	r20, 0x02	; 2
    3066:	be 01       	movw	r22, r28
    3068:	6f 5f       	subi	r22, 0xFF	; 255
    306a:	7f 4f       	sbci	r23, 0xFF	; 255
    306c:	89 e2       	ldi	r24, 0x29	; 41
    306e:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3072:	82 e4       	ldi	r24, 0x42	; 66
    3074:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3076:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3078:	42 e0       	ldi	r20, 0x02	; 2
    307a:	be 01       	movw	r22, r28
    307c:	6f 5f       	subi	r22, 0xFF	; 255
    307e:	7f 4f       	sbci	r23, 0xFF	; 255
    3080:	89 e2       	ldi	r24, 0x29	; 41
    3082:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3086:	44 e4       	ldi	r20, 0x44	; 68
    3088:	c4 2e       	mov	r12, r20
    308a:	c9 82       	std	Y+1, r12	; 0x01
	Buffer[1]=value;
    308c:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    308e:	42 e0       	ldi	r20, 0x02	; 2
    3090:	be 01       	movw	r22, r28
    3092:	6f 5f       	subi	r22, 0xFF	; 255
    3094:	7f 4f       	sbci	r23, 0xFF	; 255
    3096:	89 e2       	ldi	r24, 0x29	; 41
    3098:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    309c:	55 e4       	ldi	r21, 0x45	; 69
    309e:	75 2e       	mov	r7, r21
    30a0:	79 82       	std	Y+1, r7	; 0x01
	Buffer[1]=value;
    30a2:	86 e2       	ldi	r24, 0x26	; 38
    30a4:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    30a6:	42 e0       	ldi	r20, 0x02	; 2
    30a8:	be 01       	movw	r22, r28
    30aa:	6f 5f       	subi	r22, 0xFF	; 255
    30ac:	7f 4f       	sbci	r23, 0xFF	; 255
    30ae:	89 e2       	ldi	r24, 0x29	; 41
    30b0:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    30b4:	69 82       	std	Y+1, r6	; 0x01
	Buffer[1]=value;
    30b6:	65 e0       	ldi	r22, 0x05	; 5
    30b8:	66 2e       	mov	r6, r22
    30ba:	6a 82       	std	Y+2, r6	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    30bc:	42 e0       	ldi	r20, 0x02	; 2
    30be:	be 01       	movw	r22, r28
    30c0:	6f 5f       	subi	r22, 0xFF	; 255
    30c2:	7f 4f       	sbci	r23, 0xFF	; 255
    30c4:	89 e2       	ldi	r24, 0x29	; 41
    30c6:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    30ca:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    30cc:	ea 82       	std	Y+2, r14	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    30ce:	42 e0       	ldi	r20, 0x02	; 2
    30d0:	be 01       	movw	r22, r28
    30d2:	6f 5f       	subi	r22, 0xFF	; 255
    30d4:	7f 4f       	sbci	r23, 0xFF	; 255
    30d6:	89 e2       	ldi	r24, 0x29	; 41
    30d8:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    30dc:	8e e0       	ldi	r24, 0x0E	; 14
    30de:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    30e0:	2a 82       	std	Y+2, r2	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    30e2:	42 e0       	ldi	r20, 0x02	; 2
    30e4:	be 01       	movw	r22, r28
    30e6:	6f 5f       	subi	r22, 0xFF	; 255
    30e8:	7f 4f       	sbci	r23, 0xFF	; 255
    30ea:	89 e2       	ldi	r24, 0x29	; 41
    30ec:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    30f0:	d9 82       	std	Y+1, r13	; 0x01
	Buffer[1]=value;
    30f2:	8a e1       	ldi	r24, 0x1A	; 26
    30f4:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    30f6:	42 e0       	ldi	r20, 0x02	; 2
    30f8:	be 01       	movw	r22, r28
    30fa:	6f 5f       	subi	r22, 0xFF	; 255
    30fc:	7f 4f       	sbci	r23, 0xFF	; 255
    30fe:	89 e2       	ldi	r24, 0x29	; 41
    3100:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3104:	83 e4       	ldi	r24, 0x43	; 67
    3106:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3108:	ea 82       	std	Y+2, r14	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    310a:	42 e0       	ldi	r20, 0x02	; 2
    310c:	be 01       	movw	r22, r28
    310e:	6f 5f       	subi	r22, 0xFF	; 255
    3110:	7f 4f       	sbci	r23, 0xFF	; 255
    3112:	89 e2       	ldi	r24, 0x29	; 41
    3114:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3118:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    311a:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    311c:	42 e0       	ldi	r20, 0x02	; 2
    311e:	be 01       	movw	r22, r28
    3120:	6f 5f       	subi	r22, 0xFF	; 255
    3122:	7f 4f       	sbci	r23, 0xFF	; 255
    3124:	89 e2       	ldi	r24, 0x29	; 41
    3126:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    312a:	39 82       	std	Y+1, r3	; 0x01
	Buffer[1]=value;
    312c:	4a 82       	std	Y+2, r4	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    312e:	42 e0       	ldi	r20, 0x02	; 2
    3130:	be 01       	movw	r22, r28
    3132:	6f 5f       	subi	r22, 0xFF	; 255
    3134:	7f 4f       	sbci	r23, 0xFF	; 255
    3136:	89 e2       	ldi	r24, 0x29	; 41
    3138:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    313c:	85 e3       	ldi	r24, 0x35	; 53
    313e:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3140:	ca 82       	std	Y+2, r12	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3142:	42 e0       	ldi	r20, 0x02	; 2
    3144:	be 01       	movw	r22, r28
    3146:	6f 5f       	subi	r22, 0xFF	; 255
    3148:	7f 4f       	sbci	r23, 0xFF	; 255
    314a:	89 e2       	ldi	r24, 0x29	; 41
    314c:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3150:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    3152:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3154:	42 e0       	ldi	r20, 0x02	; 2
    3156:	be 01       	movw	r22, r28
    3158:	6f 5f       	subi	r22, 0xFF	; 255
    315a:	7f 4f       	sbci	r23, 0xFF	; 255
    315c:	89 e2       	ldi	r24, 0x29	; 41
    315e:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3162:	59 82       	std	Y+1, r5	; 0x01
	Buffer[1]=value;
    3164:	84 e0       	ldi	r24, 0x04	; 4
    3166:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3168:	42 e0       	ldi	r20, 0x02	; 2
    316a:	be 01       	movw	r22, r28
    316c:	6f 5f       	subi	r22, 0xFF	; 255
    316e:	7f 4f       	sbci	r23, 0xFF	; 255
    3170:	89 e2       	ldi	r24, 0x29	; 41
    3172:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3176:	8b e4       	ldi	r24, 0x4B	; 75
    3178:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    317a:	ba 82       	std	Y+2, r11	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    317c:	42 e0       	ldi	r20, 0x02	; 2
    317e:	be 01       	movw	r22, r28
    3180:	6f 5f       	subi	r22, 0xFF	; 255
    3182:	7f 4f       	sbci	r23, 0xFF	; 255
    3184:	89 e2       	ldi	r24, 0x29	; 41
    3186:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    318a:	8c e4       	ldi	r24, 0x4C	; 76
    318c:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    318e:	6a 82       	std	Y+2, r6	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3190:	42 e0       	ldi	r20, 0x02	; 2
    3192:	be 01       	movw	r22, r28
    3194:	6f 5f       	subi	r22, 0xFF	; 255
    3196:	7f 4f       	sbci	r23, 0xFF	; 255
    3198:	89 e2       	ldi	r24, 0x29	; 41
    319a:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    319e:	8d e4       	ldi	r24, 0x4D	; 77
    31a0:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    31a2:	a4 e0       	ldi	r26, 0x04	; 4
    31a4:	aa 83       	std	Y+2, r26	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    31a6:	42 e0       	ldi	r20, 0x02	; 2
    31a8:	be 01       	movw	r22, r28
    31aa:	6f 5f       	subi	r22, 0xFF	; 255
    31ac:	7f 4f       	sbci	r23, 0xFF	; 255
    31ae:	89 e2       	ldi	r24, 0x29	; 41
    31b0:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    31b4:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    31b6:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    31b8:	42 e0       	ldi	r20, 0x02	; 2
    31ba:	be 01       	movw	r22, r28
    31bc:	6f 5f       	subi	r22, 0xFF	; 255
    31be:	7f 4f       	sbci	r23, 0xFF	; 255
    31c0:	89 e2       	ldi	r24, 0x29	; 41
    31c2:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    31c6:	c9 82       	std	Y+1, r12	; 0x01
	Buffer[1]=value;
    31c8:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    31ca:	42 e0       	ldi	r20, 0x02	; 2
    31cc:	be 01       	movw	r22, r28
    31ce:	6f 5f       	subi	r22, 0xFF	; 255
    31d0:	7f 4f       	sbci	r23, 0xFF	; 255
    31d2:	89 e2       	ldi	r24, 0x29	; 41
    31d4:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    31d8:	79 82       	std	Y+1, r7	; 0x01
	Buffer[1]=value;
    31da:	da 82       	std	Y+2, r13	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    31dc:	42 e0       	ldi	r20, 0x02	; 2
    31de:	be 01       	movw	r22, r28
    31e0:	6f 5f       	subi	r22, 0xFF	; 255
    31e2:	7f 4f       	sbci	r23, 0xFF	; 255
    31e4:	89 e2       	ldi	r24, 0x29	; 41
    31e6:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    31ea:	89 82       	std	Y+1, r8	; 0x01
	Buffer[1]=value;
    31ec:	9a 82       	std	Y+2, r9	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    31ee:	42 e0       	ldi	r20, 0x02	; 2
    31f0:	be 01       	movw	r22, r28
    31f2:	6f 5f       	subi	r22, 0xFF	; 255
    31f4:	7f 4f       	sbci	r23, 0xFF	; 255
    31f6:	89 e2       	ldi	r24, 0x29	; 41
    31f8:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    31fc:	a9 82       	std	Y+1, r10	; 0x01
	Buffer[1]=value;
    31fe:	88 e2       	ldi	r24, 0x28	; 40
    3200:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3202:	42 e0       	ldi	r20, 0x02	; 2
    3204:	be 01       	movw	r22, r28
    3206:	6f 5f       	subi	r22, 0xFF	; 255
    3208:	7f 4f       	sbci	r23, 0xFF	; 255
    320a:	89 e2       	ldi	r24, 0x29	; 41
    320c:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3210:	87 e6       	ldi	r24, 0x67	; 103
    3212:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3214:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3216:	42 e0       	ldi	r20, 0x02	; 2
    3218:	be 01       	movw	r22, r28
    321a:	6f 5f       	subi	r22, 0xFF	; 255
    321c:	7f 4f       	sbci	r23, 0xFF	; 255
    321e:	89 e2       	ldi	r24, 0x29	; 41
    3220:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3224:	80 e7       	ldi	r24, 0x70	; 112
    3226:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3228:	b4 e0       	ldi	r27, 0x04	; 4
    322a:	ba 83       	std	Y+2, r27	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    322c:	42 e0       	ldi	r20, 0x02	; 2
    322e:	be 01       	movw	r22, r28
    3230:	6f 5f       	subi	r22, 0xFF	; 255
    3232:	7f 4f       	sbci	r23, 0xFF	; 255
    3234:	89 e2       	ldi	r24, 0x29	; 41
    3236:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    323a:	81 e7       	ldi	r24, 0x71	; 113
    323c:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    323e:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3240:	42 e0       	ldi	r20, 0x02	; 2
    3242:	be 01       	movw	r22, r28
    3244:	6f 5f       	subi	r22, 0xFF	; 255
    3246:	7f 4f       	sbci	r23, 0xFF	; 255
    3248:	89 e2       	ldi	r24, 0x29	; 41
    324a:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    324e:	82 e7       	ldi	r24, 0x72	; 114
    3250:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3252:	8e ef       	ldi	r24, 0xFE	; 254
    3254:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3256:	42 e0       	ldi	r20, 0x02	; 2
    3258:	be 01       	movw	r22, r28
    325a:	6f 5f       	subi	r22, 0xFF	; 255
    325c:	7f 4f       	sbci	r23, 0xFF	; 255
    325e:	89 e2       	ldi	r24, 0x29	; 41
    3260:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3264:	86 e7       	ldi	r24, 0x76	; 118
    3266:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3268:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    326a:	42 e0       	ldi	r20, 0x02	; 2
    326c:	be 01       	movw	r22, r28
    326e:	6f 5f       	subi	r22, 0xFF	; 255
    3270:	7f 4f       	sbci	r23, 0xFF	; 255
    3272:	89 e2       	ldi	r24, 0x29	; 41
    3274:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3278:	87 e7       	ldi	r24, 0x77	; 119
    327a:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    327c:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    327e:	42 e0       	ldi	r20, 0x02	; 2
    3280:	be 01       	movw	r22, r28
    3282:	6f 5f       	subi	r22, 0xFF	; 255
    3284:	7f 4f       	sbci	r23, 0xFF	; 255
    3286:	89 e2       	ldi	r24, 0x29	; 41
    3288:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    328c:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    328e:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3290:	42 e0       	ldi	r20, 0x02	; 2
    3292:	be 01       	movw	r22, r28
    3294:	6f 5f       	subi	r22, 0xFF	; 255
    3296:	7f 4f       	sbci	r23, 0xFF	; 255
    3298:	89 e2       	ldi	r24, 0x29	; 41
    329a:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    329e:	8d e0       	ldi	r24, 0x0D	; 13
    32a0:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    32a2:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    32a4:	42 e0       	ldi	r20, 0x02	; 2
    32a6:	be 01       	movw	r22, r28
    32a8:	6f 5f       	subi	r22, 0xFF	; 255
    32aa:	7f 4f       	sbci	r23, 0xFF	; 255
    32ac:	89 e2       	ldi	r24, 0x29	; 41
    32ae:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    32b2:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    32b4:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    32b6:	42 e0       	ldi	r20, 0x02	; 2
    32b8:	be 01       	movw	r22, r28
    32ba:	6f 5f       	subi	r22, 0xFF	; 255
    32bc:	7f 4f       	sbci	r23, 0xFF	; 255
    32be:	89 e2       	ldi	r24, 0x29	; 41
    32c0:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    32c4:	70 e8       	ldi	r23, 0x80	; 128
    32c6:	e7 2e       	mov	r14, r23
    32c8:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    32ca:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    32cc:	42 e0       	ldi	r20, 0x02	; 2
    32ce:	be 01       	movw	r22, r28
    32d0:	6f 5f       	subi	r22, 0xFF	; 255
    32d2:	7f 4f       	sbci	r23, 0xFF	; 255
    32d4:	89 e2       	ldi	r24, 0x29	; 41
    32d6:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    32da:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    32dc:	88 ef       	ldi	r24, 0xF8	; 248
    32de:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    32e0:	42 e0       	ldi	r20, 0x02	; 2
    32e2:	be 01       	movw	r22, r28
    32e4:	6f 5f       	subi	r22, 0xFF	; 255
    32e6:	7f 4f       	sbci	r23, 0xFF	; 255
    32e8:	89 e2       	ldi	r24, 0x29	; 41
    32ea:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    32ee:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    32f0:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    32f2:	42 e0       	ldi	r20, 0x02	; 2
    32f4:	be 01       	movw	r22, r28
    32f6:	6f 5f       	subi	r22, 0xFF	; 255
    32f8:	7f 4f       	sbci	r23, 0xFF	; 255
    32fa:	89 e2       	ldi	r24, 0x29	; 41
    32fc:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3300:	8e e8       	ldi	r24, 0x8E	; 142
    3302:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3304:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3306:	42 e0       	ldi	r20, 0x02	; 2
    3308:	be 01       	movw	r22, r28
    330a:	6f 5f       	subi	r22, 0xFF	; 255
    330c:	7f 4f       	sbci	r23, 0xFF	; 255
    330e:	89 e2       	ldi	r24, 0x29	; 41
    3310:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3314:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    3316:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3318:	42 e0       	ldi	r20, 0x02	; 2
    331a:	be 01       	movw	r22, r28
    331c:	6f 5f       	subi	r22, 0xFF	; 255
    331e:	7f 4f       	sbci	r23, 0xFF	; 255
    3320:	89 e2       	ldi	r24, 0x29	; 41
    3322:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3326:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    3328:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    332a:	42 e0       	ldi	r20, 0x02	; 2
    332c:	be 01       	movw	r22, r28
    332e:	6f 5f       	subi	r22, 0xFF	; 255
    3330:	7f 4f       	sbci	r23, 0xFF	; 255
    3332:	89 e2       	ldi	r24, 0x29	; 41
    3334:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3338:	e9 82       	std	Y+1, r14	; 0x01
	Buffer[1]=value;
    333a:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    333c:	42 e0       	ldi	r20, 0x02	; 2
    333e:	be 01       	movw	r22, r28
    3340:	6f 5f       	subi	r22, 0xFF	; 255
    3342:	7f 4f       	sbci	r23, 0xFF	; 255
    3344:	89 e2       	ldi	r24, 0x29	; 41
    3346:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    334a:	2a e0       	ldi	r18, 0x0A	; 10
    334c:	29 83       	std	Y+1, r18	; 0x01
	Buffer[1]=value;
    334e:	84 e0       	ldi	r24, 0x04	; 4
    3350:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3352:	42 e0       	ldi	r20, 0x02	; 2
    3354:	be 01       	movw	r22, r28
    3356:	6f 5f       	subi	r22, 0xFF	; 255
    3358:	7f 4f       	sbci	r23, 0xFF	; 255
    335a:	89 e2       	ldi	r24, 0x29	; 41
    335c:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    3360:	14 e8       	ldi	r17, 0x84	; 132
    3362:	19 83       	std	Y+1, r17	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    3364:	01 e0       	ldi	r16, 0x01	; 1
    3366:	9e 01       	movw	r18, r28
    3368:	2f 5f       	subi	r18, 0xFF	; 255
    336a:	3f 4f       	sbci	r19, 0xFF	; 255
    336c:	41 e0       	ldi	r20, 0x01	; 1
    336e:	b9 01       	movw	r22, r18
    3370:	89 e2       	ldi	r24, 0x29	; 41
    3372:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    3376:	89 81       	ldd	r24, Y+1	; 0x01
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3378:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    337a:	8f 7e       	andi	r24, 0xEF	; 239
    337c:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    337e:	42 e0       	ldi	r20, 0x02	; 2
    3380:	be 01       	movw	r22, r28
    3382:	6f 5f       	subi	r22, 0xFF	; 255
    3384:	7f 4f       	sbci	r23, 0xFF	; 255
    3386:	89 e2       	ldi	r24, 0x29	; 41
    3388:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    338c:	8b e0       	ldi	r24, 0x0B	; 11
    338e:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3390:	fa 82       	std	Y+2, r15	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3392:	42 e0       	ldi	r20, 0x02	; 2
    3394:	be 01       	movw	r22, r28
    3396:	6f 5f       	subi	r22, 0xFF	; 255
    3398:	7f 4f       	sbci	r23, 0xFF	; 255
    339a:	89 e2       	ldi	r24, 0x29	; 41
    339c:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
	uint16_t const PreRangeOverhead   = 660;
	uint16_t const FinalRangeOverhead = 550;

	// "Start and end overhead times always present"
	uint32_t budget_us = StartOverhead + EndOverhead;
	getSequenceStepEnables (&enables);
    33a0:	ce 01       	movw	r24, r28
    33a2:	4d 96       	adiw	r24, 0x1d	; 29
    33a4:	0e 94 84 11 	call	0x2308	; 0x2308 <getSequenceStepEnables>
	getSequenceStepTimeouts(&enables, &timeouts);
    33a8:	be 01       	movw	r22, r28
    33aa:	6f 5f       	subi	r22, 0xFF	; 255
    33ac:	7f 4f       	sbci	r23, 0xFF	; 255
    33ae:	ce 01       	movw	r24, r28
    33b0:	80 96       	adiw	r24, 0x20	; 32
    33b2:	0e 94 39 12 	call	0x2472	; 0x2472 <getSequenceStepTimeouts.isra.1>

	if (enables.tcc)
    33b6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    33b8:	88 23       	and	r24, r24
    33ba:	09 f4       	brne	.+2      	; 0x33be <DriverVL53L0XInit+0xb50>
    33bc:	86 c0       	rjmp	.+268    	; 0x34ca <DriverVL53L0XInit+0xc5c>
	{
		budget_us += (timeouts.msrc_dss_tcc_us + TccOverhead);
    33be:	8b 85       	ldd	r24, Y+11	; 0x0b
    33c0:	9c 85       	ldd	r25, Y+12	; 0x0c
    33c2:	ad 85       	ldd	r26, Y+13	; 0x0d
    33c4:	be 85       	ldd	r27, Y+14	; 0x0e
    33c6:	8c 57       	subi	r24, 0x7C	; 124
    33c8:	92 4f       	sbci	r25, 0xF2	; 242
    33ca:	af 4f       	sbci	r26, 0xFF	; 255
    33cc:	bf 4f       	sbci	r27, 0xFF	; 255
	}

	if (enables.dss)
    33ce:	2f 8d       	ldd	r18, Y+31	; 0x1f
    33d0:	22 23       	and	r18, r18
    33d2:	09 f4       	brne	.+2      	; 0x33d6 <DriverVL53L0XInit+0xb68>
    33d4:	69 c0       	rjmp	.+210    	; 0x34a8 <DriverVL53L0XInit+0xc3a>
	{
		budget_us += 2 * (timeouts.msrc_dss_tcc_us + DssOverhead);
    33d6:	4b 85       	ldd	r20, Y+11	; 0x0b
    33d8:	5c 85       	ldd	r21, Y+12	; 0x0c
    33da:	6d 85       	ldd	r22, Y+13	; 0x0d
    33dc:	7e 85       	ldd	r23, Y+14	; 0x0e
    33de:	4e 54       	subi	r20, 0x4E	; 78
    33e0:	5d 4f       	sbci	r21, 0xFD	; 253
    33e2:	6f 4f       	sbci	r22, 0xFF	; 255
    33e4:	7f 4f       	sbci	r23, 0xFF	; 255
    33e6:	44 0f       	add	r20, r20
    33e8:	55 1f       	adc	r21, r21
    33ea:	66 1f       	adc	r22, r22
    33ec:	77 1f       	adc	r23, r23
    33ee:	84 0f       	add	r24, r20
    33f0:	95 1f       	adc	r25, r21
    33f2:	a6 1f       	adc	r26, r22
    33f4:	b7 1f       	adc	r27, r23
	else if (enables.msrc)
	{
		budget_us += (timeouts.msrc_dss_tcc_us + MsrcOverhead);
	}

	if (enables.pre_range)
    33f6:	28 a1       	ldd	r18, Y+32	; 0x20
    33f8:	22 23       	and	r18, r18
    33fa:	61 f0       	breq	.+24     	; 0x3414 <DriverVL53L0XInit+0xba6>
	{
		budget_us += (timeouts.pre_range_us + PreRangeOverhead);
    33fc:	4f 85       	ldd	r20, Y+15	; 0x0f
    33fe:	58 89       	ldd	r21, Y+16	; 0x10
    3400:	69 89       	ldd	r22, Y+17	; 0x11
    3402:	7a 89       	ldd	r23, Y+18	; 0x12
    3404:	4c 56       	subi	r20, 0x6C	; 108
    3406:	5d 4f       	sbci	r21, 0xFD	; 253
    3408:	6f 4f       	sbci	r22, 0xFF	; 255
    340a:	7f 4f       	sbci	r23, 0xFF	; 255
    340c:	84 0f       	add	r24, r20
    340e:	95 1f       	adc	r25, r21
    3410:	a6 1f       	adc	r26, r22
    3412:	b7 1f       	adc	r27, r23
	}

	if (enables.final_range)
    3414:	29 a1       	ldd	r18, Y+33	; 0x21
    3416:	22 23       	and	r18, r18
    3418:	61 f0       	breq	.+24     	; 0x3432 <DriverVL53L0XInit+0xbc4>
	{
		budget_us += (timeouts.final_range_us + FinalRangeOverhead);
    341a:	4b 89       	ldd	r20, Y+19	; 0x13
    341c:	5c 89       	ldd	r21, Y+20	; 0x14
    341e:	6d 89       	ldd	r22, Y+21	; 0x15
    3420:	7e 89       	ldd	r23, Y+22	; 0x16
    3422:	4a 5d       	subi	r20, 0xDA	; 218
    3424:	5d 4f       	sbci	r21, 0xFD	; 253
    3426:	6f 4f       	sbci	r22, 0xFF	; 255
    3428:	7f 4f       	sbci	r23, 0xFF	; 255
    342a:	84 0f       	add	r24, r20
    342c:	95 1f       	adc	r25, r21
    342e:	a6 1f       	adc	r26, r22
    3430:	b7 1f       	adc	r27, r23
	}

	measurement_timing_budget_us = budget_us; // store for internal reuse
    3432:	80 93 81 2d 	sts	0x2D81, r24	; 0x802d81 <measurement_timing_budget_us>
    3436:	90 93 82 2d 	sts	0x2D82, r25	; 0x802d82 <measurement_timing_budget_us+0x1>
    343a:	a0 93 83 2d 	sts	0x2D83, r26	; 0x802d83 <measurement_timing_budget_us+0x2>
    343e:	b0 93 84 2d 	sts	0x2D84, r27	; 0x802d84 <measurement_timing_budget_us+0x3>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3442:	81 e0       	ldi	r24, 0x01	; 1
    3444:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3446:	88 ee       	ldi	r24, 0xE8	; 232
    3448:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    344a:	42 e0       	ldi	r20, 0x02	; 2
    344c:	be 01       	movw	r22, r28
    344e:	6f 5f       	subi	r22, 0xFF	; 255
    3450:	7f 4f       	sbci	r23, 0xFF	; 255
    3452:	89 e2       	ldi	r24, 0x29	; 41
    3454:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
	writeReg(SYSTEM_SEQUENCE_CONFIG, 0xE8);

	// -- VL53L0X_SetSequenceStepEnable() end

	// "Recalculate timing budget"
	setMeasurementTimingBudget(measurement_timing_budget_us);
    3458:	60 91 81 2d 	lds	r22, 0x2D81	; 0x802d81 <measurement_timing_budget_us>
    345c:	70 91 82 2d 	lds	r23, 0x2D82	; 0x802d82 <measurement_timing_budget_us+0x1>
    3460:	80 91 83 2d 	lds	r24, 0x2D83	; 0x802d83 <measurement_timing_budget_us+0x2>
    3464:	90 91 84 2d 	lds	r25, 0x2D84	; 0x802d84 <measurement_timing_budget_us+0x3>
	uint16_t const PreRangeOverhead   = 660;
	uint16_t const FinalRangeOverhead = 550;

	uint32_t const MinTimingBudget = 20000;

	if (budget_us < MinTimingBudget) { return false; }
    3468:	60 32       	cpi	r22, 0x20	; 32
    346a:	ae e4       	ldi	r26, 0x4E	; 78
    346c:	7a 07       	cpc	r23, r26
    346e:	81 05       	cpc	r24, r1
    3470:	91 05       	cpc	r25, r1
    3472:	08 f0       	brcs	.+2      	; 0x3476 <DriverVL53L0XInit+0xc08>
    3474:	4a c0       	rjmp	.+148    	; 0x350a <DriverVL53L0XInit+0xc9c>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3476:	11 e0       	ldi	r17, 0x01	; 1
    3478:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    347a:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    347c:	42 e0       	ldi	r20, 0x02	; 2
    347e:	be 01       	movw	r22, r28
    3480:	6f 5f       	subi	r22, 0xFF	; 255
    3482:	7f 4f       	sbci	r23, 0xFF	; 255
    3484:	89 e2       	ldi	r24, 0x29	; 41
    3486:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
	// VL53L0X_PerformRefCalibration() begin (VL53L0X_perform_ref_calibration())

	// -- VL53L0X_perform_vhv_calibration() begin

	writeReg(SYSTEM_SEQUENCE_CONFIG, 0x01);
	if (!performSingleRefCalibration(0x40)) { return false; }
    348a:	80 e4       	ldi	r24, 0x40	; 64
    348c:	0e 94 b8 11 	call	0x2370	; 0x2370 <performSingleRefCalibration>
    3490:	81 11       	cpse	r24, r1
    3492:	20 c0       	rjmp	.+64     	; 0x34d4 <DriverVL53L0XInit+0xc66>
    3494:	80 e0       	ldi	r24, 0x00	; 0
    3496:	18 ca       	rjmp	.-3024   	; 0x28c8 <DriverVL53L0XInit+0x5a>
	//Check Model ID
	res=readReg(IDENTIFICATION_MODEL_ID,&Data);
	if (!res)
	{
		#ifdef VL53L0X_DEBUG
			printf ("VL53L0X:Cannot access.\r\n");
    3498:	88 e3       	ldi	r24, 0x38	; 56
    349a:	93 e2       	ldi	r25, 0x23	; 35
    349c:	0e 94 94 4d 	call	0x9b28	; 0x9b28 <puts>
		#endif
		return false;
    34a0:	80 e0       	ldi	r24, 0x00	; 0
    34a2:	12 ca       	rjmp	.-3036   	; 0x28c8 <DriverVL53L0XInit+0x5a>
	writeReg(DYNAMIC_SPAD_REF_EN_START_OFFSET, 0x00);
	writeReg(DYNAMIC_SPAD_NUM_REQUESTED_REF_SPAD, 0x2C);
	writeReg(0xFF, 0x00);
	writeReg(GLOBAL_CONFIG_REF_EN_START_SELECT, 0xB4);

	uint8_t first_spad_to_enable = spad_type_is_aperture ? 12 : 0; // 12 is the first aperture spad
    34a4:	4c e0       	ldi	r20, 0x0C	; 12
    34a6:	df cb       	rjmp	.-2114   	; 0x2c66 <DriverVL53L0XInit+0x3f8>

	if (enables.dss)
	{
		budget_us += 2 * (timeouts.msrc_dss_tcc_us + DssOverhead);
	}
	else if (enables.msrc)
    34a8:	2e 8d       	ldd	r18, Y+30	; 0x1e
    34aa:	22 23       	and	r18, r18
    34ac:	09 f4       	brne	.+2      	; 0x34b0 <DriverVL53L0XInit+0xc42>
    34ae:	a3 cf       	rjmp	.-186    	; 0x33f6 <DriverVL53L0XInit+0xb88>
	{
		budget_us += (timeouts.msrc_dss_tcc_us + MsrcOverhead);
    34b0:	4b 85       	ldd	r20, Y+11	; 0x0b
    34b2:	5c 85       	ldd	r21, Y+12	; 0x0c
    34b4:	6d 85       	ldd	r22, Y+13	; 0x0d
    34b6:	7e 85       	ldd	r23, Y+14	; 0x0e
    34b8:	4c 56       	subi	r20, 0x6C	; 108
    34ba:	5d 4f       	sbci	r21, 0xFD	; 253
    34bc:	6f 4f       	sbci	r22, 0xFF	; 255
    34be:	7f 4f       	sbci	r23, 0xFF	; 255
    34c0:	84 0f       	add	r24, r20
    34c2:	95 1f       	adc	r25, r21
    34c4:	a6 1f       	adc	r26, r22
    34c6:	b7 1f       	adc	r27, r23
    34c8:	96 cf       	rjmp	.-212    	; 0x33f6 <DriverVL53L0XInit+0xb88>
	uint16_t const DssOverhead        = 690;
	uint16_t const PreRangeOverhead   = 660;
	uint16_t const FinalRangeOverhead = 550;

	// "Start and end overhead times always present"
	uint32_t budget_us = StartOverhead + EndOverhead;
    34ca:	86 e3       	ldi	r24, 0x36	; 54
    34cc:	9b e0       	ldi	r25, 0x0B	; 11
    34ce:	a0 e0       	ldi	r26, 0x00	; 0
    34d0:	b0 e0       	ldi	r27, 0x00	; 0
    34d2:	7d cf       	rjmp	.-262    	; 0x33ce <DriverVL53L0XInit+0xb60>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    34d4:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    34d6:	82 e0       	ldi	r24, 0x02	; 2
    34d8:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    34da:	42 e0       	ldi	r20, 0x02	; 2
    34dc:	be 01       	movw	r22, r28
    34de:	6f 5f       	subi	r22, 0xFF	; 255
    34e0:	7f 4f       	sbci	r23, 0xFF	; 255
    34e2:	89 e2       	ldi	r24, 0x29	; 41
    34e4:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
	// -- VL53L0X_perform_vhv_calibration() end

	// -- VL53L0X_perform_phase_calibration() begin

	writeReg(SYSTEM_SEQUENCE_CONFIG, 0x02);
	if (!performSingleRefCalibration(0x00)) { return false; }
    34e8:	80 e0       	ldi	r24, 0x00	; 0
    34ea:	0e 94 b8 11 	call	0x2370	; 0x2370 <performSingleRefCalibration>
    34ee:	88 23       	and	r24, r24
    34f0:	89 f2       	breq	.-94     	; 0x3494 <DriverVL53L0XInit+0xc26>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    34f2:	19 83       	std	Y+1, r17	; 0x01
	Buffer[1]=value;
    34f4:	88 ee       	ldi	r24, 0xE8	; 232
    34f6:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    34f8:	42 e0       	ldi	r20, 0x02	; 2
    34fa:	be 01       	movw	r22, r28
    34fc:	6f 5f       	subi	r22, 0xFF	; 255
    34fe:	7f 4f       	sbci	r23, 0xFF	; 255
    3500:	89 e2       	ldi	r24, 0x29	; 41
    3502:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
	// "restore the previous Sequence Config"
	writeReg(SYSTEM_SEQUENCE_CONFIG, 0xE8);

	// VL53L0X_PerformRefCalibration() end

	return true;
    3506:	81 e0       	ldi	r24, 0x01	; 1
    3508:	df c9       	rjmp	.-3138   	; 0x28c8 <DriverVL53L0XInit+0x5a>
    350a:	0e 94 30 13 	call	0x2660	; 0x2660 <setMeasurementTimingBudget.part.4>
    350e:	b3 cf       	rjmp	.-154    	; 0x3476 <DriverVL53L0XInit+0xc08>

00003510 <DriverVL53L0XReadContinuous>:

// Returns a range reading in millimeters when continuous mode is active
// (readRangeSingleMillimeters() also calls this function after starting a
// single-shot range measurement)
uint16_t DriverVL53L0XReadContinuous()
{
    3510:	0f 93       	push	r16
    3512:	1f 93       	push	r17
    3514:	cf 93       	push	r28
    3516:	df 93       	push	r29
    3518:	00 d0       	rcall	.+0      	; 0x351a <DriverVL53L0XReadContinuous+0xa>
    351a:	00 d0       	rcall	.+0      	; 0x351c <DriverVL53L0XReadContinuous+0xc>
    351c:	cd b7       	in	r28, 0x3d	; 61
    351e:	de b7       	in	r29, 0x3e	; 62
	return true;
}

static void startTimeout(void)
{
	timeout_start_ticks=portGET_RUN_TIME_COUNTER_VALUE();
    3520:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3524:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3528:	80 91 85 2d 	lds	r24, 0x2D85	; 0x802d85 <StatsTimer>
    352c:	90 91 86 2d 	lds	r25, 0x2D86	; 0x802d86 <StatsTimer+0x1>
    3530:	a0 91 87 2d 	lds	r26, 0x2D87	; 0x802d87 <StatsTimer+0x2>
    3534:	b0 91 88 2d 	lds	r27, 0x2D88	; 0x802d88 <StatsTimer+0x3>
    3538:	82 0f       	add	r24, r18
    353a:	93 1f       	adc	r25, r19
    353c:	a1 1d       	adc	r26, r1
    353e:	b1 1d       	adc	r27, r1
    3540:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <timeout_start_ticks>
    3544:	90 93 96 2c 	sts	0x2C96, r25	; 0x802c96 <timeout_start_ticks+0x1>
    3548:	a0 93 97 2c 	sts	0x2C97, r26	; 0x802c97 <timeout_start_ticks+0x2>
    354c:	b0 93 98 2c 	sts	0x2C98, r27	; 0x802c98 <timeout_start_ticks+0x3>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    3550:	13 e1       	ldi	r17, 0x13	; 19
    3552:	19 83       	std	Y+1, r17	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    3554:	01 e0       	ldi	r16, 0x01	; 1
    3556:	9e 01       	movw	r18, r28
    3558:	2f 5f       	subi	r18, 0xFF	; 255
    355a:	3f 4f       	sbci	r19, 0xFF	; 255
    355c:	41 e0       	ldi	r20, 0x01	; 1
    355e:	b9 01       	movw	r22, r18
    3560:	89 e2       	ldi	r24, 0x29	; 41
    3562:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    3566:	89 81       	ldd	r24, Y+1	; 0x01
	
	
	while (1)
	{
		readReg(RESULT_INTERRUPT_STATUS,&Data);
		if ((Data & 0x07)!=0) break;
    3568:	87 70       	andi	r24, 0x07	; 7
    356a:	99 f3       	breq	.-26     	; 0x3552 <DriverVL53L0XReadContinuous+0x42>
			return 65535;
		}		
	}
	// assumptions: Linearity Corrective Gain is 1000 (default);
	// fractional ranging is not enabled
	readReg16Bit(RESULT_RANGE_STATUS+10,&Data16);
    356c:	be 01       	movw	r22, r28
    356e:	6b 5f       	subi	r22, 0xFB	; 251
    3570:	7f 4f       	sbci	r23, 0xFF	; 255
    3572:	8e e1       	ldi	r24, 0x1E	; 30
    3574:	0e 94 0d 12 	call	0x241a	; 0x241a <readReg16Bit>
	uint16_t range = Data16;
    3578:	0d 81       	ldd	r16, Y+5	; 0x05
    357a:	1e 81       	ldd	r17, Y+6	; 0x06
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    357c:	8b e0       	ldi	r24, 0x0B	; 11
    357e:	89 83       	std	Y+1, r24	; 0x01
	Buffer[1]=value;
    3580:	81 e0       	ldi	r24, 0x01	; 1
    3582:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3584:	42 e0       	ldi	r20, 0x02	; 2
    3586:	be 01       	movw	r22, r28
    3588:	6f 5f       	subi	r22, 0xFF	; 255
    358a:	7f 4f       	sbci	r23, 0xFF	; 255
    358c:	89 e2       	ldi	r24, 0x29	; 41
    358e:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
	uint16_t range = Data16;

	writeReg(SYSTEM_INTERRUPT_CLEAR, 0x01);

	return range;
}
    3592:	c8 01       	movw	r24, r16
    3594:	26 96       	adiw	r28, 0x06	; 6
    3596:	cd bf       	out	0x3d, r28	; 61
    3598:	de bf       	out	0x3e, r29	; 62
    359a:	df 91       	pop	r29
    359c:	cf 91       	pop	r28
    359e:	1f 91       	pop	r17
    35a0:	0f 91       	pop	r16
    35a2:	08 95       	ret

000035a4 <DriverVL53L0XReadSingle>:

// Performs a single-shot range measurement and returns the reading in
// millimeters
// based on VL53L0X_PerformSingleRangingMeasurement()
uint16_t DriverVL53L0XReadSingle()
{
    35a4:	ff 92       	push	r15
    35a6:	0f 93       	push	r16
    35a8:	1f 93       	push	r17
    35aa:	cf 93       	push	r28
    35ac:	df 93       	push	r29
    35ae:	00 d0       	rcall	.+0      	; 0x35b0 <DriverVL53L0XReadSingle+0xc>
    35b0:	1f 92       	push	r1
    35b2:	cd b7       	in	r28, 0x3d	; 61
    35b4:	de b7       	in	r29, 0x3e	; 62
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    35b6:	00 e8       	ldi	r16, 0x80	; 128
    35b8:	09 83       	std	Y+1, r16	; 0x01
	Buffer[1]=value;
    35ba:	11 e0       	ldi	r17, 0x01	; 1
    35bc:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    35be:	42 e0       	ldi	r20, 0x02	; 2
    35c0:	be 01       	movw	r22, r28
    35c2:	6f 5f       	subi	r22, 0xFF	; 255
    35c4:	7f 4f       	sbci	r23, 0xFF	; 255
    35c6:	89 e2       	ldi	r24, 0x29	; 41
    35c8:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    35cc:	ff 24       	eor	r15, r15
    35ce:	fa 94       	dec	r15
    35d0:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    35d2:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    35d4:	42 e0       	ldi	r20, 0x02	; 2
    35d6:	be 01       	movw	r22, r28
    35d8:	6f 5f       	subi	r22, 0xFF	; 255
    35da:	7f 4f       	sbci	r23, 0xFF	; 255
    35dc:	89 e2       	ldi	r24, 0x29	; 41
    35de:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    35e2:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    35e4:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    35e6:	42 e0       	ldi	r20, 0x02	; 2
    35e8:	be 01       	movw	r22, r28
    35ea:	6f 5f       	subi	r22, 0xFF	; 255
    35ec:	7f 4f       	sbci	r23, 0xFF	; 255
    35ee:	89 e2       	ldi	r24, 0x29	; 41
    35f0:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
	uint8_t Data;
	
	writeReg(0x80, 0x01);
	writeReg(0xFF, 0x01);
	writeReg(0x00, 0x00);
	writeReg(0x91, stop_variable);
    35f4:	80 91 99 2c 	lds	r24, 0x2C99	; 0x802c99 <stop_variable>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    35f8:	91 e9       	ldi	r25, 0x91	; 145
    35fa:	99 83       	std	Y+1, r25	; 0x01
	Buffer[1]=value;
    35fc:	8a 83       	std	Y+2, r24	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    35fe:	42 e0       	ldi	r20, 0x02	; 2
    3600:	be 01       	movw	r22, r28
    3602:	6f 5f       	subi	r22, 0xFF	; 255
    3604:	7f 4f       	sbci	r23, 0xFF	; 255
    3606:	89 e2       	ldi	r24, 0x29	; 41
    3608:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    360c:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    360e:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3610:	42 e0       	ldi	r20, 0x02	; 2
    3612:	be 01       	movw	r22, r28
    3614:	6f 5f       	subi	r22, 0xFF	; 255
    3616:	7f 4f       	sbci	r23, 0xFF	; 255
    3618:	89 e2       	ldi	r24, 0x29	; 41
    361a:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    361e:	f9 82       	std	Y+1, r15	; 0x01
	Buffer[1]=value;
    3620:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3622:	42 e0       	ldi	r20, 0x02	; 2
    3624:	be 01       	movw	r22, r28
    3626:	6f 5f       	subi	r22, 0xFF	; 255
    3628:	7f 4f       	sbci	r23, 0xFF	; 255
    362a:	89 e2       	ldi	r24, 0x29	; 41
    362c:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3630:	09 83       	std	Y+1, r16	; 0x01
	Buffer[1]=value;
    3632:	1a 82       	std	Y+2, r1	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3634:	42 e0       	ldi	r20, 0x02	; 2
    3636:	be 01       	movw	r22, r28
    3638:	6f 5f       	subi	r22, 0xFF	; 255
    363a:	7f 4f       	sbci	r23, 0xFF	; 255
    363c:	89 e2       	ldi	r24, 0x29	; 41
    363e:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
// Write an 8-bit register
static uint8_t writeReg(uint8_t reg, uint8_t value)
{	
	uint8_t res;
	uint8_t Buffer[4];
	Buffer[0]=reg;
    3642:	19 82       	std	Y+1, r1	; 0x01
	Buffer[1]=value;
    3644:	1a 83       	std	Y+2, r17	; 0x02
	res=TWIMWrite(VL53L0X_ADDR,Buffer,2);
    3646:	42 e0       	ldi	r20, 0x02	; 2
    3648:	be 01       	movw	r22, r28
    364a:	6f 5f       	subi	r22, 0xFF	; 255
    364c:	7f 4f       	sbci	r23, 0xFF	; 255
    364e:	89 e2       	ldi	r24, 0x29	; 41
    3650:	0e 94 a9 0f 	call	0x1f52	; 0x1f52 <TWIMWrite>
	return true;
}

static void startTimeout(void)
{
	timeout_start_ticks=portGET_RUN_TIME_COUNTER_VALUE();
    3654:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3658:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    365c:	80 91 85 2d 	lds	r24, 0x2D85	; 0x802d85 <StatsTimer>
    3660:	90 91 86 2d 	lds	r25, 0x2D86	; 0x802d86 <StatsTimer+0x1>
    3664:	a0 91 87 2d 	lds	r26, 0x2D87	; 0x802d87 <StatsTimer+0x2>
    3668:	b0 91 88 2d 	lds	r27, 0x2D88	; 0x802d88 <StatsTimer+0x3>
    366c:	82 0f       	add	r24, r18
    366e:	93 1f       	adc	r25, r19
    3670:	a1 1d       	adc	r26, r1
    3672:	b1 1d       	adc	r27, r1
    3674:	80 93 95 2c 	sts	0x2C95, r24	; 0x802c95 <timeout_start_ticks>
    3678:	90 93 96 2c 	sts	0x2C96, r25	; 0x802c96 <timeout_start_ticks+0x1>
    367c:	a0 93 97 2c 	sts	0x2C97, r26	; 0x802c97 <timeout_start_ticks+0x2>
    3680:	b0 93 98 2c 	sts	0x2C98, r27	; 0x802c98 <timeout_start_ticks+0x3>
uint8_t readReg(uint8_t reg,uint8_t *data)
{	
	uint8_t res;
	uint8_t Buffer[4];
	
	Buffer[0]=reg;
    3684:	19 82       	std	Y+1, r1	; 0x01
	
	res=TWIMWriteRead(VL53L0X_ADDR,Buffer,1,Buffer,1);
    3686:	01 e0       	ldi	r16, 0x01	; 1
    3688:	9e 01       	movw	r18, r28
    368a:	2f 5f       	subi	r18, 0xFF	; 255
    368c:	3f 4f       	sbci	r19, 0xFF	; 255
    368e:	41 e0       	ldi	r20, 0x01	; 1
    3690:	b9 01       	movw	r22, r18
    3692:	89 e2       	ldi	r24, 0x29	; 41
    3694:	0e 94 1a 0f 	call	0x1e34	; 0x1e34 <TWIMWriteRead>
	if (data!=NULL) data[0]=Buffer[0];
    3698:	89 81       	ldd	r24, Y+1	; 0x01
	startTimeout();
	
	while (1)
	{
		readReg(SYSRANGE_START,&Data);
		if (! (Data & 0x01)) break;
    369a:	80 fd       	sbrc	r24, 0
    369c:	f3 cf       	rjmp	.-26     	; 0x3684 <DriverVL53L0XReadSingle+0xe0>
			did_timeout = true;
			return 65535;
		}
	}

	return DriverVL53L0XReadContinuous();
    369e:	0e 94 88 1a 	call	0x3510	; 0x3510 <DriverVL53L0XReadContinuous>
}
    36a2:	24 96       	adiw	r28, 0x04	; 4
    36a4:	cd bf       	out	0x3d, r28	; 61
    36a6:	de bf       	out	0x3e, r29	; 62
    36a8:	df 91       	pop	r29
    36aa:	cf 91       	pop	r28
    36ac:	1f 91       	pop	r17
    36ae:	0f 91       	pop	r16
    36b0:	ff 90       	pop	r15
    36b2:	08 95       	ret

000036b4 <enterSleepMode>:
#include <avr/sleep.h>
#include <avr/interrupt.h>
#include <avr/power.h>
#include "DriverPower.h"

void enterSleepMode(void) {
    36b4:	cf 93       	push	r28
    36b6:	df 93       	push	r29
	// Set the sleep mode. For XMEGA, you might use SLEEP_SMODE_PDOWN_gc for power down.
	// Check the specific group configuration (gc) value for your microcontroller.
	set_sleep_mode(SLEEP_SMODE_PDOWN_gc);
    36b8:	c8 e4       	ldi	r28, 0x48	; 72
    36ba:	d0 e0       	ldi	r29, 0x00	; 0
    36bc:	88 81       	ld	r24, Y
    36be:	81 7f       	andi	r24, 0xF1	; 241
    36c0:	84 60       	ori	r24, 0x04	; 4
    36c2:	88 83       	st	Y, r24

	// Disable any peripherals here to save power.
	// For example, power_adc_disable(); (if such function exists or equivalent)

	// Enable global interrupts so that the MCU can wake up from an interrupt.
	sei();
    36c4:	78 94       	sei
	
	vTaskDelay(100);
    36c6:	84 e6       	ldi	r24, 0x64	; 100
    36c8:	90 e0       	ldi	r25, 0x00	; 0
    36ca:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
	// Enable sleep.
	
	
	PMIC.CTRL &=0b11111100; // shut off medium and low lever interrupt
    36ce:	e0 ea       	ldi	r30, 0xA0	; 160
    36d0:	f0 e0       	ldi	r31, 0x00	; 0
    36d2:	82 81       	ldd	r24, Z+2	; 0x02
    36d4:	8c 7f       	andi	r24, 0xFC	; 252
    36d6:	82 83       	std	Z+2, r24	; 0x02
	DriverPowerVccAuxSet(0);
    36d8:	80 e0       	ldi	r24, 0x00	; 0
    36da:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <DriverPowerVccAuxSet>
	sleep_enable();
    36de:	88 81       	ld	r24, Y
    36e0:	81 60       	ori	r24, 0x01	; 1
    36e2:	88 83       	st	Y, r24

	vTaskDelay(50);
    36e4:	82 e3       	ldi	r24, 0x32	; 50
    36e6:	90 e0       	ldi	r25, 0x00	; 0
    36e8:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
	// Enter sleep mode.
	sleep_cpu();
    36ec:	88 95       	sleep

	// Sleep mode will be exited upon receiving an interrupt.

	// Disable sleep after waking up.
	sleep_disable();
    36ee:	88 81       	ld	r24, Y
    36f0:	8e 7f       	andi	r24, 0xFE	; 254
    36f2:	88 83       	st	Y, r24

	// Re-enable peripherals if needed.
	// For example, power_adc_enable(); (if such function exists or equivalent)
}
    36f4:	df 91       	pop	r29
    36f6:	cf 91       	pop	r28
    36f8:	08 95       	ret

000036fa <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    36fa:	0f 93       	push	r16
    36fc:	1f 93       	push	r17
    36fe:	cf 93       	push	r28
    3700:	df 93       	push	r29
    3702:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    3704:	0e 94 a6 28 	call	0x514c	; 0x514c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    3708:	80 91 9a 2c 	lds	r24, 0x2C9A	; 0x802c9a <xHeapHasBeenInitialised.4135>
    370c:	81 11       	cpse	r24, r1
    370e:	21 c0       	rjmp	.+66     	; 0x3752 <pvPortMalloc+0x58>
{
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    3710:	e0 91 89 2d 	lds	r30, 0x2D89	; 0x802d89 <ucHeap>
    3714:	f0 91 8a 2d 	lds	r31, 0x2D8A	; 0x802d8a <ucHeap+0x1>

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    3718:	cf 01       	movw	r24, r30
    371a:	01 96       	adiw	r24, 0x01	; 1
    371c:	80 93 9f 2c 	sts	0x2C9F, r24	; 0x802c9f <xStart>
    3720:	90 93 a0 2c 	sts	0x2CA0, r25	; 0x802ca0 <xStart+0x1>
	xStart.xBlockSize = ( size_t ) 0;
    3724:	10 92 a1 2c 	sts	0x2CA1, r1	; 0x802ca1 <xStart+0x2>
    3728:	10 92 a2 2c 	sts	0x2CA2, r1	; 0x802ca2 <xStart+0x3>

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    372c:	8f ef       	ldi	r24, 0xFF	; 255
    372e:	9f e3       	ldi	r25, 0x3F	; 63
    3730:	80 93 9d 2c 	sts	0x2C9D, r24	; 0x802c9d <xEnd+0x2>
    3734:	90 93 9e 2c 	sts	0x2C9E, r25	; 0x802c9e <xEnd+0x3>
	xEnd.pxNextFreeBlock = NULL;
    3738:	10 92 9b 2c 	sts	0x2C9B, r1	; 0x802c9b <xEnd>
    373c:	10 92 9c 2c 	sts	0x2C9C, r1	; 0x802c9c <xEnd+0x1>

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
    3740:	83 83       	std	Z+3, r24	; 0x03
    3742:	94 83       	std	Z+4, r25	; 0x04
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    3744:	8b e9       	ldi	r24, 0x9B	; 155
    3746:	9c e2       	ldi	r25, 0x2C	; 44
    3748:	81 83       	std	Z+1, r24	; 0x01
    374a:	92 83       	std	Z+2, r25	; 0x02
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
    374c:	81 e0       	ldi	r24, 0x01	; 1
    374e:	80 93 9a 2c 	sts	0x2C9A, r24	; 0x802c9a <xHeapHasBeenInitialised.4135>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    3752:	20 97       	sbiw	r28, 0x00	; 0
    3754:	09 f4       	brne	.+2      	; 0x3758 <pvPortMalloc+0x5e>
    3756:	64 c0       	rjmp	.+200    	; 0x3820 <pvPortMalloc+0x126>
		{
			xWantedSize += heapSTRUCT_SIZE;
    3758:	ae 01       	movw	r20, r28
    375a:	4c 5f       	subi	r20, 0xFC	; 252
    375c:	5f 4f       	sbci	r21, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
    375e:	23 96       	adiw	r28, 0x03	; 3
    3760:	ce 3f       	cpi	r28, 0xFE	; 254
    3762:	df 43       	sbci	r29, 0x3F	; 63
    3764:	08 f0       	brcs	.+2      	; 0x3768 <pvPortMalloc+0x6e>
    3766:	5c c0       	rjmp	.+184    	; 0x3820 <pvPortMalloc+0x126>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    3768:	e0 91 9f 2c 	lds	r30, 0x2C9F	; 0x802c9f <xStart>
    376c:	f0 91 a0 2c 	lds	r31, 0x2CA0	; 0x802ca0 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    3770:	af e9       	ldi	r26, 0x9F	; 159
    3772:	bc e2       	ldi	r27, 0x2C	; 44
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    3774:	06 c0       	rjmp	.+12     	; 0x3782 <pvPortMalloc+0x88>
    3776:	80 81       	ld	r24, Z
    3778:	91 81       	ldd	r25, Z+1	; 0x01
    377a:	00 97       	sbiw	r24, 0x00	; 0
    377c:	39 f0       	breq	.+14     	; 0x378c <pvPortMalloc+0x92>
    377e:	df 01       	movw	r26, r30
    3780:	fc 01       	movw	r30, r24
    3782:	22 81       	ldd	r18, Z+2	; 0x02
    3784:	33 81       	ldd	r19, Z+3	; 0x03
    3786:	24 17       	cp	r18, r20
    3788:	35 07       	cpc	r19, r21
    378a:	a8 f3       	brcs	.-22     	; 0x3776 <pvPortMalloc+0x7c>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    378c:	cc e2       	ldi	r28, 0x2C	; 44
    378e:	eb 39       	cpi	r30, 0x9B	; 155
    3790:	fc 07       	cpc	r31, r28
    3792:	09 f4       	brne	.+2      	; 0x3796 <pvPortMalloc+0x9c>
    3794:	45 c0       	rjmp	.+138    	; 0x3820 <pvPortMalloc+0x126>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    3796:	cd 91       	ld	r28, X+
    3798:	dc 91       	ld	r29, X
    379a:	11 97       	sbiw	r26, 0x01	; 1
    379c:	8e 01       	movw	r16, r28
    379e:	0c 5f       	subi	r16, 0xFC	; 252
    37a0:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    37a2:	80 81       	ld	r24, Z
    37a4:	91 81       	ldd	r25, Z+1	; 0x01
    37a6:	8d 93       	st	X+, r24
    37a8:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    37aa:	c9 01       	movw	r24, r18
    37ac:	84 1b       	sub	r24, r20
    37ae:	95 0b       	sbc	r25, r21
    37b0:	89 30       	cpi	r24, 0x09	; 9
    37b2:	91 05       	cpc	r25, r1
    37b4:	00 f1       	brcs	.+64     	; 0x37f6 <pvPortMalloc+0xfc>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    37b6:	bf 01       	movw	r22, r30
    37b8:	64 0f       	add	r22, r20
    37ba:	75 1f       	adc	r23, r21

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    37bc:	db 01       	movw	r26, r22
    37be:	12 96       	adiw	r26, 0x02	; 2
    37c0:	8d 93       	st	X+, r24
    37c2:	9c 93       	st	X, r25
    37c4:	13 97       	sbiw	r26, 0x03	; 3
					pxBlock->xBlockSize = xWantedSize;
    37c6:	42 83       	std	Z+2, r20	; 0x02
    37c8:	53 83       	std	Z+3, r21	; 0x03

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    37ca:	12 96       	adiw	r26, 0x02	; 2
    37cc:	2d 91       	ld	r18, X+
    37ce:	3c 91       	ld	r19, X
    37d0:	13 97       	sbiw	r26, 0x03	; 3
    37d2:	af e9       	ldi	r26, 0x9F	; 159
    37d4:	bc e2       	ldi	r27, 0x2C	; 44
    37d6:	01 c0       	rjmp	.+2      	; 0x37da <pvPortMalloc+0xe0>
    37d8:	df 01       	movw	r26, r30
    37da:	ed 91       	ld	r30, X+
    37dc:	fc 91       	ld	r31, X
    37de:	11 97       	sbiw	r26, 0x01	; 1
    37e0:	82 81       	ldd	r24, Z+2	; 0x02
    37e2:	93 81       	ldd	r25, Z+3	; 0x03
    37e4:	82 17       	cp	r24, r18
    37e6:	93 07       	cpc	r25, r19
    37e8:	b8 f3       	brcs	.-18     	; 0x37d8 <pvPortMalloc+0xde>
    37ea:	eb 01       	movw	r28, r22
    37ec:	e8 83       	st	Y, r30
    37ee:	f9 83       	std	Y+1, r31	; 0x01
    37f0:	6d 93       	st	X+, r22
    37f2:	7c 93       	st	X, r23

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
		{
			xWantedSize += heapSTRUCT_SIZE;
    37f4:	9a 01       	movw	r18, r20

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
    37f6:	80 91 14 20 	lds	r24, 0x2014	; 0x802014 <xFreeBytesRemaining>
    37fa:	90 91 15 20 	lds	r25, 0x2015	; 0x802015 <xFreeBytesRemaining+0x1>
    37fe:	82 1b       	sub	r24, r18
    3800:	93 0b       	sbc	r25, r19
    3802:	80 93 14 20 	sts	0x2014, r24	; 0x802014 <xFreeBytesRemaining>
    3806:	90 93 15 20 	sts	0x2015, r25	; 0x802015 <xFreeBytesRemaining+0x1>
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    380a:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
    380e:	01 15       	cp	r16, r1
    3810:	11 05       	cpc	r17, r1
    3812:	41 f0       	breq	.+16     	; 0x3824 <pvPortMalloc+0x12a>
		}
	}
	#endif

	return pvReturn;
}
    3814:	c8 01       	movw	r24, r16
    3816:	df 91       	pop	r29
    3818:	cf 91       	pop	r28
    381a:	1f 91       	pop	r17
    381c:	0f 91       	pop	r16
    381e:	08 95       	ret
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    3820:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
    3824:	0e 94 96 2f 	call	0x5f2c	; 0x5f2c <vApplicationMallocFailedHook>
    3828:	00 e0       	ldi	r16, 0x00	; 0
    382a:	10 e0       	ldi	r17, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
}
    382c:	c8 01       	movw	r24, r16
    382e:	df 91       	pop	r29
    3830:	cf 91       	pop	r28
    3832:	1f 91       	pop	r17
    3834:	0f 91       	pop	r16
    3836:	08 95       	ret

00003838 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    3838:	cf 93       	push	r28
    383a:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    383c:	00 97       	sbiw	r24, 0x00	; 0
    383e:	21 f1       	breq	.+72     	; 0x3888 <vPortFree+0x50>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
    3840:	ec 01       	movw	r28, r24
    3842:	24 97       	sbiw	r28, 0x04	; 4

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
    3844:	0e 94 a6 28 	call	0x514c	; 0x514c <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    3848:	4a 81       	ldd	r20, Y+2	; 0x02
    384a:	5b 81       	ldd	r21, Y+3	; 0x03
    384c:	af e9       	ldi	r26, 0x9F	; 159
    384e:	bc e2       	ldi	r27, 0x2C	; 44
    3850:	01 c0       	rjmp	.+2      	; 0x3854 <vPortFree+0x1c>
    3852:	df 01       	movw	r26, r30
    3854:	ed 91       	ld	r30, X+
    3856:	fc 91       	ld	r31, X
    3858:	11 97       	sbiw	r26, 0x01	; 1
    385a:	22 81       	ldd	r18, Z+2	; 0x02
    385c:	33 81       	ldd	r19, Z+3	; 0x03
    385e:	24 17       	cp	r18, r20
    3860:	35 07       	cpc	r19, r21
    3862:	b8 f3       	brcs	.-18     	; 0x3852 <vPortFree+0x1a>
    3864:	e8 83       	st	Y, r30
    3866:	f9 83       	std	Y+1, r31	; 0x01
    3868:	cd 93       	st	X+, r28
    386a:	dc 93       	st	X, r29
			xFreeBytesRemaining += pxLink->xBlockSize;
    386c:	80 91 14 20 	lds	r24, 0x2014	; 0x802014 <xFreeBytesRemaining>
    3870:	90 91 15 20 	lds	r25, 0x2015	; 0x802015 <xFreeBytesRemaining+0x1>
    3874:	48 0f       	add	r20, r24
    3876:	59 1f       	adc	r21, r25
    3878:	40 93 14 20 	sts	0x2014, r20	; 0x802014 <xFreeBytesRemaining>
    387c:	50 93 15 20 	sts	0x2015, r21	; 0x802015 <xFreeBytesRemaining+0x1>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
	}
}
    3880:	df 91       	pop	r29
    3882:	cf 91       	pop	r28
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
			xFreeBytesRemaining += pxLink->xBlockSize;
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
    3884:	0c 94 a2 29 	jmp	0x5344	; 0x5344 <xTaskResumeAll>
	}
}
    3888:	df 91       	pop	r29
    388a:	cf 91       	pop	r28
    388c:	08 95       	ret

0000388e <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    388e:	80 91 14 20 	lds	r24, 0x2014	; 0x802014 <xFreeBytesRemaining>
    3892:	90 91 15 20 	lds	r25, 0x2015	; 0x802015 <xFreeBytesRemaining+0x1>
    3896:	08 95       	ret

00003898 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    3898:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    389a:	03 96       	adiw	r24, 0x03	; 3
    389c:	81 83       	std	Z+1, r24	; 0x01
    389e:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    38a0:	2f ef       	ldi	r18, 0xFF	; 255
    38a2:	3f ef       	ldi	r19, 0xFF	; 255
    38a4:	23 83       	std	Z+3, r18	; 0x03
    38a6:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    38a8:	85 83       	std	Z+5, r24	; 0x05
    38aa:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    38ac:	87 83       	std	Z+7, r24	; 0x07
    38ae:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    38b0:	10 82       	st	Z, r1
    38b2:	08 95       	ret

000038b4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    38b4:	fc 01       	movw	r30, r24
    38b6:	10 86       	std	Z+8, r1	; 0x08
    38b8:	11 86       	std	Z+9, r1	; 0x09
    38ba:	08 95       	ret

000038bc <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    38bc:	cf 93       	push	r28
    38be:	df 93       	push	r29
    38c0:	9c 01       	movw	r18, r24
    38c2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    38c4:	dc 01       	movw	r26, r24
    38c6:	11 96       	adiw	r26, 0x01	; 1
    38c8:	cd 91       	ld	r28, X+
    38ca:	dc 91       	ld	r29, X
    38cc:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    38ce:	c2 83       	std	Z+2, r28	; 0x02
    38d0:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    38d2:	8c 81       	ldd	r24, Y+4	; 0x04
    38d4:	9d 81       	ldd	r25, Y+5	; 0x05
    38d6:	84 83       	std	Z+4, r24	; 0x04
    38d8:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    38da:	8c 81       	ldd	r24, Y+4	; 0x04
    38dc:	9d 81       	ldd	r25, Y+5	; 0x05
    38de:	dc 01       	movw	r26, r24
    38e0:	12 96       	adiw	r26, 0x02	; 2
    38e2:	6d 93       	st	X+, r22
    38e4:	7c 93       	st	X, r23
    38e6:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    38e8:	6c 83       	std	Y+4, r22	; 0x04
    38ea:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    38ec:	20 87       	std	Z+8, r18	; 0x08
    38ee:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    38f0:	f9 01       	movw	r30, r18
    38f2:	80 81       	ld	r24, Z
    38f4:	8f 5f       	subi	r24, 0xFF	; 255
    38f6:	80 83       	st	Z, r24
}
    38f8:	df 91       	pop	r29
    38fa:	cf 91       	pop	r28
    38fc:	08 95       	ret

000038fe <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    38fe:	cf 93       	push	r28
    3900:	df 93       	push	r29
    3902:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    3904:	48 81       	ld	r20, Y
    3906:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    3908:	4f 3f       	cpi	r20, 0xFF	; 255
    390a:	2f ef       	ldi	r18, 0xFF	; 255
    390c:	52 07       	cpc	r21, r18
    390e:	01 f1       	breq	.+64     	; 0x3950 <vListInsert+0x52>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    3910:	dc 01       	movw	r26, r24
    3912:	13 96       	adiw	r26, 0x03	; 3
    3914:	01 c0       	rjmp	.+2      	; 0x3918 <vListInsert+0x1a>
    3916:	df 01       	movw	r26, r30
    3918:	12 96       	adiw	r26, 0x02	; 2
    391a:	ed 91       	ld	r30, X+
    391c:	fc 91       	ld	r31, X
    391e:	13 97       	sbiw	r26, 0x03	; 3
    3920:	20 81       	ld	r18, Z
    3922:	31 81       	ldd	r19, Z+1	; 0x01
    3924:	42 17       	cp	r20, r18
    3926:	53 07       	cpc	r21, r19
    3928:	b0 f7       	brcc	.-20     	; 0x3916 <vListInsert+0x18>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    392a:	ea 83       	std	Y+2, r30	; 0x02
    392c:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    392e:	c4 83       	std	Z+4, r28	; 0x04
    3930:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    3932:	ac 83       	std	Y+4, r26	; 0x04
    3934:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    3936:	12 96       	adiw	r26, 0x02	; 2
    3938:	cd 93       	st	X+, r28
    393a:	dc 93       	st	X, r29
    393c:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    393e:	88 87       	std	Y+8, r24	; 0x08
    3940:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    3942:	fc 01       	movw	r30, r24
    3944:	20 81       	ld	r18, Z
    3946:	2f 5f       	subi	r18, 0xFF	; 255
    3948:	20 83       	st	Z, r18
}
    394a:	df 91       	pop	r29
    394c:	cf 91       	pop	r28
    394e:	08 95       	ret
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    3950:	fc 01       	movw	r30, r24
    3952:	a7 81       	ldd	r26, Z+7	; 0x07
    3954:	b0 85       	ldd	r27, Z+8	; 0x08
    3956:	12 96       	adiw	r26, 0x02	; 2
    3958:	ed 91       	ld	r30, X+
    395a:	fc 91       	ld	r31, X
    395c:	13 97       	sbiw	r26, 0x03	; 3
    395e:	e5 cf       	rjmp	.-54     	; 0x392a <vListInsert+0x2c>

00003960 <uxListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    3960:	cf 93       	push	r28
    3962:	df 93       	push	r29
    3964:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    3966:	a0 85       	ldd	r26, Z+8	; 0x08
    3968:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    396a:	22 81       	ldd	r18, Z+2	; 0x02
    396c:	33 81       	ldd	r19, Z+3	; 0x03
    396e:	84 81       	ldd	r24, Z+4	; 0x04
    3970:	95 81       	ldd	r25, Z+5	; 0x05
    3972:	e9 01       	movw	r28, r18
    3974:	8c 83       	std	Y+4, r24	; 0x04
    3976:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3978:	84 81       	ldd	r24, Z+4	; 0x04
    397a:	95 81       	ldd	r25, Z+5	; 0x05
    397c:	ec 01       	movw	r28, r24
    397e:	2a 83       	std	Y+2, r18	; 0x02
    3980:	3b 83       	std	Y+3, r19	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    3982:	11 96       	adiw	r26, 0x01	; 1
    3984:	2d 91       	ld	r18, X+
    3986:	3c 91       	ld	r19, X
    3988:	12 97       	sbiw	r26, 0x02	; 2
    398a:	e2 17       	cp	r30, r18
    398c:	f3 07       	cpc	r31, r19
    398e:	49 f0       	breq	.+18     	; 0x39a2 <uxListRemove+0x42>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    3990:	10 86       	std	Z+8, r1	; 0x08
    3992:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    3994:	8c 91       	ld	r24, X
    3996:	81 50       	subi	r24, 0x01	; 1
    3998:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    399a:	8c 91       	ld	r24, X
}
    399c:	df 91       	pop	r29
    399e:	cf 91       	pop	r28
    39a0:	08 95       	ret
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    39a2:	11 96       	adiw	r26, 0x01	; 1
    39a4:	8d 93       	st	X+, r24
    39a6:	9c 93       	st	X, r25
    39a8:	12 97       	sbiw	r26, 0x02	; 2
    39aa:	f2 cf       	rjmp	.-28     	; 0x3990 <uxListRemove+0x30>

000039ac <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    39ac:	31 e1       	ldi	r19, 0x11	; 17
    39ae:	fc 01       	movw	r30, r24
    39b0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    39b2:	31 97       	sbiw	r30, 0x01	; 1
    39b4:	22 e2       	ldi	r18, 0x22	; 34
    39b6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    39b8:	31 97       	sbiw	r30, 0x01	; 1
    39ba:	a3 e3       	ldi	r26, 0x33	; 51
    39bc:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    39be:	31 97       	sbiw	r30, 0x01	; 1
    39c0:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    39c2:	31 97       	sbiw	r30, 0x01	; 1
    39c4:	70 83       	st	Z, r23
	pxTopOfStack--;

#if defined(__AVR_3_BYTE_PC__) && __AVR_3_BYTE_PC__   //MCU's with more than 128kB of program memory: PC is 3 bytes
	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    39c6:	31 97       	sbiw	r30, 0x01	; 1
    39c8:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    39ca:	31 97       	sbiw	r30, 0x01	; 1
    39cc:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    39ce:	31 97       	sbiw	r30, 0x01	; 1
    39d0:	60 e8       	ldi	r22, 0x80	; 128
    39d2:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    39d4:	31 97       	sbiw	r30, 0x01	; 1
    39d6:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    39d8:	31 97       	sbiw	r30, 0x01	; 1
    39da:	62 e0       	ldi	r22, 0x02	; 2
    39dc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    39de:	31 97       	sbiw	r30, 0x01	; 1
    39e0:	63 e0       	ldi	r22, 0x03	; 3
    39e2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    39e4:	31 97       	sbiw	r30, 0x01	; 1
    39e6:	64 e0       	ldi	r22, 0x04	; 4
    39e8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    39ea:	31 97       	sbiw	r30, 0x01	; 1
    39ec:	65 e0       	ldi	r22, 0x05	; 5
    39ee:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    39f0:	31 97       	sbiw	r30, 0x01	; 1
    39f2:	66 e0       	ldi	r22, 0x06	; 6
    39f4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    39f6:	31 97       	sbiw	r30, 0x01	; 1
    39f8:	67 e0       	ldi	r22, 0x07	; 7
    39fa:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    39fc:	31 97       	sbiw	r30, 0x01	; 1
    39fe:	68 e0       	ldi	r22, 0x08	; 8
    3a00:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    3a02:	31 97       	sbiw	r30, 0x01	; 1
    3a04:	69 e0       	ldi	r22, 0x09	; 9
    3a06:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    3a08:	31 97       	sbiw	r30, 0x01	; 1
    3a0a:	60 e1       	ldi	r22, 0x10	; 16
    3a0c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    3a0e:	31 97       	sbiw	r30, 0x01	; 1
    3a10:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    3a12:	31 97       	sbiw	r30, 0x01	; 1
    3a14:	32 e1       	ldi	r19, 0x12	; 18
    3a16:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    3a18:	31 97       	sbiw	r30, 0x01	; 1
    3a1a:	33 e1       	ldi	r19, 0x13	; 19
    3a1c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    3a1e:	31 97       	sbiw	r30, 0x01	; 1
    3a20:	34 e1       	ldi	r19, 0x14	; 20
    3a22:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    3a24:	31 97       	sbiw	r30, 0x01	; 1
    3a26:	35 e1       	ldi	r19, 0x15	; 21
    3a28:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    3a2a:	31 97       	sbiw	r30, 0x01	; 1
    3a2c:	36 e1       	ldi	r19, 0x16	; 22
    3a2e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    3a30:	31 97       	sbiw	r30, 0x01	; 1
    3a32:	37 e1       	ldi	r19, 0x17	; 23
    3a34:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    3a36:	31 97       	sbiw	r30, 0x01	; 1
    3a38:	38 e1       	ldi	r19, 0x18	; 24
    3a3a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    3a3c:	31 97       	sbiw	r30, 0x01	; 1
    3a3e:	39 e1       	ldi	r19, 0x19	; 25
    3a40:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    3a42:	31 97       	sbiw	r30, 0x01	; 1
    3a44:	30 e2       	ldi	r19, 0x20	; 32
    3a46:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    3a48:	31 97       	sbiw	r30, 0x01	; 1
    3a4a:	31 e2       	ldi	r19, 0x21	; 33
    3a4c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    3a4e:	31 97       	sbiw	r30, 0x01	; 1
    3a50:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    3a52:	31 97       	sbiw	r30, 0x01	; 1
    3a54:	23 e2       	ldi	r18, 0x23	; 35
    3a56:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3a58:	31 97       	sbiw	r30, 0x01	; 1
    3a5a:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3a5c:	31 97       	sbiw	r30, 0x01	; 1
    3a5e:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    3a60:	31 97       	sbiw	r30, 0x01	; 1
    3a62:	26 e2       	ldi	r18, 0x26	; 38
    3a64:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    3a66:	31 97       	sbiw	r30, 0x01	; 1
    3a68:	27 e2       	ldi	r18, 0x27	; 39
    3a6a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    3a6c:	31 97       	sbiw	r30, 0x01	; 1
    3a6e:	28 e2       	ldi	r18, 0x28	; 40
    3a70:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    3a72:	31 97       	sbiw	r30, 0x01	; 1
    3a74:	29 e2       	ldi	r18, 0x29	; 41
    3a76:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    3a78:	31 97       	sbiw	r30, 0x01	; 1
    3a7a:	20 e3       	ldi	r18, 0x30	; 48
    3a7c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    3a7e:	31 97       	sbiw	r30, 0x01	; 1
    3a80:	21 e3       	ldi	r18, 0x31	; 49
    3a82:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    3a84:	87 97       	sbiw	r24, 0x27	; 39
    3a86:	08 95       	ret

00003a88 <xPortStartScheduler>:
 */

static void prvSetupTimerInterrupt( void )
{
	//TCC0 is used as tick timer
	TCC0.CCA=65535;
    3a88:	e0 e0       	ldi	r30, 0x00	; 0
    3a8a:	f8 e0       	ldi	r31, 0x08	; 8
    3a8c:	8f ef       	ldi	r24, 0xFF	; 255
    3a8e:	9f ef       	ldi	r25, 0xFF	; 255
    3a90:	80 a7       	std	Z+40, r24	; 0x28
    3a92:	91 a7       	std	Z+41, r25	; 0x29
	TCC0.CTRLA=0b00000001; //DIV1
    3a94:	81 e0       	ldi	r24, 0x01	; 1
    3a96:	80 83       	st	Z, r24
	TCC0.CTRLB=1<<6;
    3a98:	90 e4       	ldi	r25, 0x40	; 64
    3a9a:	91 83       	std	Z+1, r25	; 0x01
	TCC0.INTCTRLA=0b00000001; //OVF priority LOW
    3a9c:	86 83       	std	Z+6, r24	; 0x06
	TCC0.INTCTRLB=0b00000001; //CCA priority LOW
    3a9e:	87 83       	std	Z+7, r24	; 0x07
	TCC0.PER=configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3aa0:	80 e0       	ldi	r24, 0x00	; 0
    3aa2:	9d e7       	ldi	r25, 0x7D	; 125
    3aa4:	86 a3       	std	Z+38, r24	; 0x26
    3aa6:	97 a3       	std	Z+39, r25	; 0x27
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3aa8:	a0 91 41 2d 	lds	r26, 0x2D41	; 0x802d41 <pxCurrentTCB>
    3aac:	b0 91 42 2d 	lds	r27, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    3ab0:	cd 91       	ld	r28, X+
    3ab2:	cd bf       	out	0x3d, r28	; 61
    3ab4:	dd 91       	ld	r29, X+
    3ab6:	de bf       	out	0x3e, r29	; 62
    3ab8:	ff 91       	pop	r31
    3aba:	ef 91       	pop	r30
    3abc:	df 91       	pop	r29
    3abe:	cf 91       	pop	r28
    3ac0:	bf 91       	pop	r27
    3ac2:	af 91       	pop	r26
    3ac4:	9f 91       	pop	r25
    3ac6:	8f 91       	pop	r24
    3ac8:	7f 91       	pop	r23
    3aca:	6f 91       	pop	r22
    3acc:	5f 91       	pop	r21
    3ace:	4f 91       	pop	r20
    3ad0:	3f 91       	pop	r19
    3ad2:	2f 91       	pop	r18
    3ad4:	1f 91       	pop	r17
    3ad6:	0f 91       	pop	r16
    3ad8:	ff 90       	pop	r15
    3ada:	ef 90       	pop	r14
    3adc:	df 90       	pop	r13
    3ade:	cf 90       	pop	r12
    3ae0:	bf 90       	pop	r11
    3ae2:	af 90       	pop	r10
    3ae4:	9f 90       	pop	r9
    3ae6:	8f 90       	pop	r8
    3ae8:	7f 90       	pop	r7
    3aea:	6f 90       	pop	r6
    3aec:	5f 90       	pop	r5
    3aee:	4f 90       	pop	r4
    3af0:	3f 90       	pop	r3
    3af2:	2f 90       	pop	r2
    3af4:	1f 90       	pop	r1
    3af6:	0f 90       	pop	r0
    3af8:	0f be       	out	0x3f, r0	; 63
    3afa:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3afc:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    3afe:	81 e0       	ldi	r24, 0x01	; 1
    3b00:	08 95       	ret

00003b02 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3b02:	0f 92       	push	r0
    3b04:	0f b6       	in	r0, 0x3f	; 63
    3b06:	f8 94       	cli
    3b08:	0f 92       	push	r0
    3b0a:	1f 92       	push	r1
    3b0c:	11 24       	eor	r1, r1
    3b0e:	2f 92       	push	r2
    3b10:	3f 92       	push	r3
    3b12:	4f 92       	push	r4
    3b14:	5f 92       	push	r5
    3b16:	6f 92       	push	r6
    3b18:	7f 92       	push	r7
    3b1a:	8f 92       	push	r8
    3b1c:	9f 92       	push	r9
    3b1e:	af 92       	push	r10
    3b20:	bf 92       	push	r11
    3b22:	cf 92       	push	r12
    3b24:	df 92       	push	r13
    3b26:	ef 92       	push	r14
    3b28:	ff 92       	push	r15
    3b2a:	0f 93       	push	r16
    3b2c:	1f 93       	push	r17
    3b2e:	2f 93       	push	r18
    3b30:	3f 93       	push	r19
    3b32:	4f 93       	push	r20
    3b34:	5f 93       	push	r21
    3b36:	6f 93       	push	r22
    3b38:	7f 93       	push	r23
    3b3a:	8f 93       	push	r24
    3b3c:	9f 93       	push	r25
    3b3e:	af 93       	push	r26
    3b40:	bf 93       	push	r27
    3b42:	cf 93       	push	r28
    3b44:	df 93       	push	r29
    3b46:	ef 93       	push	r30
    3b48:	ff 93       	push	r31
    3b4a:	a0 91 41 2d 	lds	r26, 0x2D41	; 0x802d41 <pxCurrentTCB>
    3b4e:	b0 91 42 2d 	lds	r27, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    3b52:	0d b6       	in	r0, 0x3d	; 61
    3b54:	0d 92       	st	X+, r0
    3b56:	0e b6       	in	r0, 0x3e	; 62
    3b58:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3b5a:	0e 94 f9 2a 	call	0x55f2	; 0x55f2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3b5e:	a0 91 41 2d 	lds	r26, 0x2D41	; 0x802d41 <pxCurrentTCB>
    3b62:	b0 91 42 2d 	lds	r27, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    3b66:	cd 91       	ld	r28, X+
    3b68:	cd bf       	out	0x3d, r28	; 61
    3b6a:	dd 91       	ld	r29, X+
    3b6c:	de bf       	out	0x3e, r29	; 62
    3b6e:	ff 91       	pop	r31
    3b70:	ef 91       	pop	r30
    3b72:	df 91       	pop	r29
    3b74:	cf 91       	pop	r28
    3b76:	bf 91       	pop	r27
    3b78:	af 91       	pop	r26
    3b7a:	9f 91       	pop	r25
    3b7c:	8f 91       	pop	r24
    3b7e:	7f 91       	pop	r23
    3b80:	6f 91       	pop	r22
    3b82:	5f 91       	pop	r21
    3b84:	4f 91       	pop	r20
    3b86:	3f 91       	pop	r19
    3b88:	2f 91       	pop	r18
    3b8a:	1f 91       	pop	r17
    3b8c:	0f 91       	pop	r16
    3b8e:	ff 90       	pop	r15
    3b90:	ef 90       	pop	r14
    3b92:	df 90       	pop	r13
    3b94:	cf 90       	pop	r12
    3b96:	bf 90       	pop	r11
    3b98:	af 90       	pop	r10
    3b9a:	9f 90       	pop	r9
    3b9c:	8f 90       	pop	r8
    3b9e:	7f 90       	pop	r7
    3ba0:	6f 90       	pop	r6
    3ba2:	5f 90       	pop	r5
    3ba4:	4f 90       	pop	r4
    3ba6:	3f 90       	pop	r3
    3ba8:	2f 90       	pop	r2
    3baa:	1f 90       	pop	r1
    3bac:	0f 90       	pop	r0
    3bae:	0f be       	out	0x3f, r0	; 63
    3bb0:	0f 90       	pop	r0
	asm volatile ( "ret" );
    3bb2:	08 95       	ret

00003bb4 <vPortYieldISR>:
}*/

//void vPortYieldISR( void ) __attribute__ ( ( naked ) );
void vPortYieldISR( void )
{
	TCC0.CCA=TCC0.CNT+100;
    3bb4:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    3bb8:	90 91 21 08 	lds	r25, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    3bbc:	8c 59       	subi	r24, 0x9C	; 156
    3bbe:	9f 4f       	sbci	r25, 0xFF	; 255
    3bc0:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    3bc4:	90 93 29 08 	sts	0x0829, r25	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
	if (TCC0.CCA>=TCC0.PER) TCC0.CCA-= TCC0.PER;
    3bc8:	20 91 28 08 	lds	r18, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    3bcc:	30 91 29 08 	lds	r19, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    3bd0:	80 91 26 08 	lds	r24, 0x0826	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
    3bd4:	90 91 27 08 	lds	r25, 0x0827	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
    3bd8:	28 17       	cp	r18, r24
    3bda:	39 07       	cpc	r19, r25
    3bdc:	70 f0       	brcs	.+28     	; 0x3bfa <vPortYieldISR+0x46>
    3bde:	20 91 26 08 	lds	r18, 0x0826	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
    3be2:	30 91 27 08 	lds	r19, 0x0827	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
    3be6:	80 91 28 08 	lds	r24, 0x0828	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    3bea:	90 91 29 08 	lds	r25, 0x0829	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
    3bee:	82 1b       	sub	r24, r18
    3bf0:	93 0b       	sbc	r25, r19
    3bf2:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    3bf6:	90 93 29 08 	sts	0x0829, r25	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
	asm volatile ( "ret" );
    3bfa:	08 95       	ret

00003bfc <__vector_14>:
	 * the context is saved at the start of the ISR.  The tick
	 * count is incremented after the context is saved.
	 */	
	ISR(TCC0_OVF_vect,ISR_NAKED)
	{
		portSAVE_CONTEXT();
    3bfc:	0f 92       	push	r0
    3bfe:	0f b6       	in	r0, 0x3f	; 63
    3c00:	f8 94       	cli
    3c02:	0f 92       	push	r0
    3c04:	1f 92       	push	r1
    3c06:	11 24       	eor	r1, r1
    3c08:	2f 92       	push	r2
    3c0a:	3f 92       	push	r3
    3c0c:	4f 92       	push	r4
    3c0e:	5f 92       	push	r5
    3c10:	6f 92       	push	r6
    3c12:	7f 92       	push	r7
    3c14:	8f 92       	push	r8
    3c16:	9f 92       	push	r9
    3c18:	af 92       	push	r10
    3c1a:	bf 92       	push	r11
    3c1c:	cf 92       	push	r12
    3c1e:	df 92       	push	r13
    3c20:	ef 92       	push	r14
    3c22:	ff 92       	push	r15
    3c24:	0f 93       	push	r16
    3c26:	1f 93       	push	r17
    3c28:	2f 93       	push	r18
    3c2a:	3f 93       	push	r19
    3c2c:	4f 93       	push	r20
    3c2e:	5f 93       	push	r21
    3c30:	6f 93       	push	r22
    3c32:	7f 93       	push	r23
    3c34:	8f 93       	push	r24
    3c36:	9f 93       	push	r25
    3c38:	af 93       	push	r26
    3c3a:	bf 93       	push	r27
    3c3c:	cf 93       	push	r28
    3c3e:	df 93       	push	r29
    3c40:	ef 93       	push	r30
    3c42:	ff 93       	push	r31
    3c44:	a0 91 41 2d 	lds	r26, 0x2D41	; 0x802d41 <pxCurrentTCB>
    3c48:	b0 91 42 2d 	lds	r27, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    3c4c:	0d b6       	in	r0, 0x3d	; 61
    3c4e:	0d 92       	st	X+, r0
    3c50:	0e b6       	in	r0, 0x3e	; 62
    3c52:	0d 92       	st	X+, r0
		StatsTimer+=TCC0.PER;
    3c54:	20 91 26 08 	lds	r18, 0x0826	; 0x800826 <__TEXT_REGION_LENGTH__+0x700826>
    3c58:	30 91 27 08 	lds	r19, 0x0827	; 0x800827 <__TEXT_REGION_LENGTH__+0x700827>
    3c5c:	80 91 85 2d 	lds	r24, 0x2D85	; 0x802d85 <StatsTimer>
    3c60:	90 91 86 2d 	lds	r25, 0x2D86	; 0x802d86 <StatsTimer+0x1>
    3c64:	a0 91 87 2d 	lds	r26, 0x2D87	; 0x802d87 <StatsTimer+0x2>
    3c68:	b0 91 88 2d 	lds	r27, 0x2D88	; 0x802d88 <StatsTimer+0x3>
    3c6c:	82 0f       	add	r24, r18
    3c6e:	93 1f       	adc	r25, r19
    3c70:	a1 1d       	adc	r26, r1
    3c72:	b1 1d       	adc	r27, r1
    3c74:	80 93 85 2d 	sts	0x2D85, r24	; 0x802d85 <StatsTimer>
    3c78:	90 93 86 2d 	sts	0x2D86, r25	; 0x802d86 <StatsTimer+0x1>
    3c7c:	a0 93 87 2d 	sts	0x2D87, r26	; 0x802d87 <StatsTimer+0x2>
    3c80:	b0 93 88 2d 	sts	0x2D88, r27	; 0x802d88 <StatsTimer+0x3>
		xTaskIncrementTick();
    3c84:	0e 94 c8 28 	call	0x5190	; 0x5190 <xTaskIncrementTick>
		vTaskSwitchContext();
    3c88:	0e 94 f9 2a 	call	0x55f2	; 0x55f2 <vTaskSwitchContext>
		portRESTORE_CONTEXT();
    3c8c:	a0 91 41 2d 	lds	r26, 0x2D41	; 0x802d41 <pxCurrentTCB>
    3c90:	b0 91 42 2d 	lds	r27, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    3c94:	cd 91       	ld	r28, X+
    3c96:	cd bf       	out	0x3d, r28	; 61
    3c98:	dd 91       	ld	r29, X+
    3c9a:	de bf       	out	0x3e, r29	; 62
    3c9c:	ff 91       	pop	r31
    3c9e:	ef 91       	pop	r30
    3ca0:	df 91       	pop	r29
    3ca2:	cf 91       	pop	r28
    3ca4:	bf 91       	pop	r27
    3ca6:	af 91       	pop	r26
    3ca8:	9f 91       	pop	r25
    3caa:	8f 91       	pop	r24
    3cac:	7f 91       	pop	r23
    3cae:	6f 91       	pop	r22
    3cb0:	5f 91       	pop	r21
    3cb2:	4f 91       	pop	r20
    3cb4:	3f 91       	pop	r19
    3cb6:	2f 91       	pop	r18
    3cb8:	1f 91       	pop	r17
    3cba:	0f 91       	pop	r16
    3cbc:	ff 90       	pop	r15
    3cbe:	ef 90       	pop	r14
    3cc0:	df 90       	pop	r13
    3cc2:	cf 90       	pop	r12
    3cc4:	bf 90       	pop	r11
    3cc6:	af 90       	pop	r10
    3cc8:	9f 90       	pop	r9
    3cca:	8f 90       	pop	r8
    3ccc:	7f 90       	pop	r7
    3cce:	6f 90       	pop	r6
    3cd0:	5f 90       	pop	r5
    3cd2:	4f 90       	pop	r4
    3cd4:	3f 90       	pop	r3
    3cd6:	2f 90       	pop	r2
    3cd8:	1f 90       	pop	r1
    3cda:	0f 90       	pop	r0
    3cdc:	0f be       	out	0x3f, r0	; 63
    3cde:	0f 90       	pop	r0

		asm volatile ( "reti" );
    3ce0:	18 95       	reti

00003ce2 <vConfigureTimerForRunTimeStats>:
 */

volatile uint32_t StatsTimer;

void vConfigureTimerForRunTimeStats(void)
{
    3ce2:	08 95       	ret

00003ce4 <__vector_16>:
	//TCC1.INTCTRLA=0b00000001; //OVF priority LOW
}

ISR(TCC0_CCA_vect,ISR_NAKED)
	{
	portSAVE_CONTEXT();
    3ce4:	0f 92       	push	r0
    3ce6:	0f b6       	in	r0, 0x3f	; 63
    3ce8:	f8 94       	cli
    3cea:	0f 92       	push	r0
    3cec:	1f 92       	push	r1
    3cee:	11 24       	eor	r1, r1
    3cf0:	2f 92       	push	r2
    3cf2:	3f 92       	push	r3
    3cf4:	4f 92       	push	r4
    3cf6:	5f 92       	push	r5
    3cf8:	6f 92       	push	r6
    3cfa:	7f 92       	push	r7
    3cfc:	8f 92       	push	r8
    3cfe:	9f 92       	push	r9
    3d00:	af 92       	push	r10
    3d02:	bf 92       	push	r11
    3d04:	cf 92       	push	r12
    3d06:	df 92       	push	r13
    3d08:	ef 92       	push	r14
    3d0a:	ff 92       	push	r15
    3d0c:	0f 93       	push	r16
    3d0e:	1f 93       	push	r17
    3d10:	2f 93       	push	r18
    3d12:	3f 93       	push	r19
    3d14:	4f 93       	push	r20
    3d16:	5f 93       	push	r21
    3d18:	6f 93       	push	r22
    3d1a:	7f 93       	push	r23
    3d1c:	8f 93       	push	r24
    3d1e:	9f 93       	push	r25
    3d20:	af 93       	push	r26
    3d22:	bf 93       	push	r27
    3d24:	cf 93       	push	r28
    3d26:	df 93       	push	r29
    3d28:	ef 93       	push	r30
    3d2a:	ff 93       	push	r31
    3d2c:	a0 91 41 2d 	lds	r26, 0x2D41	; 0x802d41 <pxCurrentTCB>
    3d30:	b0 91 42 2d 	lds	r27, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    3d34:	0d b6       	in	r0, 0x3d	; 61
    3d36:	0d 92       	st	X+, r0
    3d38:	0e b6       	in	r0, 0x3e	; 62
    3d3a:	0d 92       	st	X+, r0
	TCC0.CCA=65535;
    3d3c:	8f ef       	ldi	r24, 0xFF	; 255
    3d3e:	9f ef       	ldi	r25, 0xFF	; 255
    3d40:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    3d44:	90 93 29 08 	sts	0x0829, r25	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
	vTaskSwitchContext();
    3d48:	0e 94 f9 2a 	call	0x55f2	; 0x55f2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3d4c:	a0 91 41 2d 	lds	r26, 0x2D41	; 0x802d41 <pxCurrentTCB>
    3d50:	b0 91 42 2d 	lds	r27, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    3d54:	cd 91       	ld	r28, X+
    3d56:	cd bf       	out	0x3d, r28	; 61
    3d58:	dd 91       	ld	r29, X+
    3d5a:	de bf       	out	0x3e, r29	; 62
    3d5c:	ff 91       	pop	r31
    3d5e:	ef 91       	pop	r30
    3d60:	df 91       	pop	r29
    3d62:	cf 91       	pop	r28
    3d64:	bf 91       	pop	r27
    3d66:	af 91       	pop	r26
    3d68:	9f 91       	pop	r25
    3d6a:	8f 91       	pop	r24
    3d6c:	7f 91       	pop	r23
    3d6e:	6f 91       	pop	r22
    3d70:	5f 91       	pop	r21
    3d72:	4f 91       	pop	r20
    3d74:	3f 91       	pop	r19
    3d76:	2f 91       	pop	r18
    3d78:	1f 91       	pop	r17
    3d7a:	0f 91       	pop	r16
    3d7c:	ff 90       	pop	r15
    3d7e:	ef 90       	pop	r14
    3d80:	df 90       	pop	r13
    3d82:	cf 90       	pop	r12
    3d84:	bf 90       	pop	r11
    3d86:	af 90       	pop	r10
    3d88:	9f 90       	pop	r9
    3d8a:	8f 90       	pop	r8
    3d8c:	7f 90       	pop	r7
    3d8e:	6f 90       	pop	r6
    3d90:	5f 90       	pop	r5
    3d92:	4f 90       	pop	r4
    3d94:	3f 90       	pop	r3
    3d96:	2f 90       	pop	r2
    3d98:	1f 90       	pop	r1
    3d9a:	0f 90       	pop	r0
    3d9c:	0f be       	out	0x3f, r0	; 63
    3d9e:	0f 90       	pop	r0
	asm volatile ( "reti" );
    3da0:	18 95       	reti

00003da2 <prvCopyDataToQueue>:
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;

	configASSERT( pxQueue );
    3da2:	0f 93       	push	r16
    3da4:	1f 93       	push	r17
    3da6:	cf 93       	push	r28
    3da8:	df 93       	push	r29
    3daa:	ec 01       	movw	r28, r24
    3dac:	04 2f       	mov	r16, r20
    3dae:	1a 8d       	ldd	r17, Y+26	; 0x1a
    3db0:	4c 8d       	ldd	r20, Y+28	; 0x1c
    3db2:	41 11       	cpse	r20, r1
    3db4:	0d c0       	rjmp	.+26     	; 0x3dd0 <prvCopyDataToQueue+0x2e>
    3db6:	88 81       	ld	r24, Y
    3db8:	99 81       	ldd	r25, Y+1	; 0x01
    3dba:	89 2b       	or	r24, r25
    3dbc:	09 f4       	brne	.+2      	; 0x3dc0 <prvCopyDataToQueue+0x1e>
    3dbe:	43 c0       	rjmp	.+134    	; 0x3e46 <prvCopyDataToQueue+0xa4>
    3dc0:	1f 5f       	subi	r17, 0xFF	; 255
    3dc2:	80 e0       	ldi	r24, 0x00	; 0
    3dc4:	1a 8f       	std	Y+26, r17	; 0x1a
    3dc6:	df 91       	pop	r29
    3dc8:	cf 91       	pop	r28
    3dca:	1f 91       	pop	r17
    3dcc:	0f 91       	pop	r16
    3dce:	08 95       	ret
    3dd0:	50 e0       	ldi	r21, 0x00	; 0
    3dd2:	01 11       	cpse	r16, r1
    3dd4:	15 c0       	rjmp	.+42     	; 0x3e00 <prvCopyDataToQueue+0x5e>
    3dd6:	8a 81       	ldd	r24, Y+2	; 0x02
    3dd8:	9b 81       	ldd	r25, Y+3	; 0x03
    3dda:	0e 94 87 4c 	call	0x990e	; 0x990e <memcpy>
    3dde:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3de0:	8a 81       	ldd	r24, Y+2	; 0x02
    3de2:	9b 81       	ldd	r25, Y+3	; 0x03
    3de4:	82 0f       	add	r24, r18
    3de6:	91 1d       	adc	r25, r1
    3de8:	8a 83       	std	Y+2, r24	; 0x02
    3dea:	9b 83       	std	Y+3, r25	; 0x03
    3dec:	2c 81       	ldd	r18, Y+4	; 0x04
    3dee:	3d 81       	ldd	r19, Y+5	; 0x05
    3df0:	82 17       	cp	r24, r18
    3df2:	93 07       	cpc	r25, r19
    3df4:	28 f3       	brcs	.-54     	; 0x3dc0 <prvCopyDataToQueue+0x1e>
    3df6:	88 81       	ld	r24, Y
    3df8:	99 81       	ldd	r25, Y+1	; 0x01
    3dfa:	8a 83       	std	Y+2, r24	; 0x02
    3dfc:	9b 83       	std	Y+3, r25	; 0x03
    3dfe:	e0 cf       	rjmp	.-64     	; 0x3dc0 <prvCopyDataToQueue+0x1e>
    3e00:	8e 81       	ldd	r24, Y+6	; 0x06
    3e02:	9f 81       	ldd	r25, Y+7	; 0x07
    3e04:	0e 94 87 4c 	call	0x990e	; 0x990e <memcpy>
    3e08:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3e0a:	90 e0       	ldi	r25, 0x00	; 0
    3e0c:	91 95       	neg	r25
    3e0e:	81 95       	neg	r24
    3e10:	91 09       	sbc	r25, r1
    3e12:	2e 81       	ldd	r18, Y+6	; 0x06
    3e14:	3f 81       	ldd	r19, Y+7	; 0x07
    3e16:	28 0f       	add	r18, r24
    3e18:	39 1f       	adc	r19, r25
    3e1a:	2e 83       	std	Y+6, r18	; 0x06
    3e1c:	3f 83       	std	Y+7, r19	; 0x07
    3e1e:	48 81       	ld	r20, Y
    3e20:	59 81       	ldd	r21, Y+1	; 0x01
    3e22:	24 17       	cp	r18, r20
    3e24:	35 07       	cpc	r19, r21
    3e26:	30 f4       	brcc	.+12     	; 0x3e34 <prvCopyDataToQueue+0x92>
    3e28:	2c 81       	ldd	r18, Y+4	; 0x04
    3e2a:	3d 81       	ldd	r19, Y+5	; 0x05
    3e2c:	82 0f       	add	r24, r18
    3e2e:	93 1f       	adc	r25, r19
    3e30:	8e 83       	std	Y+6, r24	; 0x06
    3e32:	9f 83       	std	Y+7, r25	; 0x07
    3e34:	02 30       	cpi	r16, 0x02	; 2
    3e36:	21 f6       	brne	.-120    	; 0x3dc0 <prvCopyDataToQueue+0x1e>
    3e38:	11 23       	and	r17, r17
    3e3a:	11 f0       	breq	.+4      	; 0x3e40 <prvCopyDataToQueue+0x9e>
    3e3c:	80 e0       	ldi	r24, 0x00	; 0
    3e3e:	c2 cf       	rjmp	.-124    	; 0x3dc4 <prvCopyDataToQueue+0x22>
    3e40:	11 e0       	ldi	r17, 0x01	; 1
    3e42:	80 e0       	ldi	r24, 0x00	; 0
    3e44:	bf cf       	rjmp	.-130    	; 0x3dc4 <prvCopyDataToQueue+0x22>
    3e46:	8c 81       	ldd	r24, Y+4	; 0x04
    3e48:	9d 81       	ldd	r25, Y+5	; 0x05
    3e4a:	0e 94 07 2e 	call	0x5c0e	; 0x5c0e <xTaskPriorityDisinherit>
    3e4e:	1c 82       	std	Y+4, r1	; 0x04
    3e50:	1d 82       	std	Y+5, r1	; 0x05
    3e52:	1f 5f       	subi	r17, 0xFF	; 255
    3e54:	b7 cf       	rjmp	.-146    	; 0x3dc4 <prvCopyDataToQueue+0x22>

00003e56 <prvCopyDataFromQueue>:
    3e56:	fc 01       	movw	r30, r24
    3e58:	cb 01       	movw	r24, r22
    3e5a:	44 8d       	ldd	r20, Z+28	; 0x1c
    3e5c:	44 23       	and	r20, r20
    3e5e:	91 f0       	breq	.+36     	; 0x3e84 <prvCopyDataFromQueue+0x2e>
    3e60:	50 e0       	ldi	r21, 0x00	; 0
    3e62:	66 81       	ldd	r22, Z+6	; 0x06
    3e64:	77 81       	ldd	r23, Z+7	; 0x07
    3e66:	64 0f       	add	r22, r20
    3e68:	75 1f       	adc	r23, r21
    3e6a:	66 83       	std	Z+6, r22	; 0x06
    3e6c:	77 83       	std	Z+7, r23	; 0x07
    3e6e:	24 81       	ldd	r18, Z+4	; 0x04
    3e70:	35 81       	ldd	r19, Z+5	; 0x05
    3e72:	62 17       	cp	r22, r18
    3e74:	73 07       	cpc	r23, r19
    3e76:	20 f0       	brcs	.+8      	; 0x3e80 <prvCopyDataFromQueue+0x2a>
    3e78:	60 81       	ld	r22, Z
    3e7a:	71 81       	ldd	r23, Z+1	; 0x01
    3e7c:	66 83       	std	Z+6, r22	; 0x06
    3e7e:	77 83       	std	Z+7, r23	; 0x07
    3e80:	0c 94 87 4c 	jmp	0x990e	; 0x990e <memcpy>
    3e84:	08 95       	ret

00003e86 <prvUnlockQueue>:
    3e86:	ef 92       	push	r14
    3e88:	ff 92       	push	r15
    3e8a:	0f 93       	push	r16
    3e8c:	1f 93       	push	r17
    3e8e:	cf 93       	push	r28
    3e90:	8c 01       	movw	r16, r24
    3e92:	0f b6       	in	r0, 0x3f	; 63
    3e94:	f8 94       	cli
    3e96:	0f 92       	push	r0
    3e98:	fc 01       	movw	r30, r24
    3e9a:	c6 8d       	ldd	r28, Z+30	; 0x1e
    3e9c:	1c 16       	cp	r1, r28
    3e9e:	c4 f4       	brge	.+48     	; 0x3ed0 <prvUnlockQueue+0x4a>
    3ea0:	fc 01       	movw	r30, r24
    3ea2:	81 89       	ldd	r24, Z+17	; 0x11
    3ea4:	88 23       	and	r24, r24
    3ea6:	a1 f0       	breq	.+40     	; 0x3ed0 <prvUnlockQueue+0x4a>
    3ea8:	78 01       	movw	r14, r16
    3eaa:	f1 e1       	ldi	r31, 0x11	; 17
    3eac:	ef 0e       	add	r14, r31
    3eae:	f1 1c       	adc	r15, r1
    3eb0:	06 c0       	rjmp	.+12     	; 0x3ebe <prvUnlockQueue+0x38>
    3eb2:	c1 50       	subi	r28, 0x01	; 1
    3eb4:	69 f0       	breq	.+26     	; 0x3ed0 <prvUnlockQueue+0x4a>
    3eb6:	f8 01       	movw	r30, r16
    3eb8:	81 89       	ldd	r24, Z+17	; 0x11
    3eba:	88 23       	and	r24, r24
    3ebc:	49 f0       	breq	.+18     	; 0x3ed0 <prvUnlockQueue+0x4a>
    3ebe:	c7 01       	movw	r24, r14
    3ec0:	0e 94 23 2b 	call	0x5646	; 0x5646 <xTaskRemoveFromEventList>
    3ec4:	88 23       	and	r24, r24
    3ec6:	a9 f3       	breq	.-22     	; 0x3eb2 <prvUnlockQueue+0x2c>
    3ec8:	0e 94 f6 2b 	call	0x57ec	; 0x57ec <vTaskMissedYield>
    3ecc:	c1 50       	subi	r28, 0x01	; 1
    3ece:	99 f7       	brne	.-26     	; 0x3eb6 <prvUnlockQueue+0x30>
    3ed0:	8f ef       	ldi	r24, 0xFF	; 255
    3ed2:	f8 01       	movw	r30, r16
    3ed4:	86 8f       	std	Z+30, r24	; 0x1e
    3ed6:	0f 90       	pop	r0
    3ed8:	0f be       	out	0x3f, r0	; 63
    3eda:	0f b6       	in	r0, 0x3f	; 63
    3edc:	f8 94       	cli
    3ede:	0f 92       	push	r0
    3ee0:	c5 8d       	ldd	r28, Z+29	; 0x1d
    3ee2:	1c 16       	cp	r1, r28
    3ee4:	c4 f4       	brge	.+48     	; 0x3f16 <prvUnlockQueue+0x90>
    3ee6:	f8 01       	movw	r30, r16
    3ee8:	80 85       	ldd	r24, Z+8	; 0x08
    3eea:	88 23       	and	r24, r24
    3eec:	a1 f0       	breq	.+40     	; 0x3f16 <prvUnlockQueue+0x90>
    3eee:	78 01       	movw	r14, r16
    3ef0:	f8 e0       	ldi	r31, 0x08	; 8
    3ef2:	ef 0e       	add	r14, r31
    3ef4:	f1 1c       	adc	r15, r1
    3ef6:	06 c0       	rjmp	.+12     	; 0x3f04 <prvUnlockQueue+0x7e>
    3ef8:	c1 50       	subi	r28, 0x01	; 1
    3efa:	69 f0       	breq	.+26     	; 0x3f16 <prvUnlockQueue+0x90>
    3efc:	f8 01       	movw	r30, r16
    3efe:	80 85       	ldd	r24, Z+8	; 0x08
    3f00:	88 23       	and	r24, r24
    3f02:	49 f0       	breq	.+18     	; 0x3f16 <prvUnlockQueue+0x90>
    3f04:	c7 01       	movw	r24, r14
    3f06:	0e 94 23 2b 	call	0x5646	; 0x5646 <xTaskRemoveFromEventList>
    3f0a:	88 23       	and	r24, r24
    3f0c:	a9 f3       	breq	.-22     	; 0x3ef8 <prvUnlockQueue+0x72>
    3f0e:	0e 94 f6 2b 	call	0x57ec	; 0x57ec <vTaskMissedYield>
    3f12:	c1 50       	subi	r28, 0x01	; 1
    3f14:	99 f7       	brne	.-26     	; 0x3efc <prvUnlockQueue+0x76>
    3f16:	8f ef       	ldi	r24, 0xFF	; 255
    3f18:	f8 01       	movw	r30, r16
    3f1a:	85 8f       	std	Z+29, r24	; 0x1d
    3f1c:	0f 90       	pop	r0
    3f1e:	0f be       	out	0x3f, r0	; 63
    3f20:	cf 91       	pop	r28
    3f22:	1f 91       	pop	r17
    3f24:	0f 91       	pop	r16
    3f26:	ff 90       	pop	r15
    3f28:	ef 90       	pop	r14
    3f2a:	08 95       	ret

00003f2c <xQueueGenericReset>:
    3f2c:	1f 93       	push	r17
    3f2e:	cf 93       	push	r28
    3f30:	df 93       	push	r29
    3f32:	ec 01       	movw	r28, r24
    3f34:	16 2f       	mov	r17, r22
    3f36:	89 2b       	or	r24, r25
    3f38:	09 f4       	brne	.+2      	; 0x3f3c <xQueueGenericReset+0x10>
    3f3a:	3e c0       	rjmp	.+124    	; 0x3fb8 <xQueueGenericReset+0x8c>
    3f3c:	0f b6       	in	r0, 0x3f	; 63
    3f3e:	f8 94       	cli
    3f40:	0f 92       	push	r0
    3f42:	48 81       	ld	r20, Y
    3f44:	59 81       	ldd	r21, Y+1	; 0x01
    3f46:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3f48:	6c 8d       	ldd	r22, Y+28	; 0x1c
    3f4a:	9a 01       	movw	r18, r20
    3f4c:	86 9f       	mul	r24, r22
    3f4e:	20 0d       	add	r18, r0
    3f50:	31 1d       	adc	r19, r1
    3f52:	11 24       	eor	r1, r1
    3f54:	2c 83       	std	Y+4, r18	; 0x04
    3f56:	3d 83       	std	Y+5, r19	; 0x05
    3f58:	1a 8e       	std	Y+26, r1	; 0x1a
    3f5a:	4a 83       	std	Y+2, r20	; 0x02
    3f5c:	5b 83       	std	Y+3, r21	; 0x03
    3f5e:	90 e0       	ldi	r25, 0x00	; 0
    3f60:	01 97       	sbiw	r24, 0x01	; 1
    3f62:	68 9f       	mul	r22, r24
    3f64:	90 01       	movw	r18, r0
    3f66:	69 9f       	mul	r22, r25
    3f68:	30 0d       	add	r19, r0
    3f6a:	11 24       	eor	r1, r1
    3f6c:	ca 01       	movw	r24, r20
    3f6e:	82 0f       	add	r24, r18
    3f70:	93 1f       	adc	r25, r19
    3f72:	8e 83       	std	Y+6, r24	; 0x06
    3f74:	9f 83       	std	Y+7, r25	; 0x07
    3f76:	8f ef       	ldi	r24, 0xFF	; 255
    3f78:	8d 8f       	std	Y+29, r24	; 0x1d
    3f7a:	8e 8f       	std	Y+30, r24	; 0x1e
    3f7c:	11 11       	cpse	r17, r1
    3f7e:	13 c0       	rjmp	.+38     	; 0x3fa6 <xQueueGenericReset+0x7a>
    3f80:	88 85       	ldd	r24, Y+8	; 0x08
    3f82:	81 11       	cpse	r24, r1
    3f84:	07 c0       	rjmp	.+14     	; 0x3f94 <xQueueGenericReset+0x68>
    3f86:	0f 90       	pop	r0
    3f88:	0f be       	out	0x3f, r0	; 63
    3f8a:	81 e0       	ldi	r24, 0x01	; 1
    3f8c:	df 91       	pop	r29
    3f8e:	cf 91       	pop	r28
    3f90:	1f 91       	pop	r17
    3f92:	08 95       	ret
    3f94:	ce 01       	movw	r24, r28
    3f96:	08 96       	adiw	r24, 0x08	; 8
    3f98:	0e 94 23 2b 	call	0x5646	; 0x5646 <xTaskRemoveFromEventList>
    3f9c:	88 23       	and	r24, r24
    3f9e:	99 f3       	breq	.-26     	; 0x3f86 <xQueueGenericReset+0x5a>
    3fa0:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <vPortYield>
    3fa4:	f0 cf       	rjmp	.-32     	; 0x3f86 <xQueueGenericReset+0x5a>
    3fa6:	ce 01       	movw	r24, r28
    3fa8:	08 96       	adiw	r24, 0x08	; 8
    3faa:	0e 94 4c 1c 	call	0x3898	; 0x3898 <vListInitialise>
    3fae:	ce 01       	movw	r24, r28
    3fb0:	41 96       	adiw	r24, 0x11	; 17
    3fb2:	0e 94 4c 1c 	call	0x3898	; 0x3898 <vListInitialise>
    3fb6:	e7 cf       	rjmp	.-50     	; 0x3f86 <xQueueGenericReset+0x5a>
    3fb8:	63 e0       	ldi	r22, 0x03	; 3
    3fba:	71 e0       	ldi	r23, 0x01	; 1
    3fbc:	8f e6       	ldi	r24, 0x6F	; 111
    3fbe:	93 e2       	ldi	r25, 0x23	; 35
    3fc0:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    3fc4:	bb cf       	rjmp	.-138    	; 0x3f3c <xQueueGenericReset+0x10>

00003fc6 <xQueueGenericCreate>:
    3fc6:	ff 92       	push	r15
    3fc8:	0f 93       	push	r16
    3fca:	1f 93       	push	r17
    3fcc:	cf 93       	push	r28
    3fce:	df 93       	push	r29
    3fd0:	18 2f       	mov	r17, r24
    3fd2:	06 2f       	mov	r16, r22
    3fd4:	f4 2e       	mov	r15, r20
    3fd6:	88 23       	and	r24, r24
    3fd8:	99 f1       	breq	.+102    	; 0x4040 <xQueueGenericCreate+0x7a>
    3fda:	00 23       	and	r16, r16
    3fdc:	d1 f0       	breq	.+52     	; 0x4012 <xQueueGenericCreate+0x4c>
    3fde:	10 9f       	mul	r17, r16
    3fe0:	c0 01       	movw	r24, r0
    3fe2:	11 24       	eor	r1, r1
    3fe4:	81 96       	adiw	r24, 0x21	; 33
    3fe6:	0e 94 7d 1b 	call	0x36fa	; 0x36fa <pvPortMalloc>
    3fea:	ec 01       	movw	r28, r24
    3fec:	00 97       	sbiw	r24, 0x00	; 0
    3fee:	51 f0       	breq	.+20     	; 0x4004 <xQueueGenericCreate+0x3e>
    3ff0:	81 96       	adiw	r24, 0x21	; 33
    3ff2:	88 83       	st	Y, r24
    3ff4:	99 83       	std	Y+1, r25	; 0x01
    3ff6:	1b 8f       	std	Y+27, r17	; 0x1b
    3ff8:	0c 8f       	std	Y+28, r16	; 0x1c
    3ffa:	61 e0       	ldi	r22, 0x01	; 1
    3ffc:	ce 01       	movw	r24, r28
    3ffe:	0e 94 96 1f 	call	0x3f2c	; 0x3f2c <xQueueGenericReset>
    4002:	f8 a2       	std	Y+32, r15	; 0x20
    4004:	ce 01       	movw	r24, r28
    4006:	df 91       	pop	r29
    4008:	cf 91       	pop	r28
    400a:	1f 91       	pop	r17
    400c:	0f 91       	pop	r16
    400e:	ff 90       	pop	r15
    4010:	08 95       	ret
    4012:	81 e2       	ldi	r24, 0x21	; 33
    4014:	90 e0       	ldi	r25, 0x00	; 0
    4016:	0e 94 7d 1b 	call	0x36fa	; 0x36fa <pvPortMalloc>
    401a:	ec 01       	movw	r28, r24
    401c:	89 2b       	or	r24, r25
    401e:	91 f3       	breq	.-28     	; 0x4004 <xQueueGenericCreate+0x3e>
    4020:	c8 83       	st	Y, r28
    4022:	d9 83       	std	Y+1, r29	; 0x01
    4024:	1b 8f       	std	Y+27, r17	; 0x1b
    4026:	0c 8f       	std	Y+28, r16	; 0x1c
    4028:	61 e0       	ldi	r22, 0x01	; 1
    402a:	ce 01       	movw	r24, r28
    402c:	0e 94 96 1f 	call	0x3f2c	; 0x3f2c <xQueueGenericReset>
    4030:	f8 a2       	std	Y+32, r15	; 0x20
    4032:	ce 01       	movw	r24, r28
    4034:	df 91       	pop	r29
    4036:	cf 91       	pop	r28
    4038:	1f 91       	pop	r17
    403a:	0f 91       	pop	r16
    403c:	ff 90       	pop	r15
    403e:	08 95       	ret
    4040:	66 e7       	ldi	r22, 0x76	; 118
    4042:	71 e0       	ldi	r23, 0x01	; 1
    4044:	8f e6       	ldi	r24, 0x6F	; 111
    4046:	93 e2       	ldi	r25, 0x23	; 35
    4048:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    404c:	c6 cf       	rjmp	.-116    	; 0x3fda <xQueueGenericCreate+0x14>

0000404e <xQueueGenericSend>:
    404e:	bf 92       	push	r11
    4050:	cf 92       	push	r12
    4052:	df 92       	push	r13
    4054:	ef 92       	push	r14
    4056:	ff 92       	push	r15
    4058:	0f 93       	push	r16
    405a:	1f 93       	push	r17
    405c:	cf 93       	push	r28
    405e:	df 93       	push	r29
    4060:	cd b7       	in	r28, 0x3d	; 61
    4062:	de b7       	in	r29, 0x3e	; 62
    4064:	25 97       	sbiw	r28, 0x05	; 5
    4066:	cd bf       	out	0x3d, r28	; 61
    4068:	de bf       	out	0x3e, r29	; 62
    406a:	8c 01       	movw	r16, r24
    406c:	6b 01       	movw	r12, r22
    406e:	4c 83       	std	Y+4, r20	; 0x04
    4070:	5d 83       	std	Y+5, r21	; 0x05
    4072:	b2 2e       	mov	r11, r18
    4074:	89 2b       	or	r24, r25
    4076:	09 f4       	brne	.+2      	; 0x407a <xQueueGenericSend+0x2c>
    4078:	b2 c0       	rjmp	.+356    	; 0x41de <xQueueGenericSend+0x190>
    407a:	c1 14       	cp	r12, r1
    407c:	d1 04       	cpc	r13, r1
    407e:	09 f4       	brne	.+2      	; 0x4082 <xQueueGenericSend+0x34>
    4080:	a2 c0       	rjmp	.+324    	; 0x41c6 <xQueueGenericSend+0x178>
    4082:	f2 e0       	ldi	r31, 0x02	; 2
    4084:	bf 16       	cp	r11, r31
    4086:	09 f4       	brne	.+2      	; 0x408a <xQueueGenericSend+0x3c>
    4088:	7d c0       	rjmp	.+250    	; 0x4184 <xQueueGenericSend+0x136>
    408a:	f8 01       	movw	r30, r16
    408c:	83 8d       	ldd	r24, Z+27	; 0x1b
    408e:	20 e0       	ldi	r18, 0x00	; 0
    4090:	78 01       	movw	r14, r16
    4092:	f8 e0       	ldi	r31, 0x08	; 8
    4094:	ef 0e       	add	r14, r31
    4096:	f1 1c       	adc	r15, r1
    4098:	10 c0       	rjmp	.+32     	; 0x40ba <xQueueGenericSend+0x6c>
    409a:	6c 81       	ldd	r22, Y+4	; 0x04
    409c:	7d 81       	ldd	r23, Y+5	; 0x05
    409e:	c7 01       	movw	r24, r14
    40a0:	0e 94 03 2b 	call	0x5606	; 0x5606 <vTaskPlaceOnEventList>
    40a4:	c8 01       	movw	r24, r16
    40a6:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
    40aa:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
    40ae:	88 23       	and	r24, r24
    40b0:	09 f4       	brne	.+2      	; 0x40b4 <xQueueGenericSend+0x66>
    40b2:	4a c0       	rjmp	.+148    	; 0x4148 <xQueueGenericSend+0xfa>
    40b4:	f8 01       	movw	r30, r16
    40b6:	83 8d       	ldd	r24, Z+27	; 0x1b
    40b8:	21 e0       	ldi	r18, 0x01	; 1
    40ba:	0f b6       	in	r0, 0x3f	; 63
    40bc:	f8 94       	cli
    40be:	0f 92       	push	r0
    40c0:	f8 01       	movw	r30, r16
    40c2:	92 8d       	ldd	r25, Z+26	; 0x1a
    40c4:	98 17       	cp	r25, r24
    40c6:	08 f4       	brcc	.+2      	; 0x40ca <xQueueGenericSend+0x7c>
    40c8:	42 c0       	rjmp	.+132    	; 0x414e <xQueueGenericSend+0x100>
    40ca:	f2 e0       	ldi	r31, 0x02	; 2
    40cc:	bf 16       	cp	r11, r31
    40ce:	09 f4       	brne	.+2      	; 0x40d2 <xQueueGenericSend+0x84>
    40d0:	3e c0       	rjmp	.+124    	; 0x414e <xQueueGenericSend+0x100>
    40d2:	8c 81       	ldd	r24, Y+4	; 0x04
    40d4:	9d 81       	ldd	r25, Y+5	; 0x05
    40d6:	89 2b       	or	r24, r25
    40d8:	09 f4       	brne	.+2      	; 0x40dc <xQueueGenericSend+0x8e>
    40da:	60 c0       	rjmp	.+192    	; 0x419c <xQueueGenericSend+0x14e>
    40dc:	22 23       	and	r18, r18
    40de:	59 f1       	breq	.+86     	; 0x4136 <xQueueGenericSend+0xe8>
    40e0:	0f 90       	pop	r0
    40e2:	0f be       	out	0x3f, r0	; 63
    40e4:	0e 94 a6 28 	call	0x514c	; 0x514c <vTaskSuspendAll>
    40e8:	0f b6       	in	r0, 0x3f	; 63
    40ea:	f8 94       	cli
    40ec:	0f 92       	push	r0
    40ee:	f8 01       	movw	r30, r16
    40f0:	85 8d       	ldd	r24, Z+29	; 0x1d
    40f2:	8f 3f       	cpi	r24, 0xFF	; 255
    40f4:	39 f1       	breq	.+78     	; 0x4144 <xQueueGenericSend+0xf6>
    40f6:	f8 01       	movw	r30, r16
    40f8:	86 8d       	ldd	r24, Z+30	; 0x1e
    40fa:	8f 3f       	cpi	r24, 0xFF	; 255
    40fc:	09 f1       	breq	.+66     	; 0x4140 <xQueueGenericSend+0xf2>
    40fe:	0f 90       	pop	r0
    4100:	0f be       	out	0x3f, r0	; 63
    4102:	be 01       	movw	r22, r28
    4104:	6c 5f       	subi	r22, 0xFC	; 252
    4106:	7f 4f       	sbci	r23, 0xFF	; 255
    4108:	ce 01       	movw	r24, r28
    410a:	01 96       	adiw	r24, 0x01	; 1
    410c:	0e 94 9f 2b 	call	0x573e	; 0x573e <xTaskCheckForTimeOut>
    4110:	81 11       	cpse	r24, r1
    4112:	48 c0       	rjmp	.+144    	; 0x41a4 <xQueueGenericSend+0x156>
    4114:	0f b6       	in	r0, 0x3f	; 63
    4116:	f8 94       	cli
    4118:	0f 92       	push	r0
    411a:	f8 01       	movw	r30, r16
    411c:	92 8d       	ldd	r25, Z+26	; 0x1a
    411e:	0f 90       	pop	r0
    4120:	0f be       	out	0x3f, r0	; 63
    4122:	83 8d       	ldd	r24, Z+27	; 0x1b
    4124:	98 17       	cp	r25, r24
    4126:	09 f4       	brne	.+2      	; 0x412a <xQueueGenericSend+0xdc>
    4128:	b8 cf       	rjmp	.-144    	; 0x409a <xQueueGenericSend+0x4c>
    412a:	c8 01       	movw	r24, r16
    412c:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
    4130:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
    4134:	bf cf       	rjmp	.-130    	; 0x40b4 <xQueueGenericSend+0x66>
    4136:	ce 01       	movw	r24, r28
    4138:	01 96       	adiw	r24, 0x01	; 1
    413a:	0e 94 94 2b 	call	0x5728	; 0x5728 <vTaskInternalSetTimeOutState>
    413e:	d0 cf       	rjmp	.-96     	; 0x40e0 <xQueueGenericSend+0x92>
    4140:	16 8e       	std	Z+30, r1	; 0x1e
    4142:	dd cf       	rjmp	.-70     	; 0x40fe <xQueueGenericSend+0xb0>
    4144:	15 8e       	std	Z+29, r1	; 0x1d
    4146:	d7 cf       	rjmp	.-82     	; 0x40f6 <xQueueGenericSend+0xa8>
    4148:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <vPortYield>
    414c:	b3 cf       	rjmp	.-154    	; 0x40b4 <xQueueGenericSend+0x66>
    414e:	4b 2d       	mov	r20, r11
    4150:	b6 01       	movw	r22, r12
    4152:	c8 01       	movw	r24, r16
    4154:	0e 94 d1 1e 	call	0x3da2	; 0x3da2 <prvCopyDataToQueue>
    4158:	f8 01       	movw	r30, r16
    415a:	91 89       	ldd	r25, Z+17	; 0x11
    415c:	91 11       	cpse	r25, r1
    415e:	2c c0       	rjmp	.+88     	; 0x41b8 <xQueueGenericSend+0x16a>
    4160:	81 11       	cpse	r24, r1
    4162:	27 c0       	rjmp	.+78     	; 0x41b2 <xQueueGenericSend+0x164>
    4164:	0f 90       	pop	r0
    4166:	0f be       	out	0x3f, r0	; 63
    4168:	81 e0       	ldi	r24, 0x01	; 1
    416a:	25 96       	adiw	r28, 0x05	; 5
    416c:	cd bf       	out	0x3d, r28	; 61
    416e:	de bf       	out	0x3e, r29	; 62
    4170:	df 91       	pop	r29
    4172:	cf 91       	pop	r28
    4174:	1f 91       	pop	r17
    4176:	0f 91       	pop	r16
    4178:	ff 90       	pop	r15
    417a:	ef 90       	pop	r14
    417c:	df 90       	pop	r13
    417e:	cf 90       	pop	r12
    4180:	bf 90       	pop	r11
    4182:	08 95       	ret
    4184:	f8 01       	movw	r30, r16
    4186:	83 8d       	ldd	r24, Z+27	; 0x1b
    4188:	81 30       	cpi	r24, 0x01	; 1
    418a:	09 f4       	brne	.+2      	; 0x418e <xQueueGenericSend+0x140>
    418c:	80 cf       	rjmp	.-256    	; 0x408e <xQueueGenericSend+0x40>
    418e:	63 ef       	ldi	r22, 0xF3	; 243
    4190:	72 e0       	ldi	r23, 0x02	; 2
    4192:	8f e6       	ldi	r24, 0x6F	; 111
    4194:	93 e2       	ldi	r25, 0x23	; 35
    4196:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    419a:	77 cf       	rjmp	.-274    	; 0x408a <xQueueGenericSend+0x3c>
    419c:	0f 90       	pop	r0
    419e:	0f be       	out	0x3f, r0	; 63
    41a0:	80 e0       	ldi	r24, 0x00	; 0
    41a2:	e3 cf       	rjmp	.-58     	; 0x416a <xQueueGenericSend+0x11c>
    41a4:	c8 01       	movw	r24, r16
    41a6:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
    41aa:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
    41ae:	80 e0       	ldi	r24, 0x00	; 0
    41b0:	dc cf       	rjmp	.-72     	; 0x416a <xQueueGenericSend+0x11c>
    41b2:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <vPortYield>
    41b6:	d6 cf       	rjmp	.-84     	; 0x4164 <xQueueGenericSend+0x116>
    41b8:	c8 01       	movw	r24, r16
    41ba:	41 96       	adiw	r24, 0x11	; 17
    41bc:	0e 94 23 2b 	call	0x5646	; 0x5646 <xTaskRemoveFromEventList>
    41c0:	88 23       	and	r24, r24
    41c2:	81 f2       	breq	.-96     	; 0x4164 <xQueueGenericSend+0x116>
    41c4:	f6 cf       	rjmp	.-20     	; 0x41b2 <xQueueGenericSend+0x164>
    41c6:	f8 01       	movw	r30, r16
    41c8:	84 8d       	ldd	r24, Z+28	; 0x1c
    41ca:	88 23       	and	r24, r24
    41cc:	09 f4       	brne	.+2      	; 0x41d0 <xQueueGenericSend+0x182>
    41ce:	59 cf       	rjmp	.-334    	; 0x4082 <xQueueGenericSend+0x34>
    41d0:	62 ef       	ldi	r22, 0xF2	; 242
    41d2:	72 e0       	ldi	r23, 0x02	; 2
    41d4:	8f e6       	ldi	r24, 0x6F	; 111
    41d6:	93 e2       	ldi	r25, 0x23	; 35
    41d8:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    41dc:	52 cf       	rjmp	.-348    	; 0x4082 <xQueueGenericSend+0x34>
    41de:	61 ef       	ldi	r22, 0xF1	; 241
    41e0:	72 e0       	ldi	r23, 0x02	; 2
    41e2:	8f e6       	ldi	r24, 0x6F	; 111
    41e4:	93 e2       	ldi	r25, 0x23	; 35
    41e6:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    41ea:	47 cf       	rjmp	.-370    	; 0x407a <xQueueGenericSend+0x2c>

000041ec <xQueueCreateMutex>:
    41ec:	cf 93       	push	r28
    41ee:	df 93       	push	r29
    41f0:	48 2f       	mov	r20, r24
    41f2:	60 e0       	ldi	r22, 0x00	; 0
    41f4:	81 e0       	ldi	r24, 0x01	; 1
    41f6:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <xQueueGenericCreate>
    41fa:	ec 01       	movw	r28, r24
    41fc:	00 97       	sbiw	r24, 0x00	; 0
    41fe:	61 f0       	breq	.+24     	; 0x4218 <xQueueCreateMutex+0x2c>
    4200:	1c 82       	std	Y+4, r1	; 0x04
    4202:	1d 82       	std	Y+5, r1	; 0x05
    4204:	18 82       	st	Y, r1
    4206:	19 82       	std	Y+1, r1	; 0x01
    4208:	1e 82       	std	Y+6, r1	; 0x06
    420a:	20 e0       	ldi	r18, 0x00	; 0
    420c:	40 e0       	ldi	r20, 0x00	; 0
    420e:	50 e0       	ldi	r21, 0x00	; 0
    4210:	60 e0       	ldi	r22, 0x00	; 0
    4212:	70 e0       	ldi	r23, 0x00	; 0
    4214:	0e 94 27 20 	call	0x404e	; 0x404e <xQueueGenericSend>
    4218:	ce 01       	movw	r24, r28
    421a:	df 91       	pop	r29
    421c:	cf 91       	pop	r28
    421e:	08 95       	ret

00004220 <xQueueGenericSendFromISR>:
    4220:	cf 92       	push	r12
    4222:	df 92       	push	r13
    4224:	ef 92       	push	r14
    4226:	ff 92       	push	r15
    4228:	0f 93       	push	r16
    422a:	1f 93       	push	r17
    422c:	cf 93       	push	r28
    422e:	df 93       	push	r29
    4230:	ec 01       	movw	r28, r24
    4232:	8b 01       	movw	r16, r22
    4234:	6a 01       	movw	r12, r20
    4236:	f2 2e       	mov	r15, r18
    4238:	89 2b       	or	r24, r25
    423a:	09 f4       	brne	.+2      	; 0x423e <xQueueGenericSendFromISR+0x1e>
    423c:	45 c0       	rjmp	.+138    	; 0x42c8 <xQueueGenericSendFromISR+0xa8>
    423e:	01 15       	cp	r16, r1
    4240:	11 05       	cpc	r17, r1
    4242:	c1 f1       	breq	.+112    	; 0x42b4 <xQueueGenericSendFromISR+0x94>
    4244:	82 e0       	ldi	r24, 0x02	; 2
    4246:	f8 16       	cp	r15, r24
    4248:	71 f0       	breq	.+28     	; 0x4266 <xQueueGenericSendFromISR+0x46>
    424a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    424c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    424e:	98 17       	cp	r25, r24
    4250:	a0 f0       	brcs	.+40     	; 0x427a <xQueueGenericSendFromISR+0x5a>
    4252:	80 e0       	ldi	r24, 0x00	; 0
    4254:	df 91       	pop	r29
    4256:	cf 91       	pop	r28
    4258:	1f 91       	pop	r17
    425a:	0f 91       	pop	r16
    425c:	ff 90       	pop	r15
    425e:	ef 90       	pop	r14
    4260:	df 90       	pop	r13
    4262:	cf 90       	pop	r12
    4264:	08 95       	ret
    4266:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4268:	81 30       	cpi	r24, 0x01	; 1
    426a:	31 f0       	breq	.+12     	; 0x4278 <xQueueGenericSendFromISR+0x58>
    426c:	65 ec       	ldi	r22, 0xC5	; 197
    426e:	73 e0       	ldi	r23, 0x03	; 3
    4270:	8f e6       	ldi	r24, 0x6F	; 111
    4272:	93 e2       	ldi	r25, 0x23	; 35
    4274:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    4278:	8a 8d       	ldd	r24, Y+26	; 0x1a
    427a:	ee 8c       	ldd	r14, Y+30	; 0x1e
    427c:	4f 2d       	mov	r20, r15
    427e:	b8 01       	movw	r22, r16
    4280:	ce 01       	movw	r24, r28
    4282:	0e 94 d1 1e 	call	0x3da2	; 0x3da2 <prvCopyDataToQueue>
    4286:	ef ef       	ldi	r30, 0xFF	; 255
    4288:	ee 16       	cp	r14, r30
    428a:	21 f0       	breq	.+8      	; 0x4294 <xQueueGenericSendFromISR+0x74>
    428c:	e3 94       	inc	r14
    428e:	ee 8e       	std	Y+30, r14	; 0x1e
    4290:	81 e0       	ldi	r24, 0x01	; 1
    4292:	e0 cf       	rjmp	.-64     	; 0x4254 <xQueueGenericSendFromISR+0x34>
    4294:	89 89       	ldd	r24, Y+17	; 0x11
    4296:	88 23       	and	r24, r24
    4298:	d9 f3       	breq	.-10     	; 0x4290 <xQueueGenericSendFromISR+0x70>
    429a:	ce 01       	movw	r24, r28
    429c:	41 96       	adiw	r24, 0x11	; 17
    429e:	0e 94 23 2b 	call	0x5646	; 0x5646 <xTaskRemoveFromEventList>
    42a2:	88 23       	and	r24, r24
    42a4:	a9 f3       	breq	.-22     	; 0x4290 <xQueueGenericSendFromISR+0x70>
    42a6:	c1 14       	cp	r12, r1
    42a8:	d1 04       	cpc	r13, r1
    42aa:	91 f3       	breq	.-28     	; 0x4290 <xQueueGenericSendFromISR+0x70>
    42ac:	81 e0       	ldi	r24, 0x01	; 1
    42ae:	f6 01       	movw	r30, r12
    42b0:	80 83       	st	Z, r24
    42b2:	d0 cf       	rjmp	.-96     	; 0x4254 <xQueueGenericSendFromISR+0x34>
    42b4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    42b6:	88 23       	and	r24, r24
    42b8:	29 f2       	breq	.-118    	; 0x4244 <xQueueGenericSendFromISR+0x24>
    42ba:	64 ec       	ldi	r22, 0xC4	; 196
    42bc:	73 e0       	ldi	r23, 0x03	; 3
    42be:	8f e6       	ldi	r24, 0x6F	; 111
    42c0:	93 e2       	ldi	r25, 0x23	; 35
    42c2:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    42c6:	be cf       	rjmp	.-132    	; 0x4244 <xQueueGenericSendFromISR+0x24>
    42c8:	63 ec       	ldi	r22, 0xC3	; 195
    42ca:	73 e0       	ldi	r23, 0x03	; 3
    42cc:	8f e6       	ldi	r24, 0x6F	; 111
    42ce:	93 e2       	ldi	r25, 0x23	; 35
    42d0:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    42d4:	b4 cf       	rjmp	.-152    	; 0x423e <xQueueGenericSendFromISR+0x1e>

000042d6 <xQueueGiveFromISR>:
    42d6:	0f 93       	push	r16
    42d8:	1f 93       	push	r17
    42da:	cf 93       	push	r28
    42dc:	df 93       	push	r29
    42de:	ec 01       	movw	r28, r24
    42e0:	8b 01       	movw	r16, r22
    42e2:	89 2b       	or	r24, r25
    42e4:	09 f4       	brne	.+2      	; 0x42e8 <xQueueGiveFromISR+0x12>
    42e6:	43 c0       	rjmp	.+134    	; 0x436e <xQueueGiveFromISR+0x98>
    42e8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    42ea:	81 11       	cpse	r24, r1
    42ec:	1b c0       	rjmp	.+54     	; 0x4324 <xQueueGiveFromISR+0x4e>
    42ee:	88 81       	ld	r24, Y
    42f0:	99 81       	ldd	r25, Y+1	; 0x01
    42f2:	89 2b       	or	r24, r25
    42f4:	09 f1       	breq	.+66     	; 0x4338 <xQueueGiveFromISR+0x62>
    42f6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    42f8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    42fa:	89 17       	cp	r24, r25
    42fc:	68 f4       	brcc	.+26     	; 0x4318 <xQueueGiveFromISR+0x42>
    42fe:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4300:	8f 5f       	subi	r24, 0xFF	; 255
    4302:	8a 8f       	std	Y+26, r24	; 0x1a
    4304:	9f 3f       	cpi	r25, 0xFF	; 255
    4306:	19 f1       	breq	.+70     	; 0x434e <xQueueGiveFromISR+0x78>
    4308:	9f 5f       	subi	r25, 0xFF	; 255
    430a:	9e 8f       	std	Y+30, r25	; 0x1e
    430c:	81 e0       	ldi	r24, 0x01	; 1
    430e:	df 91       	pop	r29
    4310:	cf 91       	pop	r28
    4312:	1f 91       	pop	r17
    4314:	0f 91       	pop	r16
    4316:	08 95       	ret
    4318:	80 e0       	ldi	r24, 0x00	; 0
    431a:	df 91       	pop	r29
    431c:	cf 91       	pop	r28
    431e:	1f 91       	pop	r17
    4320:	0f 91       	pop	r16
    4322:	08 95       	ret
    4324:	64 e6       	ldi	r22, 0x64	; 100
    4326:	74 e0       	ldi	r23, 0x04	; 4
    4328:	8f e6       	ldi	r24, 0x6F	; 111
    432a:	93 e2       	ldi	r25, 0x23	; 35
    432c:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    4330:	88 81       	ld	r24, Y
    4332:	99 81       	ldd	r25, Y+1	; 0x01
    4334:	89 2b       	or	r24, r25
    4336:	f9 f6       	brne	.-66     	; 0x42f6 <xQueueGiveFromISR+0x20>
    4338:	8c 81       	ldd	r24, Y+4	; 0x04
    433a:	9d 81       	ldd	r25, Y+5	; 0x05
    433c:	89 2b       	or	r24, r25
    433e:	d9 f2       	breq	.-74     	; 0x42f6 <xQueueGiveFromISR+0x20>
    4340:	69 e6       	ldi	r22, 0x69	; 105
    4342:	74 e0       	ldi	r23, 0x04	; 4
    4344:	8f e6       	ldi	r24, 0x6F	; 111
    4346:	93 e2       	ldi	r25, 0x23	; 35
    4348:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    434c:	d4 cf       	rjmp	.-88     	; 0x42f6 <xQueueGiveFromISR+0x20>
    434e:	89 89       	ldd	r24, Y+17	; 0x11
    4350:	88 23       	and	r24, r24
    4352:	e1 f2       	breq	.-72     	; 0x430c <xQueueGiveFromISR+0x36>
    4354:	ce 01       	movw	r24, r28
    4356:	41 96       	adiw	r24, 0x11	; 17
    4358:	0e 94 23 2b 	call	0x5646	; 0x5646 <xTaskRemoveFromEventList>
    435c:	88 23       	and	r24, r24
    435e:	b1 f2       	breq	.-84     	; 0x430c <xQueueGiveFromISR+0x36>
    4360:	01 15       	cp	r16, r1
    4362:	11 05       	cpc	r17, r1
    4364:	99 f2       	breq	.-90     	; 0x430c <xQueueGiveFromISR+0x36>
    4366:	81 e0       	ldi	r24, 0x01	; 1
    4368:	f8 01       	movw	r30, r16
    436a:	80 83       	st	Z, r24
    436c:	d0 cf       	rjmp	.-96     	; 0x430e <xQueueGiveFromISR+0x38>
    436e:	60 e6       	ldi	r22, 0x60	; 96
    4370:	74 e0       	ldi	r23, 0x04	; 4
    4372:	8f e6       	ldi	r24, 0x6F	; 111
    4374:	93 e2       	ldi	r25, 0x23	; 35
    4376:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    437a:	b6 cf       	rjmp	.-148    	; 0x42e8 <xQueueGiveFromISR+0x12>

0000437c <xQueueReceive>:
    437c:	af 92       	push	r10
    437e:	bf 92       	push	r11
    4380:	cf 92       	push	r12
    4382:	df 92       	push	r13
    4384:	ff 92       	push	r15
    4386:	0f 93       	push	r16
    4388:	1f 93       	push	r17
    438a:	cf 93       	push	r28
    438c:	df 93       	push	r29
    438e:	cd b7       	in	r28, 0x3d	; 61
    4390:	de b7       	in	r29, 0x3e	; 62
    4392:	25 97       	sbiw	r28, 0x05	; 5
    4394:	cd bf       	out	0x3d, r28	; 61
    4396:	de bf       	out	0x3e, r29	; 62
    4398:	8c 01       	movw	r16, r24
    439a:	5b 01       	movw	r10, r22
    439c:	4c 83       	std	Y+4, r20	; 0x04
    439e:	5d 83       	std	Y+5, r21	; 0x05
    43a0:	89 2b       	or	r24, r25
    43a2:	09 f4       	brne	.+2      	; 0x43a6 <xQueueReceive+0x2a>
    43a4:	a1 c0       	rjmp	.+322    	; 0x44e8 <xQueueReceive+0x16c>
    43a6:	a1 14       	cp	r10, r1
    43a8:	b1 04       	cpc	r11, r1
    43aa:	09 f4       	brne	.+2      	; 0x43ae <xQueueReceive+0x32>
    43ac:	91 c0       	rjmp	.+290    	; 0x44d0 <xQueueReceive+0x154>
    43ae:	20 e0       	ldi	r18, 0x00	; 0
    43b0:	68 01       	movw	r12, r16
    43b2:	f1 e1       	ldi	r31, 0x11	; 17
    43b4:	cf 0e       	add	r12, r31
    43b6:	d1 1c       	adc	r13, r1
    43b8:	0f b6       	in	r0, 0x3f	; 63
    43ba:	f8 94       	cli
    43bc:	0f 92       	push	r0
    43be:	f8 01       	movw	r30, r16
    43c0:	f2 8c       	ldd	r15, Z+26	; 0x1a
    43c2:	f1 10       	cpse	r15, r1
    43c4:	6a c0       	rjmp	.+212    	; 0x449a <xQueueReceive+0x11e>
    43c6:	8c 81       	ldd	r24, Y+4	; 0x04
    43c8:	9d 81       	ldd	r25, Y+5	; 0x05
    43ca:	89 2b       	or	r24, r25
    43cc:	09 f4       	brne	.+2      	; 0x43d0 <xQueueReceive+0x54>
    43ce:	73 c0       	rjmp	.+230    	; 0x44b6 <xQueueReceive+0x13a>
    43d0:	22 23       	and	r18, r18
    43d2:	09 f4       	brne	.+2      	; 0x43d6 <xQueueReceive+0x5a>
    43d4:	59 c0       	rjmp	.+178    	; 0x4488 <xQueueReceive+0x10c>
    43d6:	0f 90       	pop	r0
    43d8:	0f be       	out	0x3f, r0	; 63
    43da:	0e 94 a6 28 	call	0x514c	; 0x514c <vTaskSuspendAll>
    43de:	0f b6       	in	r0, 0x3f	; 63
    43e0:	f8 94       	cli
    43e2:	0f 92       	push	r0
    43e4:	f8 01       	movw	r30, r16
    43e6:	85 8d       	ldd	r24, Z+29	; 0x1d
    43e8:	8f 3f       	cpi	r24, 0xFF	; 255
    43ea:	09 f4       	brne	.+2      	; 0x43ee <xQueueReceive+0x72>
    43ec:	54 c0       	rjmp	.+168    	; 0x4496 <xQueueReceive+0x11a>
    43ee:	f8 01       	movw	r30, r16
    43f0:	86 8d       	ldd	r24, Z+30	; 0x1e
    43f2:	8f 3f       	cpi	r24, 0xFF	; 255
    43f4:	09 f4       	brne	.+2      	; 0x43f8 <xQueueReceive+0x7c>
    43f6:	4d c0       	rjmp	.+154    	; 0x4492 <xQueueReceive+0x116>
    43f8:	0f 90       	pop	r0
    43fa:	0f be       	out	0x3f, r0	; 63
    43fc:	be 01       	movw	r22, r28
    43fe:	6c 5f       	subi	r22, 0xFC	; 252
    4400:	7f 4f       	sbci	r23, 0xFF	; 255
    4402:	ce 01       	movw	r24, r28
    4404:	01 96       	adiw	r24, 0x01	; 1
    4406:	0e 94 9f 2b 	call	0x573e	; 0x573e <xTaskCheckForTimeOut>
    440a:	81 11       	cpse	r24, r1
    440c:	22 c0       	rjmp	.+68     	; 0x4452 <xQueueReceive+0xd6>
    440e:	0f b6       	in	r0, 0x3f	; 63
    4410:	f8 94       	cli
    4412:	0f 92       	push	r0
    4414:	f8 01       	movw	r30, r16
    4416:	82 8d       	ldd	r24, Z+26	; 0x1a
    4418:	0f 90       	pop	r0
    441a:	0f be       	out	0x3f, r0	; 63
    441c:	81 11       	cpse	r24, r1
    441e:	12 c0       	rjmp	.+36     	; 0x4444 <xQueueReceive+0xc8>
    4420:	6c 81       	ldd	r22, Y+4	; 0x04
    4422:	7d 81       	ldd	r23, Y+5	; 0x05
    4424:	c6 01       	movw	r24, r12
    4426:	0e 94 03 2b 	call	0x5606	; 0x5606 <vTaskPlaceOnEventList>
    442a:	c8 01       	movw	r24, r16
    442c:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
    4430:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
    4434:	88 23       	and	r24, r24
    4436:	11 f0       	breq	.+4      	; 0x443c <xQueueReceive+0xc0>
    4438:	21 e0       	ldi	r18, 0x01	; 1
    443a:	be cf       	rjmp	.-132    	; 0x43b8 <xQueueReceive+0x3c>
    443c:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <vPortYield>
    4440:	21 e0       	ldi	r18, 0x01	; 1
    4442:	ba cf       	rjmp	.-140    	; 0x43b8 <xQueueReceive+0x3c>
    4444:	c8 01       	movw	r24, r16
    4446:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
    444a:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
    444e:	21 e0       	ldi	r18, 0x01	; 1
    4450:	b3 cf       	rjmp	.-154    	; 0x43b8 <xQueueReceive+0x3c>
    4452:	c8 01       	movw	r24, r16
    4454:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
    4458:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
    445c:	0f b6       	in	r0, 0x3f	; 63
    445e:	f8 94       	cli
    4460:	0f 92       	push	r0
    4462:	f8 01       	movw	r30, r16
    4464:	82 8d       	ldd	r24, Z+26	; 0x1a
    4466:	0f 90       	pop	r0
    4468:	0f be       	out	0x3f, r0	; 63
    446a:	81 11       	cpse	r24, r1
    446c:	e5 cf       	rjmp	.-54     	; 0x4438 <xQueueReceive+0xbc>
    446e:	25 96       	adiw	r28, 0x05	; 5
    4470:	cd bf       	out	0x3d, r28	; 61
    4472:	de bf       	out	0x3e, r29	; 62
    4474:	df 91       	pop	r29
    4476:	cf 91       	pop	r28
    4478:	1f 91       	pop	r17
    447a:	0f 91       	pop	r16
    447c:	ff 90       	pop	r15
    447e:	df 90       	pop	r13
    4480:	cf 90       	pop	r12
    4482:	bf 90       	pop	r11
    4484:	af 90       	pop	r10
    4486:	08 95       	ret
    4488:	ce 01       	movw	r24, r28
    448a:	01 96       	adiw	r24, 0x01	; 1
    448c:	0e 94 94 2b 	call	0x5728	; 0x5728 <vTaskInternalSetTimeOutState>
    4490:	a2 cf       	rjmp	.-188    	; 0x43d6 <xQueueReceive+0x5a>
    4492:	16 8e       	std	Z+30, r1	; 0x1e
    4494:	b1 cf       	rjmp	.-158    	; 0x43f8 <xQueueReceive+0x7c>
    4496:	15 8e       	std	Z+29, r1	; 0x1d
    4498:	aa cf       	rjmp	.-172    	; 0x43ee <xQueueReceive+0x72>
    449a:	b5 01       	movw	r22, r10
    449c:	c8 01       	movw	r24, r16
    449e:	0e 94 2b 1f 	call	0x3e56	; 0x3e56 <prvCopyDataFromQueue>
    44a2:	fa 94       	dec	r15
    44a4:	f8 01       	movw	r30, r16
    44a6:	f2 8e       	std	Z+26, r15	; 0x1a
    44a8:	80 85       	ldd	r24, Z+8	; 0x08
    44aa:	81 11       	cpse	r24, r1
    44ac:	08 c0       	rjmp	.+16     	; 0x44be <xQueueReceive+0x142>
    44ae:	0f 90       	pop	r0
    44b0:	0f be       	out	0x3f, r0	; 63
    44b2:	81 e0       	ldi	r24, 0x01	; 1
    44b4:	dc cf       	rjmp	.-72     	; 0x446e <xQueueReceive+0xf2>
    44b6:	0f 90       	pop	r0
    44b8:	0f be       	out	0x3f, r0	; 63
    44ba:	80 e0       	ldi	r24, 0x00	; 0
    44bc:	d8 cf       	rjmp	.-80     	; 0x446e <xQueueReceive+0xf2>
    44be:	c8 01       	movw	r24, r16
    44c0:	08 96       	adiw	r24, 0x08	; 8
    44c2:	0e 94 23 2b 	call	0x5646	; 0x5646 <xTaskRemoveFromEventList>
    44c6:	88 23       	and	r24, r24
    44c8:	91 f3       	breq	.-28     	; 0x44ae <xQueueReceive+0x132>
    44ca:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <vPortYield>
    44ce:	ef cf       	rjmp	.-34     	; 0x44ae <xQueueReceive+0x132>
    44d0:	f8 01       	movw	r30, r16
    44d2:	84 8d       	ldd	r24, Z+28	; 0x1c
    44d4:	88 23       	and	r24, r24
    44d6:	09 f4       	brne	.+2      	; 0x44da <xQueueReceive+0x15e>
    44d8:	6a cf       	rjmp	.-300    	; 0x43ae <xQueueReceive+0x32>
    44da:	64 e0       	ldi	r22, 0x04	; 4
    44dc:	75 e0       	ldi	r23, 0x05	; 5
    44de:	8f e6       	ldi	r24, 0x6F	; 111
    44e0:	93 e2       	ldi	r25, 0x23	; 35
    44e2:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    44e6:	63 cf       	rjmp	.-314    	; 0x43ae <xQueueReceive+0x32>
    44e8:	60 e0       	ldi	r22, 0x00	; 0
    44ea:	75 e0       	ldi	r23, 0x05	; 5
    44ec:	8f e6       	ldi	r24, 0x6F	; 111
    44ee:	93 e2       	ldi	r25, 0x23	; 35
    44f0:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    44f4:	58 cf       	rjmp	.-336    	; 0x43a6 <xQueueReceive+0x2a>

000044f6 <xQueueSemaphoreTake>:
    44f6:	df 92       	push	r13
    44f8:	ef 92       	push	r14
    44fa:	ff 92       	push	r15
    44fc:	0f 93       	push	r16
    44fe:	1f 93       	push	r17
    4500:	cf 93       	push	r28
    4502:	df 93       	push	r29
    4504:	cd b7       	in	r28, 0x3d	; 61
    4506:	de b7       	in	r29, 0x3e	; 62
    4508:	25 97       	sbiw	r28, 0x05	; 5
    450a:	cd bf       	out	0x3d, r28	; 61
    450c:	de bf       	out	0x3e, r29	; 62
    450e:	8c 01       	movw	r16, r24
    4510:	6c 83       	std	Y+4, r22	; 0x04
    4512:	7d 83       	std	Y+5, r23	; 0x05
    4514:	89 2b       	or	r24, r25
    4516:	09 f4       	brne	.+2      	; 0x451a <xQueueSemaphoreTake+0x24>
    4518:	d0 c0       	rjmp	.+416    	; 0x46ba <xQueueSemaphoreTake+0x1c4>
    451a:	d8 01       	movw	r26, r16
    451c:	5c 96       	adiw	r26, 0x1c	; 28
    451e:	8c 91       	ld	r24, X
    4520:	81 11       	cpse	r24, r1
    4522:	bb c0       	rjmp	.+374    	; 0x469a <xQueueSemaphoreTake+0x1a4>
    4524:	d1 2c       	mov	r13, r1
    4526:	20 e0       	ldi	r18, 0x00	; 0
    4528:	78 01       	movw	r14, r16
    452a:	b1 e1       	ldi	r27, 0x11	; 17
    452c:	eb 0e       	add	r14, r27
    452e:	f1 1c       	adc	r15, r1
    4530:	0f b6       	in	r0, 0x3f	; 63
    4532:	f8 94       	cli
    4534:	0f 92       	push	r0
    4536:	f8 01       	movw	r30, r16
    4538:	82 8d       	ldd	r24, Z+26	; 0x1a
    453a:	81 11       	cpse	r24, r1
    453c:	89 c0       	rjmp	.+274    	; 0x4650 <xQueueSemaphoreTake+0x15a>
    453e:	8c 81       	ldd	r24, Y+4	; 0x04
    4540:	9d 81       	ldd	r25, Y+5	; 0x05
    4542:	89 2b       	or	r24, r25
    4544:	09 f4       	brne	.+2      	; 0x4548 <xQueueSemaphoreTake+0x52>
    4546:	9d c0       	rjmp	.+314    	; 0x4682 <xQueueSemaphoreTake+0x18c>
    4548:	22 23       	and	r18, r18
    454a:	09 f4       	brne	.+2      	; 0x454e <xQueueSemaphoreTake+0x58>
    454c:	5f c0       	rjmp	.+190    	; 0x460c <xQueueSemaphoreTake+0x116>
    454e:	0f 90       	pop	r0
    4550:	0f be       	out	0x3f, r0	; 63
    4552:	0e 94 a6 28 	call	0x514c	; 0x514c <vTaskSuspendAll>
    4556:	0f b6       	in	r0, 0x3f	; 63
    4558:	f8 94       	cli
    455a:	0f 92       	push	r0
    455c:	d8 01       	movw	r26, r16
    455e:	5d 96       	adiw	r26, 0x1d	; 29
    4560:	8c 91       	ld	r24, X
    4562:	5d 97       	sbiw	r26, 0x1d	; 29
    4564:	8f 3f       	cpi	r24, 0xFF	; 255
    4566:	09 f4       	brne	.+2      	; 0x456a <xQueueSemaphoreTake+0x74>
    4568:	56 c0       	rjmp	.+172    	; 0x4616 <xQueueSemaphoreTake+0x120>
    456a:	f8 01       	movw	r30, r16
    456c:	86 8d       	ldd	r24, Z+30	; 0x1e
    456e:	8f 3f       	cpi	r24, 0xFF	; 255
    4570:	09 f4       	brne	.+2      	; 0x4574 <xQueueSemaphoreTake+0x7e>
    4572:	58 c0       	rjmp	.+176    	; 0x4624 <xQueueSemaphoreTake+0x12e>
    4574:	0f 90       	pop	r0
    4576:	0f be       	out	0x3f, r0	; 63
    4578:	be 01       	movw	r22, r28
    457a:	6c 5f       	subi	r22, 0xFC	; 252
    457c:	7f 4f       	sbci	r23, 0xFF	; 255
    457e:	ce 01       	movw	r24, r28
    4580:	01 96       	adiw	r24, 0x01	; 1
    4582:	0e 94 9f 2b 	call	0x573e	; 0x573e <xTaskCheckForTimeOut>
    4586:	81 11       	cpse	r24, r1
    4588:	23 c0       	rjmp	.+70     	; 0x45d0 <xQueueSemaphoreTake+0xda>
    458a:	0f b6       	in	r0, 0x3f	; 63
    458c:	f8 94       	cli
    458e:	0f 92       	push	r0
    4590:	d8 01       	movw	r26, r16
    4592:	5a 96       	adiw	r26, 0x1a	; 26
    4594:	8c 91       	ld	r24, X
    4596:	5a 97       	sbiw	r26, 0x1a	; 26
    4598:	0f 90       	pop	r0
    459a:	0f be       	out	0x3f, r0	; 63
    459c:	81 11       	cpse	r24, r1
    459e:	44 c0       	rjmp	.+136    	; 0x4628 <xQueueSemaphoreTake+0x132>
    45a0:	f8 01       	movw	r30, r16
    45a2:	80 81       	ld	r24, Z
    45a4:	91 81       	ldd	r25, Z+1	; 0x01
    45a6:	89 2b       	or	r24, r25
    45a8:	09 f4       	brne	.+2      	; 0x45ac <xQueueSemaphoreTake+0xb6>
    45aa:	45 c0       	rjmp	.+138    	; 0x4636 <xQueueSemaphoreTake+0x140>
    45ac:	6c 81       	ldd	r22, Y+4	; 0x04
    45ae:	7d 81       	ldd	r23, Y+5	; 0x05
    45b0:	c7 01       	movw	r24, r14
    45b2:	0e 94 03 2b 	call	0x5606	; 0x5606 <vTaskPlaceOnEventList>
    45b6:	c8 01       	movw	r24, r16
    45b8:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
    45bc:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
    45c0:	88 23       	and	r24, r24
    45c2:	11 f0       	breq	.+4      	; 0x45c8 <xQueueSemaphoreTake+0xd2>
    45c4:	21 e0       	ldi	r18, 0x01	; 1
    45c6:	b4 cf       	rjmp	.-152    	; 0x4530 <xQueueSemaphoreTake+0x3a>
    45c8:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <vPortYield>
    45cc:	21 e0       	ldi	r18, 0x01	; 1
    45ce:	b0 cf       	rjmp	.-160    	; 0x4530 <xQueueSemaphoreTake+0x3a>
    45d0:	c8 01       	movw	r24, r16
    45d2:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
    45d6:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
    45da:	0f b6       	in	r0, 0x3f	; 63
    45dc:	f8 94       	cli
    45de:	0f 92       	push	r0
    45e0:	f8 01       	movw	r30, r16
    45e2:	82 8d       	ldd	r24, Z+26	; 0x1a
    45e4:	0f 90       	pop	r0
    45e6:	0f be       	out	0x3f, r0	; 63
    45e8:	81 11       	cpse	r24, r1
    45ea:	ec cf       	rjmp	.-40     	; 0x45c4 <xQueueSemaphoreTake+0xce>
    45ec:	dd 20       	and	r13, r13
    45ee:	09 f4       	brne	.+2      	; 0x45f2 <xQueueSemaphoreTake+0xfc>
    45f0:	72 c0       	rjmp	.+228    	; 0x46d6 <xQueueSemaphoreTake+0x1e0>
    45f2:	0f b6       	in	r0, 0x3f	; 63
    45f4:	f8 94       	cli
    45f6:	0f 92       	push	r0
    45f8:	81 89       	ldd	r24, Z+17	; 0x11
    45fa:	81 11       	cpse	r24, r1
    45fc:	65 c0       	rjmp	.+202    	; 0x46c8 <xQueueSemaphoreTake+0x1d2>
    45fe:	60 e0       	ldi	r22, 0x00	; 0
    4600:	f8 01       	movw	r30, r16
    4602:	84 81       	ldd	r24, Z+4	; 0x04
    4604:	95 81       	ldd	r25, Z+5	; 0x05
    4606:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <vTaskPriorityDisinheritAfterTimeout>
    460a:	43 c0       	rjmp	.+134    	; 0x4692 <xQueueSemaphoreTake+0x19c>
    460c:	ce 01       	movw	r24, r28
    460e:	01 96       	adiw	r24, 0x01	; 1
    4610:	0e 94 94 2b 	call	0x5728	; 0x5728 <vTaskInternalSetTimeOutState>
    4614:	9c cf       	rjmp	.-200    	; 0x454e <xQueueSemaphoreTake+0x58>
    4616:	5d 96       	adiw	r26, 0x1d	; 29
    4618:	1c 92       	st	X, r1
    461a:	f8 01       	movw	r30, r16
    461c:	86 8d       	ldd	r24, Z+30	; 0x1e
    461e:	8f 3f       	cpi	r24, 0xFF	; 255
    4620:	09 f0       	breq	.+2      	; 0x4624 <xQueueSemaphoreTake+0x12e>
    4622:	a8 cf       	rjmp	.-176    	; 0x4574 <xQueueSemaphoreTake+0x7e>
    4624:	16 8e       	std	Z+30, r1	; 0x1e
    4626:	a6 cf       	rjmp	.-180    	; 0x4574 <xQueueSemaphoreTake+0x7e>
    4628:	c8 01       	movw	r24, r16
    462a:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
    462e:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
    4632:	21 e0       	ldi	r18, 0x01	; 1
    4634:	7d cf       	rjmp	.-262    	; 0x4530 <xQueueSemaphoreTake+0x3a>
    4636:	0f b6       	in	r0, 0x3f	; 63
    4638:	f8 94       	cli
    463a:	0f 92       	push	r0
    463c:	14 96       	adiw	r26, 0x04	; 4
    463e:	8d 91       	ld	r24, X+
    4640:	9c 91       	ld	r25, X
    4642:	15 97       	sbiw	r26, 0x05	; 5
    4644:	0e 94 94 2d 	call	0x5b28	; 0x5b28 <xTaskPriorityInherit>
    4648:	d8 2e       	mov	r13, r24
    464a:	0f 90       	pop	r0
    464c:	0f be       	out	0x3f, r0	; 63
    464e:	ae cf       	rjmp	.-164    	; 0x45ac <xQueueSemaphoreTake+0xb6>
    4650:	81 50       	subi	r24, 0x01	; 1
    4652:	82 8f       	std	Z+26, r24	; 0x1a
    4654:	80 81       	ld	r24, Z
    4656:	91 81       	ldd	r25, Z+1	; 0x01
    4658:	89 2b       	or	r24, r25
    465a:	09 f4       	brne	.+2      	; 0x465e <xQueueSemaphoreTake+0x168>
    465c:	3e c0       	rjmp	.+124    	; 0x46da <xQueueSemaphoreTake+0x1e4>
    465e:	f8 01       	movw	r30, r16
    4660:	80 85       	ldd	r24, Z+8	; 0x08
    4662:	81 11       	cpse	r24, r1
    4664:	21 c0       	rjmp	.+66     	; 0x46a8 <xQueueSemaphoreTake+0x1b2>
    4666:	0f 90       	pop	r0
    4668:	0f be       	out	0x3f, r0	; 63
    466a:	81 e0       	ldi	r24, 0x01	; 1
    466c:	25 96       	adiw	r28, 0x05	; 5
    466e:	cd bf       	out	0x3d, r28	; 61
    4670:	de bf       	out	0x3e, r29	; 62
    4672:	df 91       	pop	r29
    4674:	cf 91       	pop	r28
    4676:	1f 91       	pop	r17
    4678:	0f 91       	pop	r16
    467a:	ff 90       	pop	r15
    467c:	ef 90       	pop	r14
    467e:	df 90       	pop	r13
    4680:	08 95       	ret
    4682:	dd 20       	and	r13, r13
    4684:	31 f0       	breq	.+12     	; 0x4692 <xQueueSemaphoreTake+0x19c>
    4686:	61 ee       	ldi	r22, 0xE1	; 225
    4688:	75 e0       	ldi	r23, 0x05	; 5
    468a:	8f e6       	ldi	r24, 0x6F	; 111
    468c:	93 e2       	ldi	r25, 0x23	; 35
    468e:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    4692:	0f 90       	pop	r0
    4694:	0f be       	out	0x3f, r0	; 63
    4696:	80 e0       	ldi	r24, 0x00	; 0
    4698:	e9 cf       	rjmp	.-46     	; 0x466c <xQueueSemaphoreTake+0x176>
    469a:	65 e9       	ldi	r22, 0x95	; 149
    469c:	75 e0       	ldi	r23, 0x05	; 5
    469e:	8f e6       	ldi	r24, 0x6F	; 111
    46a0:	93 e2       	ldi	r25, 0x23	; 35
    46a2:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    46a6:	3e cf       	rjmp	.-388    	; 0x4524 <xQueueSemaphoreTake+0x2e>
    46a8:	c8 01       	movw	r24, r16
    46aa:	08 96       	adiw	r24, 0x08	; 8
    46ac:	0e 94 23 2b 	call	0x5646	; 0x5646 <xTaskRemoveFromEventList>
    46b0:	88 23       	and	r24, r24
    46b2:	c9 f2       	breq	.-78     	; 0x4666 <xQueueSemaphoreTake+0x170>
    46b4:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <vPortYield>
    46b8:	d6 cf       	rjmp	.-84     	; 0x4666 <xQueueSemaphoreTake+0x170>
    46ba:	61 e9       	ldi	r22, 0x91	; 145
    46bc:	75 e0       	ldi	r23, 0x05	; 5
    46be:	8f e6       	ldi	r24, 0x6F	; 111
    46c0:	93 e2       	ldi	r25, 0x23	; 35
    46c2:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    46c6:	29 cf       	rjmp	.-430    	; 0x451a <xQueueSemaphoreTake+0x24>
    46c8:	06 88       	ldd	r0, Z+22	; 0x16
    46ca:	f7 89       	ldd	r31, Z+23	; 0x17
    46cc:	e0 2d       	mov	r30, r0
    46ce:	80 81       	ld	r24, Z
    46d0:	6a e0       	ldi	r22, 0x0A	; 10
    46d2:	68 1b       	sub	r22, r24
    46d4:	95 cf       	rjmp	.-214    	; 0x4600 <xQueueSemaphoreTake+0x10a>
    46d6:	80 e0       	ldi	r24, 0x00	; 0
    46d8:	c9 cf       	rjmp	.-110    	; 0x466c <xQueueSemaphoreTake+0x176>
    46da:	0e 94 83 2f 	call	0x5f06	; 0x5f06 <pvTaskIncrementMutexHeldCount>
    46de:	d8 01       	movw	r26, r16
    46e0:	14 96       	adiw	r26, 0x04	; 4
    46e2:	8d 93       	st	X+, r24
    46e4:	9c 93       	st	X, r25
    46e6:	15 97       	sbiw	r26, 0x05	; 5
    46e8:	ba cf       	rjmp	.-140    	; 0x465e <xQueueSemaphoreTake+0x168>

000046ea <xQueuePeek>:
    46ea:	cf 92       	push	r12
    46ec:	df 92       	push	r13
    46ee:	ef 92       	push	r14
    46f0:	ff 92       	push	r15
    46f2:	0f 93       	push	r16
    46f4:	1f 93       	push	r17
    46f6:	cf 93       	push	r28
    46f8:	df 93       	push	r29
    46fa:	cd b7       	in	r28, 0x3d	; 61
    46fc:	de b7       	in	r29, 0x3e	; 62
    46fe:	25 97       	sbiw	r28, 0x05	; 5
    4700:	cd bf       	out	0x3d, r28	; 61
    4702:	de bf       	out	0x3e, r29	; 62
    4704:	8c 01       	movw	r16, r24
    4706:	6b 01       	movw	r12, r22
    4708:	4c 83       	std	Y+4, r20	; 0x04
    470a:	5d 83       	std	Y+5, r21	; 0x05
    470c:	89 2b       	or	r24, r25
    470e:	09 f4       	brne	.+2      	; 0x4712 <xQueuePeek+0x28>
    4710:	a2 c0       	rjmp	.+324    	; 0x4856 <xQueuePeek+0x16c>
    4712:	c1 14       	cp	r12, r1
    4714:	d1 04       	cpc	r13, r1
    4716:	09 f4       	brne	.+2      	; 0x471a <xQueuePeek+0x30>
    4718:	92 c0       	rjmp	.+292    	; 0x483e <xQueuePeek+0x154>
    471a:	20 e0       	ldi	r18, 0x00	; 0
    471c:	78 01       	movw	r14, r16
    471e:	f1 e1       	ldi	r31, 0x11	; 17
    4720:	ef 0e       	add	r14, r31
    4722:	f1 1c       	adc	r15, r1
    4724:	0f b6       	in	r0, 0x3f	; 63
    4726:	f8 94       	cli
    4728:	0f 92       	push	r0
    472a:	f8 01       	movw	r30, r16
    472c:	82 8d       	ldd	r24, Z+26	; 0x1a
    472e:	81 11       	cpse	r24, r1
    4730:	69 c0       	rjmp	.+210    	; 0x4804 <xQueuePeek+0x11a>
    4732:	8c 81       	ldd	r24, Y+4	; 0x04
    4734:	9d 81       	ldd	r25, Y+5	; 0x05
    4736:	89 2b       	or	r24, r25
    4738:	09 f4       	brne	.+2      	; 0x473c <xQueuePeek+0x52>
    473a:	74 c0       	rjmp	.+232    	; 0x4824 <xQueuePeek+0x13a>
    473c:	22 23       	and	r18, r18
    473e:	09 f4       	brne	.+2      	; 0x4742 <xQueuePeek+0x58>
    4740:	58 c0       	rjmp	.+176    	; 0x47f2 <xQueuePeek+0x108>
    4742:	0f 90       	pop	r0
    4744:	0f be       	out	0x3f, r0	; 63
    4746:	0e 94 a6 28 	call	0x514c	; 0x514c <vTaskSuspendAll>
    474a:	0f b6       	in	r0, 0x3f	; 63
    474c:	f8 94       	cli
    474e:	0f 92       	push	r0
    4750:	f8 01       	movw	r30, r16
    4752:	85 8d       	ldd	r24, Z+29	; 0x1d
    4754:	8f 3f       	cpi	r24, 0xFF	; 255
    4756:	09 f4       	brne	.+2      	; 0x475a <xQueuePeek+0x70>
    4758:	53 c0       	rjmp	.+166    	; 0x4800 <xQueuePeek+0x116>
    475a:	f8 01       	movw	r30, r16
    475c:	86 8d       	ldd	r24, Z+30	; 0x1e
    475e:	8f 3f       	cpi	r24, 0xFF	; 255
    4760:	09 f4       	brne	.+2      	; 0x4764 <xQueuePeek+0x7a>
    4762:	4c c0       	rjmp	.+152    	; 0x47fc <xQueuePeek+0x112>
    4764:	0f 90       	pop	r0
    4766:	0f be       	out	0x3f, r0	; 63
    4768:	be 01       	movw	r22, r28
    476a:	6c 5f       	subi	r22, 0xFC	; 252
    476c:	7f 4f       	sbci	r23, 0xFF	; 255
    476e:	ce 01       	movw	r24, r28
    4770:	01 96       	adiw	r24, 0x01	; 1
    4772:	0e 94 9f 2b 	call	0x573e	; 0x573e <xTaskCheckForTimeOut>
    4776:	81 11       	cpse	r24, r1
    4778:	22 c0       	rjmp	.+68     	; 0x47be <xQueuePeek+0xd4>
    477a:	0f b6       	in	r0, 0x3f	; 63
    477c:	f8 94       	cli
    477e:	0f 92       	push	r0
    4780:	f8 01       	movw	r30, r16
    4782:	82 8d       	ldd	r24, Z+26	; 0x1a
    4784:	0f 90       	pop	r0
    4786:	0f be       	out	0x3f, r0	; 63
    4788:	81 11       	cpse	r24, r1
    478a:	12 c0       	rjmp	.+36     	; 0x47b0 <xQueuePeek+0xc6>
    478c:	6c 81       	ldd	r22, Y+4	; 0x04
    478e:	7d 81       	ldd	r23, Y+5	; 0x05
    4790:	c7 01       	movw	r24, r14
    4792:	0e 94 03 2b 	call	0x5606	; 0x5606 <vTaskPlaceOnEventList>
    4796:	c8 01       	movw	r24, r16
    4798:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
    479c:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
    47a0:	88 23       	and	r24, r24
    47a2:	11 f0       	breq	.+4      	; 0x47a8 <xQueuePeek+0xbe>
    47a4:	21 e0       	ldi	r18, 0x01	; 1
    47a6:	be cf       	rjmp	.-132    	; 0x4724 <xQueuePeek+0x3a>
    47a8:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <vPortYield>
    47ac:	21 e0       	ldi	r18, 0x01	; 1
    47ae:	ba cf       	rjmp	.-140    	; 0x4724 <xQueuePeek+0x3a>
    47b0:	c8 01       	movw	r24, r16
    47b2:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
    47b6:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
    47ba:	21 e0       	ldi	r18, 0x01	; 1
    47bc:	b3 cf       	rjmp	.-154    	; 0x4724 <xQueuePeek+0x3a>
    47be:	c8 01       	movw	r24, r16
    47c0:	0e 94 43 1f 	call	0x3e86	; 0x3e86 <prvUnlockQueue>
    47c4:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
    47c8:	0f b6       	in	r0, 0x3f	; 63
    47ca:	f8 94       	cli
    47cc:	0f 92       	push	r0
    47ce:	f8 01       	movw	r30, r16
    47d0:	82 8d       	ldd	r24, Z+26	; 0x1a
    47d2:	0f 90       	pop	r0
    47d4:	0f be       	out	0x3f, r0	; 63
    47d6:	81 11       	cpse	r24, r1
    47d8:	e5 cf       	rjmp	.-54     	; 0x47a4 <xQueuePeek+0xba>
    47da:	25 96       	adiw	r28, 0x05	; 5
    47dc:	cd bf       	out	0x3d, r28	; 61
    47de:	de bf       	out	0x3e, r29	; 62
    47e0:	df 91       	pop	r29
    47e2:	cf 91       	pop	r28
    47e4:	1f 91       	pop	r17
    47e6:	0f 91       	pop	r16
    47e8:	ff 90       	pop	r15
    47ea:	ef 90       	pop	r14
    47ec:	df 90       	pop	r13
    47ee:	cf 90       	pop	r12
    47f0:	08 95       	ret
    47f2:	ce 01       	movw	r24, r28
    47f4:	01 96       	adiw	r24, 0x01	; 1
    47f6:	0e 94 94 2b 	call	0x5728	; 0x5728 <vTaskInternalSetTimeOutState>
    47fa:	a3 cf       	rjmp	.-186    	; 0x4742 <xQueuePeek+0x58>
    47fc:	16 8e       	std	Z+30, r1	; 0x1e
    47fe:	b2 cf       	rjmp	.-156    	; 0x4764 <xQueuePeek+0x7a>
    4800:	15 8e       	std	Z+29, r1	; 0x1d
    4802:	ab cf       	rjmp	.-170    	; 0x475a <xQueuePeek+0x70>
    4804:	e6 80       	ldd	r14, Z+6	; 0x06
    4806:	f7 80       	ldd	r15, Z+7	; 0x07
    4808:	b6 01       	movw	r22, r12
    480a:	c8 01       	movw	r24, r16
    480c:	0e 94 2b 1f 	call	0x3e56	; 0x3e56 <prvCopyDataFromQueue>
    4810:	f8 01       	movw	r30, r16
    4812:	e6 82       	std	Z+6, r14	; 0x06
    4814:	f7 82       	std	Z+7, r15	; 0x07
    4816:	81 89       	ldd	r24, Z+17	; 0x11
    4818:	81 11       	cpse	r24, r1
    481a:	08 c0       	rjmp	.+16     	; 0x482c <xQueuePeek+0x142>
    481c:	0f 90       	pop	r0
    481e:	0f be       	out	0x3f, r0	; 63
    4820:	81 e0       	ldi	r24, 0x01	; 1
    4822:	db cf       	rjmp	.-74     	; 0x47da <xQueuePeek+0xf0>
    4824:	0f 90       	pop	r0
    4826:	0f be       	out	0x3f, r0	; 63
    4828:	80 e0       	ldi	r24, 0x00	; 0
    482a:	d7 cf       	rjmp	.-82     	; 0x47da <xQueuePeek+0xf0>
    482c:	c8 01       	movw	r24, r16
    482e:	41 96       	adiw	r24, 0x11	; 17
    4830:	0e 94 23 2b 	call	0x5646	; 0x5646 <xTaskRemoveFromEventList>
    4834:	88 23       	and	r24, r24
    4836:	91 f3       	breq	.-28     	; 0x481c <xQueuePeek+0x132>
    4838:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <vPortYield>
    483c:	ef cf       	rjmp	.-34     	; 0x481c <xQueuePeek+0x132>
    483e:	f8 01       	movw	r30, r16
    4840:	84 8d       	ldd	r24, Z+28	; 0x1c
    4842:	88 23       	and	r24, r24
    4844:	09 f4       	brne	.+2      	; 0x4848 <xQueuePeek+0x15e>
    4846:	69 cf       	rjmp	.-302    	; 0x471a <xQueuePeek+0x30>
    4848:	6c e6       	ldi	r22, 0x6C	; 108
    484a:	76 e0       	ldi	r23, 0x06	; 6
    484c:	8f e6       	ldi	r24, 0x6F	; 111
    484e:	93 e2       	ldi	r25, 0x23	; 35
    4850:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    4854:	62 cf       	rjmp	.-316    	; 0x471a <xQueuePeek+0x30>
    4856:	68 e6       	ldi	r22, 0x68	; 104
    4858:	76 e0       	ldi	r23, 0x06	; 6
    485a:	8f e6       	ldi	r24, 0x6F	; 111
    485c:	93 e2       	ldi	r25, 0x23	; 35
    485e:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    4862:	57 cf       	rjmp	.-338    	; 0x4712 <xQueuePeek+0x28>

00004864 <xQueueReceiveFromISR>:
    4864:	cf 92       	push	r12
    4866:	df 92       	push	r13
    4868:	ef 92       	push	r14
    486a:	ff 92       	push	r15
    486c:	0f 93       	push	r16
    486e:	1f 93       	push	r17
    4870:	cf 93       	push	r28
    4872:	df 93       	push	r29
    4874:	ec 01       	movw	r28, r24
    4876:	7b 01       	movw	r14, r22
    4878:	6a 01       	movw	r12, r20
    487a:	89 2b       	or	r24, r25
    487c:	b9 f1       	breq	.+110    	; 0x48ec <xQueueReceiveFromISR+0x88>
    487e:	e1 14       	cp	r14, r1
    4880:	f1 04       	cpc	r15, r1
    4882:	d1 f0       	breq	.+52     	; 0x48b8 <xQueueReceiveFromISR+0x54>
    4884:	1a 8d       	ldd	r17, Y+26	; 0x1a
    4886:	11 11       	cpse	r17, r1
    4888:	0a c0       	rjmp	.+20     	; 0x489e <xQueueReceiveFromISR+0x3a>
    488a:	80 e0       	ldi	r24, 0x00	; 0
    488c:	df 91       	pop	r29
    488e:	cf 91       	pop	r28
    4890:	1f 91       	pop	r17
    4892:	0f 91       	pop	r16
    4894:	ff 90       	pop	r15
    4896:	ef 90       	pop	r14
    4898:	df 90       	pop	r13
    489a:	cf 90       	pop	r12
    489c:	08 95       	ret
    489e:	0d 8d       	ldd	r16, Y+29	; 0x1d
    48a0:	b7 01       	movw	r22, r14
    48a2:	ce 01       	movw	r24, r28
    48a4:	0e 94 2b 1f 	call	0x3e56	; 0x3e56 <prvCopyDataFromQueue>
    48a8:	11 50       	subi	r17, 0x01	; 1
    48aa:	1a 8f       	std	Y+26, r17	; 0x1a
    48ac:	0f 3f       	cpi	r16, 0xFF	; 255
    48ae:	71 f0       	breq	.+28     	; 0x48cc <xQueueReceiveFromISR+0x68>
    48b0:	0f 5f       	subi	r16, 0xFF	; 255
    48b2:	0d 8f       	std	Y+29, r16	; 0x1d
    48b4:	81 e0       	ldi	r24, 0x01	; 1
    48b6:	ea cf       	rjmp	.-44     	; 0x488c <xQueueReceiveFromISR+0x28>
    48b8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    48ba:	88 23       	and	r24, r24
    48bc:	19 f3       	breq	.-58     	; 0x4884 <xQueueReceiveFromISR+0x20>
    48be:	6c ef       	ldi	r22, 0xFC	; 252
    48c0:	76 e0       	ldi	r23, 0x06	; 6
    48c2:	8f e6       	ldi	r24, 0x6F	; 111
    48c4:	93 e2       	ldi	r25, 0x23	; 35
    48c6:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    48ca:	dc cf       	rjmp	.-72     	; 0x4884 <xQueueReceiveFromISR+0x20>
    48cc:	88 85       	ldd	r24, Y+8	; 0x08
    48ce:	88 23       	and	r24, r24
    48d0:	89 f3       	breq	.-30     	; 0x48b4 <xQueueReceiveFromISR+0x50>
    48d2:	ce 01       	movw	r24, r28
    48d4:	08 96       	adiw	r24, 0x08	; 8
    48d6:	0e 94 23 2b 	call	0x5646	; 0x5646 <xTaskRemoveFromEventList>
    48da:	88 23       	and	r24, r24
    48dc:	59 f3       	breq	.-42     	; 0x48b4 <xQueueReceiveFromISR+0x50>
    48de:	c1 14       	cp	r12, r1
    48e0:	d1 04       	cpc	r13, r1
    48e2:	41 f3       	breq	.-48     	; 0x48b4 <xQueueReceiveFromISR+0x50>
    48e4:	81 e0       	ldi	r24, 0x01	; 1
    48e6:	f6 01       	movw	r30, r12
    48e8:	80 83       	st	Z, r24
    48ea:	d0 cf       	rjmp	.-96     	; 0x488c <xQueueReceiveFromISR+0x28>
    48ec:	6b ef       	ldi	r22, 0xFB	; 251
    48ee:	76 e0       	ldi	r23, 0x06	; 6
    48f0:	8f e6       	ldi	r24, 0x6F	; 111
    48f2:	93 e2       	ldi	r25, 0x23	; 35
    48f4:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    48f8:	c2 cf       	rjmp	.-124    	; 0x487e <xQueueReceiveFromISR+0x1a>

000048fa <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    48fa:	cf 93       	push	r28
    48fc:	df 93       	push	r29
    48fe:	ec 01       	movw	r28, r24
UBaseType_t uxReturn;

	configASSERT( xQueue );
    4900:	89 2b       	or	r24, r25
    4902:	49 f0       	breq	.+18     	; 0x4916 <uxQueueMessagesWaiting+0x1c>

	taskENTER_CRITICAL();
    4904:	0f b6       	in	r0, 0x3f	; 63
    4906:	f8 94       	cli
    4908:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    490a:	8a 8d       	ldd	r24, Y+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    490c:	0f 90       	pop	r0
    490e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    4910:	df 91       	pop	r29
    4912:	cf 91       	pop	r28
    4914:	08 95       	ret

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
UBaseType_t uxReturn;

	configASSERT( xQueue );
    4916:	6a e8       	ldi	r22, 0x8A	; 138
    4918:	77 e0       	ldi	r23, 0x07	; 7
    491a:	8f e6       	ldi	r24, 0x6F	; 111
    491c:	93 e2       	ldi	r25, 0x23	; 35
    491e:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    4922:	f0 cf       	rjmp	.-32     	; 0x4904 <uxQueueMessagesWaiting+0xa>

00004924 <prvWriteNameToBuffer>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    4924:	cf 93       	push	r28
    4926:	df 93       	push	r29
    4928:	ec 01       	movw	r28, r24
    492a:	0e 94 97 4c 	call	0x992e	; 0x992e <strcpy>
    492e:	fe 01       	movw	r30, r28
    4930:	01 90       	ld	r0, Z+
    4932:	00 20       	and	r0, r0
    4934:	e9 f7       	brne	.-6      	; 0x4930 <prvWriteNameToBuffer+0xc>
    4936:	31 97       	sbiw	r30, 0x01	; 1
    4938:	ec 1b       	sub	r30, r28
    493a:	fd 0b       	sbc	r31, r29
    493c:	e7 30       	cpi	r30, 0x07	; 7
    493e:	f1 05       	cpc	r31, r1
    4940:	60 f4       	brcc	.+24     	; 0x495a <prvWriteNameToBuffer+0x36>
    4942:	ec 0f       	add	r30, r28
    4944:	fd 1f       	adc	r31, r29
    4946:	9e 01       	movw	r18, r28
    4948:	29 5f       	subi	r18, 0xF9	; 249
    494a:	3f 4f       	sbci	r19, 0xFF	; 255
    494c:	80 e2       	ldi	r24, 0x20	; 32
    494e:	81 93       	st	Z+, r24
    4950:	e2 17       	cp	r30, r18
    4952:	f3 07       	cpc	r31, r19
    4954:	e1 f7       	brne	.-8      	; 0x494e <prvWriteNameToBuffer+0x2a>
    4956:	e7 e0       	ldi	r30, 0x07	; 7
    4958:	f0 e0       	ldi	r31, 0x00	; 0
    495a:	ce 01       	movw	r24, r28
    495c:	8e 0f       	add	r24, r30
    495e:	9f 1f       	adc	r25, r31
    4960:	fc 01       	movw	r30, r24
    4962:	10 82       	st	Z, r1
    4964:	df 91       	pop	r29
    4966:	cf 91       	pop	r28
    4968:	08 95       	ret

0000496a <prvGetExpectedIdleTime>:
    496a:	90 91 b1 2c 	lds	r25, 0x2CB1	; 0x802cb1 <uxTopReadyPriority>
    496e:	e0 91 41 2d 	lds	r30, 0x2D41	; 0x802d41 <pxCurrentTCB>
    4972:	f0 91 42 2d 	lds	r31, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    4976:	86 89       	ldd	r24, Z+22	; 0x16
    4978:	81 11       	cpse	r24, r1
    497a:	04 c0       	rjmp	.+8      	; 0x4984 <prvGetExpectedIdleTime+0x1a>
    497c:	80 91 e7 2c 	lds	r24, 0x2CE7	; 0x802ce7 <pxReadyTasksLists>
    4980:	82 30       	cpi	r24, 0x02	; 2
    4982:	18 f0       	brcs	.+6      	; 0x498a <prvGetExpectedIdleTime+0x20>
    4984:	80 e0       	ldi	r24, 0x00	; 0
    4986:	90 e0       	ldi	r25, 0x00	; 0
    4988:	08 95       	ret
    498a:	91 11       	cpse	r25, r1
    498c:	fb cf       	rjmp	.-10     	; 0x4984 <prvGetExpectedIdleTime+0x1a>
    498e:	80 91 aa 2c 	lds	r24, 0x2CAA	; 0x802caa <xNextTaskUnblockTime>
    4992:	90 91 ab 2c 	lds	r25, 0x2CAB	; 0x802cab <xNextTaskUnblockTime+0x1>
    4996:	20 91 b2 2c 	lds	r18, 0x2CB2	; 0x802cb2 <xTickCount>
    499a:	30 91 b3 2c 	lds	r19, 0x2CB3	; 0x802cb3 <xTickCount+0x1>
    499e:	82 1b       	sub	r24, r18
    49a0:	93 0b       	sbc	r25, r19
    49a2:	08 95       	ret

000049a4 <prvResetNextTaskUnblockTime.part.1>:
    49a4:	e0 91 d3 2c 	lds	r30, 0x2CD3	; 0x802cd3 <pxDelayedTaskList>
    49a8:	f0 91 d4 2c 	lds	r31, 0x2CD4	; 0x802cd4 <pxDelayedTaskList+0x1>
    49ac:	05 80       	ldd	r0, Z+5	; 0x05
    49ae:	f6 81       	ldd	r31, Z+6	; 0x06
    49b0:	e0 2d       	mov	r30, r0
    49b2:	06 80       	ldd	r0, Z+6	; 0x06
    49b4:	f7 81       	ldd	r31, Z+7	; 0x07
    49b6:	e0 2d       	mov	r30, r0
    49b8:	82 81       	ldd	r24, Z+2	; 0x02
    49ba:	93 81       	ldd	r25, Z+3	; 0x03
    49bc:	80 93 aa 2c 	sts	0x2CAA, r24	; 0x802caa <xNextTaskUnblockTime>
    49c0:	90 93 ab 2c 	sts	0x2CAB, r25	; 0x802cab <xNextTaskUnblockTime+0x1>
    49c4:	08 95       	ret

000049c6 <prvTaskIsTaskSuspended>:
    49c6:	cf 93       	push	r28
    49c8:	df 93       	push	r29
    49ca:	ec 01       	movw	r28, r24
    49cc:	89 2b       	or	r24, r25
    49ce:	99 f0       	breq	.+38     	; 0x49f6 <prvTaskIsTaskSuspended+0x30>
    49d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    49d2:	9b 85       	ldd	r25, Y+11	; 0x0b
    49d4:	85 5b       	subi	r24, 0xB5	; 181
    49d6:	9c 42       	sbci	r25, 0x2C	; 44
    49d8:	21 f0       	breq	.+8      	; 0x49e2 <prvTaskIsTaskSuspended+0x1c>
    49da:	80 e0       	ldi	r24, 0x00	; 0
    49dc:	df 91       	pop	r29
    49de:	cf 91       	pop	r28
    49e0:	08 95       	ret
    49e2:	2c 89       	ldd	r18, Y+20	; 0x14
    49e4:	3d 89       	ldd	r19, Y+21	; 0x15
    49e6:	8c e2       	ldi	r24, 0x2C	; 44
    49e8:	28 3c       	cpi	r18, 0xC8	; 200
    49ea:	38 07       	cpc	r19, r24
    49ec:	b1 f3       	breq	.-20     	; 0x49da <prvTaskIsTaskSuspended+0x14>
    49ee:	81 e0       	ldi	r24, 0x01	; 1
    49f0:	23 2b       	or	r18, r19
    49f2:	99 f7       	brne	.-26     	; 0x49da <prvTaskIsTaskSuspended+0x14>
    49f4:	f3 cf       	rjmp	.-26     	; 0x49dc <prvTaskIsTaskSuspended+0x16>
    49f6:	62 ef       	ldi	r22, 0xF2	; 242
    49f8:	76 e0       	ldi	r23, 0x06	; 6
    49fa:	83 e8       	ldi	r24, 0x83	; 131
    49fc:	93 e2       	ldi	r25, 0x23	; 35
    49fe:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    4a02:	e6 cf       	rjmp	.-52     	; 0x49d0 <prvTaskIsTaskSuspended+0xa>

00004a04 <prvAddCurrentTaskToDelayedList>:
    4a04:	ff 92       	push	r15
    4a06:	0f 93       	push	r16
    4a08:	1f 93       	push	r17
    4a0a:	cf 93       	push	r28
    4a0c:	df 93       	push	r29
    4a0e:	ec 01       	movw	r28, r24
    4a10:	f6 2e       	mov	r15, r22
    4a12:	00 91 b2 2c 	lds	r16, 0x2CB2	; 0x802cb2 <xTickCount>
    4a16:	10 91 b3 2c 	lds	r17, 0x2CB3	; 0x802cb3 <xTickCount+0x1>
    4a1a:	80 91 41 2d 	lds	r24, 0x2D41	; 0x802d41 <pxCurrentTCB>
    4a1e:	90 91 42 2d 	lds	r25, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    4a22:	02 96       	adiw	r24, 0x02	; 2
    4a24:	0e 94 b0 1c 	call	0x3960	; 0x3960 <uxListRemove>
    4a28:	cf 3f       	cpi	r28, 0xFF	; 255
    4a2a:	8f ef       	ldi	r24, 0xFF	; 255
    4a2c:	d8 07       	cpc	r29, r24
    4a2e:	a9 f1       	breq	.+106    	; 0x4a9a <prvAddCurrentTaskToDelayedList+0x96>
    4a30:	c0 0f       	add	r28, r16
    4a32:	d1 1f       	adc	r29, r17
    4a34:	e0 91 41 2d 	lds	r30, 0x2D41	; 0x802d41 <pxCurrentTCB>
    4a38:	f0 91 42 2d 	lds	r31, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    4a3c:	c2 83       	std	Z+2, r28	; 0x02
    4a3e:	d3 83       	std	Z+3, r29	; 0x03
    4a40:	60 91 41 2d 	lds	r22, 0x2D41	; 0x802d41 <pxCurrentTCB>
    4a44:	70 91 42 2d 	lds	r23, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    4a48:	c0 17       	cp	r28, r16
    4a4a:	d1 07       	cpc	r29, r17
    4a4c:	c8 f0       	brcs	.+50     	; 0x4a80 <prvAddCurrentTaskToDelayedList+0x7c>
    4a4e:	80 91 d3 2c 	lds	r24, 0x2CD3	; 0x802cd3 <pxDelayedTaskList>
    4a52:	90 91 d4 2c 	lds	r25, 0x2CD4	; 0x802cd4 <pxDelayedTaskList+0x1>
    4a56:	6e 5f       	subi	r22, 0xFE	; 254
    4a58:	7f 4f       	sbci	r23, 0xFF	; 255
    4a5a:	0e 94 7f 1c 	call	0x38fe	; 0x38fe <vListInsert>
    4a5e:	80 91 aa 2c 	lds	r24, 0x2CAA	; 0x802caa <xNextTaskUnblockTime>
    4a62:	90 91 ab 2c 	lds	r25, 0x2CAB	; 0x802cab <xNextTaskUnblockTime+0x1>
    4a66:	c8 17       	cp	r28, r24
    4a68:	d9 07       	cpc	r29, r25
    4a6a:	20 f4       	brcc	.+8      	; 0x4a74 <prvAddCurrentTaskToDelayedList+0x70>
    4a6c:	c0 93 aa 2c 	sts	0x2CAA, r28	; 0x802caa <xNextTaskUnblockTime>
    4a70:	d0 93 ab 2c 	sts	0x2CAB, r29	; 0x802cab <xNextTaskUnblockTime+0x1>
    4a74:	df 91       	pop	r29
    4a76:	cf 91       	pop	r28
    4a78:	1f 91       	pop	r17
    4a7a:	0f 91       	pop	r16
    4a7c:	ff 90       	pop	r15
    4a7e:	08 95       	ret
    4a80:	80 91 d1 2c 	lds	r24, 0x2CD1	; 0x802cd1 <pxOverflowDelayedTaskList>
    4a84:	90 91 d2 2c 	lds	r25, 0x2CD2	; 0x802cd2 <pxOverflowDelayedTaskList+0x1>
    4a88:	6e 5f       	subi	r22, 0xFE	; 254
    4a8a:	7f 4f       	sbci	r23, 0xFF	; 255
    4a8c:	df 91       	pop	r29
    4a8e:	cf 91       	pop	r28
    4a90:	1f 91       	pop	r17
    4a92:	0f 91       	pop	r16
    4a94:	ff 90       	pop	r15
    4a96:	0c 94 7f 1c 	jmp	0x38fe	; 0x38fe <vListInsert>
    4a9a:	ff 20       	and	r15, r15
    4a9c:	49 f2       	breq	.-110    	; 0x4a30 <prvAddCurrentTaskToDelayedList+0x2c>
    4a9e:	60 91 41 2d 	lds	r22, 0x2D41	; 0x802d41 <pxCurrentTCB>
    4aa2:	70 91 42 2d 	lds	r23, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    4aa6:	6e 5f       	subi	r22, 0xFE	; 254
    4aa8:	7f 4f       	sbci	r23, 0xFF	; 255
    4aaa:	85 eb       	ldi	r24, 0xB5	; 181
    4aac:	9c e2       	ldi	r25, 0x2C	; 44
    4aae:	df 91       	pop	r29
    4ab0:	cf 91       	pop	r28
    4ab2:	1f 91       	pop	r17
    4ab4:	0f 91       	pop	r16
    4ab6:	ff 90       	pop	r15
    4ab8:	0c 94 5e 1c 	jmp	0x38bc	; 0x38bc <vListInsertEnd>

00004abc <vTaskSwitchContext.part.6>:
    4abc:	0f 93       	push	r16
    4abe:	1f 93       	push	r17
    4ac0:	cf 93       	push	r28
    4ac2:	10 92 ae 2c 	sts	0x2CAE, r1	; 0x802cae <xYieldPending>
    4ac6:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    4aca:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    4ace:	80 91 85 2d 	lds	r24, 0x2D85	; 0x802d85 <StatsTimer>
    4ad2:	90 91 86 2d 	lds	r25, 0x2D86	; 0x802d86 <StatsTimer+0x1>
    4ad6:	a0 91 87 2d 	lds	r26, 0x2D87	; 0x802d87 <StatsTimer+0x2>
    4ada:	b0 91 88 2d 	lds	r27, 0x2D88	; 0x802d88 <StatsTimer+0x3>
    4ade:	82 0f       	add	r24, r18
    4ae0:	93 1f       	adc	r25, r19
    4ae2:	a1 1d       	adc	r26, r1
    4ae4:	b1 1d       	adc	r27, r1
    4ae6:	00 91 a3 2c 	lds	r16, 0x2CA3	; 0x802ca3 <ulTaskSwitchedInTime>
    4aea:	10 91 a4 2c 	lds	r17, 0x2CA4	; 0x802ca4 <ulTaskSwitchedInTime+0x1>
    4aee:	20 91 a5 2c 	lds	r18, 0x2CA5	; 0x802ca5 <ulTaskSwitchedInTime+0x2>
    4af2:	30 91 a6 2c 	lds	r19, 0x2CA6	; 0x802ca6 <ulTaskSwitchedInTime+0x3>
    4af6:	08 17       	cp	r16, r24
    4af8:	19 07       	cpc	r17, r25
    4afa:	2a 07       	cpc	r18, r26
    4afc:	3b 07       	cpc	r19, r27
    4afe:	a0 f4       	brcc	.+40     	; 0x4b28 <vTaskSwitchContext.part.6+0x6c>
    4b00:	e0 91 41 2d 	lds	r30, 0x2D41	; 0x802d41 <pxCurrentTCB>
    4b04:	f0 91 42 2d 	lds	r31, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    4b08:	47 a1       	ldd	r20, Z+39	; 0x27
    4b0a:	50 a5       	ldd	r21, Z+40	; 0x28
    4b0c:	61 a5       	ldd	r22, Z+41	; 0x29
    4b0e:	72 a5       	ldd	r23, Z+42	; 0x2a
    4b10:	40 1b       	sub	r20, r16
    4b12:	51 0b       	sbc	r21, r17
    4b14:	62 0b       	sbc	r22, r18
    4b16:	73 0b       	sbc	r23, r19
    4b18:	48 0f       	add	r20, r24
    4b1a:	59 1f       	adc	r21, r25
    4b1c:	6a 1f       	adc	r22, r26
    4b1e:	7b 1f       	adc	r23, r27
    4b20:	47 a3       	std	Z+39, r20	; 0x27
    4b22:	50 a7       	std	Z+40, r21	; 0x28
    4b24:	61 a7       	std	Z+41, r22	; 0x29
    4b26:	72 a7       	std	Z+42, r23	; 0x2a
    4b28:	80 93 a3 2c 	sts	0x2CA3, r24	; 0x802ca3 <ulTaskSwitchedInTime>
    4b2c:	90 93 a4 2c 	sts	0x2CA4, r25	; 0x802ca4 <ulTaskSwitchedInTime+0x1>
    4b30:	a0 93 a5 2c 	sts	0x2CA5, r26	; 0x802ca5 <ulTaskSwitchedInTime+0x2>
    4b34:	b0 93 a6 2c 	sts	0x2CA6, r27	; 0x802ca6 <ulTaskSwitchedInTime+0x3>
    4b38:	e0 91 41 2d 	lds	r30, 0x2D41	; 0x802d41 <pxCurrentTCB>
    4b3c:	f0 91 42 2d 	lds	r31, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    4b40:	07 88       	ldd	r0, Z+23	; 0x17
    4b42:	f0 8d       	ldd	r31, Z+24	; 0x18
    4b44:	e0 2d       	mov	r30, r0
    4b46:	80 81       	ld	r24, Z
    4b48:	91 81       	ldd	r25, Z+1	; 0x01
    4b4a:	a2 81       	ldd	r26, Z+2	; 0x02
    4b4c:	b3 81       	ldd	r27, Z+3	; 0x03
    4b4e:	85 3a       	cpi	r24, 0xA5	; 165
    4b50:	95 4a       	sbci	r25, 0xA5	; 165
    4b52:	a5 4a       	sbci	r26, 0xA5	; 165
    4b54:	b5 4a       	sbci	r27, 0xA5	; 165
    4b56:	09 f4       	brne	.+2      	; 0x4b5a <vTaskSwitchContext.part.6+0x9e>
    4b58:	4c c0       	rjmp	.+152    	; 0x4bf2 <vTaskSwitchContext.part.6+0x136>
    4b5a:	60 91 41 2d 	lds	r22, 0x2D41	; 0x802d41 <pxCurrentTCB>
    4b5e:	70 91 42 2d 	lds	r23, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    4b62:	80 91 41 2d 	lds	r24, 0x2D41	; 0x802d41 <pxCurrentTCB>
    4b66:	90 91 42 2d 	lds	r25, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    4b6a:	67 5e       	subi	r22, 0xE7	; 231
    4b6c:	7f 4f       	sbci	r23, 0xFF	; 255
    4b6e:	0e 94 b5 2f 	call	0x5f6a	; 0x5f6a <vApplicationStackOverflowHook>
    4b72:	c0 91 b1 2c 	lds	r28, 0x2CB1	; 0x802cb1 <uxTopReadyPriority>
    4b76:	8c 2f       	mov	r24, r28
    4b78:	90 e0       	ldi	r25, 0x00	; 0
    4b7a:	9c 01       	movw	r18, r24
    4b7c:	22 0f       	add	r18, r18
    4b7e:	33 1f       	adc	r19, r19
    4b80:	22 0f       	add	r18, r18
    4b82:	33 1f       	adc	r19, r19
    4b84:	22 0f       	add	r18, r18
    4b86:	33 1f       	adc	r19, r19
    4b88:	f9 01       	movw	r30, r18
    4b8a:	e8 0f       	add	r30, r24
    4b8c:	f9 1f       	adc	r31, r25
    4b8e:	e9 51       	subi	r30, 0x19	; 25
    4b90:	f3 4d       	sbci	r31, 0xD3	; 211
    4b92:	40 81       	ld	r20, Z
    4b94:	41 11       	cpse	r20, r1
    4b96:	0c c0       	rjmp	.+24     	; 0x4bb0 <vTaskSwitchContext.part.6+0xf4>
    4b98:	cc 23       	and	r28, r28
    4b9a:	11 f0       	breq	.+4      	; 0x4ba0 <vTaskSwitchContext.part.6+0xe4>
    4b9c:	c1 50       	subi	r28, 0x01	; 1
    4b9e:	eb cf       	rjmp	.-42     	; 0x4b76 <vTaskSwitchContext.part.6+0xba>
    4ba0:	6c e8       	ldi	r22, 0x8C	; 140
    4ba2:	7b e0       	ldi	r23, 0x0B	; 11
    4ba4:	83 e8       	ldi	r24, 0x83	; 131
    4ba6:	93 e2       	ldi	r25, 0x23	; 35
    4ba8:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    4bac:	c1 50       	subi	r28, 0x01	; 1
    4bae:	e3 cf       	rjmp	.-58     	; 0x4b76 <vTaskSwitchContext.part.6+0xba>
    4bb0:	82 0f       	add	r24, r18
    4bb2:	93 1f       	adc	r25, r19
    4bb4:	dc 01       	movw	r26, r24
    4bb6:	a9 51       	subi	r26, 0x19	; 25
    4bb8:	b3 4d       	sbci	r27, 0xD3	; 211
    4bba:	11 96       	adiw	r26, 0x01	; 1
    4bbc:	ed 91       	ld	r30, X+
    4bbe:	fc 91       	ld	r31, X
    4bc0:	12 97       	sbiw	r26, 0x02	; 2
    4bc2:	02 80       	ldd	r0, Z+2	; 0x02
    4bc4:	f3 81       	ldd	r31, Z+3	; 0x03
    4bc6:	e0 2d       	mov	r30, r0
    4bc8:	11 96       	adiw	r26, 0x01	; 1
    4bca:	ed 93       	st	X+, r30
    4bcc:	fc 93       	st	X, r31
    4bce:	12 97       	sbiw	r26, 0x02	; 2
    4bd0:	86 51       	subi	r24, 0x16	; 22
    4bd2:	93 4d       	sbci	r25, 0xD3	; 211
    4bd4:	e8 17       	cp	r30, r24
    4bd6:	f9 07       	cpc	r31, r25
    4bd8:	59 f1       	breq	.+86     	; 0x4c30 <vTaskSwitchContext.part.6+0x174>
    4bda:	86 81       	ldd	r24, Z+6	; 0x06
    4bdc:	97 81       	ldd	r25, Z+7	; 0x07
    4bde:	80 93 41 2d 	sts	0x2D41, r24	; 0x802d41 <pxCurrentTCB>
    4be2:	90 93 42 2d 	sts	0x2D42, r25	; 0x802d42 <pxCurrentTCB+0x1>
    4be6:	c0 93 b1 2c 	sts	0x2CB1, r28	; 0x802cb1 <uxTopReadyPriority>
    4bea:	cf 91       	pop	r28
    4bec:	1f 91       	pop	r17
    4bee:	0f 91       	pop	r16
    4bf0:	08 95       	ret
    4bf2:	84 81       	ldd	r24, Z+4	; 0x04
    4bf4:	95 81       	ldd	r25, Z+5	; 0x05
    4bf6:	a6 81       	ldd	r26, Z+6	; 0x06
    4bf8:	b7 81       	ldd	r27, Z+7	; 0x07
    4bfa:	85 3a       	cpi	r24, 0xA5	; 165
    4bfc:	95 4a       	sbci	r25, 0xA5	; 165
    4bfe:	a5 4a       	sbci	r26, 0xA5	; 165
    4c00:	b5 4a       	sbci	r27, 0xA5	; 165
    4c02:	09 f0       	breq	.+2      	; 0x4c06 <vTaskSwitchContext.part.6+0x14a>
    4c04:	aa cf       	rjmp	.-172    	; 0x4b5a <vTaskSwitchContext.part.6+0x9e>
    4c06:	80 85       	ldd	r24, Z+8	; 0x08
    4c08:	91 85       	ldd	r25, Z+9	; 0x09
    4c0a:	a2 85       	ldd	r26, Z+10	; 0x0a
    4c0c:	b3 85       	ldd	r27, Z+11	; 0x0b
    4c0e:	85 3a       	cpi	r24, 0xA5	; 165
    4c10:	95 4a       	sbci	r25, 0xA5	; 165
    4c12:	a5 4a       	sbci	r26, 0xA5	; 165
    4c14:	b5 4a       	sbci	r27, 0xA5	; 165
    4c16:	09 f0       	breq	.+2      	; 0x4c1a <vTaskSwitchContext.part.6+0x15e>
    4c18:	a0 cf       	rjmp	.-192    	; 0x4b5a <vTaskSwitchContext.part.6+0x9e>
    4c1a:	84 85       	ldd	r24, Z+12	; 0x0c
    4c1c:	95 85       	ldd	r25, Z+13	; 0x0d
    4c1e:	a6 85       	ldd	r26, Z+14	; 0x0e
    4c20:	b7 85       	ldd	r27, Z+15	; 0x0f
    4c22:	85 3a       	cpi	r24, 0xA5	; 165
    4c24:	95 4a       	sbci	r25, 0xA5	; 165
    4c26:	a5 4a       	sbci	r26, 0xA5	; 165
    4c28:	b5 4a       	sbci	r27, 0xA5	; 165
    4c2a:	09 f0       	breq	.+2      	; 0x4c2e <vTaskSwitchContext.part.6+0x172>
    4c2c:	96 cf       	rjmp	.-212    	; 0x4b5a <vTaskSwitchContext.part.6+0x9e>
    4c2e:	a1 cf       	rjmp	.-190    	; 0x4b72 <vTaskSwitchContext.part.6+0xb6>
    4c30:	02 80       	ldd	r0, Z+2	; 0x02
    4c32:	f3 81       	ldd	r31, Z+3	; 0x03
    4c34:	e0 2d       	mov	r30, r0
    4c36:	11 96       	adiw	r26, 0x01	; 1
    4c38:	ed 93       	st	X+, r30
    4c3a:	fc 93       	st	X, r31
    4c3c:	12 97       	sbiw	r26, 0x02	; 2
    4c3e:	cd cf       	rjmp	.-102    	; 0x4bda <vTaskSwitchContext.part.6+0x11e>

00004c40 <xTaskCreate>:
    4c40:	5f 92       	push	r5
    4c42:	6f 92       	push	r6
    4c44:	7f 92       	push	r7
    4c46:	8f 92       	push	r8
    4c48:	9f 92       	push	r9
    4c4a:	af 92       	push	r10
    4c4c:	bf 92       	push	r11
    4c4e:	cf 92       	push	r12
    4c50:	df 92       	push	r13
    4c52:	ef 92       	push	r14
    4c54:	ff 92       	push	r15
    4c56:	0f 93       	push	r16
    4c58:	1f 93       	push	r17
    4c5a:	cf 93       	push	r28
    4c5c:	df 93       	push	r29
    4c5e:	4c 01       	movw	r8, r24
    4c60:	eb 01       	movw	r28, r22
    4c62:	5a 01       	movw	r10, r20
    4c64:	39 01       	movw	r6, r18
    4c66:	50 2e       	mov	r5, r16
    4c68:	ca 01       	movw	r24, r20
    4c6a:	0e 94 7d 1b 	call	0x36fa	; 0x36fa <pvPortMalloc>
    4c6e:	8c 01       	movw	r16, r24
    4c70:	89 2b       	or	r24, r25
    4c72:	09 f4       	brne	.+2      	; 0x4c76 <xTaskCreate+0x36>
    4c74:	de c0       	rjmp	.+444    	; 0x4e32 <xTaskCreate+0x1f2>
    4c76:	80 e3       	ldi	r24, 0x30	; 48
    4c78:	90 e0       	ldi	r25, 0x00	; 0
    4c7a:	0e 94 7d 1b 	call	0x36fa	; 0x36fa <pvPortMalloc>
    4c7e:	6c 01       	movw	r12, r24
    4c80:	00 97       	sbiw	r24, 0x00	; 0
    4c82:	09 f4       	brne	.+2      	; 0x4c86 <xTaskCreate+0x46>
    4c84:	d3 c0       	rjmp	.+422    	; 0x4e2c <xTaskCreate+0x1ec>
    4c86:	dc 01       	movw	r26, r24
    4c88:	57 96       	adiw	r26, 0x17	; 23
    4c8a:	0d 93       	st	X+, r16
    4c8c:	1c 93       	st	X, r17
    4c8e:	58 97       	sbiw	r26, 0x18	; 24
    4c90:	20 97       	sbiw	r28, 0x00	; 0
    4c92:	09 f4       	brne	.+2      	; 0x4c96 <xTaskCreate+0x56>
    4c94:	d0 c0       	rjmp	.+416    	; 0x4e36 <xTaskCreate+0x1f6>
    4c96:	c8 01       	movw	r24, r16
    4c98:	a5 01       	movw	r20, r10
    4c9a:	65 ea       	ldi	r22, 0xA5	; 165
    4c9c:	70 e0       	ldi	r23, 0x00	; 0
    4c9e:	0e 94 90 4c 	call	0x9920	; 0x9920 <memset>
    4ca2:	f1 e0       	ldi	r31, 0x01	; 1
    4ca4:	af 1a       	sub	r10, r31
    4ca6:	b1 08       	sbc	r11, r1
    4ca8:	d6 01       	movw	r26, r12
    4caa:	57 96       	adiw	r26, 0x17	; 23
    4cac:	8d 91       	ld	r24, X+
    4cae:	9c 91       	ld	r25, X
    4cb0:	58 97       	sbiw	r26, 0x18	; 24
    4cb2:	a8 0e       	add	r10, r24
    4cb4:	b9 1e       	adc	r11, r25
    4cb6:	f6 01       	movw	r30, r12
    4cb8:	79 96       	adiw	r30, 0x19	; 25
    4cba:	9e 01       	movw	r18, r28
    4cbc:	28 5f       	subi	r18, 0xF8	; 248
    4cbe:	3f 4f       	sbci	r19, 0xFF	; 255
    4cc0:	de 01       	movw	r26, r28
    4cc2:	89 91       	ld	r24, Y+
    4cc4:	81 93       	st	Z+, r24
    4cc6:	8c 91       	ld	r24, X
    4cc8:	88 23       	and	r24, r24
    4cca:	19 f0       	breq	.+6      	; 0x4cd2 <xTaskCreate+0x92>
    4ccc:	c2 17       	cp	r28, r18
    4cce:	d3 07       	cpc	r29, r19
    4cd0:	b9 f7       	brne	.-18     	; 0x4cc0 <xTaskCreate+0x80>
    4cd2:	f6 01       	movw	r30, r12
    4cd4:	10 a2       	std	Z+32, r1	; 0x20
    4cd6:	05 2d       	mov	r16, r5
    4cd8:	0a 30       	cpi	r16, 0x0A	; 10
    4cda:	08 f0       	brcs	.+2      	; 0x4cde <xTaskCreate+0x9e>
    4cdc:	a1 c0       	rjmp	.+322    	; 0x4e20 <xTaskCreate+0x1e0>
    4cde:	d6 01       	movw	r26, r12
    4ce0:	56 96       	adiw	r26, 0x16	; 22
    4ce2:	0c 93       	st	X, r16
    4ce4:	56 97       	sbiw	r26, 0x16	; 22
    4ce6:	93 96       	adiw	r26, 0x23	; 35
    4ce8:	0c 93       	st	X, r16
    4cea:	93 97       	sbiw	r26, 0x23	; 35
    4cec:	94 96       	adiw	r26, 0x24	; 36
    4cee:	1c 92       	st	X, r1
    4cf0:	e6 01       	movw	r28, r12
    4cf2:	22 96       	adiw	r28, 0x02	; 2
    4cf4:	ce 01       	movw	r24, r28
    4cf6:	0e 94 5a 1c 	call	0x38b4	; 0x38b4 <vListInitialiseItem>
    4cfa:	c6 01       	movw	r24, r12
    4cfc:	0c 96       	adiw	r24, 0x0c	; 12
    4cfe:	0e 94 5a 1c 	call	0x38b4	; 0x38b4 <vListInitialiseItem>
    4d02:	f6 01       	movw	r30, r12
    4d04:	c0 86       	std	Z+8, r12	; 0x08
    4d06:	d1 86       	std	Z+9, r13	; 0x09
    4d08:	8a e0       	ldi	r24, 0x0A	; 10
    4d0a:	90 e0       	ldi	r25, 0x00	; 0
    4d0c:	80 1b       	sub	r24, r16
    4d0e:	91 09       	sbc	r25, r1
    4d10:	84 87       	std	Z+12, r24	; 0x0c
    4d12:	95 87       	std	Z+13, r25	; 0x0d
    4d14:	c2 8a       	std	Z+18, r12	; 0x12
    4d16:	d3 8a       	std	Z+19, r13	; 0x13
    4d18:	15 a2       	std	Z+37, r1	; 0x25
    4d1a:	16 a2       	std	Z+38, r1	; 0x26
    4d1c:	17 a2       	std	Z+39, r1	; 0x27
    4d1e:	10 a6       	std	Z+40, r1	; 0x28
    4d20:	11 a6       	std	Z+41, r1	; 0x29
    4d22:	12 a6       	std	Z+42, r1	; 0x2a
    4d24:	13 a6       	std	Z+43, r1	; 0x2b
    4d26:	14 a6       	std	Z+44, r1	; 0x2c
    4d28:	15 a6       	std	Z+45, r1	; 0x2d
    4d2a:	16 a6       	std	Z+46, r1	; 0x2e
    4d2c:	17 a6       	std	Z+47, r1	; 0x2f
    4d2e:	a3 01       	movw	r20, r6
    4d30:	b4 01       	movw	r22, r8
    4d32:	c5 01       	movw	r24, r10
    4d34:	0e 94 d6 1c 	call	0x39ac	; 0x39ac <pxPortInitialiseStack>
    4d38:	d6 01       	movw	r26, r12
    4d3a:	8d 93       	st	X+, r24
    4d3c:	9c 93       	st	X, r25
    4d3e:	e1 14       	cp	r14, r1
    4d40:	f1 04       	cpc	r15, r1
    4d42:	19 f0       	breq	.+6      	; 0x4d4a <xTaskCreate+0x10a>
    4d44:	f7 01       	movw	r30, r14
    4d46:	c0 82       	st	Z, r12
    4d48:	d1 82       	std	Z+1, r13	; 0x01
    4d4a:	0f b6       	in	r0, 0x3f	; 63
    4d4c:	f8 94       	cli
    4d4e:	0f 92       	push	r0
    4d50:	80 91 b4 2c 	lds	r24, 0x2CB4	; 0x802cb4 <uxCurrentNumberOfTasks>
    4d54:	8f 5f       	subi	r24, 0xFF	; 255
    4d56:	80 93 b4 2c 	sts	0x2CB4, r24	; 0x802cb4 <uxCurrentNumberOfTasks>
    4d5a:	80 91 41 2d 	lds	r24, 0x2D41	; 0x802d41 <pxCurrentTCB>
    4d5e:	90 91 42 2d 	lds	r25, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    4d62:	89 2b       	or	r24, r25
    4d64:	99 f0       	breq	.+38     	; 0x4d8c <xTaskCreate+0x14c>
    4d66:	80 91 b0 2c 	lds	r24, 0x2CB0	; 0x802cb0 <xSchedulerRunning>
    4d6a:	81 11       	cpse	r24, r1
    4d6c:	18 c0       	rjmp	.+48     	; 0x4d9e <xTaskCreate+0x15e>
    4d6e:	e0 91 41 2d 	lds	r30, 0x2D41	; 0x802d41 <pxCurrentTCB>
    4d72:	f0 91 42 2d 	lds	r31, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    4d76:	d6 01       	movw	r26, r12
    4d78:	56 96       	adiw	r26, 0x16	; 22
    4d7a:	8c 91       	ld	r24, X
    4d7c:	96 89       	ldd	r25, Z+22	; 0x16
    4d7e:	89 17       	cp	r24, r25
    4d80:	88 f0       	brcs	.+34     	; 0x4da4 <xTaskCreate+0x164>
    4d82:	c0 92 41 2d 	sts	0x2D41, r12	; 0x802d41 <pxCurrentTCB>
    4d86:	d0 92 42 2d 	sts	0x2D42, r13	; 0x802d42 <pxCurrentTCB+0x1>
    4d8a:	0c c0       	rjmp	.+24     	; 0x4da4 <xTaskCreate+0x164>
    4d8c:	c0 92 41 2d 	sts	0x2D41, r12	; 0x802d41 <pxCurrentTCB>
    4d90:	d0 92 42 2d 	sts	0x2D42, r13	; 0x802d42 <pxCurrentTCB+0x1>
    4d94:	80 91 b4 2c 	lds	r24, 0x2CB4	; 0x802cb4 <uxCurrentNumberOfTasks>
    4d98:	81 30       	cpi	r24, 0x01	; 1
    4d9a:	09 f4       	brne	.+2      	; 0x4d9e <xTaskCreate+0x15e>
    4d9c:	56 c0       	rjmp	.+172    	; 0x4e4a <xTaskCreate+0x20a>
    4d9e:	d6 01       	movw	r26, r12
    4da0:	56 96       	adiw	r26, 0x16	; 22
    4da2:	8c 91       	ld	r24, X
    4da4:	90 91 ac 2c 	lds	r25, 0x2CAC	; 0x802cac <uxTaskNumber>
    4da8:	9f 5f       	subi	r25, 0xFF	; 255
    4daa:	90 93 ac 2c 	sts	0x2CAC, r25	; 0x802cac <uxTaskNumber>
    4dae:	f6 01       	movw	r30, r12
    4db0:	91 a3       	std	Z+33, r25	; 0x21
    4db2:	90 91 b1 2c 	lds	r25, 0x2CB1	; 0x802cb1 <uxTopReadyPriority>
    4db6:	98 17       	cp	r25, r24
    4db8:	80 f1       	brcs	.+96     	; 0x4e1a <xTaskCreate+0x1da>
    4dba:	90 e0       	ldi	r25, 0x00	; 0
    4dbc:	9c 01       	movw	r18, r24
    4dbe:	22 0f       	add	r18, r18
    4dc0:	33 1f       	adc	r19, r19
    4dc2:	22 0f       	add	r18, r18
    4dc4:	33 1f       	adc	r19, r19
    4dc6:	22 0f       	add	r18, r18
    4dc8:	33 1f       	adc	r19, r19
    4dca:	82 0f       	add	r24, r18
    4dcc:	93 1f       	adc	r25, r19
    4dce:	be 01       	movw	r22, r28
    4dd0:	89 51       	subi	r24, 0x19	; 25
    4dd2:	93 4d       	sbci	r25, 0xD3	; 211
    4dd4:	0e 94 5e 1c 	call	0x38bc	; 0x38bc <vListInsertEnd>
    4dd8:	0f 90       	pop	r0
    4dda:	0f be       	out	0x3f, r0	; 63
    4ddc:	80 91 b0 2c 	lds	r24, 0x2CB0	; 0x802cb0 <xSchedulerRunning>
    4de0:	88 23       	and	r24, r24
    4de2:	51 f0       	breq	.+20     	; 0x4df8 <xTaskCreate+0x1b8>
    4de4:	e0 91 41 2d 	lds	r30, 0x2D41	; 0x802d41 <pxCurrentTCB>
    4de8:	f0 91 42 2d 	lds	r31, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    4dec:	96 89       	ldd	r25, Z+22	; 0x16
    4dee:	d6 01       	movw	r26, r12
    4df0:	56 96       	adiw	r26, 0x16	; 22
    4df2:	8c 91       	ld	r24, X
    4df4:	98 17       	cp	r25, r24
    4df6:	b0 f0       	brcs	.+44     	; 0x4e24 <xTaskCreate+0x1e4>
    4df8:	81 e0       	ldi	r24, 0x01	; 1
    4dfa:	df 91       	pop	r29
    4dfc:	cf 91       	pop	r28
    4dfe:	1f 91       	pop	r17
    4e00:	0f 91       	pop	r16
    4e02:	ff 90       	pop	r15
    4e04:	ef 90       	pop	r14
    4e06:	df 90       	pop	r13
    4e08:	cf 90       	pop	r12
    4e0a:	bf 90       	pop	r11
    4e0c:	af 90       	pop	r10
    4e0e:	9f 90       	pop	r9
    4e10:	8f 90       	pop	r8
    4e12:	7f 90       	pop	r7
    4e14:	6f 90       	pop	r6
    4e16:	5f 90       	pop	r5
    4e18:	08 95       	ret
    4e1a:	80 93 b1 2c 	sts	0x2CB1, r24	; 0x802cb1 <uxTopReadyPriority>
    4e1e:	cd cf       	rjmp	.-102    	; 0x4dba <xTaskCreate+0x17a>
    4e20:	09 e0       	ldi	r16, 0x09	; 9
    4e22:	5d cf       	rjmp	.-326    	; 0x4cde <xTaskCreate+0x9e>
    4e24:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <vPortYield>
    4e28:	81 e0       	ldi	r24, 0x01	; 1
    4e2a:	e7 cf       	rjmp	.-50     	; 0x4dfa <xTaskCreate+0x1ba>
    4e2c:	c8 01       	movw	r24, r16
    4e2e:	0e 94 1c 1c 	call	0x3838	; 0x3838 <vPortFree>
    4e32:	8f ef       	ldi	r24, 0xFF	; 255
    4e34:	e2 cf       	rjmp	.-60     	; 0x4dfa <xTaskCreate+0x1ba>
    4e36:	60 e6       	ldi	r22, 0x60	; 96
    4e38:	73 e0       	ldi	r23, 0x03	; 3
    4e3a:	83 e8       	ldi	r24, 0x83	; 131
    4e3c:	93 e2       	ldi	r25, 0x23	; 35
    4e3e:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    4e42:	f6 01       	movw	r30, r12
    4e44:	87 89       	ldd	r24, Z+23	; 0x17
    4e46:	90 8d       	ldd	r25, Z+24	; 0x18
    4e48:	27 cf       	rjmp	.-434    	; 0x4c98 <xTaskCreate+0x58>
    4e4a:	07 ee       	ldi	r16, 0xE7	; 231
    4e4c:	1c e2       	ldi	r17, 0x2C	; 44
    4e4e:	51 e4       	ldi	r21, 0x41	; 65
    4e50:	e5 2e       	mov	r14, r21
    4e52:	5d e2       	ldi	r21, 0x2D	; 45
    4e54:	f5 2e       	mov	r15, r21
    4e56:	c8 01       	movw	r24, r16
    4e58:	0e 94 4c 1c 	call	0x3898	; 0x3898 <vListInitialise>
    4e5c:	07 5f       	subi	r16, 0xF7	; 247
    4e5e:	1f 4f       	sbci	r17, 0xFF	; 255
    4e60:	e0 16       	cp	r14, r16
    4e62:	f1 06       	cpc	r15, r17
    4e64:	c1 f7       	brne	.-16     	; 0x4e56 <xTaskCreate+0x216>
    4e66:	8e ed       	ldi	r24, 0xDE	; 222
    4e68:	9c e2       	ldi	r25, 0x2C	; 44
    4e6a:	0e 94 4c 1c 	call	0x3898	; 0x3898 <vListInitialise>
    4e6e:	85 ed       	ldi	r24, 0xD5	; 213
    4e70:	9c e2       	ldi	r25, 0x2C	; 44
    4e72:	0e 94 4c 1c 	call	0x3898	; 0x3898 <vListInitialise>
    4e76:	88 ec       	ldi	r24, 0xC8	; 200
    4e78:	9c e2       	ldi	r25, 0x2C	; 44
    4e7a:	0e 94 4c 1c 	call	0x3898	; 0x3898 <vListInitialise>
    4e7e:	8f eb       	ldi	r24, 0xBF	; 191
    4e80:	9c e2       	ldi	r25, 0x2C	; 44
    4e82:	0e 94 4c 1c 	call	0x3898	; 0x3898 <vListInitialise>
    4e86:	85 eb       	ldi	r24, 0xB5	; 181
    4e88:	9c e2       	ldi	r25, 0x2C	; 44
    4e8a:	0e 94 4c 1c 	call	0x3898	; 0x3898 <vListInitialise>
    4e8e:	8e ed       	ldi	r24, 0xDE	; 222
    4e90:	9c e2       	ldi	r25, 0x2C	; 44
    4e92:	80 93 d3 2c 	sts	0x2CD3, r24	; 0x802cd3 <pxDelayedTaskList>
    4e96:	90 93 d4 2c 	sts	0x2CD4, r25	; 0x802cd4 <pxDelayedTaskList+0x1>
    4e9a:	85 ed       	ldi	r24, 0xD5	; 213
    4e9c:	9c e2       	ldi	r25, 0x2C	; 44
    4e9e:	80 93 d1 2c 	sts	0x2CD1, r24	; 0x802cd1 <pxOverflowDelayedTaskList>
    4ea2:	90 93 d2 2c 	sts	0x2CD2, r25	; 0x802cd2 <pxOverflowDelayedTaskList+0x1>
    4ea6:	f6 01       	movw	r30, r12
    4ea8:	86 89       	ldd	r24, Z+22	; 0x16
    4eaa:	7c cf       	rjmp	.-264    	; 0x4da4 <xTaskCreate+0x164>

00004eac <eTaskGetState>:
    4eac:	cf 93       	push	r28
    4eae:	df 93       	push	r29
    4eb0:	ec 01       	movw	r28, r24
    4eb2:	89 2b       	or	r24, r25
    4eb4:	09 f4       	brne	.+2      	; 0x4eb8 <eTaskGetState+0xc>
    4eb6:	3a c0       	rjmp	.+116    	; 0x4f2c <eTaskGetState+0x80>
    4eb8:	80 91 41 2d 	lds	r24, 0x2D41	; 0x802d41 <pxCurrentTCB>
    4ebc:	90 91 42 2d 	lds	r25, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    4ec0:	c8 17       	cp	r28, r24
    4ec2:	d9 07       	cpc	r29, r25
    4ec4:	79 f1       	breq	.+94     	; 0x4f24 <eTaskGetState+0x78>
    4ec6:	0f b6       	in	r0, 0x3f	; 63
    4ec8:	f8 94       	cli
    4eca:	0f 92       	push	r0
    4ecc:	8a 85       	ldd	r24, Y+10	; 0x0a
    4ece:	9b 85       	ldd	r25, Y+11	; 0x0b
    4ed0:	20 91 d3 2c 	lds	r18, 0x2CD3	; 0x802cd3 <pxDelayedTaskList>
    4ed4:	30 91 d4 2c 	lds	r19, 0x2CD4	; 0x802cd4 <pxDelayedTaskList+0x1>
    4ed8:	40 91 d1 2c 	lds	r20, 0x2CD1	; 0x802cd1 <pxOverflowDelayedTaskList>
    4edc:	50 91 d2 2c 	lds	r21, 0x2CD2	; 0x802cd2 <pxOverflowDelayedTaskList+0x1>
    4ee0:	0f 90       	pop	r0
    4ee2:	0f be       	out	0x3f, r0	; 63
    4ee4:	82 17       	cp	r24, r18
    4ee6:	93 07       	cpc	r25, r19
    4ee8:	a9 f0       	breq	.+42     	; 0x4f14 <eTaskGetState+0x68>
    4eea:	84 17       	cp	r24, r20
    4eec:	95 07       	cpc	r25, r21
    4eee:	91 f0       	breq	.+36     	; 0x4f14 <eTaskGetState+0x68>
    4ef0:	2c e2       	ldi	r18, 0x2C	; 44
    4ef2:	85 3b       	cpi	r24, 0xB5	; 181
    4ef4:	92 07       	cpc	r25, r18
    4ef6:	51 f0       	breq	.+20     	; 0x4f0c <eTaskGetState+0x60>
    4ef8:	2c e2       	ldi	r18, 0x2C	; 44
    4efa:	8f 3b       	cpi	r24, 0xBF	; 191
    4efc:	92 07       	cpc	r25, r18
    4efe:	71 f0       	breq	.+28     	; 0x4f1c <eTaskGetState+0x70>
    4f00:	89 2b       	or	r24, r25
    4f02:	61 f0       	breq	.+24     	; 0x4f1c <eTaskGetState+0x70>
    4f04:	81 e0       	ldi	r24, 0x01	; 1
    4f06:	df 91       	pop	r29
    4f08:	cf 91       	pop	r28
    4f0a:	08 95       	ret
    4f0c:	8c 89       	ldd	r24, Y+20	; 0x14
    4f0e:	9d 89       	ldd	r25, Y+21	; 0x15
    4f10:	89 2b       	or	r24, r25
    4f12:	99 f0       	breq	.+38     	; 0x4f3a <eTaskGetState+0x8e>
    4f14:	82 e0       	ldi	r24, 0x02	; 2
    4f16:	df 91       	pop	r29
    4f18:	cf 91       	pop	r28
    4f1a:	08 95       	ret
    4f1c:	84 e0       	ldi	r24, 0x04	; 4
    4f1e:	df 91       	pop	r29
    4f20:	cf 91       	pop	r28
    4f22:	08 95       	ret
    4f24:	80 e0       	ldi	r24, 0x00	; 0
    4f26:	df 91       	pop	r29
    4f28:	cf 91       	pop	r28
    4f2a:	08 95       	ret
    4f2c:	6c e4       	ldi	r22, 0x4C	; 76
    4f2e:	75 e0       	ldi	r23, 0x05	; 5
    4f30:	83 e8       	ldi	r24, 0x83	; 131
    4f32:	93 e2       	ldi	r25, 0x23	; 35
    4f34:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    4f38:	bf cf       	rjmp	.-130    	; 0x4eb8 <eTaskGetState+0xc>
    4f3a:	8f a5       	ldd	r24, Y+47	; 0x2f
    4f3c:	81 30       	cpi	r24, 0x01	; 1
    4f3e:	51 f3       	breq	.-44     	; 0x4f14 <eTaskGetState+0x68>
    4f40:	83 e0       	ldi	r24, 0x03	; 3
    4f42:	e1 cf       	rjmp	.-62     	; 0x4f06 <eTaskGetState+0x5a>

00004f44 <vTaskSuspend>:
    4f44:	0f 93       	push	r16
    4f46:	1f 93       	push	r17
    4f48:	cf 93       	push	r28
    4f4a:	df 93       	push	r29
    4f4c:	ec 01       	movw	r28, r24
    4f4e:	0f b6       	in	r0, 0x3f	; 63
    4f50:	f8 94       	cli
    4f52:	0f 92       	push	r0
    4f54:	89 2b       	or	r24, r25
    4f56:	09 f4       	brne	.+2      	; 0x4f5a <vTaskSuspend+0x16>
    4f58:	62 c0       	rjmp	.+196    	; 0x501e <vTaskSuspend+0xda>
    4f5a:	8e 01       	movw	r16, r28
    4f5c:	0e 5f       	subi	r16, 0xFE	; 254
    4f5e:	1f 4f       	sbci	r17, 0xFF	; 255
    4f60:	c8 01       	movw	r24, r16
    4f62:	0e 94 b0 1c 	call	0x3960	; 0x3960 <uxListRemove>
    4f66:	8c 89       	ldd	r24, Y+20	; 0x14
    4f68:	9d 89       	ldd	r25, Y+21	; 0x15
    4f6a:	89 2b       	or	r24, r25
    4f6c:	21 f0       	breq	.+8      	; 0x4f76 <vTaskSuspend+0x32>
    4f6e:	ce 01       	movw	r24, r28
    4f70:	0c 96       	adiw	r24, 0x0c	; 12
    4f72:	0e 94 b0 1c 	call	0x3960	; 0x3960 <uxListRemove>
    4f76:	b8 01       	movw	r22, r16
    4f78:	85 eb       	ldi	r24, 0xB5	; 181
    4f7a:	9c e2       	ldi	r25, 0x2C	; 44
    4f7c:	0e 94 5e 1c 	call	0x38bc	; 0x38bc <vListInsertEnd>
    4f80:	8f a5       	ldd	r24, Y+47	; 0x2f
    4f82:	81 30       	cpi	r24, 0x01	; 1
    4f84:	21 f1       	breq	.+72     	; 0x4fce <vTaskSuspend+0x8a>
    4f86:	0f 90       	pop	r0
    4f88:	0f be       	out	0x3f, r0	; 63
    4f8a:	80 91 b0 2c 	lds	r24, 0x2CB0	; 0x802cb0 <xSchedulerRunning>
    4f8e:	88 23       	and	r24, r24
    4f90:	91 f0       	breq	.+36     	; 0x4fb6 <vTaskSuspend+0x72>
    4f92:	0f b6       	in	r0, 0x3f	; 63
    4f94:	f8 94       	cli
    4f96:	0f 92       	push	r0
    4f98:	e0 91 d3 2c 	lds	r30, 0x2CD3	; 0x802cd3 <pxDelayedTaskList>
    4f9c:	f0 91 d4 2c 	lds	r31, 0x2CD4	; 0x802cd4 <pxDelayedTaskList+0x1>
    4fa0:	80 81       	ld	r24, Z
    4fa2:	81 11       	cpse	r24, r1
    4fa4:	2b c0       	rjmp	.+86     	; 0x4ffc <vTaskSuspend+0xb8>
    4fa6:	8f ef       	ldi	r24, 0xFF	; 255
    4fa8:	9f ef       	ldi	r25, 0xFF	; 255
    4faa:	80 93 aa 2c 	sts	0x2CAA, r24	; 0x802caa <xNextTaskUnblockTime>
    4fae:	90 93 ab 2c 	sts	0x2CAB, r25	; 0x802cab <xNextTaskUnblockTime+0x1>
    4fb2:	0f 90       	pop	r0
    4fb4:	0f be       	out	0x3f, r0	; 63
    4fb6:	80 91 41 2d 	lds	r24, 0x2D41	; 0x802d41 <pxCurrentTCB>
    4fba:	90 91 42 2d 	lds	r25, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    4fbe:	c8 17       	cp	r28, r24
    4fc0:	d9 07       	cpc	r29, r25
    4fc2:	39 f0       	breq	.+14     	; 0x4fd2 <vTaskSuspend+0x8e>
    4fc4:	df 91       	pop	r29
    4fc6:	cf 91       	pop	r28
    4fc8:	1f 91       	pop	r17
    4fca:	0f 91       	pop	r16
    4fcc:	08 95       	ret
    4fce:	1f a6       	std	Y+47, r1	; 0x2f
    4fd0:	da cf       	rjmp	.-76     	; 0x4f86 <vTaskSuspend+0x42>
    4fd2:	80 91 b0 2c 	lds	r24, 0x2CB0	; 0x802cb0 <xSchedulerRunning>
    4fd6:	88 23       	and	r24, r24
    4fd8:	a1 f0       	breq	.+40     	; 0x5002 <vTaskSuspend+0xbe>
    4fda:	80 91 a7 2c 	lds	r24, 0x2CA7	; 0x802ca7 <uxSchedulerSuspended>
    4fde:	88 23       	and	r24, r24
    4fe0:	31 f0       	breq	.+12     	; 0x4fee <vTaskSuspend+0xaa>
    4fe2:	68 ec       	ldi	r22, 0xC8	; 200
    4fe4:	76 e0       	ldi	r23, 0x06	; 6
    4fe6:	83 e8       	ldi	r24, 0x83	; 131
    4fe8:	93 e2       	ldi	r25, 0x23	; 35
    4fea:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    4fee:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <vPortYield>
    4ff2:	df 91       	pop	r29
    4ff4:	cf 91       	pop	r28
    4ff6:	1f 91       	pop	r17
    4ff8:	0f 91       	pop	r16
    4ffa:	08 95       	ret
    4ffc:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <prvResetNextTaskUnblockTime.part.1>
    5000:	d8 cf       	rjmp	.-80     	; 0x4fb2 <vTaskSuspend+0x6e>
    5002:	90 91 b5 2c 	lds	r25, 0x2CB5	; 0x802cb5 <xSuspendedTaskList>
    5006:	80 91 b4 2c 	lds	r24, 0x2CB4	; 0x802cb4 <uxCurrentNumberOfTasks>
    500a:	98 17       	cp	r25, r24
    500c:	99 f0       	breq	.+38     	; 0x5034 <vTaskSuspend+0xf0>
    500e:	80 91 a7 2c 	lds	r24, 0x2CA7	; 0x802ca7 <uxSchedulerSuspended>
    5012:	88 23       	and	r24, r24
    5014:	49 f0       	breq	.+18     	; 0x5028 <vTaskSuspend+0xe4>
    5016:	81 e0       	ldi	r24, 0x01	; 1
    5018:	80 93 ae 2c 	sts	0x2CAE, r24	; 0x802cae <xYieldPending>
    501c:	d3 cf       	rjmp	.-90     	; 0x4fc4 <vTaskSuspend+0x80>
    501e:	c0 91 41 2d 	lds	r28, 0x2D41	; 0x802d41 <pxCurrentTCB>
    5022:	d0 91 42 2d 	lds	r29, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    5026:	99 cf       	rjmp	.-206    	; 0x4f5a <vTaskSuspend+0x16>
    5028:	df 91       	pop	r29
    502a:	cf 91       	pop	r28
    502c:	1f 91       	pop	r17
    502e:	0f 91       	pop	r16
    5030:	0c 94 5e 25 	jmp	0x4abc	; 0x4abc <vTaskSwitchContext.part.6>
    5034:	10 92 41 2d 	sts	0x2D41, r1	; 0x802d41 <pxCurrentTCB>
    5038:	10 92 42 2d 	sts	0x2D42, r1	; 0x802d42 <pxCurrentTCB+0x1>
    503c:	c3 cf       	rjmp	.-122    	; 0x4fc4 <vTaskSuspend+0x80>

0000503e <vTaskResume>:
    503e:	0f 93       	push	r16
    5040:	1f 93       	push	r17
    5042:	cf 93       	push	r28
    5044:	df 93       	push	r29
    5046:	ec 01       	movw	r28, r24
    5048:	89 2b       	or	r24, r25
    504a:	09 f4       	brne	.+2      	; 0x504e <vTaskResume+0x10>
    504c:	3d c0       	rjmp	.+122    	; 0x50c8 <vTaskResume+0x8a>
    504e:	80 91 41 2d 	lds	r24, 0x2D41	; 0x802d41 <pxCurrentTCB>
    5052:	90 91 42 2d 	lds	r25, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    5056:	c8 17       	cp	r28, r24
    5058:	d9 07       	cpc	r29, r25
    505a:	51 f0       	breq	.+20     	; 0x5070 <vTaskResume+0x32>
    505c:	0f b6       	in	r0, 0x3f	; 63
    505e:	f8 94       	cli
    5060:	0f 92       	push	r0
    5062:	ce 01       	movw	r24, r28
    5064:	0e 94 e3 24 	call	0x49c6	; 0x49c6 <prvTaskIsTaskSuspended>
    5068:	81 11       	cpse	r24, r1
    506a:	07 c0       	rjmp	.+14     	; 0x507a <vTaskResume+0x3c>
    506c:	0f 90       	pop	r0
    506e:	0f be       	out	0x3f, r0	; 63
    5070:	df 91       	pop	r29
    5072:	cf 91       	pop	r28
    5074:	1f 91       	pop	r17
    5076:	0f 91       	pop	r16
    5078:	08 95       	ret
    507a:	8e 01       	movw	r16, r28
    507c:	0e 5f       	subi	r16, 0xFE	; 254
    507e:	1f 4f       	sbci	r17, 0xFF	; 255
    5080:	c8 01       	movw	r24, r16
    5082:	0e 94 b0 1c 	call	0x3960	; 0x3960 <uxListRemove>
    5086:	8e 89       	ldd	r24, Y+22	; 0x16
    5088:	90 91 b1 2c 	lds	r25, 0x2CB1	; 0x802cb1 <uxTopReadyPriority>
    508c:	98 17       	cp	r25, r24
    508e:	10 f4       	brcc	.+4      	; 0x5094 <vTaskResume+0x56>
    5090:	80 93 b1 2c 	sts	0x2CB1, r24	; 0x802cb1 <uxTopReadyPriority>
    5094:	90 e0       	ldi	r25, 0x00	; 0
    5096:	9c 01       	movw	r18, r24
    5098:	22 0f       	add	r18, r18
    509a:	33 1f       	adc	r19, r19
    509c:	22 0f       	add	r18, r18
    509e:	33 1f       	adc	r19, r19
    50a0:	22 0f       	add	r18, r18
    50a2:	33 1f       	adc	r19, r19
    50a4:	82 0f       	add	r24, r18
    50a6:	93 1f       	adc	r25, r19
    50a8:	b8 01       	movw	r22, r16
    50aa:	89 51       	subi	r24, 0x19	; 25
    50ac:	93 4d       	sbci	r25, 0xD3	; 211
    50ae:	0e 94 5e 1c 	call	0x38bc	; 0x38bc <vListInsertEnd>
    50b2:	e0 91 41 2d 	lds	r30, 0x2D41	; 0x802d41 <pxCurrentTCB>
    50b6:	f0 91 42 2d 	lds	r31, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    50ba:	9e 89       	ldd	r25, Y+22	; 0x16
    50bc:	86 89       	ldd	r24, Z+22	; 0x16
    50be:	98 17       	cp	r25, r24
    50c0:	a8 f2       	brcs	.-86     	; 0x506c <vTaskResume+0x2e>
    50c2:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <vPortYield>
    50c6:	d2 cf       	rjmp	.-92     	; 0x506c <vTaskResume+0x2e>
    50c8:	6c e1       	ldi	r22, 0x1C	; 28
    50ca:	77 e0       	ldi	r23, 0x07	; 7
    50cc:	83 e8       	ldi	r24, 0x83	; 131
    50ce:	93 e2       	ldi	r25, 0x23	; 35
    50d0:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    50d4:	80 91 41 2d 	lds	r24, 0x2D41	; 0x802d41 <pxCurrentTCB>
    50d8:	90 91 42 2d 	lds	r25, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    50dc:	c9 cf       	rjmp	.-110    	; 0x5070 <vTaskResume+0x32>

000050de <vTaskStartScheduler>:
    50de:	ef 92       	push	r14
    50e0:	ff 92       	push	r15
    50e2:	0f 93       	push	r16
    50e4:	88 ea       	ldi	r24, 0xA8	; 168
    50e6:	e8 2e       	mov	r14, r24
    50e8:	8c e2       	ldi	r24, 0x2C	; 44
    50ea:	f8 2e       	mov	r15, r24
    50ec:	00 e0       	ldi	r16, 0x00	; 0
    50ee:	20 e0       	ldi	r18, 0x00	; 0
    50f0:	30 e0       	ldi	r19, 0x00	; 0
    50f2:	40 e0       	ldi	r20, 0x00	; 0
    50f4:	51 e0       	ldi	r21, 0x01	; 1
    50f6:	67 e9       	ldi	r22, 0x97	; 151
    50f8:	73 e2       	ldi	r23, 0x23	; 35
    50fa:	8c ea       	ldi	r24, 0xAC	; 172
    50fc:	9a e2       	ldi	r25, 0x2A	; 42
    50fe:	0e 94 20 26 	call	0x4c40	; 0x4c40 <xTaskCreate>
    5102:	81 30       	cpi	r24, 0x01	; 1
    5104:	79 f0       	breq	.+30     	; 0x5124 <vTaskStartScheduler+0x46>
    5106:	8f 3f       	cpi	r24, 0xFF	; 255
    5108:	21 f0       	breq	.+8      	; 0x5112 <vTaskStartScheduler+0x34>
    510a:	0f 91       	pop	r16
    510c:	ff 90       	pop	r15
    510e:	ef 90       	pop	r14
    5110:	08 95       	ret
    5112:	67 e0       	ldi	r22, 0x07	; 7
    5114:	78 e0       	ldi	r23, 0x08	; 8
    5116:	83 e8       	ldi	r24, 0x83	; 131
    5118:	93 e2       	ldi	r25, 0x23	; 35
    511a:	0f 91       	pop	r16
    511c:	ff 90       	pop	r15
    511e:	ef 90       	pop	r14
    5120:	0c 94 df 2f 	jmp	0x5fbe	; 0x5fbe <vAssertCalled>
    5124:	f8 94       	cli
    5126:	2f ef       	ldi	r18, 0xFF	; 255
    5128:	3f ef       	ldi	r19, 0xFF	; 255
    512a:	20 93 aa 2c 	sts	0x2CAA, r18	; 0x802caa <xNextTaskUnblockTime>
    512e:	30 93 ab 2c 	sts	0x2CAB, r19	; 0x802cab <xNextTaskUnblockTime+0x1>
    5132:	80 93 b0 2c 	sts	0x2CB0, r24	; 0x802cb0 <xSchedulerRunning>
    5136:	10 92 b2 2c 	sts	0x2CB2, r1	; 0x802cb2 <xTickCount>
    513a:	10 92 b3 2c 	sts	0x2CB3, r1	; 0x802cb3 <xTickCount+0x1>
    513e:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <vConfigureTimerForRunTimeStats>
    5142:	0f 91       	pop	r16
    5144:	ff 90       	pop	r15
    5146:	ef 90       	pop	r14
    5148:	0c 94 44 1d 	jmp	0x3a88	; 0x3a88 <xPortStartScheduler>

0000514c <vTaskSuspendAll>:
    514c:	80 91 a7 2c 	lds	r24, 0x2CA7	; 0x802ca7 <uxSchedulerSuspended>
    5150:	8f 5f       	subi	r24, 0xFF	; 255
    5152:	80 93 a7 2c 	sts	0x2CA7, r24	; 0x802ca7 <uxSchedulerSuspended>
    5156:	08 95       	ret

00005158 <xTaskGetTickCount>:
    5158:	0f b6       	in	r0, 0x3f	; 63
    515a:	f8 94       	cli
    515c:	0f 92       	push	r0
    515e:	80 91 b2 2c 	lds	r24, 0x2CB2	; 0x802cb2 <xTickCount>
    5162:	90 91 b3 2c 	lds	r25, 0x2CB3	; 0x802cb3 <xTickCount+0x1>
    5166:	0f 90       	pop	r0
    5168:	0f be       	out	0x3f, r0	; 63
    516a:	08 95       	ret

0000516c <xTaskGetIdleTaskHandle>:
    516c:	80 91 a8 2c 	lds	r24, 0x2CA8	; 0x802ca8 <xIdleTaskHandle>
    5170:	90 91 a9 2c 	lds	r25, 0x2CA9	; 0x802ca9 <xIdleTaskHandle+0x1>
    5174:	00 97       	sbiw	r24, 0x00	; 0
    5176:	09 f0       	breq	.+2      	; 0x517a <xTaskGetIdleTaskHandle+0xe>
    5178:	08 95       	ret
    517a:	6a ee       	ldi	r22, 0xEA	; 234
    517c:	79 e0       	ldi	r23, 0x09	; 9
    517e:	83 e8       	ldi	r24, 0x83	; 131
    5180:	93 e2       	ldi	r25, 0x23	; 35
    5182:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    5186:	80 91 a8 2c 	lds	r24, 0x2CA8	; 0x802ca8 <xIdleTaskHandle>
    518a:	90 91 a9 2c 	lds	r25, 0x2CA9	; 0x802ca9 <xIdleTaskHandle+0x1>
    518e:	08 95       	ret

00005190 <xTaskIncrementTick>:
    5190:	df 92       	push	r13
    5192:	ef 92       	push	r14
    5194:	ff 92       	push	r15
    5196:	0f 93       	push	r16
    5198:	1f 93       	push	r17
    519a:	cf 93       	push	r28
    519c:	df 93       	push	r29
    519e:	80 91 a7 2c 	lds	r24, 0x2CA7	; 0x802ca7 <uxSchedulerSuspended>
    51a2:	81 11       	cpse	r24, r1
    51a4:	b9 c0       	rjmp	.+370    	; 0x5318 <xTaskIncrementTick+0x188>
    51a6:	e0 90 b2 2c 	lds	r14, 0x2CB2	; 0x802cb2 <xTickCount>
    51aa:	f0 90 b3 2c 	lds	r15, 0x2CB3	; 0x802cb3 <xTickCount+0x1>
    51ae:	8f ef       	ldi	r24, 0xFF	; 255
    51b0:	e8 1a       	sub	r14, r24
    51b2:	f8 0a       	sbc	r15, r24
    51b4:	e0 92 b2 2c 	sts	0x2CB2, r14	; 0x802cb2 <xTickCount>
    51b8:	f0 92 b3 2c 	sts	0x2CB3, r15	; 0x802cb3 <xTickCount+0x1>
    51bc:	e1 14       	cp	r14, r1
    51be:	f1 04       	cpc	r15, r1
    51c0:	49 f5       	brne	.+82     	; 0x5214 <xTaskIncrementTick+0x84>
    51c2:	e0 91 d3 2c 	lds	r30, 0x2CD3	; 0x802cd3 <pxDelayedTaskList>
    51c6:	f0 91 d4 2c 	lds	r31, 0x2CD4	; 0x802cd4 <pxDelayedTaskList+0x1>
    51ca:	80 81       	ld	r24, Z
    51cc:	81 11       	cpse	r24, r1
    51ce:	ab c0       	rjmp	.+342    	; 0x5326 <xTaskIncrementTick+0x196>
    51d0:	80 91 d3 2c 	lds	r24, 0x2CD3	; 0x802cd3 <pxDelayedTaskList>
    51d4:	90 91 d4 2c 	lds	r25, 0x2CD4	; 0x802cd4 <pxDelayedTaskList+0x1>
    51d8:	20 91 d1 2c 	lds	r18, 0x2CD1	; 0x802cd1 <pxOverflowDelayedTaskList>
    51dc:	30 91 d2 2c 	lds	r19, 0x2CD2	; 0x802cd2 <pxOverflowDelayedTaskList+0x1>
    51e0:	20 93 d3 2c 	sts	0x2CD3, r18	; 0x802cd3 <pxDelayedTaskList>
    51e4:	30 93 d4 2c 	sts	0x2CD4, r19	; 0x802cd4 <pxDelayedTaskList+0x1>
    51e8:	80 93 d1 2c 	sts	0x2CD1, r24	; 0x802cd1 <pxOverflowDelayedTaskList>
    51ec:	90 93 d2 2c 	sts	0x2CD2, r25	; 0x802cd2 <pxOverflowDelayedTaskList+0x1>
    51f0:	80 91 ad 2c 	lds	r24, 0x2CAD	; 0x802cad <xNumOfOverflows>
    51f4:	8f 5f       	subi	r24, 0xFF	; 255
    51f6:	80 93 ad 2c 	sts	0x2CAD, r24	; 0x802cad <xNumOfOverflows>
    51fa:	e0 91 d3 2c 	lds	r30, 0x2CD3	; 0x802cd3 <pxDelayedTaskList>
    51fe:	f0 91 d4 2c 	lds	r31, 0x2CD4	; 0x802cd4 <pxDelayedTaskList+0x1>
    5202:	80 81       	ld	r24, Z
    5204:	81 11       	cpse	r24, r1
    5206:	96 c0       	rjmp	.+300    	; 0x5334 <xTaskIncrementTick+0x1a4>
    5208:	8f ef       	ldi	r24, 0xFF	; 255
    520a:	9f ef       	ldi	r25, 0xFF	; 255
    520c:	80 93 aa 2c 	sts	0x2CAA, r24	; 0x802caa <xNextTaskUnblockTime>
    5210:	90 93 ab 2c 	sts	0x2CAB, r25	; 0x802cab <xNextTaskUnblockTime+0x1>
    5214:	80 91 aa 2c 	lds	r24, 0x2CAA	; 0x802caa <xNextTaskUnblockTime>
    5218:	90 91 ab 2c 	lds	r25, 0x2CAB	; 0x802cab <xNextTaskUnblockTime+0x1>
    521c:	d1 2c       	mov	r13, r1
    521e:	e8 16       	cp	r14, r24
    5220:	f9 06       	cpc	r15, r25
    5222:	08 f4       	brcc	.+2      	; 0x5226 <xTaskIncrementTick+0x96>
    5224:	53 c0       	rjmp	.+166    	; 0x52cc <xTaskIncrementTick+0x13c>
    5226:	e0 91 d3 2c 	lds	r30, 0x2CD3	; 0x802cd3 <pxDelayedTaskList>
    522a:	f0 91 d4 2c 	lds	r31, 0x2CD4	; 0x802cd4 <pxDelayedTaskList+0x1>
    522e:	80 81       	ld	r24, Z
    5230:	88 23       	and	r24, r24
    5232:	09 f4       	brne	.+2      	; 0x5236 <xTaskIncrementTick+0xa6>
    5234:	45 c0       	rjmp	.+138    	; 0x52c0 <xTaskIncrementTick+0x130>
    5236:	e0 91 d3 2c 	lds	r30, 0x2CD3	; 0x802cd3 <pxDelayedTaskList>
    523a:	f0 91 d4 2c 	lds	r31, 0x2CD4	; 0x802cd4 <pxDelayedTaskList+0x1>
    523e:	05 80       	ldd	r0, Z+5	; 0x05
    5240:	f6 81       	ldd	r31, Z+6	; 0x06
    5242:	e0 2d       	mov	r30, r0
    5244:	c6 81       	ldd	r28, Z+6	; 0x06
    5246:	d7 81       	ldd	r29, Z+7	; 0x07
    5248:	8a 81       	ldd	r24, Y+2	; 0x02
    524a:	9b 81       	ldd	r25, Y+3	; 0x03
    524c:	e8 16       	cp	r14, r24
    524e:	f9 06       	cpc	r15, r25
    5250:	08 f4       	brcc	.+2      	; 0x5254 <xTaskIncrementTick+0xc4>
    5252:	73 c0       	rjmp	.+230    	; 0x533a <xTaskIncrementTick+0x1aa>
    5254:	8e 01       	movw	r16, r28
    5256:	0e 5f       	subi	r16, 0xFE	; 254
    5258:	1f 4f       	sbci	r17, 0xFF	; 255
    525a:	c8 01       	movw	r24, r16
    525c:	0e 94 b0 1c 	call	0x3960	; 0x3960 <uxListRemove>
    5260:	8c 89       	ldd	r24, Y+20	; 0x14
    5262:	9d 89       	ldd	r25, Y+21	; 0x15
    5264:	89 2b       	or	r24, r25
    5266:	21 f0       	breq	.+8      	; 0x5270 <xTaskIncrementTick+0xe0>
    5268:	ce 01       	movw	r24, r28
    526a:	0c 96       	adiw	r24, 0x0c	; 12
    526c:	0e 94 b0 1c 	call	0x3960	; 0x3960 <uxListRemove>
    5270:	8e 89       	ldd	r24, Y+22	; 0x16
    5272:	90 91 b1 2c 	lds	r25, 0x2CB1	; 0x802cb1 <uxTopReadyPriority>
    5276:	98 17       	cp	r25, r24
    5278:	10 f4       	brcc	.+4      	; 0x527e <xTaskIncrementTick+0xee>
    527a:	80 93 b1 2c 	sts	0x2CB1, r24	; 0x802cb1 <uxTopReadyPriority>
    527e:	90 e0       	ldi	r25, 0x00	; 0
    5280:	9c 01       	movw	r18, r24
    5282:	22 0f       	add	r18, r18
    5284:	33 1f       	adc	r19, r19
    5286:	22 0f       	add	r18, r18
    5288:	33 1f       	adc	r19, r19
    528a:	22 0f       	add	r18, r18
    528c:	33 1f       	adc	r19, r19
    528e:	82 0f       	add	r24, r18
    5290:	93 1f       	adc	r25, r19
    5292:	b8 01       	movw	r22, r16
    5294:	89 51       	subi	r24, 0x19	; 25
    5296:	93 4d       	sbci	r25, 0xD3	; 211
    5298:	0e 94 5e 1c 	call	0x38bc	; 0x38bc <vListInsertEnd>
    529c:	e0 91 41 2d 	lds	r30, 0x2D41	; 0x802d41 <pxCurrentTCB>
    52a0:	f0 91 42 2d 	lds	r31, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    52a4:	9e 89       	ldd	r25, Y+22	; 0x16
    52a6:	86 89       	ldd	r24, Z+22	; 0x16
    52a8:	98 17       	cp	r25, r24
    52aa:	08 f4       	brcc	.+2      	; 0x52ae <xTaskIncrementTick+0x11e>
    52ac:	bc cf       	rjmp	.-136    	; 0x5226 <xTaskIncrementTick+0x96>
    52ae:	dd 24       	eor	r13, r13
    52b0:	d3 94       	inc	r13
    52b2:	e0 91 d3 2c 	lds	r30, 0x2CD3	; 0x802cd3 <pxDelayedTaskList>
    52b6:	f0 91 d4 2c 	lds	r31, 0x2CD4	; 0x802cd4 <pxDelayedTaskList+0x1>
    52ba:	80 81       	ld	r24, Z
    52bc:	81 11       	cpse	r24, r1
    52be:	bb cf       	rjmp	.-138    	; 0x5236 <xTaskIncrementTick+0xa6>
    52c0:	8f ef       	ldi	r24, 0xFF	; 255
    52c2:	9f ef       	ldi	r25, 0xFF	; 255
    52c4:	80 93 aa 2c 	sts	0x2CAA, r24	; 0x802caa <xNextTaskUnblockTime>
    52c8:	90 93 ab 2c 	sts	0x2CAB, r25	; 0x802cab <xNextTaskUnblockTime+0x1>
    52cc:	e0 91 41 2d 	lds	r30, 0x2D41	; 0x802d41 <pxCurrentTCB>
    52d0:	f0 91 42 2d 	lds	r31, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    52d4:	86 89       	ldd	r24, Z+22	; 0x16
    52d6:	90 e0       	ldi	r25, 0x00	; 0
    52d8:	fc 01       	movw	r30, r24
    52da:	ee 0f       	add	r30, r30
    52dc:	ff 1f       	adc	r31, r31
    52de:	ee 0f       	add	r30, r30
    52e0:	ff 1f       	adc	r31, r31
    52e2:	ee 0f       	add	r30, r30
    52e4:	ff 1f       	adc	r31, r31
    52e6:	8e 0f       	add	r24, r30
    52e8:	9f 1f       	adc	r25, r31
    52ea:	fc 01       	movw	r30, r24
    52ec:	e9 51       	subi	r30, 0x19	; 25
    52ee:	f3 4d       	sbci	r31, 0xD3	; 211
    52f0:	80 81       	ld	r24, Z
    52f2:	82 30       	cpi	r24, 0x02	; 2
    52f4:	10 f0       	brcs	.+4      	; 0x52fa <xTaskIncrementTick+0x16a>
    52f6:	dd 24       	eor	r13, r13
    52f8:	d3 94       	inc	r13
    52fa:	80 91 ae 2c 	lds	r24, 0x2CAE	; 0x802cae <xYieldPending>
    52fe:	88 23       	and	r24, r24
    5300:	11 f0       	breq	.+4      	; 0x5306 <xTaskIncrementTick+0x176>
    5302:	dd 24       	eor	r13, r13
    5304:	d3 94       	inc	r13
    5306:	8d 2d       	mov	r24, r13
    5308:	df 91       	pop	r29
    530a:	cf 91       	pop	r28
    530c:	1f 91       	pop	r17
    530e:	0f 91       	pop	r16
    5310:	ff 90       	pop	r15
    5312:	ef 90       	pop	r14
    5314:	df 90       	pop	r13
    5316:	08 95       	ret
    5318:	80 91 af 2c 	lds	r24, 0x2CAF	; 0x802caf <uxPendedTicks>
    531c:	8f 5f       	subi	r24, 0xFF	; 255
    531e:	80 93 af 2c 	sts	0x2CAF, r24	; 0x802caf <uxPendedTicks>
    5322:	d1 2c       	mov	r13, r1
    5324:	ea cf       	rjmp	.-44     	; 0x52fa <xTaskIncrementTick+0x16a>
    5326:	66 e6       	ldi	r22, 0x66	; 102
    5328:	7a e0       	ldi	r23, 0x0A	; 10
    532a:	83 e8       	ldi	r24, 0x83	; 131
    532c:	93 e2       	ldi	r25, 0x23	; 35
    532e:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    5332:	4e cf       	rjmp	.-356    	; 0x51d0 <xTaskIncrementTick+0x40>
    5334:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <prvResetNextTaskUnblockTime.part.1>
    5338:	6d cf       	rjmp	.-294    	; 0x5214 <xTaskIncrementTick+0x84>
    533a:	80 93 aa 2c 	sts	0x2CAA, r24	; 0x802caa <xNextTaskUnblockTime>
    533e:	90 93 ab 2c 	sts	0x2CAB, r25	; 0x802cab <xNextTaskUnblockTime+0x1>
    5342:	c4 cf       	rjmp	.-120    	; 0x52cc <xTaskIncrementTick+0x13c>

00005344 <xTaskResumeAll>:
    5344:	ff 92       	push	r15
    5346:	0f 93       	push	r16
    5348:	1f 93       	push	r17
    534a:	cf 93       	push	r28
    534c:	df 93       	push	r29
    534e:	80 91 a7 2c 	lds	r24, 0x2CA7	; 0x802ca7 <uxSchedulerSuspended>
    5352:	88 23       	and	r24, r24
    5354:	09 f4       	brne	.+2      	; 0x5358 <xTaskResumeAll+0x14>
    5356:	77 c0       	rjmp	.+238    	; 0x5446 <xTaskResumeAll+0x102>
    5358:	0f b6       	in	r0, 0x3f	; 63
    535a:	f8 94       	cli
    535c:	0f 92       	push	r0
    535e:	80 91 a7 2c 	lds	r24, 0x2CA7	; 0x802ca7 <uxSchedulerSuspended>
    5362:	81 50       	subi	r24, 0x01	; 1
    5364:	80 93 a7 2c 	sts	0x2CA7, r24	; 0x802ca7 <uxSchedulerSuspended>
    5368:	80 91 a7 2c 	lds	r24, 0x2CA7	; 0x802ca7 <uxSchedulerSuspended>
    536c:	81 11       	cpse	r24, r1
    536e:	62 c0       	rjmp	.+196    	; 0x5434 <xTaskResumeAll+0xf0>
    5370:	80 91 b4 2c 	lds	r24, 0x2CB4	; 0x802cb4 <uxCurrentNumberOfTasks>
    5374:	88 23       	and	r24, r24
    5376:	09 f4       	brne	.+2      	; 0x537a <xTaskResumeAll+0x36>
    5378:	5d c0       	rjmp	.+186    	; 0x5434 <xTaskResumeAll+0xf0>
    537a:	c0 e0       	ldi	r28, 0x00	; 0
    537c:	d0 e0       	ldi	r29, 0x00	; 0
    537e:	ff 24       	eor	r15, r15
    5380:	f3 94       	inc	r15
    5382:	80 91 c8 2c 	lds	r24, 0x2CC8	; 0x802cc8 <xPendingReadyList>
    5386:	88 23       	and	r24, r24
    5388:	a1 f1       	breq	.+104    	; 0x53f2 <xTaskResumeAll+0xae>
    538a:	e0 91 cd 2c 	lds	r30, 0x2CCD	; 0x802ccd <xPendingReadyList+0x5>
    538e:	f0 91 ce 2c 	lds	r31, 0x2CCE	; 0x802cce <xPendingReadyList+0x6>
    5392:	c6 81       	ldd	r28, Z+6	; 0x06
    5394:	d7 81       	ldd	r29, Z+7	; 0x07
    5396:	ce 01       	movw	r24, r28
    5398:	0c 96       	adiw	r24, 0x0c	; 12
    539a:	0e 94 b0 1c 	call	0x3960	; 0x3960 <uxListRemove>
    539e:	8e 01       	movw	r16, r28
    53a0:	0e 5f       	subi	r16, 0xFE	; 254
    53a2:	1f 4f       	sbci	r17, 0xFF	; 255
    53a4:	c8 01       	movw	r24, r16
    53a6:	0e 94 b0 1c 	call	0x3960	; 0x3960 <uxListRemove>
    53aa:	8e 89       	ldd	r24, Y+22	; 0x16
    53ac:	90 91 b1 2c 	lds	r25, 0x2CB1	; 0x802cb1 <uxTopReadyPriority>
    53b0:	98 17       	cp	r25, r24
    53b2:	10 f4       	brcc	.+4      	; 0x53b8 <xTaskResumeAll+0x74>
    53b4:	80 93 b1 2c 	sts	0x2CB1, r24	; 0x802cb1 <uxTopReadyPriority>
    53b8:	90 e0       	ldi	r25, 0x00	; 0
    53ba:	9c 01       	movw	r18, r24
    53bc:	22 0f       	add	r18, r18
    53be:	33 1f       	adc	r19, r19
    53c0:	22 0f       	add	r18, r18
    53c2:	33 1f       	adc	r19, r19
    53c4:	22 0f       	add	r18, r18
    53c6:	33 1f       	adc	r19, r19
    53c8:	82 0f       	add	r24, r18
    53ca:	93 1f       	adc	r25, r19
    53cc:	b8 01       	movw	r22, r16
    53ce:	89 51       	subi	r24, 0x19	; 25
    53d0:	93 4d       	sbci	r25, 0xD3	; 211
    53d2:	0e 94 5e 1c 	call	0x38bc	; 0x38bc <vListInsertEnd>
    53d6:	e0 91 41 2d 	lds	r30, 0x2D41	; 0x802d41 <pxCurrentTCB>
    53da:	f0 91 42 2d 	lds	r31, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    53de:	9e 89       	ldd	r25, Y+22	; 0x16
    53e0:	86 89       	ldd	r24, Z+22	; 0x16
    53e2:	98 17       	cp	r25, r24
    53e4:	70 f2       	brcs	.-100    	; 0x5382 <xTaskResumeAll+0x3e>
    53e6:	f0 92 ae 2c 	sts	0x2CAE, r15	; 0x802cae <xYieldPending>
    53ea:	80 91 c8 2c 	lds	r24, 0x2CC8	; 0x802cc8 <xPendingReadyList>
    53ee:	81 11       	cpse	r24, r1
    53f0:	cc cf       	rjmp	.-104    	; 0x538a <xTaskResumeAll+0x46>
    53f2:	cd 2b       	or	r28, r29
    53f4:	69 f0       	breq	.+26     	; 0x5410 <xTaskResumeAll+0xcc>
    53f6:	e0 91 d3 2c 	lds	r30, 0x2CD3	; 0x802cd3 <pxDelayedTaskList>
    53fa:	f0 91 d4 2c 	lds	r31, 0x2CD4	; 0x802cd4 <pxDelayedTaskList+0x1>
    53fe:	80 81       	ld	r24, Z
    5400:	81 11       	cpse	r24, r1
    5402:	2c c0       	rjmp	.+88     	; 0x545c <xTaskResumeAll+0x118>
    5404:	8f ef       	ldi	r24, 0xFF	; 255
    5406:	9f ef       	ldi	r25, 0xFF	; 255
    5408:	80 93 aa 2c 	sts	0x2CAA, r24	; 0x802caa <xNextTaskUnblockTime>
    540c:	90 93 ab 2c 	sts	0x2CAB, r25	; 0x802cab <xNextTaskUnblockTime+0x1>
    5410:	c0 91 af 2c 	lds	r28, 0x2CAF	; 0x802caf <uxPendedTicks>
    5414:	cc 23       	and	r28, r28
    5416:	51 f0       	breq	.+20     	; 0x542c <xTaskResumeAll+0xe8>
    5418:	d1 e0       	ldi	r29, 0x01	; 1
    541a:	0e 94 c8 28 	call	0x5190	; 0x5190 <xTaskIncrementTick>
    541e:	81 11       	cpse	r24, r1
    5420:	d0 93 ae 2c 	sts	0x2CAE, r29	; 0x802cae <xYieldPending>
    5424:	c1 50       	subi	r28, 0x01	; 1
    5426:	c9 f7       	brne	.-14     	; 0x541a <xTaskResumeAll+0xd6>
    5428:	10 92 af 2c 	sts	0x2CAF, r1	; 0x802caf <uxPendedTicks>
    542c:	80 91 ae 2c 	lds	r24, 0x2CAE	; 0x802cae <xYieldPending>
    5430:	81 11       	cpse	r24, r1
    5432:	10 c0       	rjmp	.+32     	; 0x5454 <xTaskResumeAll+0x110>
    5434:	80 e0       	ldi	r24, 0x00	; 0
    5436:	0f 90       	pop	r0
    5438:	0f be       	out	0x3f, r0	; 63
    543a:	df 91       	pop	r29
    543c:	cf 91       	pop	r28
    543e:	1f 91       	pop	r17
    5440:	0f 91       	pop	r16
    5442:	ff 90       	pop	r15
    5444:	08 95       	ret
    5446:	6c e6       	ldi	r22, 0x6C	; 108
    5448:	78 e0       	ldi	r23, 0x08	; 8
    544a:	83 e8       	ldi	r24, 0x83	; 131
    544c:	93 e2       	ldi	r25, 0x23	; 35
    544e:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    5452:	82 cf       	rjmp	.-252    	; 0x5358 <xTaskResumeAll+0x14>
    5454:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <vPortYield>
    5458:	81 e0       	ldi	r24, 0x01	; 1
    545a:	ed cf       	rjmp	.-38     	; 0x5436 <xTaskResumeAll+0xf2>
    545c:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <prvResetNextTaskUnblockTime.part.1>
    5460:	d7 cf       	rjmp	.-82     	; 0x5410 <xTaskResumeAll+0xcc>

00005462 <vTaskDelayUntil>:
    5462:	0f 93       	push	r16
    5464:	1f 93       	push	r17
    5466:	cf 93       	push	r28
    5468:	df 93       	push	r29
    546a:	8c 01       	movw	r16, r24
    546c:	eb 01       	movw	r28, r22
    546e:	89 2b       	or	r24, r25
    5470:	09 f4       	brne	.+2      	; 0x5474 <vTaskDelayUntil+0x12>
    5472:	46 c0       	rjmp	.+140    	; 0x5500 <vTaskDelayUntil+0x9e>
    5474:	20 97       	sbiw	r28, 0x00	; 0
    5476:	e9 f1       	breq	.+122    	; 0x54f2 <vTaskDelayUntil+0x90>
    5478:	80 91 a7 2c 	lds	r24, 0x2CA7	; 0x802ca7 <uxSchedulerSuspended>
    547c:	81 11       	cpse	r24, r1
    547e:	32 c0       	rjmp	.+100    	; 0x54e4 <vTaskDelayUntil+0x82>
    5480:	80 91 a7 2c 	lds	r24, 0x2CA7	; 0x802ca7 <uxSchedulerSuspended>
    5484:	8f 5f       	subi	r24, 0xFF	; 255
    5486:	80 93 a7 2c 	sts	0x2CA7, r24	; 0x802ca7 <uxSchedulerSuspended>
    548a:	40 91 b2 2c 	lds	r20, 0x2CB2	; 0x802cb2 <xTickCount>
    548e:	50 91 b3 2c 	lds	r21, 0x2CB3	; 0x802cb3 <xTickCount+0x1>
    5492:	f8 01       	movw	r30, r16
    5494:	20 81       	ld	r18, Z
    5496:	31 81       	ldd	r19, Z+1	; 0x01
    5498:	ce 01       	movw	r24, r28
    549a:	82 0f       	add	r24, r18
    549c:	93 1f       	adc	r25, r19
    549e:	42 17       	cp	r20, r18
    54a0:	53 07       	cpc	r21, r19
    54a2:	88 f4       	brcc	.+34     	; 0x54c6 <vTaskDelayUntil+0x64>
    54a4:	82 17       	cp	r24, r18
    54a6:	93 07       	cpc	r25, r19
    54a8:	88 f0       	brcs	.+34     	; 0x54cc <vTaskDelayUntil+0x6a>
    54aa:	f8 01       	movw	r30, r16
    54ac:	80 83       	st	Z, r24
    54ae:	91 83       	std	Z+1, r25	; 0x01
    54b0:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
    54b4:	81 11       	cpse	r24, r1
    54b6:	02 c0       	rjmp	.+4      	; 0x54bc <vTaskDelayUntil+0x5a>
    54b8:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <vPortYield>
    54bc:	df 91       	pop	r29
    54be:	cf 91       	pop	r28
    54c0:	1f 91       	pop	r17
    54c2:	0f 91       	pop	r16
    54c4:	08 95       	ret
    54c6:	82 17       	cp	r24, r18
    54c8:	93 07       	cpc	r25, r19
    54ca:	18 f0       	brcs	.+6      	; 0x54d2 <vTaskDelayUntil+0x70>
    54cc:	48 17       	cp	r20, r24
    54ce:	59 07       	cpc	r21, r25
    54d0:	60 f7       	brcc	.-40     	; 0x54aa <vTaskDelayUntil+0x48>
    54d2:	f8 01       	movw	r30, r16
    54d4:	80 83       	st	Z, r24
    54d6:	91 83       	std	Z+1, r25	; 0x01
    54d8:	60 e0       	ldi	r22, 0x00	; 0
    54da:	84 1b       	sub	r24, r20
    54dc:	95 0b       	sbc	r25, r21
    54de:	0e 94 02 25 	call	0x4a04	; 0x4a04 <prvAddCurrentTaskToDelayedList>
    54e2:	e6 cf       	rjmp	.-52     	; 0x54b0 <vTaskDelayUntil+0x4e>
    54e4:	6c ec       	ldi	r22, 0xCC	; 204
    54e6:	74 e0       	ldi	r23, 0x04	; 4
    54e8:	83 e8       	ldi	r24, 0x83	; 131
    54ea:	93 e2       	ldi	r25, 0x23	; 35
    54ec:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    54f0:	c7 cf       	rjmp	.-114    	; 0x5480 <vTaskDelayUntil+0x1e>
    54f2:	6b ec       	ldi	r22, 0xCB	; 203
    54f4:	74 e0       	ldi	r23, 0x04	; 4
    54f6:	83 e8       	ldi	r24, 0x83	; 131
    54f8:	93 e2       	ldi	r25, 0x23	; 35
    54fa:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    54fe:	bc cf       	rjmp	.-136    	; 0x5478 <vTaskDelayUntil+0x16>
    5500:	6a ec       	ldi	r22, 0xCA	; 202
    5502:	74 e0       	ldi	r23, 0x04	; 4
    5504:	83 e8       	ldi	r24, 0x83	; 131
    5506:	93 e2       	ldi	r25, 0x23	; 35
    5508:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    550c:	b3 cf       	rjmp	.-154    	; 0x5474 <vTaskDelayUntil+0x12>

0000550e <vTaskDelay>:
    550e:	cf 93       	push	r28
    5510:	df 93       	push	r29
    5512:	ec 01       	movw	r28, r24
    5514:	89 2b       	or	r24, r25
    5516:	29 f4       	brne	.+10     	; 0x5522 <vTaskDelay+0x14>
    5518:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <vPortYield>
    551c:	df 91       	pop	r29
    551e:	cf 91       	pop	r28
    5520:	08 95       	ret
    5522:	80 91 a7 2c 	lds	r24, 0x2CA7	; 0x802ca7 <uxSchedulerSuspended>
    5526:	81 11       	cpse	r24, r1
    5528:	10 c0       	rjmp	.+32     	; 0x554a <vTaskDelay+0x3c>
    552a:	80 91 a7 2c 	lds	r24, 0x2CA7	; 0x802ca7 <uxSchedulerSuspended>
    552e:	8f 5f       	subi	r24, 0xFF	; 255
    5530:	80 93 a7 2c 	sts	0x2CA7, r24	; 0x802ca7 <uxSchedulerSuspended>
    5534:	60 e0       	ldi	r22, 0x00	; 0
    5536:	ce 01       	movw	r24, r28
    5538:	0e 94 02 25 	call	0x4a04	; 0x4a04 <prvAddCurrentTaskToDelayedList>
    553c:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
    5540:	88 23       	and	r24, r24
    5542:	51 f3       	breq	.-44     	; 0x5518 <vTaskDelay+0xa>
    5544:	df 91       	pop	r29
    5546:	cf 91       	pop	r28
    5548:	08 95       	ret
    554a:	60 e2       	ldi	r22, 0x20	; 32
    554c:	75 e0       	ldi	r23, 0x05	; 5
    554e:	83 e8       	ldi	r24, 0x83	; 131
    5550:	93 e2       	ldi	r25, 0x23	; 35
    5552:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    5556:	e9 cf       	rjmp	.-46     	; 0x552a <vTaskDelay+0x1c>

00005558 <prvIdleTask>:
    5558:	20 c0       	rjmp	.+64     	; 0x559a <prvIdleTask+0x42>
    555a:	0f b6       	in	r0, 0x3f	; 63
    555c:	f8 94       	cli
    555e:	0f 92       	push	r0
    5560:	e0 91 c4 2c 	lds	r30, 0x2CC4	; 0x802cc4 <xTasksWaitingTermination+0x5>
    5564:	f0 91 c5 2c 	lds	r31, 0x2CC5	; 0x802cc5 <xTasksWaitingTermination+0x6>
    5568:	c6 81       	ldd	r28, Z+6	; 0x06
    556a:	d7 81       	ldd	r29, Z+7	; 0x07
    556c:	ce 01       	movw	r24, r28
    556e:	02 96       	adiw	r24, 0x02	; 2
    5570:	0e 94 b0 1c 	call	0x3960	; 0x3960 <uxListRemove>
    5574:	80 91 b4 2c 	lds	r24, 0x2CB4	; 0x802cb4 <uxCurrentNumberOfTasks>
    5578:	81 50       	subi	r24, 0x01	; 1
    557a:	80 93 b4 2c 	sts	0x2CB4, r24	; 0x802cb4 <uxCurrentNumberOfTasks>
    557e:	80 91 be 2c 	lds	r24, 0x2CBE	; 0x802cbe <uxDeletedTasksWaitingCleanUp>
    5582:	81 50       	subi	r24, 0x01	; 1
    5584:	80 93 be 2c 	sts	0x2CBE, r24	; 0x802cbe <uxDeletedTasksWaitingCleanUp>
    5588:	0f 90       	pop	r0
    558a:	0f be       	out	0x3f, r0	; 63
    558c:	8f 89       	ldd	r24, Y+23	; 0x17
    558e:	98 8d       	ldd	r25, Y+24	; 0x18
    5590:	0e 94 1c 1c 	call	0x3838	; 0x3838 <vPortFree>
    5594:	ce 01       	movw	r24, r28
    5596:	0e 94 1c 1c 	call	0x3838	; 0x3838 <vPortFree>
    559a:	80 91 be 2c 	lds	r24, 0x2CBE	; 0x802cbe <uxDeletedTasksWaitingCleanUp>
    559e:	81 11       	cpse	r24, r1
    55a0:	dc cf       	rjmp	.-72     	; 0x555a <prvIdleTask+0x2>
    55a2:	80 91 e7 2c 	lds	r24, 0x2CE7	; 0x802ce7 <pxReadyTasksLists>
    55a6:	82 30       	cpi	r24, 0x02	; 2
    55a8:	10 f0       	brcs	.+4      	; 0x55ae <prvIdleTask+0x56>
    55aa:	0e 94 81 1d 	call	0x3b02	; 0x3b02 <vPortYield>
    55ae:	0e 94 95 2f 	call	0x5f2a	; 0x5f2a <vApplicationIdleHook>
    55b2:	0e 94 b5 24 	call	0x496a	; 0x496a <prvGetExpectedIdleTime>
    55b6:	02 97       	sbiw	r24, 0x02	; 2
    55b8:	80 f3       	brcs	.-32     	; 0x559a <prvIdleTask+0x42>
    55ba:	80 91 a7 2c 	lds	r24, 0x2CA7	; 0x802ca7 <uxSchedulerSuspended>
    55be:	8f 5f       	subi	r24, 0xFF	; 255
    55c0:	80 93 a7 2c 	sts	0x2CA7, r24	; 0x802ca7 <uxSchedulerSuspended>
    55c4:	20 91 aa 2c 	lds	r18, 0x2CAA	; 0x802caa <xNextTaskUnblockTime>
    55c8:	30 91 ab 2c 	lds	r19, 0x2CAB	; 0x802cab <xNextTaskUnblockTime+0x1>
    55cc:	80 91 b2 2c 	lds	r24, 0x2CB2	; 0x802cb2 <xTickCount>
    55d0:	90 91 b3 2c 	lds	r25, 0x2CB3	; 0x802cb3 <xTickCount+0x1>
    55d4:	28 17       	cp	r18, r24
    55d6:	39 07       	cpc	r19, r25
    55d8:	28 f0       	brcs	.+10     	; 0x55e4 <prvIdleTask+0x8c>
    55da:	0e 94 b5 24 	call	0x496a	; 0x496a <prvGetExpectedIdleTime>
    55de:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
    55e2:	db cf       	rjmp	.-74     	; 0x559a <prvIdleTask+0x42>
    55e4:	61 e3       	ldi	r22, 0x31	; 49
    55e6:	7d e0       	ldi	r23, 0x0D	; 13
    55e8:	83 e8       	ldi	r24, 0x83	; 131
    55ea:	93 e2       	ldi	r25, 0x23	; 35
    55ec:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    55f0:	f4 cf       	rjmp	.-24     	; 0x55da <prvIdleTask+0x82>

000055f2 <vTaskSwitchContext>:
    55f2:	80 91 a7 2c 	lds	r24, 0x2CA7	; 0x802ca7 <uxSchedulerSuspended>
    55f6:	81 11       	cpse	r24, r1
    55f8:	02 c0       	rjmp	.+4      	; 0x55fe <vTaskSwitchContext+0xc>
    55fa:	0c 94 5e 25 	jmp	0x4abc	; 0x4abc <vTaskSwitchContext.part.6>
    55fe:	81 e0       	ldi	r24, 0x01	; 1
    5600:	80 93 ae 2c 	sts	0x2CAE, r24	; 0x802cae <xYieldPending>
    5604:	08 95       	ret

00005606 <vTaskPlaceOnEventList>:
    5606:	0f 93       	push	r16
    5608:	1f 93       	push	r17
    560a:	cf 93       	push	r28
    560c:	df 93       	push	r29
    560e:	ec 01       	movw	r28, r24
    5610:	8b 01       	movw	r16, r22
    5612:	89 2b       	or	r24, r25
    5614:	89 f0       	breq	.+34     	; 0x5638 <vTaskPlaceOnEventList+0x32>
    5616:	60 91 41 2d 	lds	r22, 0x2D41	; 0x802d41 <pxCurrentTCB>
    561a:	70 91 42 2d 	lds	r23, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    561e:	64 5f       	subi	r22, 0xF4	; 244
    5620:	7f 4f       	sbci	r23, 0xFF	; 255
    5622:	ce 01       	movw	r24, r28
    5624:	0e 94 7f 1c 	call	0x38fe	; 0x38fe <vListInsert>
    5628:	61 e0       	ldi	r22, 0x01	; 1
    562a:	c8 01       	movw	r24, r16
    562c:	df 91       	pop	r29
    562e:	cf 91       	pop	r28
    5630:	1f 91       	pop	r17
    5632:	0f 91       	pop	r16
    5634:	0c 94 02 25 	jmp	0x4a04	; 0x4a04 <prvAddCurrentTaskToDelayedList>
    5638:	63 ea       	ldi	r22, 0xA3	; 163
    563a:	7b e0       	ldi	r23, 0x0B	; 11
    563c:	83 e8       	ldi	r24, 0x83	; 131
    563e:	93 e2       	ldi	r25, 0x23	; 35
    5640:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    5644:	e8 cf       	rjmp	.-48     	; 0x5616 <vTaskPlaceOnEventList+0x10>

00005646 <xTaskRemoveFromEventList>:
    5646:	0f 93       	push	r16
    5648:	1f 93       	push	r17
    564a:	cf 93       	push	r28
    564c:	df 93       	push	r29
    564e:	dc 01       	movw	r26, r24
    5650:	15 96       	adiw	r26, 0x05	; 5
    5652:	ed 91       	ld	r30, X+
    5654:	fc 91       	ld	r31, X
    5656:	16 97       	sbiw	r26, 0x06	; 6
    5658:	c6 81       	ldd	r28, Z+6	; 0x06
    565a:	d7 81       	ldd	r29, Z+7	; 0x07
    565c:	20 97       	sbiw	r28, 0x00	; 0
    565e:	09 f4       	brne	.+2      	; 0x5662 <xTaskRemoveFromEventList+0x1c>
    5660:	5c c0       	rjmp	.+184    	; 0x571a <xTaskRemoveFromEventList+0xd4>
    5662:	8e 01       	movw	r16, r28
    5664:	04 5f       	subi	r16, 0xF4	; 244
    5666:	1f 4f       	sbci	r17, 0xFF	; 255
    5668:	c8 01       	movw	r24, r16
    566a:	0e 94 b0 1c 	call	0x3960	; 0x3960 <uxListRemove>
    566e:	80 91 a7 2c 	lds	r24, 0x2CA7	; 0x802ca7 <uxSchedulerSuspended>
    5672:	81 11       	cpse	r24, r1
    5674:	39 c0       	rjmp	.+114    	; 0x56e8 <xTaskRemoveFromEventList+0xa2>
    5676:	0a 50       	subi	r16, 0x0A	; 10
    5678:	11 09       	sbc	r17, r1
    567a:	c8 01       	movw	r24, r16
    567c:	0e 94 b0 1c 	call	0x3960	; 0x3960 <uxListRemove>
    5680:	8e 89       	ldd	r24, Y+22	; 0x16
    5682:	90 91 b1 2c 	lds	r25, 0x2CB1	; 0x802cb1 <uxTopReadyPriority>
    5686:	98 17       	cp	r25, r24
    5688:	08 f4       	brcc	.+2      	; 0x568c <xTaskRemoveFromEventList+0x46>
    568a:	44 c0       	rjmp	.+136    	; 0x5714 <xTaskRemoveFromEventList+0xce>
    568c:	90 e0       	ldi	r25, 0x00	; 0
    568e:	9c 01       	movw	r18, r24
    5690:	22 0f       	add	r18, r18
    5692:	33 1f       	adc	r19, r19
    5694:	22 0f       	add	r18, r18
    5696:	33 1f       	adc	r19, r19
    5698:	22 0f       	add	r18, r18
    569a:	33 1f       	adc	r19, r19
    569c:	82 0f       	add	r24, r18
    569e:	93 1f       	adc	r25, r19
    56a0:	b8 01       	movw	r22, r16
    56a2:	89 51       	subi	r24, 0x19	; 25
    56a4:	93 4d       	sbci	r25, 0xD3	; 211
    56a6:	0e 94 5e 1c 	call	0x38bc	; 0x38bc <vListInsertEnd>
    56aa:	e0 91 41 2d 	lds	r30, 0x2D41	; 0x802d41 <pxCurrentTCB>
    56ae:	f0 91 42 2d 	lds	r31, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    56b2:	9e 89       	ldd	r25, Y+22	; 0x16
    56b4:	86 89       	ldd	r24, Z+22	; 0x16
    56b6:	89 17       	cp	r24, r25
    56b8:	e8 f4       	brcc	.+58     	; 0x56f4 <xTaskRemoveFromEventList+0xae>
    56ba:	81 e0       	ldi	r24, 0x01	; 1
    56bc:	80 93 ae 2c 	sts	0x2CAE, r24	; 0x802cae <xYieldPending>
    56c0:	c1 e0       	ldi	r28, 0x01	; 1
    56c2:	e0 91 d3 2c 	lds	r30, 0x2CD3	; 0x802cd3 <pxDelayedTaskList>
    56c6:	f0 91 d4 2c 	lds	r31, 0x2CD4	; 0x802cd4 <pxDelayedTaskList+0x1>
    56ca:	80 81       	ld	r24, Z
    56cc:	81 11       	cpse	r24, r1
    56ce:	1a c0       	rjmp	.+52     	; 0x5704 <xTaskRemoveFromEventList+0xbe>
    56d0:	8f ef       	ldi	r24, 0xFF	; 255
    56d2:	9f ef       	ldi	r25, 0xFF	; 255
    56d4:	80 93 aa 2c 	sts	0x2CAA, r24	; 0x802caa <xNextTaskUnblockTime>
    56d8:	90 93 ab 2c 	sts	0x2CAB, r25	; 0x802cab <xNextTaskUnblockTime+0x1>
    56dc:	8c 2f       	mov	r24, r28
    56de:	df 91       	pop	r29
    56e0:	cf 91       	pop	r28
    56e2:	1f 91       	pop	r17
    56e4:	0f 91       	pop	r16
    56e6:	08 95       	ret
    56e8:	b8 01       	movw	r22, r16
    56ea:	88 ec       	ldi	r24, 0xC8	; 200
    56ec:	9c e2       	ldi	r25, 0x2C	; 44
    56ee:	0e 94 5e 1c 	call	0x38bc	; 0x38bc <vListInsertEnd>
    56f2:	db cf       	rjmp	.-74     	; 0x56aa <xTaskRemoveFromEventList+0x64>
    56f4:	c0 e0       	ldi	r28, 0x00	; 0
    56f6:	e0 91 d3 2c 	lds	r30, 0x2CD3	; 0x802cd3 <pxDelayedTaskList>
    56fa:	f0 91 d4 2c 	lds	r31, 0x2CD4	; 0x802cd4 <pxDelayedTaskList+0x1>
    56fe:	80 81       	ld	r24, Z
    5700:	88 23       	and	r24, r24
    5702:	31 f3       	breq	.-52     	; 0x56d0 <xTaskRemoveFromEventList+0x8a>
    5704:	0e 94 d2 24 	call	0x49a4	; 0x49a4 <prvResetNextTaskUnblockTime.part.1>
    5708:	8c 2f       	mov	r24, r28
    570a:	df 91       	pop	r29
    570c:	cf 91       	pop	r28
    570e:	1f 91       	pop	r17
    5710:	0f 91       	pop	r16
    5712:	08 95       	ret
    5714:	80 93 b1 2c 	sts	0x2CB1, r24	; 0x802cb1 <uxTopReadyPriority>
    5718:	b9 cf       	rjmp	.-142    	; 0x568c <xTaskRemoveFromEventList+0x46>
    571a:	6e ef       	ldi	r22, 0xFE	; 254
    571c:	7b e0       	ldi	r23, 0x0B	; 11
    571e:	83 e8       	ldi	r24, 0x83	; 131
    5720:	93 e2       	ldi	r25, 0x23	; 35
    5722:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    5726:	9d cf       	rjmp	.-198    	; 0x5662 <xTaskRemoveFromEventList+0x1c>

00005728 <vTaskInternalSetTimeOutState>:
    5728:	20 91 ad 2c 	lds	r18, 0x2CAD	; 0x802cad <xNumOfOverflows>
    572c:	fc 01       	movw	r30, r24
    572e:	20 83       	st	Z, r18
    5730:	20 91 b2 2c 	lds	r18, 0x2CB2	; 0x802cb2 <xTickCount>
    5734:	30 91 b3 2c 	lds	r19, 0x2CB3	; 0x802cb3 <xTickCount+0x1>
    5738:	21 83       	std	Z+1, r18	; 0x01
    573a:	32 83       	std	Z+2, r19	; 0x02
    573c:	08 95       	ret

0000573e <xTaskCheckForTimeOut>:
    573e:	0f 93       	push	r16
    5740:	1f 93       	push	r17
    5742:	cf 93       	push	r28
    5744:	df 93       	push	r29
    5746:	ec 01       	movw	r28, r24
    5748:	8b 01       	movw	r16, r22
    574a:	89 2b       	or	r24, r25
    574c:	09 f4       	brne	.+2      	; 0x5750 <xTaskCheckForTimeOut+0x12>
    574e:	40 c0       	rjmp	.+128    	; 0x57d0 <xTaskCheckForTimeOut+0x92>
    5750:	01 15       	cp	r16, r1
    5752:	11 05       	cpc	r17, r1
    5754:	09 f4       	brne	.+2      	; 0x5758 <xTaskCheckForTimeOut+0x1a>
    5756:	43 c0       	rjmp	.+134    	; 0x57de <xTaskCheckForTimeOut+0xa0>
    5758:	0f b6       	in	r0, 0x3f	; 63
    575a:	f8 94       	cli
    575c:	0f 92       	push	r0
    575e:	80 91 b2 2c 	lds	r24, 0x2CB2	; 0x802cb2 <xTickCount>
    5762:	90 91 b3 2c 	lds	r25, 0x2CB3	; 0x802cb3 <xTickCount+0x1>
    5766:	f8 01       	movw	r30, r16
    5768:	20 81       	ld	r18, Z
    576a:	31 81       	ldd	r19, Z+1	; 0x01
    576c:	2f 3f       	cpi	r18, 0xFF	; 255
    576e:	ff ef       	ldi	r31, 0xFF	; 255
    5770:	3f 07       	cpc	r19, r31
    5772:	61 f1       	breq	.+88     	; 0x57cc <xTaskCheckForTimeOut+0x8e>
    5774:	49 81       	ldd	r20, Y+1	; 0x01
    5776:	5a 81       	ldd	r21, Y+2	; 0x02
    5778:	60 91 ad 2c 	lds	r22, 0x2CAD	; 0x802cad <xNumOfOverflows>
    577c:	78 81       	ld	r23, Y
    577e:	76 17       	cp	r23, r22
    5780:	19 f0       	breq	.+6      	; 0x5788 <xTaskCheckForTimeOut+0x4a>
    5782:	84 17       	cp	r24, r20
    5784:	95 07       	cpc	r25, r21
    5786:	80 f4       	brcc	.+32     	; 0x57a8 <xTaskCheckForTimeOut+0x6a>
    5788:	84 1b       	sub	r24, r20
    578a:	95 0b       	sbc	r25, r21
    578c:	82 17       	cp	r24, r18
    578e:	93 07       	cpc	r25, r19
    5790:	68 f0       	brcs	.+26     	; 0x57ac <xTaskCheckForTimeOut+0x6e>
    5792:	f8 01       	movw	r30, r16
    5794:	10 82       	st	Z, r1
    5796:	11 82       	std	Z+1, r1	; 0x01
    5798:	81 e0       	ldi	r24, 0x01	; 1
    579a:	0f 90       	pop	r0
    579c:	0f be       	out	0x3f, r0	; 63
    579e:	df 91       	pop	r29
    57a0:	cf 91       	pop	r28
    57a2:	1f 91       	pop	r17
    57a4:	0f 91       	pop	r16
    57a6:	08 95       	ret
    57a8:	81 e0       	ldi	r24, 0x01	; 1
    57aa:	f7 cf       	rjmp	.-18     	; 0x579a <xTaskCheckForTimeOut+0x5c>
    57ac:	28 1b       	sub	r18, r24
    57ae:	39 0b       	sbc	r19, r25
    57b0:	f8 01       	movw	r30, r16
    57b2:	20 83       	st	Z, r18
    57b4:	31 83       	std	Z+1, r19	; 0x01
    57b6:	80 91 ad 2c 	lds	r24, 0x2CAD	; 0x802cad <xNumOfOverflows>
    57ba:	88 83       	st	Y, r24
    57bc:	80 91 b2 2c 	lds	r24, 0x2CB2	; 0x802cb2 <xTickCount>
    57c0:	90 91 b3 2c 	lds	r25, 0x2CB3	; 0x802cb3 <xTickCount+0x1>
    57c4:	89 83       	std	Y+1, r24	; 0x01
    57c6:	9a 83       	std	Y+2, r25	; 0x02
    57c8:	80 e0       	ldi	r24, 0x00	; 0
    57ca:	e7 cf       	rjmp	.-50     	; 0x579a <xTaskCheckForTimeOut+0x5c>
    57cc:	80 e0       	ldi	r24, 0x00	; 0
    57ce:	e5 cf       	rjmp	.-54     	; 0x579a <xTaskCheckForTimeOut+0x5c>
    57d0:	69 e6       	ldi	r22, 0x69	; 105
    57d2:	7c e0       	ldi	r23, 0x0C	; 12
    57d4:	83 e8       	ldi	r24, 0x83	; 131
    57d6:	93 e2       	ldi	r25, 0x23	; 35
    57d8:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    57dc:	b9 cf       	rjmp	.-142    	; 0x5750 <xTaskCheckForTimeOut+0x12>
    57de:	6a e6       	ldi	r22, 0x6A	; 106
    57e0:	7c e0       	ldi	r23, 0x0C	; 12
    57e2:	83 e8       	ldi	r24, 0x83	; 131
    57e4:	93 e2       	ldi	r25, 0x23	; 35
    57e6:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    57ea:	b6 cf       	rjmp	.-148    	; 0x5758 <xTaskCheckForTimeOut+0x1a>

000057ec <vTaskMissedYield>:
    57ec:	81 e0       	ldi	r24, 0x01	; 1
    57ee:	80 93 ae 2c 	sts	0x2CAE, r24	; 0x802cae <xYieldPending>
    57f2:	08 95       	ret

000057f4 <vTaskGetInfo>:
    57f4:	ff 92       	push	r15
    57f6:	0f 93       	push	r16
    57f8:	1f 93       	push	r17
    57fa:	cf 93       	push	r28
    57fc:	df 93       	push	r29
    57fe:	8c 01       	movw	r16, r24
    5800:	eb 01       	movw	r28, r22
    5802:	f4 2e       	mov	r15, r20
    5804:	89 2b       	or	r24, r25
    5806:	09 f4       	brne	.+2      	; 0x580a <vTaskGetInfo+0x16>
    5808:	64 c0       	rjmp	.+200    	; 0x58d2 <vTaskGetInfo+0xde>
    580a:	08 83       	st	Y, r16
    580c:	19 83       	std	Y+1, r17	; 0x01
    580e:	c8 01       	movw	r24, r16
    5810:	49 96       	adiw	r24, 0x19	; 25
    5812:	8a 83       	std	Y+2, r24	; 0x02
    5814:	9b 83       	std	Y+3, r25	; 0x03
    5816:	d8 01       	movw	r26, r16
    5818:	56 96       	adiw	r26, 0x16	; 22
    581a:	8c 91       	ld	r24, X
    581c:	56 97       	sbiw	r26, 0x16	; 22
    581e:	8e 83       	std	Y+6, r24	; 0x06
    5820:	57 96       	adiw	r26, 0x17	; 23
    5822:	8d 91       	ld	r24, X+
    5824:	9c 91       	ld	r25, X
    5826:	58 97       	sbiw	r26, 0x18	; 24
    5828:	8c 87       	std	Y+12, r24	; 0x0c
    582a:	9d 87       	std	Y+13, r25	; 0x0d
    582c:	91 96       	adiw	r26, 0x21	; 33
    582e:	8c 91       	ld	r24, X
    5830:	91 97       	sbiw	r26, 0x21	; 33
    5832:	8c 83       	std	Y+4, r24	; 0x04
    5834:	93 96       	adiw	r26, 0x23	; 35
    5836:	8c 91       	ld	r24, X
    5838:	93 97       	sbiw	r26, 0x23	; 35
    583a:	8f 83       	std	Y+7, r24	; 0x07
    583c:	97 96       	adiw	r26, 0x27	; 39
    583e:	8d 91       	ld	r24, X+
    5840:	9d 91       	ld	r25, X+
    5842:	0d 90       	ld	r0, X+
    5844:	bc 91       	ld	r27, X
    5846:	a0 2d       	mov	r26, r0
    5848:	88 87       	std	Y+8, r24	; 0x08
    584a:	99 87       	std	Y+9, r25	; 0x09
    584c:	aa 87       	std	Y+10, r26	; 0x0a
    584e:	bb 87       	std	Y+11, r27	; 0x0b
    5850:	25 30       	cpi	r18, 0x05	; 5
    5852:	09 f4       	brne	.+2      	; 0x5856 <vTaskGetInfo+0x62>
    5854:	43 c0       	rjmp	.+134    	; 0x58dc <vTaskGetInfo+0xe8>
    5856:	80 91 41 2d 	lds	r24, 0x2D41	; 0x802d41 <pxCurrentTCB>
    585a:	90 91 42 2d 	lds	r25, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    585e:	08 17       	cp	r16, r24
    5860:	19 07       	cpc	r17, r25
    5862:	09 f4       	brne	.+2      	; 0x5866 <vTaskGetInfo+0x72>
    5864:	40 c0       	rjmp	.+128    	; 0x58e6 <vTaskGetInfo+0xf2>
    5866:	2d 83       	std	Y+5, r18	; 0x05
    5868:	23 30       	cpi	r18, 0x03	; 3
    586a:	21 f1       	breq	.+72     	; 0x58b4 <vTaskGetInfo+0xc0>
    586c:	ff 20       	and	r15, r15
    586e:	d1 f0       	breq	.+52     	; 0x58a4 <vTaskGetInfo+0xb0>
    5870:	d8 01       	movw	r26, r16
    5872:	57 96       	adiw	r26, 0x17	; 23
    5874:	ed 91       	ld	r30, X+
    5876:	fc 91       	ld	r31, X
    5878:	58 97       	sbiw	r26, 0x18	; 24
    587a:	80 81       	ld	r24, Z
    587c:	85 3a       	cpi	r24, 0xA5	; 165
    587e:	a9 f5       	brne	.+106    	; 0x58ea <vTaskGetInfo+0xf6>
    5880:	31 96       	adiw	r30, 0x01	; 1
    5882:	80 e0       	ldi	r24, 0x00	; 0
    5884:	90 e0       	ldi	r25, 0x00	; 0
    5886:	dc 01       	movw	r26, r24
    5888:	01 96       	adiw	r24, 0x01	; 1
    588a:	a1 1d       	adc	r26, r1
    588c:	b1 1d       	adc	r27, r1
    588e:	21 91       	ld	r18, Z+
    5890:	25 3a       	cpi	r18, 0xA5	; 165
    5892:	d1 f3       	breq	.-12     	; 0x5888 <vTaskGetInfo+0x94>
    5894:	8e 87       	std	Y+14, r24	; 0x0e
    5896:	9f 87       	std	Y+15, r25	; 0x0f
    5898:	df 91       	pop	r29
    589a:	cf 91       	pop	r28
    589c:	1f 91       	pop	r17
    589e:	0f 91       	pop	r16
    58a0:	ff 90       	pop	r15
    58a2:	08 95       	ret
    58a4:	1e 86       	std	Y+14, r1	; 0x0e
    58a6:	1f 86       	std	Y+15, r1	; 0x0f
    58a8:	df 91       	pop	r29
    58aa:	cf 91       	pop	r28
    58ac:	1f 91       	pop	r17
    58ae:	0f 91       	pop	r16
    58b0:	ff 90       	pop	r15
    58b2:	08 95       	ret
    58b4:	80 91 a7 2c 	lds	r24, 0x2CA7	; 0x802ca7 <uxSchedulerSuspended>
    58b8:	8f 5f       	subi	r24, 0xFF	; 255
    58ba:	80 93 a7 2c 	sts	0x2CA7, r24	; 0x802ca7 <uxSchedulerSuspended>
    58be:	f8 01       	movw	r30, r16
    58c0:	84 89       	ldd	r24, Z+20	; 0x14
    58c2:	95 89       	ldd	r25, Z+21	; 0x15
    58c4:	89 2b       	or	r24, r25
    58c6:	11 f0       	breq	.+4      	; 0x58cc <vTaskGetInfo+0xd8>
    58c8:	82 e0       	ldi	r24, 0x02	; 2
    58ca:	8d 83       	std	Y+5, r24	; 0x05
    58cc:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
    58d0:	cd cf       	rjmp	.-102    	; 0x586c <vTaskGetInfo+0x78>
    58d2:	00 91 41 2d 	lds	r16, 0x2D41	; 0x802d41 <pxCurrentTCB>
    58d6:	10 91 42 2d 	lds	r17, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    58da:	97 cf       	rjmp	.-210    	; 0x580a <vTaskGetInfo+0x16>
    58dc:	c8 01       	movw	r24, r16
    58de:	0e 94 56 27 	call	0x4eac	; 0x4eac <eTaskGetState>
    58e2:	8d 83       	std	Y+5, r24	; 0x05
    58e4:	c3 cf       	rjmp	.-122    	; 0x586c <vTaskGetInfo+0x78>
    58e6:	1d 82       	std	Y+5, r1	; 0x05
    58e8:	c1 cf       	rjmp	.-126    	; 0x586c <vTaskGetInfo+0x78>
    58ea:	80 e0       	ldi	r24, 0x00	; 0
    58ec:	90 e0       	ldi	r25, 0x00	; 0
    58ee:	d2 cf       	rjmp	.-92     	; 0x5894 <vTaskGetInfo+0xa0>

000058f0 <prvListTasksWithinSingleList.part.7>:
    58f0:	8f 92       	push	r8
    58f2:	9f 92       	push	r9
    58f4:	af 92       	push	r10
    58f6:	bf 92       	push	r11
    58f8:	cf 92       	push	r12
    58fa:	df 92       	push	r13
    58fc:	ef 92       	push	r14
    58fe:	ff 92       	push	r15
    5900:	0f 93       	push	r16
    5902:	1f 93       	push	r17
    5904:	cf 93       	push	r28
    5906:	df 93       	push	r29
    5908:	5c 01       	movw	r10, r24
    590a:	8b 01       	movw	r16, r22
    590c:	d4 2f       	mov	r29, r20
    590e:	db 01       	movw	r26, r22
    5910:	11 96       	adiw	r26, 0x01	; 1
    5912:	ed 91       	ld	r30, X+
    5914:	fc 91       	ld	r31, X
    5916:	12 97       	sbiw	r26, 0x02	; 2
    5918:	02 80       	ldd	r0, Z+2	; 0x02
    591a:	f3 81       	ldd	r31, Z+3	; 0x03
    591c:	e0 2d       	mov	r30, r0
    591e:	11 96       	adiw	r26, 0x01	; 1
    5920:	ed 93       	st	X+, r30
    5922:	fc 93       	st	X, r31
    5924:	12 97       	sbiw	r26, 0x02	; 2
    5926:	7b 01       	movw	r14, r22
    5928:	b3 e0       	ldi	r27, 0x03	; 3
    592a:	eb 0e       	add	r14, r27
    592c:	f1 1c       	adc	r15, r1
    592e:	ee 15       	cp	r30, r14
    5930:	ff 05       	cpc	r31, r15
    5932:	e1 f1       	breq	.+120    	; 0x59ac <prvListTasksWithinSingleList.part.7+0xbc>
    5934:	c6 80       	ldd	r12, Z+6	; 0x06
    5936:	d7 80       	ldd	r13, Z+7	; 0x07
    5938:	c0 e0       	ldi	r28, 0x00	; 0
    593a:	16 c0       	rjmp	.+44     	; 0x5968 <prvListTasksWithinSingleList.part.7+0x78>
    593c:	86 80       	ldd	r8, Z+6	; 0x06
    593e:	97 80       	ldd	r9, Z+7	; 0x07
    5940:	b5 01       	movw	r22, r10
    5942:	b0 e1       	ldi	r27, 0x10	; 16
    5944:	cb 9f       	mul	r28, r27
    5946:	60 0d       	add	r22, r0
    5948:	71 1d       	adc	r23, r1
    594a:	11 24       	eor	r1, r1
    594c:	2d 2f       	mov	r18, r29
    594e:	41 e0       	ldi	r20, 0x01	; 1
    5950:	c4 01       	movw	r24, r8
    5952:	0e 94 fa 2b 	call	0x57f4	; 0x57f4 <vTaskGetInfo>
    5956:	cf 5f       	subi	r28, 0xFF	; 255
    5958:	c8 14       	cp	r12, r8
    595a:	d9 04       	cpc	r13, r9
    595c:	c9 f0       	breq	.+50     	; 0x5990 <prvListTasksWithinSingleList.part.7+0xa0>
    595e:	d8 01       	movw	r26, r16
    5960:	11 96       	adiw	r26, 0x01	; 1
    5962:	ed 91       	ld	r30, X+
    5964:	fc 91       	ld	r31, X
    5966:	12 97       	sbiw	r26, 0x02	; 2
    5968:	02 80       	ldd	r0, Z+2	; 0x02
    596a:	f3 81       	ldd	r31, Z+3	; 0x03
    596c:	e0 2d       	mov	r30, r0
    596e:	d8 01       	movw	r26, r16
    5970:	11 96       	adiw	r26, 0x01	; 1
    5972:	ed 93       	st	X+, r30
    5974:	fc 93       	st	X, r31
    5976:	12 97       	sbiw	r26, 0x02	; 2
    5978:	ee 16       	cp	r14, r30
    597a:	ff 06       	cpc	r15, r31
    597c:	f9 f6       	brne	.-66     	; 0x593c <prvListTasksWithinSingleList.part.7+0x4c>
    597e:	15 96       	adiw	r26, 0x05	; 5
    5980:	ed 91       	ld	r30, X+
    5982:	fc 91       	ld	r31, X
    5984:	16 97       	sbiw	r26, 0x06	; 6
    5986:	11 96       	adiw	r26, 0x01	; 1
    5988:	ed 93       	st	X+, r30
    598a:	fc 93       	st	X, r31
    598c:	12 97       	sbiw	r26, 0x02	; 2
    598e:	d6 cf       	rjmp	.-84     	; 0x593c <prvListTasksWithinSingleList.part.7+0x4c>
    5990:	8c 2f       	mov	r24, r28
    5992:	df 91       	pop	r29
    5994:	cf 91       	pop	r28
    5996:	1f 91       	pop	r17
    5998:	0f 91       	pop	r16
    599a:	ff 90       	pop	r15
    599c:	ef 90       	pop	r14
    599e:	df 90       	pop	r13
    59a0:	cf 90       	pop	r12
    59a2:	bf 90       	pop	r11
    59a4:	af 90       	pop	r10
    59a6:	9f 90       	pop	r9
    59a8:	8f 90       	pop	r8
    59aa:	08 95       	ret
    59ac:	02 80       	ldd	r0, Z+2	; 0x02
    59ae:	f3 81       	ldd	r31, Z+3	; 0x03
    59b0:	e0 2d       	mov	r30, r0
    59b2:	c0 cf       	rjmp	.-128    	; 0x5934 <prvListTasksWithinSingleList.part.7+0x44>

000059b4 <uxTaskGetSystemState>:
    59b4:	ef 92       	push	r14
    59b6:	ff 92       	push	r15
    59b8:	0f 93       	push	r16
    59ba:	1f 93       	push	r17
    59bc:	cf 93       	push	r28
    59be:	df 93       	push	r29
    59c0:	8c 01       	movw	r16, r24
    59c2:	7a 01       	movw	r14, r20
    59c4:	80 91 a7 2c 	lds	r24, 0x2CA7	; 0x802ca7 <uxSchedulerSuspended>
    59c8:	8f 5f       	subi	r24, 0xFF	; 255
    59ca:	80 93 a7 2c 	sts	0x2CA7, r24	; 0x802ca7 <uxSchedulerSuspended>
    59ce:	80 91 b4 2c 	lds	r24, 0x2CB4	; 0x802cb4 <uxCurrentNumberOfTasks>
    59d2:	68 17       	cp	r22, r24
    59d4:	08 f4       	brcc	.+2      	; 0x59d8 <uxTaskGetSystemState+0x24>
    59d6:	66 c0       	rjmp	.+204    	; 0x5aa4 <uxTaskGetSystemState+0xf0>
    59d8:	ca e0       	ldi	r28, 0x0A	; 10
    59da:	d0 e0       	ldi	r29, 0x00	; 0
    59dc:	04 c0       	rjmp	.+8      	; 0x59e6 <uxTaskGetSystemState+0x32>
    59de:	80 e0       	ldi	r24, 0x00	; 0
    59e0:	d8 0f       	add	r29, r24
    59e2:	cc 23       	and	r28, r28
    59e4:	f9 f0       	breq	.+62     	; 0x5a24 <uxTaskGetSystemState+0x70>
    59e6:	c1 50       	subi	r28, 0x01	; 1
    59e8:	6c 2f       	mov	r22, r28
    59ea:	70 e0       	ldi	r23, 0x00	; 0
    59ec:	cb 01       	movw	r24, r22
    59ee:	88 0f       	add	r24, r24
    59f0:	99 1f       	adc	r25, r25
    59f2:	88 0f       	add	r24, r24
    59f4:	99 1f       	adc	r25, r25
    59f6:	88 0f       	add	r24, r24
    59f8:	99 1f       	adc	r25, r25
    59fa:	68 0f       	add	r22, r24
    59fc:	79 1f       	adc	r23, r25
    59fe:	fb 01       	movw	r30, r22
    5a00:	e9 51       	subi	r30, 0x19	; 25
    5a02:	f3 4d       	sbci	r31, 0xD3	; 211
    5a04:	80 81       	ld	r24, Z
    5a06:	88 23       	and	r24, r24
    5a08:	51 f3       	breq	.-44     	; 0x59de <uxTaskGetSystemState+0x2a>
    5a0a:	41 e0       	ldi	r20, 0x01	; 1
    5a0c:	bf 01       	movw	r22, r30
    5a0e:	c8 01       	movw	r24, r16
    5a10:	20 e1       	ldi	r18, 0x10	; 16
    5a12:	d2 9f       	mul	r29, r18
    5a14:	80 0d       	add	r24, r0
    5a16:	91 1d       	adc	r25, r1
    5a18:	11 24       	eor	r1, r1
    5a1a:	0e 94 78 2c 	call	0x58f0	; 0x58f0 <prvListTasksWithinSingleList.part.7>
    5a1e:	d8 0f       	add	r29, r24
    5a20:	c1 11       	cpse	r28, r1
    5a22:	e1 cf       	rjmp	.-62     	; 0x59e6 <uxTaskGetSystemState+0x32>
    5a24:	e0 91 d3 2c 	lds	r30, 0x2CD3	; 0x802cd3 <pxDelayedTaskList>
    5a28:	f0 91 d4 2c 	lds	r31, 0x2CD4	; 0x802cd4 <pxDelayedTaskList+0x1>
    5a2c:	80 81       	ld	r24, Z
    5a2e:	81 11       	cpse	r24, r1
    5a30:	3b c0       	rjmp	.+118    	; 0x5aa8 <uxTaskGetSystemState+0xf4>
    5a32:	80 e0       	ldi	r24, 0x00	; 0
    5a34:	d8 0f       	add	r29, r24
    5a36:	e0 91 d1 2c 	lds	r30, 0x2CD1	; 0x802cd1 <pxOverflowDelayedTaskList>
    5a3a:	f0 91 d2 2c 	lds	r31, 0x2CD2	; 0x802cd2 <pxOverflowDelayedTaskList+0x1>
    5a3e:	80 81       	ld	r24, Z
    5a40:	81 11       	cpse	r24, r1
    5a42:	45 c0       	rjmp	.+138    	; 0x5ace <uxTaskGetSystemState+0x11a>
    5a44:	80 e0       	ldi	r24, 0x00	; 0
    5a46:	d8 0f       	add	r29, r24
    5a48:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <xTasksWaitingTermination>
    5a4c:	81 11       	cpse	r24, r1
    5a4e:	4f c0       	rjmp	.+158    	; 0x5aee <uxTaskGetSystemState+0x13a>
    5a50:	80 e0       	ldi	r24, 0x00	; 0
    5a52:	d8 0f       	add	r29, r24
    5a54:	80 91 b5 2c 	lds	r24, 0x2CB5	; 0x802cb5 <xSuspendedTaskList>
    5a58:	81 11       	cpse	r24, r1
    5a5a:	5a c0       	rjmp	.+180    	; 0x5b10 <uxTaskGetSystemState+0x15c>
    5a5c:	80 e0       	ldi	r24, 0x00	; 0
    5a5e:	d8 0f       	add	r29, r24
    5a60:	e1 14       	cp	r14, r1
    5a62:	f1 04       	cpc	r15, r1
    5a64:	a9 f0       	breq	.+42     	; 0x5a90 <uxTaskGetSystemState+0xdc>
    5a66:	20 91 20 08 	lds	r18, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x700820>
    5a6a:	30 91 21 08 	lds	r19, 0x0821	; 0x800821 <__TEXT_REGION_LENGTH__+0x700821>
    5a6e:	80 91 85 2d 	lds	r24, 0x2D85	; 0x802d85 <StatsTimer>
    5a72:	90 91 86 2d 	lds	r25, 0x2D86	; 0x802d86 <StatsTimer+0x1>
    5a76:	a0 91 87 2d 	lds	r26, 0x2D87	; 0x802d87 <StatsTimer+0x2>
    5a7a:	b0 91 88 2d 	lds	r27, 0x2D88	; 0x802d88 <StatsTimer+0x3>
    5a7e:	82 0f       	add	r24, r18
    5a80:	93 1f       	adc	r25, r19
    5a82:	a1 1d       	adc	r26, r1
    5a84:	b1 1d       	adc	r27, r1
    5a86:	f7 01       	movw	r30, r14
    5a88:	80 83       	st	Z, r24
    5a8a:	91 83       	std	Z+1, r25	; 0x01
    5a8c:	a2 83       	std	Z+2, r26	; 0x02
    5a8e:	b3 83       	std	Z+3, r27	; 0x03
    5a90:	0e 94 a2 29 	call	0x5344	; 0x5344 <xTaskResumeAll>
    5a94:	8d 2f       	mov	r24, r29
    5a96:	df 91       	pop	r29
    5a98:	cf 91       	pop	r28
    5a9a:	1f 91       	pop	r17
    5a9c:	0f 91       	pop	r16
    5a9e:	ff 90       	pop	r15
    5aa0:	ef 90       	pop	r14
    5aa2:	08 95       	ret
    5aa4:	d0 e0       	ldi	r29, 0x00	; 0
    5aa6:	f4 cf       	rjmp	.-24     	; 0x5a90 <uxTaskGetSystemState+0xdc>
    5aa8:	42 e0       	ldi	r20, 0x02	; 2
    5aaa:	bf 01       	movw	r22, r30
    5aac:	c8 01       	movw	r24, r16
    5aae:	e0 e1       	ldi	r30, 0x10	; 16
    5ab0:	de 9f       	mul	r29, r30
    5ab2:	80 0d       	add	r24, r0
    5ab4:	91 1d       	adc	r25, r1
    5ab6:	11 24       	eor	r1, r1
    5ab8:	0e 94 78 2c 	call	0x58f0	; 0x58f0 <prvListTasksWithinSingleList.part.7>
    5abc:	d8 0f       	add	r29, r24
    5abe:	e0 91 d1 2c 	lds	r30, 0x2CD1	; 0x802cd1 <pxOverflowDelayedTaskList>
    5ac2:	f0 91 d2 2c 	lds	r31, 0x2CD2	; 0x802cd2 <pxOverflowDelayedTaskList+0x1>
    5ac6:	80 81       	ld	r24, Z
    5ac8:	88 23       	and	r24, r24
    5aca:	09 f4       	brne	.+2      	; 0x5ace <uxTaskGetSystemState+0x11a>
    5acc:	bb cf       	rjmp	.-138    	; 0x5a44 <uxTaskGetSystemState+0x90>
    5ace:	42 e0       	ldi	r20, 0x02	; 2
    5ad0:	bf 01       	movw	r22, r30
    5ad2:	c8 01       	movw	r24, r16
    5ad4:	f0 e1       	ldi	r31, 0x10	; 16
    5ad6:	df 9f       	mul	r29, r31
    5ad8:	80 0d       	add	r24, r0
    5ada:	91 1d       	adc	r25, r1
    5adc:	11 24       	eor	r1, r1
    5ade:	0e 94 78 2c 	call	0x58f0	; 0x58f0 <prvListTasksWithinSingleList.part.7>
    5ae2:	d8 0f       	add	r29, r24
    5ae4:	80 91 bf 2c 	lds	r24, 0x2CBF	; 0x802cbf <xTasksWaitingTermination>
    5ae8:	88 23       	and	r24, r24
    5aea:	09 f4       	brne	.+2      	; 0x5aee <uxTaskGetSystemState+0x13a>
    5aec:	b1 cf       	rjmp	.-158    	; 0x5a50 <uxTaskGetSystemState+0x9c>
    5aee:	44 e0       	ldi	r20, 0x04	; 4
    5af0:	6f eb       	ldi	r22, 0xBF	; 191
    5af2:	7c e2       	ldi	r23, 0x2C	; 44
    5af4:	c8 01       	movw	r24, r16
    5af6:	20 e1       	ldi	r18, 0x10	; 16
    5af8:	d2 9f       	mul	r29, r18
    5afa:	80 0d       	add	r24, r0
    5afc:	91 1d       	adc	r25, r1
    5afe:	11 24       	eor	r1, r1
    5b00:	0e 94 78 2c 	call	0x58f0	; 0x58f0 <prvListTasksWithinSingleList.part.7>
    5b04:	d8 0f       	add	r29, r24
    5b06:	80 91 b5 2c 	lds	r24, 0x2CB5	; 0x802cb5 <xSuspendedTaskList>
    5b0a:	88 23       	and	r24, r24
    5b0c:	09 f4       	brne	.+2      	; 0x5b10 <uxTaskGetSystemState+0x15c>
    5b0e:	a6 cf       	rjmp	.-180    	; 0x5a5c <uxTaskGetSystemState+0xa8>
    5b10:	43 e0       	ldi	r20, 0x03	; 3
    5b12:	65 eb       	ldi	r22, 0xB5	; 181
    5b14:	7c e2       	ldi	r23, 0x2C	; 44
    5b16:	c8 01       	movw	r24, r16
    5b18:	e0 e1       	ldi	r30, 0x10	; 16
    5b1a:	de 9f       	mul	r29, r30
    5b1c:	80 0d       	add	r24, r0
    5b1e:	91 1d       	adc	r25, r1
    5b20:	11 24       	eor	r1, r1
    5b22:	0e 94 78 2c 	call	0x58f0	; 0x58f0 <prvListTasksWithinSingleList.part.7>
    5b26:	9b cf       	rjmp	.-202    	; 0x5a5e <uxTaskGetSystemState+0xaa>

00005b28 <xTaskPriorityInherit>:
    5b28:	0f 93       	push	r16
    5b2a:	1f 93       	push	r17
    5b2c:	cf 93       	push	r28
    5b2e:	df 93       	push	r29
    5b30:	fc 01       	movw	r30, r24
    5b32:	89 2b       	or	r24, r25
    5b34:	09 f4       	brne	.+2      	; 0x5b38 <xTaskPriorityInherit+0x10>
    5b36:	41 c0       	rjmp	.+130    	; 0x5bba <xTaskPriorityInherit+0x92>
    5b38:	26 89       	ldd	r18, Z+22	; 0x16
    5b3a:	a0 91 41 2d 	lds	r26, 0x2D41	; 0x802d41 <pxCurrentTCB>
    5b3e:	b0 91 42 2d 	lds	r27, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    5b42:	56 96       	adiw	r26, 0x16	; 22
    5b44:	8c 91       	ld	r24, X
    5b46:	28 17       	cp	r18, r24
    5b48:	70 f5       	brcc	.+92     	; 0x5ba6 <xTaskPriorityInherit+0x7e>
    5b4a:	84 85       	ldd	r24, Z+12	; 0x0c
    5b4c:	95 85       	ldd	r25, Z+13	; 0x0d
    5b4e:	97 fd       	sbrc	r25, 7
    5b50:	0c c0       	rjmp	.+24     	; 0x5b6a <xTaskPriorityInherit+0x42>
    5b52:	a0 91 41 2d 	lds	r26, 0x2D41	; 0x802d41 <pxCurrentTCB>
    5b56:	b0 91 42 2d 	lds	r27, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    5b5a:	56 96       	adiw	r26, 0x16	; 22
    5b5c:	3c 91       	ld	r19, X
    5b5e:	8a e0       	ldi	r24, 0x0A	; 10
    5b60:	90 e0       	ldi	r25, 0x00	; 0
    5b62:	83 1b       	sub	r24, r19
    5b64:	91 09       	sbc	r25, r1
    5b66:	84 87       	std	Z+12, r24	; 0x0c
    5b68:	95 87       	std	Z+13, r25	; 0x0d
    5b6a:	30 e0       	ldi	r19, 0x00	; 0
    5b6c:	c9 01       	movw	r24, r18
    5b6e:	88 0f       	add	r24, r24
    5b70:	99 1f       	adc	r25, r25
    5b72:	88 0f       	add	r24, r24
    5b74:	99 1f       	adc	r25, r25
    5b76:	88 0f       	add	r24, r24
    5b78:	99 1f       	adc	r25, r25
    5b7a:	28 0f       	add	r18, r24
    5b7c:	39 1f       	adc	r19, r25
    5b7e:	29 51       	subi	r18, 0x19	; 25
    5b80:	33 4d       	sbci	r19, 0xD3	; 211
    5b82:	82 85       	ldd	r24, Z+10	; 0x0a
    5b84:	93 85       	ldd	r25, Z+11	; 0x0b
    5b86:	82 17       	cp	r24, r18
    5b88:	93 07       	cpc	r25, r19
    5b8a:	e9 f0       	breq	.+58     	; 0x5bc6 <xTaskPriorityInherit+0x9e>
    5b8c:	a0 91 41 2d 	lds	r26, 0x2D41	; 0x802d41 <pxCurrentTCB>
    5b90:	b0 91 42 2d 	lds	r27, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    5b94:	56 96       	adiw	r26, 0x16	; 22
    5b96:	8c 91       	ld	r24, X
    5b98:	86 8b       	std	Z+22, r24	; 0x16
    5b9a:	81 e0       	ldi	r24, 0x01	; 1
    5b9c:	df 91       	pop	r29
    5b9e:	cf 91       	pop	r28
    5ba0:	1f 91       	pop	r17
    5ba2:	0f 91       	pop	r16
    5ba4:	08 95       	ret
    5ba6:	a0 91 41 2d 	lds	r26, 0x2D41	; 0x802d41 <pxCurrentTCB>
    5baa:	b0 91 42 2d 	lds	r27, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    5bae:	81 e0       	ldi	r24, 0x01	; 1
    5bb0:	23 a1       	ldd	r18, Z+35	; 0x23
    5bb2:	56 96       	adiw	r26, 0x16	; 22
    5bb4:	9c 91       	ld	r25, X
    5bb6:	29 17       	cp	r18, r25
    5bb8:	88 f3       	brcs	.-30     	; 0x5b9c <xTaskPriorityInherit+0x74>
    5bba:	80 e0       	ldi	r24, 0x00	; 0
    5bbc:	df 91       	pop	r29
    5bbe:	cf 91       	pop	r28
    5bc0:	1f 91       	pop	r17
    5bc2:	0f 91       	pop	r16
    5bc4:	08 95       	ret
    5bc6:	8f 01       	movw	r16, r30
    5bc8:	ef 01       	movw	r28, r30
    5bca:	22 96       	adiw	r28, 0x02	; 2
    5bcc:	ce 01       	movw	r24, r28
    5bce:	0e 94 b0 1c 	call	0x3960	; 0x3960 <uxListRemove>
    5bd2:	e0 91 41 2d 	lds	r30, 0x2D41	; 0x802d41 <pxCurrentTCB>
    5bd6:	f0 91 42 2d 	lds	r31, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    5bda:	86 89       	ldd	r24, Z+22	; 0x16
    5bdc:	f8 01       	movw	r30, r16
    5bde:	86 8b       	std	Z+22, r24	; 0x16
    5be0:	90 91 b1 2c 	lds	r25, 0x2CB1	; 0x802cb1 <uxTopReadyPriority>
    5be4:	98 17       	cp	r25, r24
    5be6:	10 f4       	brcc	.+4      	; 0x5bec <xTaskPriorityInherit+0xc4>
    5be8:	80 93 b1 2c 	sts	0x2CB1, r24	; 0x802cb1 <uxTopReadyPriority>
    5bec:	90 e0       	ldi	r25, 0x00	; 0
    5bee:	9c 01       	movw	r18, r24
    5bf0:	22 0f       	add	r18, r18
    5bf2:	33 1f       	adc	r19, r19
    5bf4:	22 0f       	add	r18, r18
    5bf6:	33 1f       	adc	r19, r19
    5bf8:	22 0f       	add	r18, r18
    5bfa:	33 1f       	adc	r19, r19
    5bfc:	82 0f       	add	r24, r18
    5bfe:	93 1f       	adc	r25, r19
    5c00:	be 01       	movw	r22, r28
    5c02:	89 51       	subi	r24, 0x19	; 25
    5c04:	93 4d       	sbci	r25, 0xD3	; 211
    5c06:	0e 94 5e 1c 	call	0x38bc	; 0x38bc <vListInsertEnd>
    5c0a:	81 e0       	ldi	r24, 0x01	; 1
    5c0c:	c7 cf       	rjmp	.-114    	; 0x5b9c <xTaskPriorityInherit+0x74>

00005c0e <xTaskPriorityDisinherit>:
    5c0e:	0f 93       	push	r16
    5c10:	1f 93       	push	r17
    5c12:	cf 93       	push	r28
    5c14:	df 93       	push	r29
    5c16:	00 97       	sbiw	r24, 0x00	; 0
    5c18:	c9 f0       	breq	.+50     	; 0x5c4c <xTaskPriorityDisinherit+0x3e>
    5c1a:	ec 01       	movw	r28, r24
    5c1c:	80 91 41 2d 	lds	r24, 0x2D41	; 0x802d41 <pxCurrentTCB>
    5c20:	90 91 42 2d 	lds	r25, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    5c24:	c8 17       	cp	r28, r24
    5c26:	d9 07       	cpc	r29, r25
    5c28:	31 f0       	breq	.+12     	; 0x5c36 <xTaskPriorityDisinherit+0x28>
    5c2a:	6e e7       	ldi	r22, 0x7E	; 126
    5c2c:	7f e0       	ldi	r23, 0x0F	; 15
    5c2e:	83 e8       	ldi	r24, 0x83	; 131
    5c30:	93 e2       	ldi	r25, 0x23	; 35
    5c32:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    5c36:	8c a1       	ldd	r24, Y+36	; 0x24
    5c38:	88 23       	and	r24, r24
    5c3a:	c1 f1       	breq	.+112    	; 0x5cac <xTaskPriorityDisinherit+0x9e>
    5c3c:	81 50       	subi	r24, 0x01	; 1
    5c3e:	8c a3       	std	Y+36, r24	; 0x24
    5c40:	2e 89       	ldd	r18, Y+22	; 0x16
    5c42:	9b a1       	ldd	r25, Y+35	; 0x23
    5c44:	29 17       	cp	r18, r25
    5c46:	11 f0       	breq	.+4      	; 0x5c4c <xTaskPriorityDisinherit+0x3e>
    5c48:	88 23       	and	r24, r24
    5c4a:	31 f0       	breq	.+12     	; 0x5c58 <xTaskPriorityDisinherit+0x4a>
    5c4c:	80 e0       	ldi	r24, 0x00	; 0
    5c4e:	df 91       	pop	r29
    5c50:	cf 91       	pop	r28
    5c52:	1f 91       	pop	r17
    5c54:	0f 91       	pop	r16
    5c56:	08 95       	ret
    5c58:	8e 01       	movw	r16, r28
    5c5a:	0e 5f       	subi	r16, 0xFE	; 254
    5c5c:	1f 4f       	sbci	r17, 0xFF	; 255
    5c5e:	c8 01       	movw	r24, r16
    5c60:	0e 94 b0 1c 	call	0x3960	; 0x3960 <uxListRemove>
    5c64:	2b a1       	ldd	r18, Y+35	; 0x23
    5c66:	2e 8b       	std	Y+22, r18	; 0x16
    5c68:	82 2f       	mov	r24, r18
    5c6a:	90 e0       	ldi	r25, 0x00	; 0
    5c6c:	4a e0       	ldi	r20, 0x0A	; 10
    5c6e:	50 e0       	ldi	r21, 0x00	; 0
    5c70:	48 1b       	sub	r20, r24
    5c72:	59 0b       	sbc	r21, r25
    5c74:	4c 87       	std	Y+12, r20	; 0x0c
    5c76:	5d 87       	std	Y+13, r21	; 0x0d
    5c78:	30 91 b1 2c 	lds	r19, 0x2CB1	; 0x802cb1 <uxTopReadyPriority>
    5c7c:	32 17       	cp	r19, r18
    5c7e:	10 f4       	brcc	.+4      	; 0x5c84 <xTaskPriorityDisinherit+0x76>
    5c80:	20 93 b1 2c 	sts	0x2CB1, r18	; 0x802cb1 <uxTopReadyPriority>
    5c84:	9c 01       	movw	r18, r24
    5c86:	22 0f       	add	r18, r18
    5c88:	33 1f       	adc	r19, r19
    5c8a:	22 0f       	add	r18, r18
    5c8c:	33 1f       	adc	r19, r19
    5c8e:	22 0f       	add	r18, r18
    5c90:	33 1f       	adc	r19, r19
    5c92:	82 0f       	add	r24, r18
    5c94:	93 1f       	adc	r25, r19
    5c96:	b8 01       	movw	r22, r16
    5c98:	89 51       	subi	r24, 0x19	; 25
    5c9a:	93 4d       	sbci	r25, 0xD3	; 211
    5c9c:	0e 94 5e 1c 	call	0x38bc	; 0x38bc <vListInsertEnd>
    5ca0:	81 e0       	ldi	r24, 0x01	; 1
    5ca2:	df 91       	pop	r29
    5ca4:	cf 91       	pop	r28
    5ca6:	1f 91       	pop	r17
    5ca8:	0f 91       	pop	r16
    5caa:	08 95       	ret
    5cac:	6f e7       	ldi	r22, 0x7F	; 127
    5cae:	7f e0       	ldi	r23, 0x0F	; 15
    5cb0:	83 e8       	ldi	r24, 0x83	; 131
    5cb2:	93 e2       	ldi	r25, 0x23	; 35
    5cb4:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    5cb8:	8c a1       	ldd	r24, Y+36	; 0x24
    5cba:	c0 cf       	rjmp	.-128    	; 0x5c3c <xTaskPriorityDisinherit+0x2e>

00005cbc <vTaskPriorityDisinheritAfterTimeout>:
    5cbc:	0f 93       	push	r16
    5cbe:	1f 93       	push	r17
    5cc0:	cf 93       	push	r28
    5cc2:	df 93       	push	r29
    5cc4:	00 97       	sbiw	r24, 0x00	; 0
    5cc6:	79 f0       	breq	.+30     	; 0x5ce6 <vTaskPriorityDisinheritAfterTimeout+0x2a>
    5cc8:	16 2f       	mov	r17, r22
    5cca:	ec 01       	movw	r28, r24
    5ccc:	8c a1       	ldd	r24, Y+36	; 0x24
    5cce:	88 23       	and	r24, r24
    5cd0:	09 f4       	brne	.+2      	; 0x5cd4 <vTaskPriorityDisinheritAfterTimeout+0x18>
    5cd2:	54 c0       	rjmp	.+168    	; 0x5d7c <vTaskPriorityDisinheritAfterTimeout+0xc0>
    5cd4:	0b a1       	ldd	r16, Y+35	; 0x23
    5cd6:	01 17       	cp	r16, r17
    5cd8:	58 f0       	brcs	.+22     	; 0x5cf0 <vTaskPriorityDisinheritAfterTimeout+0x34>
    5cda:	8e 89       	ldd	r24, Y+22	; 0x16
    5cdc:	80 17       	cp	r24, r16
    5cde:	19 f0       	breq	.+6      	; 0x5ce6 <vTaskPriorityDisinheritAfterTimeout+0x2a>
    5ce0:	9c a1       	ldd	r25, Y+36	; 0x24
    5ce2:	91 30       	cpi	r25, 0x01	; 1
    5ce4:	39 f0       	breq	.+14     	; 0x5cf4 <vTaskPriorityDisinheritAfterTimeout+0x38>
    5ce6:	df 91       	pop	r29
    5ce8:	cf 91       	pop	r28
    5cea:	1f 91       	pop	r17
    5cec:	0f 91       	pop	r16
    5cee:	08 95       	ret
    5cf0:	01 2f       	mov	r16, r17
    5cf2:	f3 cf       	rjmp	.-26     	; 0x5cda <vTaskPriorityDisinheritAfterTimeout+0x1e>
    5cf4:	20 91 41 2d 	lds	r18, 0x2D41	; 0x802d41 <pxCurrentTCB>
    5cf8:	30 91 42 2d 	lds	r19, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    5cfc:	c2 17       	cp	r28, r18
    5cfe:	d3 07       	cpc	r29, r19
    5d00:	09 f4       	brne	.+2      	; 0x5d04 <vTaskPriorityDisinheritAfterTimeout+0x48>
    5d02:	43 c0       	rjmp	.+134    	; 0x5d8a <vTaskPriorityDisinheritAfterTimeout+0xce>
    5d04:	0e 8b       	std	Y+22, r16	; 0x16
    5d06:	2c 85       	ldd	r18, Y+12	; 0x0c
    5d08:	3d 85       	ldd	r19, Y+13	; 0x0d
    5d0a:	37 fd       	sbrc	r19, 7
    5d0c:	06 c0       	rjmp	.+12     	; 0x5d1a <vTaskPriorityDisinheritAfterTimeout+0x5e>
    5d0e:	2a e0       	ldi	r18, 0x0A	; 10
    5d10:	30 e0       	ldi	r19, 0x00	; 0
    5d12:	20 1b       	sub	r18, r16
    5d14:	31 09       	sbc	r19, r1
    5d16:	2c 87       	std	Y+12, r18	; 0x0c
    5d18:	3d 87       	std	Y+13, r19	; 0x0d
    5d1a:	90 e0       	ldi	r25, 0x00	; 0
    5d1c:	9c 01       	movw	r18, r24
    5d1e:	22 0f       	add	r18, r18
    5d20:	33 1f       	adc	r19, r19
    5d22:	22 0f       	add	r18, r18
    5d24:	33 1f       	adc	r19, r19
    5d26:	22 0f       	add	r18, r18
    5d28:	33 1f       	adc	r19, r19
    5d2a:	82 0f       	add	r24, r18
    5d2c:	93 1f       	adc	r25, r19
    5d2e:	89 51       	subi	r24, 0x19	; 25
    5d30:	93 4d       	sbci	r25, 0xD3	; 211
    5d32:	2a 85       	ldd	r18, Y+10	; 0x0a
    5d34:	3b 85       	ldd	r19, Y+11	; 0x0b
    5d36:	28 17       	cp	r18, r24
    5d38:	39 07       	cpc	r19, r25
    5d3a:	a9 f6       	brne	.-86     	; 0x5ce6 <vTaskPriorityDisinheritAfterTimeout+0x2a>
    5d3c:	8e 01       	movw	r16, r28
    5d3e:	0e 5f       	subi	r16, 0xFE	; 254
    5d40:	1f 4f       	sbci	r17, 0xFF	; 255
    5d42:	c8 01       	movw	r24, r16
    5d44:	0e 94 b0 1c 	call	0x3960	; 0x3960 <uxListRemove>
    5d48:	8e 89       	ldd	r24, Y+22	; 0x16
    5d4a:	90 91 b1 2c 	lds	r25, 0x2CB1	; 0x802cb1 <uxTopReadyPriority>
    5d4e:	98 17       	cp	r25, r24
    5d50:	10 f4       	brcc	.+4      	; 0x5d56 <vTaskPriorityDisinheritAfterTimeout+0x9a>
    5d52:	80 93 b1 2c 	sts	0x2CB1, r24	; 0x802cb1 <uxTopReadyPriority>
    5d56:	90 e0       	ldi	r25, 0x00	; 0
    5d58:	9c 01       	movw	r18, r24
    5d5a:	22 0f       	add	r18, r18
    5d5c:	33 1f       	adc	r19, r19
    5d5e:	22 0f       	add	r18, r18
    5d60:	33 1f       	adc	r19, r19
    5d62:	22 0f       	add	r18, r18
    5d64:	33 1f       	adc	r19, r19
    5d66:	82 0f       	add	r24, r18
    5d68:	93 1f       	adc	r25, r19
    5d6a:	b8 01       	movw	r22, r16
    5d6c:	89 51       	subi	r24, 0x19	; 25
    5d6e:	93 4d       	sbci	r25, 0xD3	; 211
    5d70:	df 91       	pop	r29
    5d72:	cf 91       	pop	r28
    5d74:	1f 91       	pop	r17
    5d76:	0f 91       	pop	r16
    5d78:	0c 94 5e 1c 	jmp	0x38bc	; 0x38bc <vListInsertEnd>
    5d7c:	6d ec       	ldi	r22, 0xCD	; 205
    5d7e:	7f e0       	ldi	r23, 0x0F	; 15
    5d80:	83 e8       	ldi	r24, 0x83	; 131
    5d82:	93 e2       	ldi	r25, 0x23	; 35
    5d84:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    5d88:	a5 cf       	rjmp	.-182    	; 0x5cd4 <vTaskPriorityDisinheritAfterTimeout+0x18>
    5d8a:	68 ee       	ldi	r22, 0xE8	; 232
    5d8c:	7f e0       	ldi	r23, 0x0F	; 15
    5d8e:	83 e8       	ldi	r24, 0x83	; 131
    5d90:	93 e2       	ldi	r25, 0x23	; 35
    5d92:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    5d96:	8e 89       	ldd	r24, Y+22	; 0x16
    5d98:	b5 cf       	rjmp	.-150    	; 0x5d04 <vTaskPriorityDisinheritAfterTimeout+0x48>

00005d9a <vTaskGetRunTimeStats>:
    5d9a:	2f 92       	push	r2
    5d9c:	3f 92       	push	r3
    5d9e:	4f 92       	push	r4
    5da0:	5f 92       	push	r5
    5da2:	6f 92       	push	r6
    5da4:	7f 92       	push	r7
    5da6:	8f 92       	push	r8
    5da8:	9f 92       	push	r9
    5daa:	af 92       	push	r10
    5dac:	bf 92       	push	r11
    5dae:	cf 92       	push	r12
    5db0:	df 92       	push	r13
    5db2:	ef 92       	push	r14
    5db4:	ff 92       	push	r15
    5db6:	0f 93       	push	r16
    5db8:	1f 93       	push	r17
    5dba:	cf 93       	push	r28
    5dbc:	df 93       	push	r29
    5dbe:	00 d0       	rcall	.+0      	; 0x5dc0 <vTaskGetRunTimeStats+0x26>
    5dc0:	1f 92       	push	r1
    5dc2:	cd b7       	in	r28, 0x3d	; 61
    5dc4:	de b7       	in	r29, 0x3e	; 62
    5dc6:	8c 01       	movw	r16, r24
    5dc8:	fc 01       	movw	r30, r24
    5dca:	10 82       	st	Z, r1
    5dcc:	f0 90 b4 2c 	lds	r15, 0x2CB4	; 0x802cb4 <uxCurrentNumberOfTasks>
    5dd0:	80 91 b4 2c 	lds	r24, 0x2CB4	; 0x802cb4 <uxCurrentNumberOfTasks>
    5dd4:	f0 e1       	ldi	r31, 0x10	; 16
    5dd6:	8f 9f       	mul	r24, r31
    5dd8:	c0 01       	movw	r24, r0
    5dda:	11 24       	eor	r1, r1
    5ddc:	0e 94 7d 1b 	call	0x36fa	; 0x36fa <pvPortMalloc>
    5de0:	5c 01       	movw	r10, r24
    5de2:	00 97       	sbiw	r24, 0x00	; 0
    5de4:	09 f4       	brne	.+2      	; 0x5de8 <vTaskGetRunTimeStats+0x4e>
    5de6:	79 c0       	rjmp	.+242    	; 0x5eda <vTaskGetRunTimeStats+0x140>
    5de8:	ae 01       	movw	r20, r28
    5dea:	4f 5f       	subi	r20, 0xFF	; 255
    5dec:	5f 4f       	sbci	r21, 0xFF	; 255
    5dee:	6f 2d       	mov	r22, r15
    5df0:	0e 94 da 2c 	call	0x59b4	; 0x59b4 <uxTaskGetSystemState>
    5df4:	88 2e       	mov	r8, r24
    5df6:	69 81       	ldd	r22, Y+1	; 0x01
    5df8:	7a 81       	ldd	r23, Y+2	; 0x02
    5dfa:	8b 81       	ldd	r24, Y+3	; 0x03
    5dfc:	9c 81       	ldd	r25, Y+4	; 0x04
    5dfe:	24 e6       	ldi	r18, 0x64	; 100
    5e00:	30 e0       	ldi	r19, 0x00	; 0
    5e02:	40 e0       	ldi	r20, 0x00	; 0
    5e04:	50 e0       	ldi	r21, 0x00	; 0
    5e06:	0e 94 29 48 	call	0x9052	; 0x9052 <__udivmodsi4>
    5e0a:	29 83       	std	Y+1, r18	; 0x01
    5e0c:	3a 83       	std	Y+2, r19	; 0x02
    5e0e:	4b 83       	std	Y+3, r20	; 0x03
    5e10:	5c 83       	std	Y+4, r21	; 0x04
    5e12:	21 15       	cp	r18, r1
    5e14:	31 05       	cpc	r19, r1
    5e16:	41 05       	cpc	r20, r1
    5e18:	51 05       	cpc	r21, r1
    5e1a:	09 f4       	brne	.+2      	; 0x5e1e <vTaskGetRunTimeStats+0x84>
    5e1c:	5b c0       	rjmp	.+182    	; 0x5ed4 <vTaskGetRunTimeStats+0x13a>
    5e1e:	88 20       	and	r8, r8
    5e20:	09 f4       	brne	.+2      	; 0x5e24 <vTaskGetRunTimeStats+0x8a>
    5e22:	58 c0       	rjmp	.+176    	; 0x5ed4 <vTaskGetRunTimeStats+0x13a>
    5e24:	75 01       	movw	r14, r10
    5e26:	91 2c       	mov	r9, r1
    5e28:	89 eb       	ldi	r24, 0xB9	; 185
    5e2a:	c8 2e       	mov	r12, r24
    5e2c:	83 e2       	ldi	r24, 0x23	; 35
    5e2e:	d8 2e       	mov	r13, r24
    5e30:	9b ea       	ldi	r25, 0xAB	; 171
    5e32:	29 2e       	mov	r2, r25
    5e34:	93 e2       	ldi	r25, 0x23	; 35
    5e36:	39 2e       	mov	r3, r25
    5e38:	26 c0       	rjmp	.+76     	; 0x5e86 <vTaskGetRunTimeStats+0xec>
    5e3a:	7f 92       	push	r7
    5e3c:	6f 92       	push	r6
    5e3e:	5f 92       	push	r5
    5e40:	4f 92       	push	r4
    5e42:	f7 01       	movw	r30, r14
    5e44:	83 85       	ldd	r24, Z+11	; 0x0b
    5e46:	8f 93       	push	r24
    5e48:	82 85       	ldd	r24, Z+10	; 0x0a
    5e4a:	8f 93       	push	r24
    5e4c:	81 85       	ldd	r24, Z+9	; 0x09
    5e4e:	8f 93       	push	r24
    5e50:	80 85       	ldd	r24, Z+8	; 0x08
    5e52:	8f 93       	push	r24
    5e54:	3f 92       	push	r3
    5e56:	2f 92       	push	r2
    5e58:	1f 93       	push	r17
    5e5a:	0f 93       	push	r16
    5e5c:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
    5e60:	cd bf       	out	0x3d, r28	; 61
    5e62:	de bf       	out	0x3e, r29	; 62
    5e64:	f8 01       	movw	r30, r16
    5e66:	01 90       	ld	r0, Z+
    5e68:	00 20       	and	r0, r0
    5e6a:	e9 f7       	brne	.-6      	; 0x5e66 <vTaskGetRunTimeStats+0xcc>
    5e6c:	8f 01       	movw	r16, r30
    5e6e:	01 50       	subi	r16, 0x01	; 1
    5e70:	11 09       	sbc	r17, r1
    5e72:	93 94       	inc	r9
    5e74:	90 e1       	ldi	r25, 0x10	; 16
    5e76:	e9 0e       	add	r14, r25
    5e78:	f1 1c       	adc	r15, r1
    5e7a:	89 14       	cp	r8, r9
    5e7c:	59 f1       	breq	.+86     	; 0x5ed4 <vTaskGetRunTimeStats+0x13a>
    5e7e:	29 81       	ldd	r18, Y+1	; 0x01
    5e80:	3a 81       	ldd	r19, Y+2	; 0x02
    5e82:	4b 81       	ldd	r20, Y+3	; 0x03
    5e84:	5c 81       	ldd	r21, Y+4	; 0x04
    5e86:	f7 01       	movw	r30, r14
    5e88:	60 85       	ldd	r22, Z+8	; 0x08
    5e8a:	71 85       	ldd	r23, Z+9	; 0x09
    5e8c:	82 85       	ldd	r24, Z+10	; 0x0a
    5e8e:	93 85       	ldd	r25, Z+11	; 0x0b
    5e90:	0e 94 29 48 	call	0x9052	; 0x9052 <__udivmodsi4>
    5e94:	29 01       	movw	r4, r18
    5e96:	3a 01       	movw	r6, r20
    5e98:	f7 01       	movw	r30, r14
    5e9a:	62 81       	ldd	r22, Z+2	; 0x02
    5e9c:	73 81       	ldd	r23, Z+3	; 0x03
    5e9e:	c8 01       	movw	r24, r16
    5ea0:	0e 94 92 24 	call	0x4924	; 0x4924 <prvWriteNameToBuffer>
    5ea4:	8c 01       	movw	r16, r24
    5ea6:	41 14       	cp	r4, r1
    5ea8:	51 04       	cpc	r5, r1
    5eaa:	61 04       	cpc	r6, r1
    5eac:	71 04       	cpc	r7, r1
    5eae:	29 f6       	brne	.-118    	; 0x5e3a <vTaskGetRunTimeStats+0xa0>
    5eb0:	f7 01       	movw	r30, r14
    5eb2:	83 85       	ldd	r24, Z+11	; 0x0b
    5eb4:	8f 93       	push	r24
    5eb6:	82 85       	ldd	r24, Z+10	; 0x0a
    5eb8:	8f 93       	push	r24
    5eba:	81 85       	ldd	r24, Z+9	; 0x09
    5ebc:	8f 93       	push	r24
    5ebe:	80 85       	ldd	r24, Z+8	; 0x08
    5ec0:	8f 93       	push	r24
    5ec2:	df 92       	push	r13
    5ec4:	cf 92       	push	r12
    5ec6:	1f 93       	push	r17
    5ec8:	0f 93       	push	r16
    5eca:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
    5ece:	cd bf       	out	0x3d, r28	; 61
    5ed0:	de bf       	out	0x3e, r29	; 62
    5ed2:	c8 cf       	rjmp	.-112    	; 0x5e64 <vTaskGetRunTimeStats+0xca>
    5ed4:	c5 01       	movw	r24, r10
    5ed6:	0e 94 1c 1c 	call	0x3838	; 0x3838 <vPortFree>
    5eda:	24 96       	adiw	r28, 0x04	; 4
    5edc:	cd bf       	out	0x3d, r28	; 61
    5ede:	de bf       	out	0x3e, r29	; 62
    5ee0:	df 91       	pop	r29
    5ee2:	cf 91       	pop	r28
    5ee4:	1f 91       	pop	r17
    5ee6:	0f 91       	pop	r16
    5ee8:	ff 90       	pop	r15
    5eea:	ef 90       	pop	r14
    5eec:	df 90       	pop	r13
    5eee:	cf 90       	pop	r12
    5ef0:	bf 90       	pop	r11
    5ef2:	af 90       	pop	r10
    5ef4:	9f 90       	pop	r9
    5ef6:	8f 90       	pop	r8
    5ef8:	7f 90       	pop	r7
    5efa:	6f 90       	pop	r6
    5efc:	5f 90       	pop	r5
    5efe:	4f 90       	pop	r4
    5f00:	3f 90       	pop	r3
    5f02:	2f 90       	pop	r2
    5f04:	08 95       	ret

00005f06 <pvTaskIncrementMutexHeldCount>:

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    5f06:	80 91 41 2d 	lds	r24, 0x2D41	; 0x802d41 <pxCurrentTCB>
    5f0a:	90 91 42 2d 	lds	r25, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    5f0e:	89 2b       	or	r24, r25
    5f10:	39 f0       	breq	.+14     	; 0x5f20 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    5f12:	e0 91 41 2d 	lds	r30, 0x2D41	; 0x802d41 <pxCurrentTCB>
    5f16:	f0 91 42 2d 	lds	r31, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
    5f1a:	84 a1       	ldd	r24, Z+36	; 0x24
    5f1c:	8f 5f       	subi	r24, 0xFF	; 255
    5f1e:	84 a3       	std	Z+36, r24	; 0x24
		}

		return pxCurrentTCB;
    5f20:	80 91 41 2d 	lds	r24, 0x2D41	; 0x802d41 <pxCurrentTCB>
    5f24:	90 91 42 2d 	lds	r25, 0x2D42	; 0x802d42 <pxCurrentTCB+0x1>
	}
    5f28:	08 95       	ret

00005f2a <vApplicationIdleHook>:
#define SET_ERR_LED() PORTA.OUTSET=1<<7
#define CLR_ERR_LED() PORTA.OUTCLR=1<<7


void vApplicationIdleHook( void )
{
    5f2a:	08 95       	ret

00005f2c <vApplicationMallocFailedHook>:
	
}

void vApplicationMallocFailedHook(void)
{
	taskDISABLE_INTERRUPTS();
    5f2c:	f8 94       	cli
	DbgPrint ("ERROR: memory allocation failed\r\n");
    5f2e:	86 ec       	ldi	r24, 0xC6	; 198
    5f30:	93 e2       	ldi	r25, 0x23	; 35
    5f32:	0e 94 ef 05 	call	0xbde	; 0xbde <DbgPrint>
	CFG_ERR_LED();
    5f36:	80 e8       	ldi	r24, 0x80	; 128
    5f38:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	while (1)
	{
		SET_ERR_LED();
    5f3c:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5f40:	2f ef       	ldi	r18, 0xFF	; 255
    5f42:	33 ec       	ldi	r19, 0xC3	; 195
    5f44:	99 e0       	ldi	r25, 0x09	; 9
    5f46:	21 50       	subi	r18, 0x01	; 1
    5f48:	30 40       	sbci	r19, 0x00	; 0
    5f4a:	90 40       	sbci	r25, 0x00	; 0
    5f4c:	e1 f7       	brne	.-8      	; 0x5f46 <vApplicationMallocFailedHook+0x1a>
    5f4e:	00 c0       	rjmp	.+0      	; 0x5f50 <vApplicationMallocFailedHook+0x24>
    5f50:	00 00       	nop
		_delay_ms(100);
		CLR_ERR_LED();
    5f52:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    5f56:	2f ef       	ldi	r18, 0xFF	; 255
    5f58:	33 ec       	ldi	r19, 0xC3	; 195
    5f5a:	99 e0       	ldi	r25, 0x09	; 9
    5f5c:	21 50       	subi	r18, 0x01	; 1
    5f5e:	30 40       	sbci	r19, 0x00	; 0
    5f60:	90 40       	sbci	r25, 0x00	; 0
    5f62:	e1 f7       	brne	.-8      	; 0x5f5c <vApplicationMallocFailedHook+0x30>
    5f64:	00 c0       	rjmp	.+0      	; 0x5f66 <vApplicationMallocFailedHook+0x3a>
    5f66:	00 00       	nop
    5f68:	e9 cf       	rjmp	.-46     	; 0x5f3c <vApplicationMallocFailedHook+0x10>

00005f6a <vApplicationStackOverflowHook>:
}



void vApplicationStackOverflowHook( TaskHandle_t xTask,signed char *pcTaskName )
{
    5f6a:	eb 01       	movw	r28, r22
	taskDISABLE_INTERRUPTS();
    5f6c:	f8 94       	cli
	CFG_ERR_LED();
    5f6e:	80 e8       	ldi	r24, 0x80	; 128
    5f70:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	DbgPrint("STACK overflow in task ");
    5f74:	88 ee       	ldi	r24, 0xE8	; 232
    5f76:	93 e2       	ldi	r25, 0x23	; 35
    5f78:	0e 94 ef 05 	call	0xbde	; 0xbde <DbgPrint>
	DbgPrintn(pcTaskName,10);
    5f7c:	6a e0       	ldi	r22, 0x0A	; 10
    5f7e:	70 e0       	ldi	r23, 0x00	; 0
    5f80:	ce 01       	movw	r24, r28
    5f82:	0e 94 0e 06 	call	0xc1c	; 0xc1c <DbgPrintn>
	DbgPrint("\r\n");
    5f86:	83 ec       	ldi	r24, 0xC3	; 195
    5f88:	93 e2       	ldi	r25, 0x23	; 35
    5f8a:	0e 94 ef 05 	call	0xbde	; 0xbde <DbgPrint>
	while (1)
	{
		SET_ERR_LED();
    5f8e:	80 e8       	ldi	r24, 0x80	; 128
    5f90:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
    5f94:	2f ef       	ldi	r18, 0xFF	; 255
    5f96:	33 ed       	ldi	r19, 0xD3	; 211
    5f98:	90 e3       	ldi	r25, 0x30	; 48
    5f9a:	21 50       	subi	r18, 0x01	; 1
    5f9c:	30 40       	sbci	r19, 0x00	; 0
    5f9e:	90 40       	sbci	r25, 0x00	; 0
    5fa0:	e1 f7       	brne	.-8      	; 0x5f9a <vApplicationStackOverflowHook+0x30>
    5fa2:	00 c0       	rjmp	.+0      	; 0x5fa4 <vApplicationStackOverflowHook+0x3a>
    5fa4:	00 00       	nop
		_delay_ms(500);
		CLR_ERR_LED();
    5fa6:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    5faa:	2f ef       	ldi	r18, 0xFF	; 255
    5fac:	33 ed       	ldi	r19, 0xD3	; 211
    5fae:	90 e3       	ldi	r25, 0x30	; 48
    5fb0:	21 50       	subi	r18, 0x01	; 1
    5fb2:	30 40       	sbci	r19, 0x00	; 0
    5fb4:	90 40       	sbci	r25, 0x00	; 0
    5fb6:	e1 f7       	brne	.-8      	; 0x5fb0 <vApplicationStackOverflowHook+0x46>
    5fb8:	00 c0       	rjmp	.+0      	; 0x5fba <vApplicationStackOverflowHook+0x50>
    5fba:	00 00       	nop
    5fbc:	e9 cf       	rjmp	.-46     	; 0x5f90 <vApplicationStackOverflowHook+0x26>

00005fbe <vAssertCalled>:
		_delay_ms(500);
	}
}

void vAssertCalled( char *File, int Line)
{
    5fbe:	8c 01       	movw	r16, r24
    5fc0:	eb 01       	movw	r28, r22
	taskDISABLE_INTERRUPTS();	
    5fc2:	f8 94       	cli
	CFG_ERR_LED();
    5fc4:	80 e8       	ldi	r24, 0x80	; 128
    5fc6:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	DbgPrint("Assert in file ");
    5fca:	80 e0       	ldi	r24, 0x00	; 0
    5fcc:	94 e2       	ldi	r25, 0x24	; 36
    5fce:	0e 94 ef 05 	call	0xbde	; 0xbde <DbgPrint>
	DbgPrintn(File,100);
    5fd2:	64 e6       	ldi	r22, 0x64	; 100
    5fd4:	70 e0       	ldi	r23, 0x00	; 0
    5fd6:	c8 01       	movw	r24, r16
    5fd8:	0e 94 0e 06 	call	0xc1c	; 0xc1c <DbgPrintn>
	DbgPrint(", line nr ");
    5fdc:	80 e1       	ldi	r24, 0x10	; 16
    5fde:	94 e2       	ldi	r25, 0x24	; 36
    5fe0:	0e 94 ef 05 	call	0xbde	; 0xbde <DbgPrint>
	DbgPrintInt(Line);
    5fe4:	ce 01       	movw	r24, r28
    5fe6:	0e 94 33 06 	call	0xc66	; 0xc66 <DbgPrintInt>
	DbgPrint("\r\n");
    5fea:	83 ec       	ldi	r24, 0xC3	; 195
    5fec:	93 e2       	ldi	r25, 0x23	; 35
    5fee:	0e 94 ef 05 	call	0xbde	; 0xbde <DbgPrint>

	while (1)
	{
		SET_ERR_LED();
    5ff2:	80 e8       	ldi	r24, 0x80	; 128
    5ff4:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x700605>
    5ff8:	2f ef       	ldi	r18, 0xFF	; 255
    5ffa:	33 ec       	ldi	r19, 0xC3	; 195
    5ffc:	99 e0       	ldi	r25, 0x09	; 9
    5ffe:	21 50       	subi	r18, 0x01	; 1
    6000:	30 40       	sbci	r19, 0x00	; 0
    6002:	90 40       	sbci	r25, 0x00	; 0
    6004:	e1 f7       	brne	.-8      	; 0x5ffe <vAssertCalled+0x40>
    6006:	00 c0       	rjmp	.+0      	; 0x6008 <vAssertCalled+0x4a>
    6008:	00 00       	nop
		_delay_ms(100);
		CLR_ERR_LED();
    600a:	80 93 06 06 	sts	0x0606, r24	; 0x800606 <__TEXT_REGION_LENGTH__+0x700606>
    600e:	2f ef       	ldi	r18, 0xFF	; 255
    6010:	33 ed       	ldi	r19, 0xD3	; 211
    6012:	90 e3       	ldi	r25, 0x30	; 48
    6014:	21 50       	subi	r18, 0x01	; 1
    6016:	30 40       	sbci	r19, 0x00	; 0
    6018:	90 40       	sbci	r25, 0x00	; 0
    601a:	e1 f7       	brne	.-8      	; 0x6014 <vAssertCalled+0x56>
    601c:	00 c0       	rjmp	.+0      	; 0x601e <vAssertCalled+0x60>
    601e:	00 00       	nop
    6020:	e9 cf       	rjmp	.-46     	; 0x5ff4 <vAssertCalled+0x36>

00006022 <main>:

uint8_t *ucHeap;

int main(void)
{
	DriverSysClkXtalInit();	//Clock init
    6022:	0e 94 e0 0e 	call	0x1dc0	; 0x1dc0 <DriverSysClkXtalInit>
	//Allocate FreeRTOS heap
	ucHeap=malloc(configTOTAL_HEAP_SIZE);
    6026:	80 e0       	ldi	r24, 0x00	; 0
    6028:	90 e4       	ldi	r25, 0x40	; 64
    602a:	0e 94 6d 48 	call	0x90da	; 0x90da <malloc>
    602e:	80 93 89 2d 	sts	0x2D89, r24	; 0x802d89 <ucHeap>
    6032:	90 93 8a 2d 	sts	0x2D8A, r25	; 0x802d8a <ucHeap+0x1>
	if (ucHeap==NULL) while(1);
    6036:	89 2b       	or	r24, r25
    6038:	59 f0       	breq	.+22     	; 0x6050 <main+0x2e>
	
	//Enable interrupts
	PMIC.CTRL=0b111;		
    603a:	87 e0       	ldi	r24, 0x07	; 7
    603c:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	sei();
    6040:	78 94       	sei
	
	//Init startup task
	InitStartupTask();
    6042:	0e 94 71 3f 	call	0x7ee2	; 0x7ee2 <InitStartupTask>
	
	
	//Start scheduler loop
	vTaskStartScheduler();	
    6046:	0e 94 6f 28 	call	0x50de	; 0x50de <vTaskStartScheduler>
	
	


	return 0;
}
    604a:	80 e0       	ldi	r24, 0x00	; 0
    604c:	90 e0       	ldi	r25, 0x00	; 0
    604e:	08 95       	ret
    6050:	ff cf       	rjmp	.-2      	; 0x6050 <main+0x2e>

00006052 <cmpfunc>:
int cmpfunc (const void * a, const void * b) {
	TaskStatus_t *TaskA, *TaskB;
	TaskA=(TaskStatus_t *) a;
	TaskB=(TaskStatus_t *) b;
	
	if (TaskA->pxStackBase<TaskB->pxStackBase) return -1;
    6052:	fc 01       	movw	r30, r24
    6054:	44 85       	ldd	r20, Z+12	; 0x0c
    6056:	55 85       	ldd	r21, Z+13	; 0x0d
    6058:	fb 01       	movw	r30, r22
    605a:	24 85       	ldd	r18, Z+12	; 0x0c
    605c:	35 85       	ldd	r19, Z+13	; 0x0d
    605e:	42 17       	cp	r20, r18
    6060:	53 07       	cpc	r21, r19
    6062:	40 f0       	brcs	.+16     	; 0x6074 <cmpfunc+0x22>
    6064:	81 e0       	ldi	r24, 0x01	; 1
    6066:	90 e0       	ldi	r25, 0x00	; 0
    6068:	24 17       	cp	r18, r20
    606a:	35 07       	cpc	r19, r21
    606c:	08 f4       	brcc	.+2      	; 0x6070 <cmpfunc+0x1e>
	else if (TaskA->pxStackBase>TaskB->pxStackBase) return 1;
	else return 0;
	
}
    606e:	08 95       	ret
int cmpfunc (const void * a, const void * b) {
	TaskStatus_t *TaskA, *TaskB;
	TaskA=(TaskStatus_t *) a;
	TaskB=(TaskStatus_t *) b;
	
	if (TaskA->pxStackBase<TaskB->pxStackBase) return -1;
    6070:	80 e0       	ldi	r24, 0x00	; 0
    6072:	08 95       	ret
    6074:	8f ef       	ldi	r24, 0xFF	; 255
    6076:	9f ef       	ldi	r25, 0xFF	; 255
	else if (TaskA->pxStackBase>TaskB->pxStackBase) return 1;
	else return 0;
	
}
    6078:	08 95       	ret

0000607a <MemMap>:

void MemMap()
{
    607a:	5f 92       	push	r5
    607c:	6f 92       	push	r6
    607e:	7f 92       	push	r7
    6080:	8f 92       	push	r8
    6082:	9f 92       	push	r9
    6084:	af 92       	push	r10
    6086:	bf 92       	push	r11
    6088:	cf 92       	push	r12
    608a:	df 92       	push	r13
    608c:	ef 92       	push	r14
    608e:	ff 92       	push	r15
    6090:	0f 93       	push	r16
    6092:	1f 93       	push	r17
    6094:	cf 93       	push	r28
    6096:	df 93       	push	r29
    6098:	cd b7       	in	r28, 0x3d	; 61
    609a:	de b7       	in	r29, 0x3e	; 62
    609c:	c0 54       	subi	r28, 0x40	; 64
    609e:	d1 40       	sbci	r29, 0x01	; 1
    60a0:	cd bf       	out	0x3d, r28	; 61
    60a2:	de bf       	out	0x3e, r29	; 62
	uint8_t a;
	TaskStatus_t TaskStatusArray[MAX_TASKS];
	int TCBSize;
	
	
	NumTasks=uxTaskGetSystemState(TaskStatusArray,MAX_TASKS,NULL);
    60a4:	40 e0       	ldi	r20, 0x00	; 0
    60a6:	50 e0       	ldi	r21, 0x00	; 0
    60a8:	64 e1       	ldi	r22, 0x14	; 20
    60aa:	ce 01       	movw	r24, r28
    60ac:	01 96       	adiw	r24, 0x01	; 1
    60ae:	0e 94 da 2c 	call	0x59b4	; 0x59b4 <uxTaskGetSystemState>
    60b2:	88 2e       	mov	r8, r24
    60b4:	91 2c       	mov	r9, r1
	qsort(TaskStatusArray, NumTasks, sizeof(TaskStatus_t), cmpfunc);
    60b6:	29 e2       	ldi	r18, 0x29	; 41
    60b8:	30 e3       	ldi	r19, 0x30	; 48
    60ba:	40 e1       	ldi	r20, 0x10	; 16
    60bc:	50 e0       	ldi	r21, 0x00	; 0
    60be:	b4 01       	movw	r22, r8
    60c0:	ce 01       	movw	r24, r28
    60c2:	01 96       	adiw	r24, 0x01	; 1
    60c4:	0e 94 d5 49 	call	0x93aa	; 0x93aa <qsort>
	
	printf("MEMORY MAP:\r\n");
    60c8:	8b e1       	ldi	r24, 0x1B	; 27
    60ca:	94 e2       	ldi	r25, 0x24	; 36
    60cc:	0e 94 94 4d 	call	0x9b28	; 0x9b28 <puts>
	printf("-----------\r\n");
    60d0:	88 e2       	ldi	r24, 0x28	; 40
    60d2:	94 e2       	ldi	r25, 0x24	; 36
    60d4:	0e 94 94 4d 	call	0x9b28	; 0x9b28 <puts>
	printf("IO registers start:\t\t\t0x%04x\r\n",MEM_IO_REGS_START);
    60d8:	1f 92       	push	r1
    60da:	1f 92       	push	r1
    60dc:	1f 92       	push	r1
    60de:	1f 92       	push	r1
    60e0:	85 e3       	ldi	r24, 0x35	; 53
    60e2:	94 e2       	ldi	r25, 0x24	; 36
    60e4:	9f 93       	push	r25
    60e6:	8f 93       	push	r24
    60e8:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
	printf("IO registers end:\t\t\t0x%04x\r\n",MEM_IO_REGS_STOP);
    60ec:	1f 92       	push	r1
    60ee:	1f 92       	push	r1
    60f0:	8f e0       	ldi	r24, 0x0F	; 15
    60f2:	8f 93       	push	r24
    60f4:	1f ef       	ldi	r17, 0xFF	; 255
    60f6:	1f 93       	push	r17
    60f8:	84 e5       	ldi	r24, 0x54	; 84
    60fa:	94 e2       	ldi	r25, 0x24	; 36
    60fc:	9f 93       	push	r25
    60fe:	8f 93       	push	r24
    6100:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
	printf("EEPROM start:\t\t\t\t0x%04x\r\n",MEM_EEPROM_START);
    6104:	1f 92       	push	r1
    6106:	1f 92       	push	r1
    6108:	80 e1       	ldi	r24, 0x10	; 16
    610a:	8f 93       	push	r24
    610c:	1f 92       	push	r1
    610e:	81 e7       	ldi	r24, 0x71	; 113
    6110:	94 e2       	ldi	r25, 0x24	; 36
    6112:	9f 93       	push	r25
    6114:	8f 93       	push	r24
    6116:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
	printf("EEPROM end:\t\t\t\t0x%04x\r\n",MEM_EEPROM_STOP);
    611a:	1f 92       	push	r1
    611c:	1f 92       	push	r1
    611e:	8f e1       	ldi	r24, 0x1F	; 31
    6120:	8f 93       	push	r24
    6122:	1f 93       	push	r17
    6124:	8b e8       	ldi	r24, 0x8B	; 139
    6126:	94 e2       	ldi	r25, 0x24	; 36
    6128:	9f 93       	push	r25
    612a:	8f 93       	push	r24
    612c:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
	printf("SRAM start:\t\t\t\t0x%04x\r\n",MEM_SRAM_START);
    6130:	1f 92       	push	r1
    6132:	1f 92       	push	r1
    6134:	80 e2       	ldi	r24, 0x20	; 32
    6136:	8f 93       	push	r24
    6138:	1f 92       	push	r1
    613a:	83 ea       	ldi	r24, 0xA3	; 163
    613c:	94 e2       	ldi	r25, 0x24	; 36
    613e:	9f 93       	push	r25
    6140:	8f 93       	push	r24
    6142:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
	printf ("\t.DATA start:\t\t\t0x%04x\r\n",__data_start);
    6146:	80 e0       	ldi	r24, 0x00	; 0
    6148:	90 e2       	ldi	r25, 0x20	; 32
    614a:	9f 93       	push	r25
    614c:	8f 93       	push	r24
    614e:	8b eb       	ldi	r24, 0xBB	; 187
    6150:	94 e2       	ldi	r25, 0x24	; 36
    6152:	9f 93       	push	r25
    6154:	8f 93       	push	r24
    6156:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
	printf ("\t.DATA end:\t\t\t0x%04x\r\n",__data_end-1);
    615a:	cd bf       	out	0x3d, r28	; 61
    615c:	de bf       	out	0x3e, r29	; 62
    615e:	85 e2       	ldi	r24, 0x25	; 37
    6160:	98 e2       	ldi	r25, 0x28	; 40
    6162:	9f 93       	push	r25
    6164:	8f 93       	push	r24
    6166:	84 ed       	ldi	r24, 0xD4	; 212
    6168:	94 e2       	ldi	r25, 0x24	; 36
    616a:	9f 93       	push	r25
    616c:	8f 93       	push	r24
    616e:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
	printf ("\t.BSS start:\t\t\t0x%04x\r\n",__bss_start);
    6172:	86 e2       	ldi	r24, 0x26	; 38
    6174:	98 e2       	ldi	r25, 0x28	; 40
    6176:	9f 93       	push	r25
    6178:	8f 93       	push	r24
    617a:	8b ee       	ldi	r24, 0xEB	; 235
    617c:	94 e2       	ldi	r25, 0x24	; 36
    617e:	9f 93       	push	r25
    6180:	8f 93       	push	r24
    6182:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
	printf ("\t.BSS end:\t\t\t0x%04x\r\n",__bss_end-1);
    6186:	8a e9       	ldi	r24, 0x9A	; 154
    6188:	9d e2       	ldi	r25, 0x2D	; 45
    618a:	9f 93       	push	r25
    618c:	8f 93       	push	r24
    618e:	83 e0       	ldi	r24, 0x03	; 3
    6190:	95 e2       	ldi	r25, 0x25	; 37
    6192:	9f 93       	push	r25
    6194:	8f 93       	push	r24
    6196:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
	printf ("\t.HEAP start:\t\t\t0x%04x\r\n",ucHeap);
    619a:	80 91 8a 2d 	lds	r24, 0x2D8A	; 0x802d8a <ucHeap+0x1>
    619e:	8f 93       	push	r24
    61a0:	80 91 89 2d 	lds	r24, 0x2D89	; 0x802d89 <ucHeap>
    61a4:	8f 93       	push	r24
    61a6:	89 e1       	ldi	r24, 0x19	; 25
    61a8:	95 e2       	ldi	r25, 0x25	; 37
    61aa:	9f 93       	push	r25
    61ac:	8f 93       	push	r24
    61ae:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
	
	for (a=0;a<NumTasks;a++)
    61b2:	cd bf       	out	0x3d, r28	; 61
    61b4:	de bf       	out	0x3e, r29	; 62
    61b6:	81 14       	cp	r8, r1
    61b8:	91 04       	cpc	r9, r1
    61ba:	09 f4       	brne	.+2      	; 0x61be <MemMap+0x144>
    61bc:	52 c0       	rjmp	.+164    	; 0x6262 <MemMap+0x1e8>
    61be:	00 e0       	ldi	r16, 0x00	; 0
    61c0:	10 e0       	ldi	r17, 0x00	; 0
    61c2:	51 2c       	mov	r5, r1
	{
		printf ("\tTask name: %s\r\n",TaskStatusArray[a].pcTaskName);
    61c4:	95 ea       	ldi	r25, 0xA5	; 165
    61c6:	a9 2e       	mov	r10, r25
    61c8:	95 e2       	ldi	r25, 0x25	; 37
    61ca:	b9 2e       	mov	r11, r25
		printf ("\t\tSTACK end:\t\t0x%04x\r\n",TaskStatusArray[a].pxStackBase);
    61cc:	26 eb       	ldi	r18, 0xB6	; 182
    61ce:	c2 2e       	mov	r12, r18
    61d0:	25 e2       	ldi	r18, 0x25	; 37
    61d2:	d2 2e       	mov	r13, r18
		printf ("\t\tTCB start:\t\t0x%04x\r\n",TaskStatusArray[a].xHandle);
    61d4:	3d ec       	ldi	r19, 0xCD	; 205
    61d6:	e3 2e       	mov	r14, r19
    61d8:	35 e2       	ldi	r19, 0x25	; 37
    61da:	f3 2e       	mov	r15, r19
		TCBSize=(*(uint16_t *) ((uint16_t) (TaskStatusArray[a].xHandle)-2))-4;
		printf ("\t\tTCB end:\t\t0x%04x\r\n",(uint16_t)(TaskStatusArray[a].xHandle)+TCBSize-1);
    61dc:	44 ee       	ldi	r20, 0xE4	; 228
    61de:	64 2e       	mov	r6, r20
    61e0:	45 e2       	ldi	r20, 0x25	; 37
    61e2:	74 2e       	mov	r7, r20
	printf ("\t.BSS end:\t\t\t0x%04x\r\n",__bss_end-1);
	printf ("\t.HEAP start:\t\t\t0x%04x\r\n",ucHeap);
	
	for (a=0;a<NumTasks;a++)
	{
		printf ("\tTask name: %s\r\n",TaskStatusArray[a].pcTaskName);
    61e4:	02 95       	swap	r16
    61e6:	12 95       	swap	r17
    61e8:	10 7f       	andi	r17, 0xF0	; 240
    61ea:	10 27       	eor	r17, r16
    61ec:	00 7f       	andi	r16, 0xF0	; 240
    61ee:	10 27       	eor	r17, r16
    61f0:	e1 e0       	ldi	r30, 0x01	; 1
    61f2:	f0 e0       	ldi	r31, 0x00	; 0
    61f4:	ec 0f       	add	r30, r28
    61f6:	fd 1f       	adc	r31, r29
    61f8:	0e 0f       	add	r16, r30
    61fa:	1f 1f       	adc	r17, r31
    61fc:	f8 01       	movw	r30, r16
    61fe:	83 81       	ldd	r24, Z+3	; 0x03
    6200:	8f 93       	push	r24
    6202:	82 81       	ldd	r24, Z+2	; 0x02
    6204:	8f 93       	push	r24
    6206:	bf 92       	push	r11
    6208:	af 92       	push	r10
    620a:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
		printf ("\t\tSTACK end:\t\t0x%04x\r\n",TaskStatusArray[a].pxStackBase);
    620e:	f8 01       	movw	r30, r16
    6210:	85 85       	ldd	r24, Z+13	; 0x0d
    6212:	8f 93       	push	r24
    6214:	84 85       	ldd	r24, Z+12	; 0x0c
    6216:	8f 93       	push	r24
    6218:	df 92       	push	r13
    621a:	cf 92       	push	r12
    621c:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
		printf ("\t\tTCB start:\t\t0x%04x\r\n",TaskStatusArray[a].xHandle);
    6220:	f8 01       	movw	r30, r16
    6222:	81 81       	ldd	r24, Z+1	; 0x01
    6224:	8f 93       	push	r24
    6226:	80 81       	ld	r24, Z
    6228:	8f 93       	push	r24
    622a:	ff 92       	push	r15
    622c:	ef 92       	push	r14
    622e:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
		TCBSize=(*(uint16_t *) ((uint16_t) (TaskStatusArray[a].xHandle)-2))-4;
    6232:	f8 01       	movw	r30, r16
    6234:	80 81       	ld	r24, Z
    6236:	91 81       	ldd	r25, Z+1	; 0x01
    6238:	fc 01       	movw	r30, r24
    623a:	32 97       	sbiw	r30, 0x02	; 2
		printf ("\t\tTCB end:\t\t0x%04x\r\n",(uint16_t)(TaskStatusArray[a].xHandle)+TCBSize-1);
    623c:	05 97       	sbiw	r24, 0x05	; 5
    623e:	20 81       	ld	r18, Z
    6240:	31 81       	ldd	r19, Z+1	; 0x01
    6242:	82 0f       	add	r24, r18
    6244:	93 1f       	adc	r25, r19
    6246:	9f 93       	push	r25
    6248:	8f 93       	push	r24
    624a:	7f 92       	push	r7
    624c:	6f 92       	push	r6
    624e:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
	printf ("\t.DATA end:\t\t\t0x%04x\r\n",__data_end-1);
	printf ("\t.BSS start:\t\t\t0x%04x\r\n",__bss_start);
	printf ("\t.BSS end:\t\t\t0x%04x\r\n",__bss_end-1);
	printf ("\t.HEAP start:\t\t\t0x%04x\r\n",ucHeap);
	
	for (a=0;a<NumTasks;a++)
    6252:	53 94       	inc	r5
    6254:	05 2d       	mov	r16, r5
    6256:	10 e0       	ldi	r17, 0x00	; 0
    6258:	cd bf       	out	0x3d, r28	; 61
    625a:	de bf       	out	0x3e, r29	; 62
    625c:	08 15       	cp	r16, r8
    625e:	19 05       	cpc	r17, r9
    6260:	0c f2       	brlt	.-126    	; 0x61e4 <MemMap+0x16a>
		TCBSize=(*(uint16_t *) ((uint16_t) (TaskStatusArray[a].xHandle)-2))-4;
		printf ("\t\tTCB end:\t\t0x%04x\r\n",(uint16_t)(TaskStatusArray[a].xHandle)+TCBSize-1);
	}
	
	
	printf ("\t.HEAP end:\t\t\t0x%04x\r\n",ucHeap+configTOTAL_HEAP_SIZE-1);
    6262:	80 91 89 2d 	lds	r24, 0x2D89	; 0x802d89 <ucHeap>
    6266:	90 91 8a 2d 	lds	r25, 0x2D8A	; 0x802d8a <ucHeap+0x1>
    626a:	81 50       	subi	r24, 0x01	; 1
    626c:	90 4c       	sbci	r25, 0xC0	; 192
    626e:	9f 93       	push	r25
    6270:	8f 93       	push	r24
    6272:	82 e3       	ldi	r24, 0x32	; 50
    6274:	95 e2       	ldi	r25, 0x25	; 37
    6276:	9f 93       	push	r25
    6278:	8f 93       	push	r24
    627a:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
	printf ("\t.Bare metal STACK end:\t\t0x%04x\r\n",ucHeap+configTOTAL_HEAP_SIZE);
    627e:	80 91 89 2d 	lds	r24, 0x2D89	; 0x802d89 <ucHeap>
    6282:	90 91 8a 2d 	lds	r25, 0x2D8A	; 0x802d8a <ucHeap+0x1>
    6286:	90 5c       	subi	r25, 0xC0	; 192
    6288:	9f 93       	push	r25
    628a:	8f 93       	push	r24
    628c:	89 e4       	ldi	r24, 0x49	; 73
    628e:	95 e2       	ldi	r25, 0x25	; 37
    6290:	9f 93       	push	r25
    6292:	8f 93       	push	r24
    6294:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
	printf ("\t.Bare metal STACK start:\t0x%04x\r\n",MEM_SRAM_STOP);
    6298:	1f 92       	push	r1
    629a:	1f 92       	push	r1
    629c:	0f e9       	ldi	r16, 0x9F	; 159
    629e:	0f 93       	push	r16
    62a0:	1f ef       	ldi	r17, 0xFF	; 255
    62a2:	1f 93       	push	r17
    62a4:	8b e6       	ldi	r24, 0x6B	; 107
    62a6:	95 e2       	ldi	r25, 0x25	; 37
    62a8:	9f 93       	push	r25
    62aa:	8f 93       	push	r24
    62ac:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
	printf("SRAM stop:\t\t\t\t0x%04x\r\n",MEM_SRAM_STOP);
    62b0:	1f 92       	push	r1
    62b2:	1f 92       	push	r1
    62b4:	0f 93       	push	r16
    62b6:	1f 93       	push	r17
    62b8:	8e e8       	ldi	r24, 0x8E	; 142
    62ba:	95 e2       	ldi	r25, 0x25	; 37
    62bc:	9f 93       	push	r25
    62be:	8f 93       	push	r24
    62c0:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
	
	printf("-----------\r\n");
    62c4:	88 e2       	ldi	r24, 0x28	; 40
    62c6:	94 e2       	ldi	r25, 0x24	; 36
    62c8:	0e 94 94 4d 	call	0x9b28	; 0x9b28 <puts>
}
    62cc:	cd bf       	out	0x3d, r28	; 61
    62ce:	de bf       	out	0x3e, r29	; 62
    62d0:	c0 5c       	subi	r28, 0xC0	; 192
    62d2:	de 4f       	sbci	r29, 0xFE	; 254
    62d4:	cd bf       	out	0x3d, r28	; 61
    62d6:	de bf       	out	0x3e, r29	; 62
    62d8:	df 91       	pop	r29
    62da:	cf 91       	pop	r28
    62dc:	1f 91       	pop	r17
    62de:	0f 91       	pop	r16
    62e0:	ff 90       	pop	r15
    62e2:	ef 90       	pop	r14
    62e4:	df 90       	pop	r13
    62e6:	cf 90       	pop	r12
    62e8:	bf 90       	pop	r11
    62ea:	af 90       	pop	r10
    62ec:	9f 90       	pop	r9
    62ee:	8f 90       	pop	r8
    62f0:	7f 90       	pop	r7
    62f2:	6f 90       	pop	r6
    62f4:	5f 90       	pop	r5
    62f6:	08 95       	ret

000062f8 <WorkerADC>:
	ADCQueue=xQueueCreate(1,sizeof(ADCStruct));
	xTaskCreate( WorkerADC, "ADC", 512, NULL, tskIDLE_PRIORITY+2, NULL );
}

void WorkerADC(void *pvParameters)
{
    62f8:	cf 93       	push	r28
    62fa:	df 93       	push	r29
    62fc:	cd b7       	in	r28, 0x3d	; 61
    62fe:	de b7       	in	r29, 0x3e	; 62
    6300:	2a 97       	sbiw	r28, 0x0a	; 10
    6302:	cd bf       	out	0x3d, r28	; 61
    6304:	de bf       	out	0x3e, r29	; 62
	TickType_t xLastWakeTime;
	const TickType_t xPeriod = 10;
	ADCStruct ADCData;
	
	DriverLedSet(0b0111);
    6306:	87 e0       	ldi	r24, 0x07	; 7
    6308:	0e 94 9f 06 	call	0xd3e	; 0xd3e <DriverLedSet>
	
	xLastWakeTime=xTaskGetTickCount();
    630c:	0e 94 ac 28 	call	0x5158	; 0x5158 <xTaskGetTickCount>
    6310:	89 87       	std	Y+9, r24	; 0x09
    6312:	9a 87       	std	Y+10, r25	; 0x0a
	while(1)
	{
		ADCData.PhotoL=DriverAdcGetCh(0,4);
    6314:	64 e0       	ldi	r22, 0x04	; 4
    6316:	80 e0       	ldi	r24, 0x00	; 0
    6318:	0e 94 b8 03 	call	0x770	; 0x770 <DriverAdcGetCh>
    631c:	89 83       	std	Y+1, r24	; 0x01
    631e:	9a 83       	std	Y+2, r25	; 0x02
		ADCData.PhotoM=DriverAdcGetCh(1,4);
    6320:	64 e0       	ldi	r22, 0x04	; 4
    6322:	81 e0       	ldi	r24, 0x01	; 1
    6324:	0e 94 b8 03 	call	0x770	; 0x770 <DriverAdcGetCh>
    6328:	8b 83       	std	Y+3, r24	; 0x03
    632a:	9c 83       	std	Y+4, r25	; 0x04
		ADCData.PhotoR=DriverAdcGetCh(2,4);
    632c:	64 e0       	ldi	r22, 0x04	; 4
    632e:	82 e0       	ldi	r24, 0x02	; 2
    6330:	0e 94 b8 03 	call	0x770	; 0x770 <DriverAdcGetCh>
    6334:	8d 83       	std	Y+5, r24	; 0x05
    6336:	9e 83       	std	Y+6, r25	; 0x06
		ADCData.Potmeter=DriverAdcGetCh(3,4);
    6338:	64 e0       	ldi	r22, 0x04	; 4
    633a:	83 e0       	ldi	r24, 0x03	; 3
    633c:	0e 94 b8 03 	call	0x770	; 0x770 <DriverAdcGetCh>
    6340:	8f 83       	std	Y+7, r24	; 0x07
    6342:	98 87       	std	Y+8, r25	; 0x08
		xQueueOverwrite(ADCQueue,&ADCData);
    6344:	22 e0       	ldi	r18, 0x02	; 2
    6346:	40 e0       	ldi	r20, 0x00	; 0
    6348:	50 e0       	ldi	r21, 0x00	; 0
    634a:	be 01       	movw	r22, r28
    634c:	6f 5f       	subi	r22, 0xFF	; 255
    634e:	7f 4f       	sbci	r23, 0xFF	; 255
    6350:	80 91 8b 2d 	lds	r24, 0x2D8B	; 0x802d8b <ADCQueue>
    6354:	90 91 8c 2d 	lds	r25, 0x2D8C	; 0x802d8c <ADCQueue+0x1>
    6358:	0e 94 27 20 	call	0x404e	; 0x404e <xQueueGenericSend>
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    635c:	6a e0       	ldi	r22, 0x0A	; 10
    635e:	70 e0       	ldi	r23, 0x00	; 0
    6360:	ce 01       	movw	r24, r28
    6362:	09 96       	adiw	r24, 0x09	; 9
    6364:	0e 94 31 2a 	call	0x5462	; 0x5462 <vTaskDelayUntil>
    6368:	d5 cf       	rjmp	.-86     	; 0x6314 <WorkerADC+0x1c>

0000636a <InitADCTask>:

void WorkerADC(void *pvParameters);

//Function definitions
void InitADCTask()
{
    636a:	ef 92       	push	r14
    636c:	ff 92       	push	r15
    636e:	0f 93       	push	r16
	ADCQueue=xQueueCreate(1,sizeof(ADCStruct));
    6370:	40 e0       	ldi	r20, 0x00	; 0
    6372:	68 e0       	ldi	r22, 0x08	; 8
    6374:	81 e0       	ldi	r24, 0x01	; 1
    6376:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <xQueueGenericCreate>
    637a:	80 93 8b 2d 	sts	0x2D8B, r24	; 0x802d8b <ADCQueue>
    637e:	90 93 8c 2d 	sts	0x2D8C, r25	; 0x802d8c <ADCQueue+0x1>
	xTaskCreate( WorkerADC, "ADC", 512, NULL, tskIDLE_PRIORITY+2, NULL );
    6382:	e1 2c       	mov	r14, r1
    6384:	f1 2c       	mov	r15, r1
    6386:	02 e0       	ldi	r16, 0x02	; 2
    6388:	20 e0       	ldi	r18, 0x00	; 0
    638a:	30 e0       	ldi	r19, 0x00	; 0
    638c:	40 e0       	ldi	r20, 0x00	; 0
    638e:	52 e0       	ldi	r21, 0x02	; 2
    6390:	69 ef       	ldi	r22, 0xF9	; 249
    6392:	75 e2       	ldi	r23, 0x25	; 37
    6394:	8c e7       	ldi	r24, 0x7C	; 124
    6396:	91 e3       	ldi	r25, 0x31	; 49
    6398:	0e 94 20 26 	call	0x4c40	; 0x4c40 <xTaskCreate>
}
    639c:	0f 91       	pop	r16
    639e:	ff 90       	pop	r15
    63a0:	ef 90       	pop	r14
    63a2:	08 95       	ret

000063a4 <GetADCData>:
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
	}
}

ADCStruct GetADCData(void)
{
    63a4:	cf 93       	push	r28
    63a6:	df 93       	push	r29
    63a8:	cd b7       	in	r28, 0x3d	; 61
    63aa:	de b7       	in	r29, 0x3e	; 62
    63ac:	60 97       	sbiw	r28, 0x10	; 16
    63ae:	cd bf       	out	0x3d, r28	; 61
    63b0:	de bf       	out	0x3e, r29	; 62
	ADCStruct ADCData;
	xQueuePeek(ADCQueue,&ADCData,portMAX_DELAY);
    63b2:	4f ef       	ldi	r20, 0xFF	; 255
    63b4:	5f ef       	ldi	r21, 0xFF	; 255
    63b6:	be 01       	movw	r22, r28
    63b8:	67 5f       	subi	r22, 0xF7	; 247
    63ba:	7f 4f       	sbci	r23, 0xFF	; 255
    63bc:	80 91 8b 2d 	lds	r24, 0x2D8B	; 0x802d8b <ADCQueue>
    63c0:	90 91 8c 2d 	lds	r25, 0x2D8C	; 0x802d8c <ADCQueue+0x1>
    63c4:	0e 94 75 23 	call	0x46ea	; 0x46ea <xQueuePeek>
	return ADCData;
    63c8:	88 e0       	ldi	r24, 0x08	; 8
    63ca:	fe 01       	movw	r30, r28
    63cc:	39 96       	adiw	r30, 0x09	; 9
    63ce:	de 01       	movw	r26, r28
    63d0:	11 96       	adiw	r26, 0x01	; 1
    63d2:	01 90       	ld	r0, Z+
    63d4:	0d 92       	st	X+, r0
    63d6:	8a 95       	dec	r24
    63d8:	e1 f7       	brne	.-8      	; 0x63d2 <GetADCData+0x2e>
    63da:	29 81       	ldd	r18, Y+1	; 0x01
    63dc:	3a 81       	ldd	r19, Y+2	; 0x02
    63de:	4b 81       	ldd	r20, Y+3	; 0x03
    63e0:	5c 81       	ldd	r21, Y+4	; 0x04
    63e2:	6d 81       	ldd	r22, Y+5	; 0x05
    63e4:	7e 81       	ldd	r23, Y+6	; 0x06
    63e6:	8f 81       	ldd	r24, Y+7	; 0x07
    63e8:	98 85       	ldd	r25, Y+8	; 0x08
    63ea:	60 96       	adiw	r28, 0x10	; 16
    63ec:	cd bf       	out	0x3d, r28	; 61
    63ee:	de bf       	out	0x3e, r29	; 62
    63f0:	df 91       	pop	r29
    63f2:	cf 91       	pop	r28
    63f4:	08 95       	ret

000063f6 <GyroGet>:
	}

}

void GyroGet(float *YawRate, float *Yaw)
{
    63f6:	0f 93       	push	r16
    63f8:	1f 93       	push	r17
    63fa:	cf 93       	push	r28
    63fc:	df 93       	push	r29
    63fe:	8c 01       	movw	r16, r24
    6400:	eb 01       	movw	r28, r22
		xSemaphoreTake(GyroSema,portMAX_DELAY);
    6402:	6f ef       	ldi	r22, 0xFF	; 255
    6404:	7f ef       	ldi	r23, 0xFF	; 255
    6406:	80 91 4b 2d 	lds	r24, 0x2D4B	; 0x802d4b <GyroSema>
    640a:	90 91 4c 2d 	lds	r25, 0x2D4C	; 0x802d4c <GyroSema+0x1>
    640e:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <xQueueSemaphoreTake>
		if (YawRate!=NULL) *YawRate=GlobYawRate;
    6412:	01 15       	cp	r16, r1
    6414:	11 05       	cpc	r17, r1
    6416:	69 f0       	breq	.+26     	; 0x6432 <GyroGet+0x3c>
    6418:	80 91 47 2d 	lds	r24, 0x2D47	; 0x802d47 <GlobYawRate>
    641c:	90 91 48 2d 	lds	r25, 0x2D48	; 0x802d48 <GlobYawRate+0x1>
    6420:	a0 91 49 2d 	lds	r26, 0x2D49	; 0x802d49 <GlobYawRate+0x2>
    6424:	b0 91 4a 2d 	lds	r27, 0x2D4A	; 0x802d4a <GlobYawRate+0x3>
    6428:	f8 01       	movw	r30, r16
    642a:	80 83       	st	Z, r24
    642c:	91 83       	std	Z+1, r25	; 0x01
    642e:	a2 83       	std	Z+2, r26	; 0x02
    6430:	b3 83       	std	Z+3, r27	; 0x03
		if (Yaw!=NULL) *Yaw=GlobYaw;
    6432:	20 97       	sbiw	r28, 0x00	; 0
    6434:	61 f0       	breq	.+24     	; 0x644e <GyroGet+0x58>
    6436:	80 91 43 2d 	lds	r24, 0x2D43	; 0x802d43 <GlobYaw>
    643a:	90 91 44 2d 	lds	r25, 0x2D44	; 0x802d44 <GlobYaw+0x1>
    643e:	a0 91 45 2d 	lds	r26, 0x2D45	; 0x802d45 <GlobYaw+0x2>
    6442:	b0 91 46 2d 	lds	r27, 0x2D46	; 0x802d46 <GlobYaw+0x3>
    6446:	88 83       	st	Y, r24
    6448:	99 83       	std	Y+1, r25	; 0x01
    644a:	aa 83       	std	Y+2, r26	; 0x02
    644c:	bb 83       	std	Y+3, r27	; 0x03
		xSemaphoreGive(GyroSema);
    644e:	20 e0       	ldi	r18, 0x00	; 0
    6450:	40 e0       	ldi	r20, 0x00	; 0
    6452:	50 e0       	ldi	r21, 0x00	; 0
    6454:	60 e0       	ldi	r22, 0x00	; 0
    6456:	70 e0       	ldi	r23, 0x00	; 0
    6458:	80 91 4b 2d 	lds	r24, 0x2D4B	; 0x802d4b <GyroSema>
    645c:	90 91 4c 2d 	lds	r25, 0x2D4C	; 0x802d4c <GyroSema+0x1>
	
}
    6460:	df 91       	pop	r29
    6462:	cf 91       	pop	r28
    6464:	1f 91       	pop	r17
    6466:	0f 91       	pop	r16
void GyroGet(float *YawRate, float *Yaw)
{
		xSemaphoreTake(GyroSema,portMAX_DELAY);
		if (YawRate!=NULL) *YawRate=GlobYawRate;
		if (Yaw!=NULL) *Yaw=GlobYaw;
		xSemaphoreGive(GyroSema);
    6468:	0c 94 27 20 	jmp	0x404e	; 0x404e <xQueueGenericSend>

0000646c <WorkerLineFollowerDirect>:
{
	vTaskSuspend(LineFollowerDirectTaskHandle);
}

static void WorkerLineFollowerDirect(void *pvParameters)
{
    646c:	cf 93       	push	r28
    646e:	df 93       	push	r29
    6470:	cd b7       	in	r28, 0x3d	; 61
    6472:	de b7       	in	r29, 0x3e	; 62
    6474:	2a 97       	sbiw	r28, 0x0a	; 10
    6476:	cd bf       	out	0x3d, r28	; 61
    6478:	de bf       	out	0x3e, r29	; 62
	{
		xLastWakeTime=xTaskGetTickCount();

		ADCData=GetADCData();
		Diff=(float) (ADCData.PhotoL-ADCData.PhotoR+SensorOffset);
		printf ("Diff:%f\r\n",Diff);
    647a:	0d ef       	ldi	r16, 0xFD	; 253
    647c:	15 e2       	ldi	r17, 0x25	; 37
    647e:	1b c0       	rjmp	.+54     	; 0x64b6 <WorkerLineFollowerDirect+0x4a>
    6480:	c3 01       	movw	r24, r6
    6482:	b2 01       	movw	r22, r4
    6484:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
    6488:	7b 01       	movw	r14, r22
		OutL=Speed+(Diff*LineFollowKp);
		OutR=Speed-(Diff*LineFollowKp);
		
		if (OutL<0) OutL=0;
		if (OutR<0) OutR=0;
    648a:	20 e0       	ldi	r18, 0x00	; 0
    648c:	30 e0       	ldi	r19, 0x00	; 0
    648e:	a9 01       	movw	r20, r18
    6490:	c5 01       	movw	r24, r10
    6492:	b4 01       	movw	r22, r8
    6494:	0e 94 90 42 	call	0x8520	; 0x8520 <__cmpsf2>
    6498:	87 fd       	sbrc	r24, 7
    649a:	5d c0       	rjmp	.+186    	; 0x6556 <WorkerLineFollowerDirect+0xea>
    649c:	c5 01       	movw	r24, r10
    649e:	b4 01       	movw	r22, r8
    64a0:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
		DriverMotorSet((int16_t) OutL, (int16_t) OutR);
    64a4:	c7 01       	movw	r24, r14
    64a6:	0e 94 f2 06 	call	0xde4	; 0xde4 <DriverMotorSet>
			

		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    64aa:	6a e0       	ldi	r22, 0x0A	; 10
    64ac:	70 e0       	ldi	r23, 0x00	; 0
    64ae:	ce 01       	movw	r24, r28
    64b0:	09 96       	adiw	r24, 0x09	; 9
    64b2:	0e 94 31 2a 	call	0x5462	; 0x5462 <vTaskDelayUntil>
	ADCStruct ADCData;

	
	while(1)
	{
		xLastWakeTime=xTaskGetTickCount();
    64b6:	0e 94 ac 28 	call	0x5158	; 0x5158 <xTaskGetTickCount>
    64ba:	89 87       	std	Y+9, r24	; 0x09
    64bc:	9a 87       	std	Y+10, r25	; 0x0a

		ADCData=GetADCData();
    64be:	0e 94 d2 31 	call	0x63a4	; 0x63a4 <GetADCData>
    64c2:	29 83       	std	Y+1, r18	; 0x01
    64c4:	3a 83       	std	Y+2, r19	; 0x02
    64c6:	6d 83       	std	Y+5, r22	; 0x05
    64c8:	7e 83       	std	Y+6, r23	; 0x06
		Diff=(float) (ADCData.PhotoL-ADCData.PhotoR+SensorOffset);
    64ca:	69 81       	ldd	r22, Y+1	; 0x01
    64cc:	7a 81       	ldd	r23, Y+2	; 0x02
    64ce:	8d 81       	ldd	r24, Y+5	; 0x05
    64d0:	9e 81       	ldd	r25, Y+6	; 0x06
    64d2:	68 1b       	sub	r22, r24
    64d4:	79 0b       	sbc	r23, r25
    64d6:	07 2e       	mov	r0, r23
    64d8:	00 0c       	add	r0, r0
    64da:	88 0b       	sbc	r24, r24
    64dc:	99 0b       	sbc	r25, r25
    64de:	0e 94 3f 43 	call	0x867e	; 0x867e <__floatsisf>
    64e2:	6b 01       	movw	r12, r22
    64e4:	7c 01       	movw	r14, r24
		printf ("Diff:%f\r\n",Diff);
    64e6:	ff 92       	push	r15
    64e8:	8f 93       	push	r24
    64ea:	df 92       	push	r13
    64ec:	6f 93       	push	r22
    64ee:	1f 93       	push	r17
    64f0:	0f 93       	push	r16
    64f2:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
		OutL=Speed+(Diff*LineFollowKp);
    64f6:	2d ec       	ldi	r18, 0xCD	; 205
    64f8:	3c ec       	ldi	r19, 0xCC	; 204
    64fa:	4c e4       	ldi	r20, 0x4C	; 76
    64fc:	5e e3       	ldi	r21, 0x3E	; 62
    64fe:	6c 2d       	mov	r22, r12
    6500:	7d 2d       	mov	r23, r13
    6502:	8e 2d       	mov	r24, r14
    6504:	9f 2d       	mov	r25, r15
    6506:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    650a:	6b 01       	movw	r12, r22
    650c:	7c 01       	movw	r14, r24
    650e:	20 e0       	ldi	r18, 0x00	; 0
    6510:	30 e0       	ldi	r19, 0x00	; 0
    6512:	48 e4       	ldi	r20, 0x48	; 72
    6514:	55 e4       	ldi	r21, 0x45	; 69
    6516:	0e 94 24 42 	call	0x8448	; 0x8448 <__addsf3>
    651a:	2b 01       	movw	r4, r22
    651c:	3c 01       	movw	r6, r24
		OutR=Speed-(Diff*LineFollowKp);
    651e:	a7 01       	movw	r20, r14
    6520:	96 01       	movw	r18, r12
    6522:	60 e0       	ldi	r22, 0x00	; 0
    6524:	70 e0       	ldi	r23, 0x00	; 0
    6526:	88 e4       	ldi	r24, 0x48	; 72
    6528:	95 e4       	ldi	r25, 0x45	; 69
    652a:	0e 94 23 42 	call	0x8446	; 0x8446 <__subsf3>
    652e:	4b 01       	movw	r8, r22
    6530:	5c 01       	movw	r10, r24
		
		if (OutL<0) OutL=0;
    6532:	0f 90       	pop	r0
    6534:	0f 90       	pop	r0
    6536:	0f 90       	pop	r0
    6538:	0f 90       	pop	r0
    653a:	0f 90       	pop	r0
    653c:	0f 90       	pop	r0
    653e:	20 e0       	ldi	r18, 0x00	; 0
    6540:	30 e0       	ldi	r19, 0x00	; 0
    6542:	a9 01       	movw	r20, r18
    6544:	c3 01       	movw	r24, r6
    6546:	b2 01       	movw	r22, r4
    6548:	0e 94 90 42 	call	0x8520	; 0x8520 <__cmpsf2>
    654c:	87 ff       	sbrs	r24, 7
    654e:	98 cf       	rjmp	.-208    	; 0x6480 <WorkerLineFollowerDirect+0x14>
    6550:	e1 2c       	mov	r14, r1
    6552:	f1 2c       	mov	r15, r1
    6554:	9a cf       	rjmp	.-204    	; 0x648a <WorkerLineFollowerDirect+0x1e>
    6556:	60 e0       	ldi	r22, 0x00	; 0
    6558:	70 e0       	ldi	r23, 0x00	; 0
    655a:	a4 cf       	rjmp	.-184    	; 0x64a4 <WorkerLineFollowerDirect+0x38>

0000655c <InitLineFollowerDirectTask>:
//Private function prototypes
static void WorkerLineFollowerDirect(void *pvParameters);

//Function definitions
void InitLineFollowerDirectTask()
{
    655c:	ef 92       	push	r14
    655e:	ff 92       	push	r15
    6560:	0f 93       	push	r16
	xTaskCreate( WorkerLineFollowerDirect, "LFdirect", 256, NULL, tskIDLE_PRIORITY+3, &LineFollowerDirectTaskHandle );	
    6562:	8d e4       	ldi	r24, 0x4D	; 77
    6564:	e8 2e       	mov	r14, r24
    6566:	8d e2       	ldi	r24, 0x2D	; 45
    6568:	f8 2e       	mov	r15, r24
    656a:	03 e0       	ldi	r16, 0x03	; 3
    656c:	20 e0       	ldi	r18, 0x00	; 0
    656e:	30 e0       	ldi	r19, 0x00	; 0
    6570:	40 e0       	ldi	r20, 0x00	; 0
    6572:	51 e0       	ldi	r21, 0x01	; 1
    6574:	67 e0       	ldi	r22, 0x07	; 7
    6576:	76 e2       	ldi	r23, 0x26	; 38
    6578:	86 e3       	ldi	r24, 0x36	; 54
    657a:	92 e3       	ldi	r25, 0x32	; 50
    657c:	0e 94 20 26 	call	0x4c40	; 0x4c40 <xTaskCreate>
	vTaskResume(LineFollowerDirectTaskHandle);
}

void DisableLineFollowerDirectTask()
{
	vTaskSuspend(LineFollowerDirectTaskHandle);
    6580:	80 91 4d 2d 	lds	r24, 0x2D4D	; 0x802d4d <LineFollowerDirectTaskHandle>
    6584:	90 91 4e 2d 	lds	r25, 0x2D4E	; 0x802d4e <LineFollowerDirectTaskHandle+0x1>
//Function definitions
void InitLineFollowerDirectTask()
{
	xTaskCreate( WorkerLineFollowerDirect, "LFdirect", 256, NULL, tskIDLE_PRIORITY+3, &LineFollowerDirectTaskHandle );	
	DisableLineFollowerDirectTask();
}
    6588:	0f 91       	pop	r16
    658a:	ff 90       	pop	r15
    658c:	ef 90       	pop	r14
	vTaskResume(LineFollowerDirectTaskHandle);
}

void DisableLineFollowerDirectTask()
{
	vTaskSuspend(LineFollowerDirectTaskHandle);
    658e:	0c 94 a2 27 	jmp	0x4f44	; 0x4f44 <vTaskSuspend>

00006592 <EnableLineFollowerDirectTask>:
	DisableLineFollowerDirectTask();
}

void EnableLineFollowerDirectTask()
{
	vTaskResume(LineFollowerDirectTaskHandle);
    6592:	80 91 4d 2d 	lds	r24, 0x2D4D	; 0x802d4d <LineFollowerDirectTaskHandle>
    6596:	90 91 4e 2d 	lds	r25, 0x2D4E	; 0x802d4e <LineFollowerDirectTaskHandle+0x1>
    659a:	0c 94 1f 28 	jmp	0x503e	; 0x503e <vTaskResume>

0000659e <DisableLineFollowerDirectTask>:
}

void DisableLineFollowerDirectTask()
{
	vTaskSuspend(LineFollowerDirectTaskHandle);
    659e:	80 91 4d 2d 	lds	r24, 0x2D4D	; 0x802d4d <LineFollowerDirectTaskHandle>
    65a2:	90 91 4e 2d 	lds	r25, 0x2D4E	; 0x802d4e <LineFollowerDirectTaskHandle+0x1>
    65a6:	0c 94 a2 27 	jmp	0x4f44	; 0x4f44 <vTaskSuspend>

000065aa <WorkerLineFollowerSpeed>:
	StopSema=xSemaphoreCreateBinary();
	xTaskCreate( WorkerLineFollowerSpeed, "LFSpeed", 512, NULL, tskIDLE_PRIORITY+2, NULL );
}

void WorkerLineFollowerSpeed(void *pvParameters)
{
    65aa:	cf 93       	push	r28
    65ac:	df 93       	push	r29
    65ae:	cd b7       	in	r28, 0x3d	; 61
    65b0:	de b7       	in	r29, 0x3e	; 62
    65b2:	2a 97       	sbiw	r28, 0x0a	; 10
    65b4:	cd bf       	out	0x3d, r28	; 61
    65b6:	de bf       	out	0x3e, r29	; 62
	float OutL,OutR;
	ADCStruct ADCData;
	
	while(1)
	{
		xSemaphoreTake(StartSema,portMAX_DELAY);
    65b8:	6f ef       	ldi	r22, 0xFF	; 255
    65ba:	7f ef       	ldi	r23, 0xFF	; 255
    65bc:	80 91 51 2d 	lds	r24, 0x2D51	; 0x802d51 <StartSema>
    65c0:	90 91 52 2d 	lds	r25, 0x2D52	; 0x802d52 <StartSema+0x1>
    65c4:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <xQueueSemaphoreTake>
		Speed=ReqSpeed;
    65c8:	80 91 57 2d 	lds	r24, 0x2D57	; 0x802d57 <ReqSpeed>
    65cc:	90 91 58 2d 	lds	r25, 0x2D58	; 0x802d58 <ReqSpeed+0x1>
    65d0:	a0 91 59 2d 	lds	r26, 0x2D59	; 0x802d59 <ReqSpeed+0x2>
    65d4:	b0 91 5a 2d 	lds	r27, 0x2D5A	; 0x802d5a <ReqSpeed+0x3>
    65d8:	80 93 53 2d 	sts	0x2D53, r24	; 0x802d53 <Speed>
    65dc:	90 93 54 2d 	sts	0x2D54, r25	; 0x802d54 <Speed+0x1>
    65e0:	a0 93 55 2d 	sts	0x2D55, r26	; 0x802d55 <Speed+0x2>
    65e4:	b0 93 56 2d 	sts	0x2D56, r27	; 0x802d56 <Speed+0x3>
		xLastWakeTime=xTaskGetTickCount();
    65e8:	0e 94 ac 28 	call	0x5158	; 0x5158 <xTaskGetTickCount>
    65ec:	89 87       	std	Y+9, r24	; 0x09
    65ee:	9a 87       	std	Y+10, r25	; 0x0a
    65f0:	18 c0       	rjmp	.+48     	; 0x6622 <WorkerLineFollowerSpeed+0x78>
    65f2:	c5 01       	movw	r24, r10
    65f4:	b4 01       	movw	r22, r8
    65f6:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
			//printf ("Diff:%f\r\n",Diff);
			OutL=Speed+(Diff*(float) (LINEFOLLOW_SPEED_KP));
			OutR=Speed-(Diff*(float) (LINEFOLLOW_SPEED_KP));
			if (OutL<0) OutL=0;
			if (OutR<0) OutR=0;
			MotorSpeedSet((int16_t) OutL, (int16_t) OutR);	
    65fa:	c7 01       	movw	r24, r14
    65fc:	0e 94 95 38 	call	0x712a	; 0x712a <MotorSpeedSet>
			
			if (xSemaphoreTake(StopSema,0)==pdPASS)
    6600:	60 e0       	ldi	r22, 0x00	; 0
    6602:	70 e0       	ldi	r23, 0x00	; 0
    6604:	80 91 4f 2d 	lds	r24, 0x2D4F	; 0x802d4f <StopSema>
    6608:	90 91 50 2d 	lds	r25, 0x2D50	; 0x802d50 <StopSema+0x1>
    660c:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <xQueueSemaphoreTake>
    6610:	81 30       	cpi	r24, 0x01	; 1
    6612:	09 f4       	brne	.+2      	; 0x6616 <WorkerLineFollowerSpeed+0x6c>
    6614:	55 c0       	rjmp	.+170    	; 0x66c0 <WorkerLineFollowerSpeed+0x116>
			{
				MotorSpeedSet(0,0);	
				break;
			}
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
    6616:	6a e0       	ldi	r22, 0x0A	; 10
    6618:	70 e0       	ldi	r23, 0x00	; 0
    661a:	ce 01       	movw	r24, r28
    661c:	09 96       	adiw	r24, 0x09	; 9
    661e:	0e 94 31 2a 	call	0x5462	; 0x5462 <vTaskDelayUntil>
		Speed=ReqSpeed;
		xLastWakeTime=xTaskGetTickCount();
		while (1)
		{
			
			ADCData=GetADCData();
    6622:	0e 94 d2 31 	call	0x63a4	; 0x63a4 <GetADCData>
    6626:	29 83       	std	Y+1, r18	; 0x01
    6628:	3a 83       	std	Y+2, r19	; 0x02
    662a:	6d 83       	std	Y+5, r22	; 0x05
    662c:	7e 83       	std	Y+6, r23	; 0x06
			Diff=(float) (ADCData.PhotoL-ADCData.PhotoR+SensorOffset);
			//printf ("Diff:%f\r\n",Diff);
			OutL=Speed+(Diff*(float) (LINEFOLLOW_SPEED_KP));
    662e:	69 81       	ldd	r22, Y+1	; 0x01
    6630:	7a 81       	ldd	r23, Y+2	; 0x02
    6632:	8d 81       	ldd	r24, Y+5	; 0x05
    6634:	9e 81       	ldd	r25, Y+6	; 0x06
    6636:	68 1b       	sub	r22, r24
    6638:	79 0b       	sbc	r23, r25
    663a:	64 56       	subi	r22, 0x64	; 100
    663c:	71 09       	sbc	r23, r1
    663e:	07 2e       	mov	r0, r23
    6640:	00 0c       	add	r0, r0
    6642:	88 0b       	sbc	r24, r24
    6644:	99 0b       	sbc	r25, r25
    6646:	0e 94 3f 43 	call	0x867e	; 0x867e <__floatsisf>
    664a:	2d ec       	ldi	r18, 0xCD	; 205
    664c:	3c ec       	ldi	r19, 0xCC	; 204
    664e:	4c ec       	ldi	r20, 0xCC	; 204
    6650:	5d e3       	ldi	r21, 0x3D	; 61
    6652:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    6656:	4b 01       	movw	r8, r22
    6658:	5c 01       	movw	r10, r24
    665a:	c0 90 53 2d 	lds	r12, 0x2D53	; 0x802d53 <Speed>
    665e:	d0 90 54 2d 	lds	r13, 0x2D54	; 0x802d54 <Speed+0x1>
    6662:	e0 90 55 2d 	lds	r14, 0x2D55	; 0x802d55 <Speed+0x2>
    6666:	f0 90 56 2d 	lds	r15, 0x2D56	; 0x802d56 <Speed+0x3>
    666a:	a7 01       	movw	r20, r14
    666c:	96 01       	movw	r18, r12
    666e:	0e 94 24 42 	call	0x8448	; 0x8448 <__addsf3>
    6672:	2b 01       	movw	r4, r22
    6674:	3c 01       	movw	r6, r24
			OutR=Speed-(Diff*(float) (LINEFOLLOW_SPEED_KP));
    6676:	a5 01       	movw	r20, r10
    6678:	94 01       	movw	r18, r8
    667a:	c7 01       	movw	r24, r14
    667c:	b6 01       	movw	r22, r12
    667e:	0e 94 23 42 	call	0x8446	; 0x8446 <__subsf3>
    6682:	4b 01       	movw	r8, r22
    6684:	5c 01       	movw	r10, r24
			if (OutL<0) OutL=0;
    6686:	20 e0       	ldi	r18, 0x00	; 0
    6688:	30 e0       	ldi	r19, 0x00	; 0
    668a:	a9 01       	movw	r20, r18
    668c:	c3 01       	movw	r24, r6
    668e:	b2 01       	movw	r22, r4
    6690:	0e 94 90 42 	call	0x8520	; 0x8520 <__cmpsf2>
    6694:	87 ff       	sbrs	r24, 7
    6696:	0e c0       	rjmp	.+28     	; 0x66b4 <WorkerLineFollowerSpeed+0x10a>
    6698:	e1 2c       	mov	r14, r1
    669a:	f1 2c       	mov	r15, r1
			if (OutR<0) OutR=0;
    669c:	20 e0       	ldi	r18, 0x00	; 0
    669e:	30 e0       	ldi	r19, 0x00	; 0
    66a0:	a9 01       	movw	r20, r18
    66a2:	c5 01       	movw	r24, r10
    66a4:	b4 01       	movw	r22, r8
    66a6:	0e 94 90 42 	call	0x8520	; 0x8520 <__cmpsf2>
    66aa:	87 ff       	sbrs	r24, 7
    66ac:	a2 cf       	rjmp	.-188    	; 0x65f2 <WorkerLineFollowerSpeed+0x48>
    66ae:	60 e0       	ldi	r22, 0x00	; 0
    66b0:	70 e0       	ldi	r23, 0x00	; 0
    66b2:	a3 cf       	rjmp	.-186    	; 0x65fa <WorkerLineFollowerSpeed+0x50>
    66b4:	c3 01       	movw	r24, r6
    66b6:	b2 01       	movw	r22, r4
    66b8:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
    66bc:	7b 01       	movw	r14, r22
    66be:	ee cf       	rjmp	.-36     	; 0x669c <WorkerLineFollowerSpeed+0xf2>
			MotorSpeedSet((int16_t) OutL, (int16_t) OutR);	
			
			if (xSemaphoreTake(StopSema,0)==pdPASS)
			{
				MotorSpeedSet(0,0);	
    66c0:	60 e0       	ldi	r22, 0x00	; 0
    66c2:	70 e0       	ldi	r23, 0x00	; 0
    66c4:	80 e0       	ldi	r24, 0x00	; 0
    66c6:	90 e0       	ldi	r25, 0x00	; 0
    66c8:	0e 94 95 38 	call	0x712a	; 0x712a <MotorSpeedSet>
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
		}

		
		
	}
    66cc:	75 cf       	rjmp	.-278    	; 0x65b8 <WorkerLineFollowerSpeed+0xe>

000066ce <InitLineFollowerSpeedTask>:
void WorkerLineFollowerSpeed(void *pvParameters);


//Function definitions
void InitLineFollowerSpeedTask()
{
    66ce:	ef 92       	push	r14
    66d0:	ff 92       	push	r15
    66d2:	0f 93       	push	r16
	StartSema=xSemaphoreCreateBinary();
    66d4:	43 e0       	ldi	r20, 0x03	; 3
    66d6:	60 e0       	ldi	r22, 0x00	; 0
    66d8:	81 e0       	ldi	r24, 0x01	; 1
    66da:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <xQueueGenericCreate>
    66de:	80 93 51 2d 	sts	0x2D51, r24	; 0x802d51 <StartSema>
    66e2:	90 93 52 2d 	sts	0x2D52, r25	; 0x802d52 <StartSema+0x1>
	StopSema=xSemaphoreCreateBinary();
    66e6:	43 e0       	ldi	r20, 0x03	; 3
    66e8:	60 e0       	ldi	r22, 0x00	; 0
    66ea:	81 e0       	ldi	r24, 0x01	; 1
    66ec:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <xQueueGenericCreate>
    66f0:	80 93 4f 2d 	sts	0x2D4F, r24	; 0x802d4f <StopSema>
    66f4:	90 93 50 2d 	sts	0x2D50, r25	; 0x802d50 <StopSema+0x1>
	xTaskCreate( WorkerLineFollowerSpeed, "LFSpeed", 512, NULL, tskIDLE_PRIORITY+2, NULL );
    66f8:	e1 2c       	mov	r14, r1
    66fa:	f1 2c       	mov	r15, r1
    66fc:	02 e0       	ldi	r16, 0x02	; 2
    66fe:	20 e0       	ldi	r18, 0x00	; 0
    6700:	30 e0       	ldi	r19, 0x00	; 0
    6702:	40 e0       	ldi	r20, 0x00	; 0
    6704:	52 e0       	ldi	r21, 0x02	; 2
    6706:	60 e1       	ldi	r22, 0x10	; 16
    6708:	76 e2       	ldi	r23, 0x26	; 38
    670a:	85 ed       	ldi	r24, 0xD5	; 213
    670c:	92 e3       	ldi	r25, 0x32	; 50
    670e:	0e 94 20 26 	call	0x4c40	; 0x4c40 <xTaskCreate>
}
    6712:	0f 91       	pop	r16
    6714:	ff 90       	pop	r15
    6716:	ef 90       	pop	r14
    6718:	08 95       	ret

0000671a <StartLineFollower>:
	}
}

void StartLineFollower(float Speed)
{
	ReqSpeed=Speed;
    671a:	60 93 57 2d 	sts	0x2D57, r22	; 0x802d57 <ReqSpeed>
    671e:	70 93 58 2d 	sts	0x2D58, r23	; 0x802d58 <ReqSpeed+0x1>
    6722:	80 93 59 2d 	sts	0x2D59, r24	; 0x802d59 <ReqSpeed+0x2>
    6726:	90 93 5a 2d 	sts	0x2D5A, r25	; 0x802d5a <ReqSpeed+0x3>
	xSemaphoreGive(StartSema);
    672a:	20 e0       	ldi	r18, 0x00	; 0
    672c:	40 e0       	ldi	r20, 0x00	; 0
    672e:	50 e0       	ldi	r21, 0x00	; 0
    6730:	60 e0       	ldi	r22, 0x00	; 0
    6732:	70 e0       	ldi	r23, 0x00	; 0
    6734:	80 91 51 2d 	lds	r24, 0x2D51	; 0x802d51 <StartSema>
    6738:	90 91 52 2d 	lds	r25, 0x2D52	; 0x802d52 <StartSema+0x1>
    673c:	0c 94 27 20 	jmp	0x404e	; 0x404e <xQueueGenericSend>

00006740 <StopLineFollower>:
	
}
void StopLineFollower()
{
	xSemaphoreGive(StopSema);
    6740:	20 e0       	ldi	r18, 0x00	; 0
    6742:	40 e0       	ldi	r20, 0x00	; 0
    6744:	50 e0       	ldi	r21, 0x00	; 0
    6746:	60 e0       	ldi	r22, 0x00	; 0
    6748:	70 e0       	ldi	r23, 0x00	; 0
    674a:	80 91 4f 2d 	lds	r24, 0x2D4F	; 0x802d4f <StopSema>
    674e:	90 91 50 2d 	lds	r25, 0x2D50	; 0x802d50 <StopSema+0x1>
    6752:	0c 94 27 20 	jmp	0x404e	; 0x404e <xQueueGenericSend>

00006756 <WorkerMotion>:
	DisableMotorSpeedTask();
	
}

static void WorkerMotion(void *pvParameters)
{
    6756:	cf 93       	push	r28
    6758:	df 93       	push	r29
    675a:	cd b7       	in	r28, 0x3d	; 61
    675c:	de b7       	in	r29, 0x3e	; 62
    675e:	67 97       	sbiw	r28, 0x17	; 23
    6760:	cd bf       	out	0x3d, r28	; 61
    6762:	de bf       	out	0x3e, r29	; 62
    6764:	0f c0       	rjmp	.+30     	; 0x6784 <WorkerMotion+0x2e>

		if (MotionCmd.Cmd==CMD_DRIVE_STRAIGHT)
		{
			CmdDriveStraight(MotionCmd.Params[0],MotionCmd.Params[1]);
		}	
		else if (MotionCmd.Cmd==CMD_DRIVE_SEGMENT)
    6766:	82 30       	cpi	r24, 0x02	; 2
    6768:	09 f4       	brne	.+2      	; 0x676c <WorkerMotion+0x16>
    676a:	ae c0       	rjmp	.+348    	; 0x68c8 <WorkerMotion+0x172>
		{
			CmdDriveSegment(MotionCmd.Params[0]);
		}
		else if (MotionCmd.Cmd==CMD_ROTATE_CENTER)
    676c:	83 30       	cpi	r24, 0x03	; 3
    676e:	09 f4       	brne	.+2      	; 0x6772 <WorkerMotion+0x1c>
    6770:	fa c0       	rjmp	.+500    	; 0x6966 <WorkerMotion+0x210>
		{
			CmdRotateCenter(MotionCmd.Params[0],MotionCmd.Params[1]);	
		}			
		if (uxQueueMessagesWaiting(CmdQueue)==0) xSemaphoreGive(CmdCompleteSema);
    6772:	80 91 5d 2d 	lds	r24, 0x2D5D	; 0x802d5d <CmdQueue>
    6776:	90 91 5e 2d 	lds	r25, 0x2D5E	; 0x802d5e <CmdQueue+0x1>
    677a:	0e 94 7d 24 	call	0x48fa	; 0x48fa <uxQueueMessagesWaiting>
    677e:	88 23       	and	r24, r24
    6780:	09 f4       	brne	.+2      	; 0x6784 <WorkerMotion+0x2e>
    6782:	96 c0       	rjmp	.+300    	; 0x68b0 <WorkerMotion+0x15a>
	
	float fa;
	
	while (1)
	{
		xQueueReceive(CmdQueue,&MotionCmd,portMAX_DELAY);
    6784:	4f ef       	ldi	r20, 0xFF	; 255
    6786:	5f ef       	ldi	r21, 0xFF	; 255
    6788:	be 01       	movw	r22, r28
    678a:	6f 5f       	subi	r22, 0xFF	; 255
    678c:	7f 4f       	sbci	r23, 0xFF	; 255
    678e:	80 91 5d 2d 	lds	r24, 0x2D5D	; 0x802d5d <CmdQueue>
    6792:	90 91 5e 2d 	lds	r25, 0x2D5E	; 0x802d5e <CmdQueue+0x1>
    6796:	0e 94 be 21 	call	0x437c	; 0x437c <xQueueReceive>

		if (MotionCmd.Cmd==CMD_DRIVE_STRAIGHT)
    679a:	89 81       	ldd	r24, Y+1	; 0x01
    679c:	81 30       	cpi	r24, 0x01	; 1
    679e:	19 f7       	brne	.-58     	; 0x6766 <WorkerMotion+0x10>
		{
			CmdDriveStraight(MotionCmd.Params[0],MotionCmd.Params[1]);
    67a0:	4e 80       	ldd	r4, Y+6	; 0x06
    67a2:	5f 80       	ldd	r5, Y+7	; 0x07
    67a4:	68 84       	ldd	r6, Y+8	; 0x08
    67a6:	79 84       	ldd	r7, Y+9	; 0x09
    67a8:	8a 80       	ldd	r8, Y+2	; 0x02
    67aa:	9b 80       	ldd	r9, Y+3	; 0x03
    67ac:	ac 80       	ldd	r10, Y+4	; 0x04
    67ae:	bd 80       	ldd	r11, Y+5	; 0x05
	ADCStruct ADCData;
	int Cnt;
		
	float fa;
		
	xLastWakeTime = xTaskGetTickCount();
    67b0:	0e 94 ac 28 	call	0x5158	; 0x5158 <xTaskGetTickCount>
    67b4:	8a 87       	std	Y+10, r24	; 0x0a
    67b6:	9b 87       	std	Y+11, r25	; 0x0b
	EnableMotorPosTask();
    67b8:	0e 94 b6 37 	call	0x6f6c	; 0x6f6c <EnableMotorPosTask>
	EnableMotorSpeedTask();
    67bc:	0e 94 83 38 	call	0x7106	; 0x7106 <EnableMotorSpeedTask>
	Encoder=DriverMotorGetEncoder();
    67c0:	0e 94 5d 07 	call	0xeba	; 0xeba <DriverMotorGetEncoder>
    67c4:	6b 01       	movw	r12, r22
    67c6:	7c 01       	movw	r14, r24
	if (Distance>0)
    67c8:	20 e0       	ldi	r18, 0x00	; 0
    67ca:	30 e0       	ldi	r19, 0x00	; 0
    67cc:	a9 01       	movw	r20, r18
    67ce:	c5 01       	movw	r24, r10
    67d0:	b4 01       	movw	r22, r8
    67d2:	0e 94 ef 43 	call	0x87de	; 0x87de <__gesf2>
	{
		//Fwd
		EncoderTarget.Cnt1=Encoder.Cnt1+MM_TO_CNT(Distance);
    67d6:	2d ec       	ldi	r18, 0xCD	; 205
    67d8:	3c e4       	ldi	r19, 0x4C	; 76
    67da:	4f e4       	ldi	r20, 0x4F	; 79
    67dc:	53 e4       	ldi	r21, 0x43	; 67
		
	xLastWakeTime = xTaskGetTickCount();
	EnableMotorPosTask();
	EnableMotorSpeedTask();
	Encoder=DriverMotorGetEncoder();
	if (Distance>0)
    67de:	18 16       	cp	r1, r24
    67e0:	0c f0       	brlt	.+2      	; 0x67e4 <WorkerMotion+0x8e>
    67e2:	50 c1       	rjmp	.+672    	; 0x6a84 <WorkerMotion+0x32e>
	{
		//Fwd
		EncoderTarget.Cnt1=Encoder.Cnt1+MM_TO_CNT(Distance);
    67e4:	c5 01       	movw	r24, r10
    67e6:	b4 01       	movw	r22, r8
    67e8:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    67ec:	20 e0       	ldi	r18, 0x00	; 0
    67ee:	30 e0       	ldi	r19, 0x00	; 0
    67f0:	44 eb       	ldi	r20, 0xB4	; 180
    67f2:	53 e4       	ldi	r21, 0x43	; 67
    67f4:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    67f8:	20 e0       	ldi	r18, 0x00	; 0
    67fa:	30 e0       	ldi	r19, 0x00	; 0
    67fc:	40 e4       	ldi	r20, 0x40	; 64
    67fe:	50 e4       	ldi	r21, 0x40	; 64
    6800:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    6804:	6c 8b       	std	Y+20, r22	; 0x14
    6806:	7d 8b       	std	Y+21, r23	; 0x15
    6808:	8e 8b       	std	Y+22, r24	; 0x16
    680a:	9f 8b       	std	Y+23, r25	; 0x17
    680c:	b6 01       	movw	r22, r12
    680e:	dd 0c       	add	r13, r13
    6810:	88 0b       	sbc	r24, r24
    6812:	99 0b       	sbc	r25, r25
    6814:	0e 94 3f 43 	call	0x867e	; 0x867e <__floatsisf>
    6818:	9b 01       	movw	r18, r22
    681a:	ac 01       	movw	r20, r24
    681c:	6c 89       	ldd	r22, Y+20	; 0x14
    681e:	7d 89       	ldd	r23, Y+21	; 0x15
    6820:	8e 89       	ldd	r24, Y+22	; 0x16
    6822:	9f 89       	ldd	r25, Y+23	; 0x17
    6824:	0e 94 24 42 	call	0x8448	; 0x8448 <__addsf3>
    6828:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
    682c:	8b 01       	movw	r16, r22
				
		MotorSpeedSet(MM_TO_CNT(Speed),MM_TO_CNT(Speed));
    682e:	2d ec       	ldi	r18, 0xCD	; 205
    6830:	3c e4       	ldi	r19, 0x4C	; 76
    6832:	4f e4       	ldi	r20, 0x4F	; 79
    6834:	53 e4       	ldi	r21, 0x43	; 67
    6836:	c3 01       	movw	r24, r6
    6838:	b2 01       	movw	r22, r4
    683a:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    683e:	20 e0       	ldi	r18, 0x00	; 0
    6840:	30 e0       	ldi	r19, 0x00	; 0
    6842:	44 eb       	ldi	r20, 0xB4	; 180
    6844:	53 e4       	ldi	r21, 0x43	; 67
    6846:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    684a:	20 e0       	ldi	r18, 0x00	; 0
    684c:	30 e0       	ldi	r19, 0x00	; 0
    684e:	40 e4       	ldi	r20, 0x40	; 64
    6850:	50 e4       	ldi	r21, 0x40	; 64
    6852:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    6856:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
    685a:	dc 01       	movw	r26, r24
    685c:	cb 01       	movw	r24, r22
    685e:	bc 01       	movw	r22, r24
    6860:	0e 94 95 38 	call	0x712a	; 0x712a <MotorSpeedSet>
    6864:	09 c0       	rjmp	.+18     	; 0x6878 <WorkerMotion+0x122>
		Encoder=DriverMotorGetEncoder();
				
		//Stop if target distance is reached
		if (Distance>0)
		{//Fwd
			if (Encoder.Cnt1>EncoderTarget.Cnt1) break;
    6866:	0c 15       	cp	r16, r12
    6868:	1d 05       	cpc	r17, r13
    686a:	b4 f0       	brlt	.+44     	; 0x6898 <WorkerMotion+0x142>
		else
		{//Reverse
			if (Encoder.Cnt1<EncoderTarget.Cnt1) break;
		}
				
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    686c:	6a e0       	ldi	r22, 0x0A	; 10
    686e:	70 e0       	ldi	r23, 0x00	; 0
    6870:	ce 01       	movw	r24, r28
    6872:	0a 96       	adiw	r24, 0x0a	; 10
    6874:	0e 94 31 2a 	call	0x5462	; 0x5462 <vTaskDelayUntil>
		EncoderTarget.Cnt1=Encoder.Cnt1+MM_TO_CNT(Distance);
		MotorSpeedSet(-MM_TO_CNT(Speed),-MM_TO_CNT(Speed));
	}
	while (1)
	{
		Encoder=DriverMotorGetEncoder();
    6878:	0e 94 5d 07 	call	0xeba	; 0xeba <DriverMotorGetEncoder>
    687c:	6b 01       	movw	r12, r22
    687e:	7c 01       	movw	r14, r24
				
		//Stop if target distance is reached
		if (Distance>0)
    6880:	20 e0       	ldi	r18, 0x00	; 0
    6882:	30 e0       	ldi	r19, 0x00	; 0
    6884:	a9 01       	movw	r20, r18
    6886:	c5 01       	movw	r24, r10
    6888:	b4 01       	movw	r22, r8
    688a:	0e 94 ef 43 	call	0x87de	; 0x87de <__gesf2>
    688e:	18 16       	cp	r1, r24
    6890:	54 f3       	brlt	.-44     	; 0x6866 <WorkerMotion+0x110>
		{//Fwd
			if (Encoder.Cnt1>EncoderTarget.Cnt1) break;
		}
		else
		{//Reverse
			if (Encoder.Cnt1<EncoderTarget.Cnt1) break;
    6892:	c0 16       	cp	r12, r16
    6894:	d1 06       	cpc	r13, r17
    6896:	54 f7       	brge	.-44     	; 0x686c <WorkerMotion+0x116>
			if (Encoder.Cnt1>EncoderTarget.Cnt1) break;
		}
		
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
	}
	DisableMotorPosTask();
    6898:	0e 94 cf 37 	call	0x6f9e	; 0x6f9e <DisableMotorPosTask>
	DisableMotorSpeedTask();
    689c:	0e 94 8f 38 	call	0x711e	; 0x711e <DisableMotorSpeedTask>
		}
		else if (MotionCmd.Cmd==CMD_ROTATE_CENTER)
		{
			CmdRotateCenter(MotionCmd.Params[0],MotionCmd.Params[1]);	
		}			
		if (uxQueueMessagesWaiting(CmdQueue)==0) xSemaphoreGive(CmdCompleteSema);
    68a0:	80 91 5d 2d 	lds	r24, 0x2D5D	; 0x802d5d <CmdQueue>
    68a4:	90 91 5e 2d 	lds	r25, 0x2D5E	; 0x802d5e <CmdQueue+0x1>
    68a8:	0e 94 7d 24 	call	0x48fa	; 0x48fa <uxQueueMessagesWaiting>
    68ac:	81 11       	cpse	r24, r1
    68ae:	6a cf       	rjmp	.-300    	; 0x6784 <WorkerMotion+0x2e>
    68b0:	20 e0       	ldi	r18, 0x00	; 0
    68b2:	40 e0       	ldi	r20, 0x00	; 0
    68b4:	50 e0       	ldi	r21, 0x00	; 0
    68b6:	60 e0       	ldi	r22, 0x00	; 0
    68b8:	70 e0       	ldi	r23, 0x00	; 0
    68ba:	80 91 5b 2d 	lds	r24, 0x2D5B	; 0x802d5b <CmdCompleteSema>
    68be:	90 91 5c 2d 	lds	r25, 0x2D5C	; 0x802d5c <CmdCompleteSema+0x1>
    68c2:	0e 94 27 20 	call	0x404e	; 0x404e <xQueueGenericSend>
    68c6:	5e cf       	rjmp	.-324    	; 0x6784 <WorkerMotion+0x2e>
		{
			CmdDriveStraight(MotionCmd.Params[0],MotionCmd.Params[1]);
		}	
		else if (MotionCmd.Cmd==CMD_DRIVE_SEGMENT)
		{
			CmdDriveSegment(MotionCmd.Params[0]);
    68c8:	ca 80       	ldd	r12, Y+2	; 0x02
    68ca:	db 80       	ldd	r13, Y+3	; 0x03
    68cc:	ec 80       	ldd	r14, Y+4	; 0x04
    68ce:	fd 80       	ldd	r15, Y+5	; 0x05
	ADCStruct ADCData;
	int Cnt;
			
	float fa;
			
	xLastWakeTime = xTaskGetTickCount();
    68d0:	0e 94 ac 28 	call	0x5158	; 0x5158 <xTaskGetTickCount>
    68d4:	8a 8b       	std	Y+18, r24	; 0x12
    68d6:	9b 8b       	std	Y+19, r25	; 0x13
	EnableMotorPosTask();
    68d8:	0e 94 b6 37 	call	0x6f6c	; 0x6f6c <EnableMotorPosTask>
	EnableMotorSpeedTask();
    68dc:	0e 94 83 38 	call	0x7106	; 0x7106 <EnableMotorSpeedTask>
	Encoder=DriverMotorGetEncoder();
    68e0:	0e 94 5d 07 	call	0xeba	; 0xeba <DriverMotorGetEncoder>
				
	StartLineFollower(MM_TO_CNT(Speed));
    68e4:	2d ec       	ldi	r18, 0xCD	; 205
    68e6:	3c e4       	ldi	r19, 0x4C	; 76
    68e8:	4f e4       	ldi	r20, 0x4F	; 79
    68ea:	53 e4       	ldi	r21, 0x43	; 67
    68ec:	c7 01       	movw	r24, r14
    68ee:	b6 01       	movw	r22, r12
    68f0:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    68f4:	20 e0       	ldi	r18, 0x00	; 0
    68f6:	30 e0       	ldi	r19, 0x00	; 0
    68f8:	44 eb       	ldi	r20, 0xB4	; 180
    68fa:	53 e4       	ldi	r21, 0x43	; 67
    68fc:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    6900:	20 e0       	ldi	r18, 0x00	; 0
    6902:	30 e0       	ldi	r19, 0x00	; 0
    6904:	40 e4       	ldi	r20, 0x40	; 64
    6906:	50 e4       	ldi	r21, 0x40	; 64
    6908:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    690c:	0e 94 8d 33 	call	0x671a	; 0x671a <StartLineFollower>

	Cnt=0;
    6910:	00 e0       	ldi	r16, 0x00	; 0
    6912:	10 e0       	ldi	r17, 0x00	; 0
    6914:	0b c0       	rjmp	.+22     	; 0x692c <WorkerMotion+0x1d6>
	while (1)
	{
		ADCData=GetADCData();
		if ((ADCData.PhotoL+ADCData.PhotoR)/2>LINEFOLLOW_THRESHOLD)
		{
			Cnt++;
    6916:	0f 5f       	subi	r16, 0xFF	; 255
    6918:	1f 4f       	sbci	r17, 0xFF	; 255
			if (Cnt>LINEFOLLOW_THRESHOLD_CNT) break;
    691a:	05 31       	cpi	r16, 0x15	; 21
    691c:	11 05       	cpc	r17, r1
    691e:	e4 f4       	brge	.+56     	; 0x6958 <WorkerMotion+0x202>
		}
		else
		Cnt=0;
					
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    6920:	6a e0       	ldi	r22, 0x0A	; 10
    6922:	70 e0       	ldi	r23, 0x00	; 0
    6924:	ce 01       	movw	r24, r28
    6926:	42 96       	adiw	r24, 0x12	; 18
    6928:	0e 94 31 2a 	call	0x5462	; 0x5462 <vTaskDelayUntil>
	StartLineFollower(MM_TO_CNT(Speed));

	Cnt=0;
	while (1)
	{
		ADCData=GetADCData();
    692c:	0e 94 d2 31 	call	0x63a4	; 0x63a4 <GetADCData>
    6930:	2a 87       	std	Y+10, r18	; 0x0a
    6932:	3b 87       	std	Y+11, r19	; 0x0b
    6934:	4c 87       	std	Y+12, r20	; 0x0c
    6936:	5d 87       	std	Y+13, r21	; 0x0d
    6938:	6e 87       	std	Y+14, r22	; 0x0e
    693a:	7f 87       	std	Y+15, r23	; 0x0f
    693c:	88 8b       	std	Y+16, r24	; 0x10
    693e:	99 8b       	std	Y+17, r25	; 0x11
		if ((ADCData.PhotoL+ADCData.PhotoR)/2>LINEFOLLOW_THRESHOLD)
    6940:	2a 85       	ldd	r18, Y+10	; 0x0a
    6942:	3b 85       	ldd	r19, Y+11	; 0x0b
    6944:	8e 85       	ldd	r24, Y+14	; 0x0e
    6946:	9f 85       	ldd	r25, Y+15	; 0x0f
    6948:	82 0f       	add	r24, r18
    694a:	93 1f       	adc	r25, r19
    694c:	8a 38       	cpi	r24, 0x8A	; 138
    694e:	93 41       	sbci	r25, 0x13	; 19
    6950:	14 f7       	brge	.-60     	; 0x6916 <WorkerMotion+0x1c0>
		{
			Cnt++;
			if (Cnt>LINEFOLLOW_THRESHOLD_CNT) break;
		}
		else
		Cnt=0;
    6952:	00 e0       	ldi	r16, 0x00	; 0
    6954:	10 e0       	ldi	r17, 0x00	; 0
    6956:	e4 cf       	rjmp	.-56     	; 0x6920 <WorkerMotion+0x1ca>
					
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
	}
	StopLineFollower();
    6958:	0e 94 a0 33 	call	0x6740	; 0x6740 <StopLineFollower>
	DisableMotorPosTask();
    695c:	0e 94 cf 37 	call	0x6f9e	; 0x6f9e <DisableMotorPosTask>
	DisableMotorSpeedTask();
    6960:	0e 94 8f 38 	call	0x711e	; 0x711e <DisableMotorSpeedTask>
    6964:	06 cf       	rjmp	.-500    	; 0x6772 <WorkerMotion+0x1c>
		{
			CmdDriveSegment(MotionCmd.Params[0]);
		}
		else if (MotionCmd.Cmd==CMD_ROTATE_CENTER)
		{
			CmdRotateCenter(MotionCmd.Params[0],MotionCmd.Params[1]);	
    6966:	4e 80       	ldd	r4, Y+6	; 0x06
    6968:	5f 80       	ldd	r5, Y+7	; 0x07
    696a:	68 84       	ldd	r6, Y+8	; 0x08
    696c:	79 84       	ldd	r7, Y+9	; 0x09
    696e:	8a 80       	ldd	r8, Y+2	; 0x02
    6970:	9b 80       	ldd	r9, Y+3	; 0x03
    6972:	ac 80       	ldd	r10, Y+4	; 0x04
    6974:	bd 80       	ldd	r11, Y+5	; 0x05
	ADCStruct ADCData;
	int Cnt;
		
	float fa;
	
	xLastWakeTime = xTaskGetTickCount();
    6976:	0e 94 ac 28 	call	0x5158	; 0x5158 <xTaskGetTickCount>
    697a:	8a 87       	std	Y+10, r24	; 0x0a
    697c:	9b 87       	std	Y+11, r25	; 0x0b
	EnableMotorPosTask();
    697e:	0e 94 b6 37 	call	0x6f6c	; 0x6f6c <EnableMotorPosTask>
	EnableMotorSpeedTask();
    6982:	0e 94 83 38 	call	0x7106	; 0x7106 <EnableMotorSpeedTask>
	Encoder=DriverMotorGetEncoder();
    6986:	0e 94 5d 07 	call	0xeba	; 0xeba <DriverMotorGetEncoder>
    698a:	6b 01       	movw	r12, r22
    698c:	7c 01       	movw	r14, r24
	fa=WHEEL_DISTANCE*3.14/360*Angle; //Calculate wheel distance to travel
    698e:	26 ec       	ldi	r18, 0xC6	; 198
    6990:	39 ed       	ldi	r19, 0xD9	; 217
    6992:	47 e7       	ldi	r20, 0x77	; 119
    6994:	5f e3       	ldi	r21, 0x3F	; 63
    6996:	c5 01       	movw	r24, r10
    6998:	b4 01       	movw	r22, r8
    699a:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    699e:	4b 01       	movw	r8, r22
    69a0:	5c 01       	movw	r10, r24
	if (fa>0)
    69a2:	20 e0       	ldi	r18, 0x00	; 0
    69a4:	30 e0       	ldi	r19, 0x00	; 0
    69a6:	a9 01       	movw	r20, r18
    69a8:	0e 94 ef 43 	call	0x87de	; 0x87de <__gesf2>
    69ac:	18 16       	cp	r1, r24
    69ae:	0c f0       	brlt	.+2      	; 0x69b2 <WorkerMotion+0x25c>
    69b0:	ab c0       	rjmp	.+342    	; 0x6b08 <WorkerMotion+0x3b2>
	{
		//Fwd
		EncoderTarget.Cnt1=(float) Encoder.Cnt1-MM_TO_CNT(fa);
    69b2:	b6 01       	movw	r22, r12
    69b4:	dd 0c       	add	r13, r13
    69b6:	88 0b       	sbc	r24, r24
    69b8:	99 0b       	sbc	r25, r25
    69ba:	0e 94 3f 43 	call	0x867e	; 0x867e <__floatsisf>
    69be:	6b 01       	movw	r12, r22
    69c0:	7c 01       	movw	r14, r24
    69c2:	2d ec       	ldi	r18, 0xCD	; 205
    69c4:	3c e4       	ldi	r19, 0x4C	; 76
    69c6:	4f e4       	ldi	r20, 0x4F	; 79
    69c8:	53 e4       	ldi	r21, 0x43	; 67
    69ca:	c5 01       	movw	r24, r10
    69cc:	b4 01       	movw	r22, r8
    69ce:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    69d2:	20 e0       	ldi	r18, 0x00	; 0
    69d4:	30 e0       	ldi	r19, 0x00	; 0
    69d6:	44 eb       	ldi	r20, 0xB4	; 180
    69d8:	53 e4       	ldi	r21, 0x43	; 67
    69da:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    69de:	20 e0       	ldi	r18, 0x00	; 0
    69e0:	30 e0       	ldi	r19, 0x00	; 0
    69e2:	40 e4       	ldi	r20, 0x40	; 64
    69e4:	50 e4       	ldi	r21, 0x40	; 64
    69e6:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    69ea:	9b 01       	movw	r18, r22
    69ec:	ac 01       	movw	r20, r24
    69ee:	c7 01       	movw	r24, r14
    69f0:	b6 01       	movw	r22, r12
    69f2:	0e 94 23 42 	call	0x8446	; 0x8446 <__subsf3>
    69f6:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
    69fa:	8b 01       	movw	r16, r22
		MotorSpeedSet(-MM_TO_CNT(Speed),MM_TO_CNT(Speed));
    69fc:	2d ec       	ldi	r18, 0xCD	; 205
    69fe:	3c e4       	ldi	r19, 0x4C	; 76
    6a00:	4f e4       	ldi	r20, 0x4F	; 79
    6a02:	53 e4       	ldi	r21, 0x43	; 67
    6a04:	c3 01       	movw	r24, r6
    6a06:	b2 01       	movw	r22, r4
    6a08:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    6a0c:	20 e0       	ldi	r18, 0x00	; 0
    6a0e:	30 e0       	ldi	r19, 0x00	; 0
    6a10:	44 eb       	ldi	r20, 0xB4	; 180
    6a12:	53 e4       	ldi	r21, 0x43	; 67
    6a14:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    6a18:	20 e0       	ldi	r18, 0x00	; 0
    6a1a:	30 e0       	ldi	r19, 0x00	; 0
    6a1c:	40 e4       	ldi	r20, 0x40	; 64
    6a1e:	50 e4       	ldi	r21, 0x40	; 64
    6a20:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    6a24:	2b 01       	movw	r4, r22
    6a26:	3c 01       	movw	r6, r24
    6a28:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
    6a2c:	6b 01       	movw	r12, r22
    6a2e:	7c 01       	movw	r14, r24
    6a30:	c3 01       	movw	r24, r6
    6a32:	b2 01       	movw	r22, r4
    6a34:	90 58       	subi	r25, 0x80	; 128
    6a36:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
    6a3a:	dc 01       	movw	r26, r24
    6a3c:	cb 01       	movw	r24, r22
    6a3e:	b6 01       	movw	r22, r12
    6a40:	0e 94 95 38 	call	0x712a	; 0x712a <MotorSpeedSet>
    6a44:	0a c0       	rjmp	.+20     	; 0x6a5a <WorkerMotion+0x304>
		Encoder=DriverMotorGetEncoder();
		
		//Stop if target distance is reached
		if (fa>0)
		{//Fwd
			if (Encoder.Cnt1<EncoderTarget.Cnt1) break;
    6a46:	c0 16       	cp	r12, r16
    6a48:	d1 06       	cpc	r13, r17
    6a4a:	0c f4       	brge	.+2      	; 0x6a4e <WorkerMotion+0x2f8>
    6a4c:	25 cf       	rjmp	.-438    	; 0x6898 <WorkerMotion+0x142>
		else
		{//Reverse
			if (Encoder.Cnt1>EncoderTarget.Cnt1) break;
		}
		
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
    6a4e:	6a e0       	ldi	r22, 0x0A	; 10
    6a50:	70 e0       	ldi	r23, 0x00	; 0
    6a52:	ce 01       	movw	r24, r28
    6a54:	0a 96       	adiw	r24, 0x0a	; 10
    6a56:	0e 94 31 2a 	call	0x5462	; 0x5462 <vTaskDelayUntil>
		EncoderTarget.Cnt1=(float) Encoder.Cnt1-MM_TO_CNT(fa);
		MotorSpeedSet(MM_TO_CNT(Speed),-MM_TO_CNT(Speed));
	}
	while (1)
	{
		Encoder=DriverMotorGetEncoder();
    6a5a:	0e 94 5d 07 	call	0xeba	; 0xeba <DriverMotorGetEncoder>
    6a5e:	6b 01       	movw	r12, r22
    6a60:	7c 01       	movw	r14, r24
		
		//Stop if target distance is reached
		if (fa>0)
    6a62:	20 e0       	ldi	r18, 0x00	; 0
    6a64:	30 e0       	ldi	r19, 0x00	; 0
    6a66:	a9 01       	movw	r20, r18
    6a68:	c5 01       	movw	r24, r10
    6a6a:	b4 01       	movw	r22, r8
    6a6c:	0e 94 ef 43 	call	0x87de	; 0x87de <__gesf2>
    6a70:	18 16       	cp	r1, r24
    6a72:	4c f3       	brlt	.-46     	; 0x6a46 <WorkerMotion+0x2f0>
		{//Fwd
			if (Encoder.Cnt1<EncoderTarget.Cnt1) break;
		}
		else
		{//Reverse
			if (Encoder.Cnt1>EncoderTarget.Cnt1) break;
    6a74:	0c 15       	cp	r16, r12
    6a76:	1d 05       	cpc	r17, r13
    6a78:	54 f7       	brge	.-44     	; 0x6a4e <WorkerMotion+0x2f8>
		}
		
		vTaskDelayUntil( &xLastWakeTime, xPeriod );
	}
	DisableMotorPosTask();
    6a7a:	0e 94 cf 37 	call	0x6f9e	; 0x6f9e <DisableMotorPosTask>
	DisableMotorSpeedTask();
    6a7e:	0e 94 8f 38 	call	0x711e	; 0x711e <DisableMotorSpeedTask>
    6a82:	0e cf       	rjmp	.-484    	; 0x68a0 <WorkerMotion+0x14a>
		MotorSpeedSet(MM_TO_CNT(Speed),MM_TO_CNT(Speed));
	}
	else
	{
		//Reverse
		EncoderTarget.Cnt1=Encoder.Cnt1+MM_TO_CNT(Distance);
    6a84:	c5 01       	movw	r24, r10
    6a86:	b4 01       	movw	r22, r8
    6a88:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    6a8c:	20 e0       	ldi	r18, 0x00	; 0
    6a8e:	30 e0       	ldi	r19, 0x00	; 0
    6a90:	44 eb       	ldi	r20, 0xB4	; 180
    6a92:	53 e4       	ldi	r21, 0x43	; 67
    6a94:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    6a98:	20 e0       	ldi	r18, 0x00	; 0
    6a9a:	30 e0       	ldi	r19, 0x00	; 0
    6a9c:	40 e4       	ldi	r20, 0x40	; 64
    6a9e:	50 e4       	ldi	r21, 0x40	; 64
    6aa0:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    6aa4:	6c 8b       	std	Y+20, r22	; 0x14
    6aa6:	7d 8b       	std	Y+21, r23	; 0x15
    6aa8:	8e 8b       	std	Y+22, r24	; 0x16
    6aaa:	9f 8b       	std	Y+23, r25	; 0x17
    6aac:	b6 01       	movw	r22, r12
    6aae:	dd 0c       	add	r13, r13
    6ab0:	88 0b       	sbc	r24, r24
    6ab2:	99 0b       	sbc	r25, r25
    6ab4:	0e 94 3f 43 	call	0x867e	; 0x867e <__floatsisf>
    6ab8:	9b 01       	movw	r18, r22
    6aba:	ac 01       	movw	r20, r24
    6abc:	6c 89       	ldd	r22, Y+20	; 0x14
    6abe:	7d 89       	ldd	r23, Y+21	; 0x15
    6ac0:	8e 89       	ldd	r24, Y+22	; 0x16
    6ac2:	9f 89       	ldd	r25, Y+23	; 0x17
    6ac4:	0e 94 24 42 	call	0x8448	; 0x8448 <__addsf3>
    6ac8:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
    6acc:	8b 01       	movw	r16, r22
		MotorSpeedSet(-MM_TO_CNT(Speed),-MM_TO_CNT(Speed));
    6ace:	2d ec       	ldi	r18, 0xCD	; 205
    6ad0:	3c e4       	ldi	r19, 0x4C	; 76
    6ad2:	4f e4       	ldi	r20, 0x4F	; 79
    6ad4:	53 e4       	ldi	r21, 0x43	; 67
    6ad6:	c3 01       	movw	r24, r6
    6ad8:	b2 01       	movw	r22, r4
    6ada:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    6ade:	20 e0       	ldi	r18, 0x00	; 0
    6ae0:	30 e0       	ldi	r19, 0x00	; 0
    6ae2:	44 eb       	ldi	r20, 0xB4	; 180
    6ae4:	53 e4       	ldi	r21, 0x43	; 67
    6ae6:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    6aea:	20 e0       	ldi	r18, 0x00	; 0
    6aec:	30 e0       	ldi	r19, 0x00	; 0
    6aee:	40 e4       	ldi	r20, 0x40	; 64
    6af0:	50 e4       	ldi	r21, 0x40	; 64
    6af2:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    6af6:	90 58       	subi	r25, 0x80	; 128
    6af8:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
    6afc:	dc 01       	movw	r26, r24
    6afe:	cb 01       	movw	r24, r22
    6b00:	bc 01       	movw	r22, r24
    6b02:	0e 94 95 38 	call	0x712a	; 0x712a <MotorSpeedSet>
    6b06:	b8 ce       	rjmp	.-656    	; 0x6878 <WorkerMotion+0x122>
		MotorSpeedSet(-MM_TO_CNT(Speed),MM_TO_CNT(Speed));
	}
	else
	{
		//Reverse
		EncoderTarget.Cnt1=(float) Encoder.Cnt1-MM_TO_CNT(fa);
    6b08:	b6 01       	movw	r22, r12
    6b0a:	dd 0c       	add	r13, r13
    6b0c:	88 0b       	sbc	r24, r24
    6b0e:	99 0b       	sbc	r25, r25
    6b10:	0e 94 3f 43 	call	0x867e	; 0x867e <__floatsisf>
    6b14:	6b 01       	movw	r12, r22
    6b16:	7c 01       	movw	r14, r24
    6b18:	2d ec       	ldi	r18, 0xCD	; 205
    6b1a:	3c e4       	ldi	r19, 0x4C	; 76
    6b1c:	4f e4       	ldi	r20, 0x4F	; 79
    6b1e:	53 e4       	ldi	r21, 0x43	; 67
    6b20:	c5 01       	movw	r24, r10
    6b22:	b4 01       	movw	r22, r8
    6b24:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    6b28:	20 e0       	ldi	r18, 0x00	; 0
    6b2a:	30 e0       	ldi	r19, 0x00	; 0
    6b2c:	44 eb       	ldi	r20, 0xB4	; 180
    6b2e:	53 e4       	ldi	r21, 0x43	; 67
    6b30:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    6b34:	20 e0       	ldi	r18, 0x00	; 0
    6b36:	30 e0       	ldi	r19, 0x00	; 0
    6b38:	40 e4       	ldi	r20, 0x40	; 64
    6b3a:	50 e4       	ldi	r21, 0x40	; 64
    6b3c:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    6b40:	9b 01       	movw	r18, r22
    6b42:	ac 01       	movw	r20, r24
    6b44:	c7 01       	movw	r24, r14
    6b46:	b6 01       	movw	r22, r12
    6b48:	0e 94 23 42 	call	0x8446	; 0x8446 <__subsf3>
    6b4c:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
    6b50:	8b 01       	movw	r16, r22
		MotorSpeedSet(MM_TO_CNT(Speed),-MM_TO_CNT(Speed));
    6b52:	2d ec       	ldi	r18, 0xCD	; 205
    6b54:	3c e4       	ldi	r19, 0x4C	; 76
    6b56:	4f e4       	ldi	r20, 0x4F	; 79
    6b58:	53 e4       	ldi	r21, 0x43	; 67
    6b5a:	c3 01       	movw	r24, r6
    6b5c:	b2 01       	movw	r22, r4
    6b5e:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    6b62:	20 e0       	ldi	r18, 0x00	; 0
    6b64:	30 e0       	ldi	r19, 0x00	; 0
    6b66:	44 eb       	ldi	r20, 0xB4	; 180
    6b68:	53 e4       	ldi	r21, 0x43	; 67
    6b6a:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    6b6e:	20 e0       	ldi	r18, 0x00	; 0
    6b70:	30 e0       	ldi	r19, 0x00	; 0
    6b72:	40 e4       	ldi	r20, 0x40	; 64
    6b74:	50 e4       	ldi	r21, 0x40	; 64
    6b76:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    6b7a:	2b 01       	movw	r4, r22
    6b7c:	3c 01       	movw	r6, r24
    6b7e:	90 58       	subi	r25, 0x80	; 128
    6b80:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
    6b84:	6b 01       	movw	r12, r22
    6b86:	7c 01       	movw	r14, r24
    6b88:	c3 01       	movw	r24, r6
    6b8a:	b2 01       	movw	r22, r4
    6b8c:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
    6b90:	dc 01       	movw	r26, r24
    6b92:	cb 01       	movw	r24, r22
    6b94:	b6 01       	movw	r22, r12
    6b96:	0e 94 95 38 	call	0x712a	; 0x712a <MotorSpeedSet>
    6b9a:	5f cf       	rjmp	.-322    	; 0x6a5a <WorkerMotion+0x304>

00006b9c <InitMotionTask>:
static void CmdDriveStraight(float Distance, float Speed);
static void CmdDriveSegment(float Speed);

//Function definitions
void InitMotionTask()
{
    6b9c:	ef 92       	push	r14
    6b9e:	ff 92       	push	r15
    6ba0:	0f 93       	push	r16
	xTaskCreate( WorkerMotion, "motion", 256, NULL, tskIDLE_PRIORITY+3, NULL );	
    6ba2:	e1 2c       	mov	r14, r1
    6ba4:	f1 2c       	mov	r15, r1
    6ba6:	03 e0       	ldi	r16, 0x03	; 3
    6ba8:	20 e0       	ldi	r18, 0x00	; 0
    6baa:	30 e0       	ldi	r19, 0x00	; 0
    6bac:	40 e0       	ldi	r20, 0x00	; 0
    6bae:	51 e0       	ldi	r21, 0x01	; 1
    6bb0:	68 e1       	ldi	r22, 0x18	; 24
    6bb2:	76 e2       	ldi	r23, 0x26	; 38
    6bb4:	8b ea       	ldi	r24, 0xAB	; 171
    6bb6:	93 e3       	ldi	r25, 0x33	; 51
    6bb8:	0e 94 20 26 	call	0x4c40	; 0x4c40 <xTaskCreate>
	CmdQueue=xQueueCreate(1,sizeof(MotionCmdStruct));
    6bbc:	40 e0       	ldi	r20, 0x00	; 0
    6bbe:	69 e0       	ldi	r22, 0x09	; 9
    6bc0:	81 e0       	ldi	r24, 0x01	; 1
    6bc2:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <xQueueGenericCreate>
    6bc6:	80 93 5d 2d 	sts	0x2D5D, r24	; 0x802d5d <CmdQueue>
    6bca:	90 93 5e 2d 	sts	0x2D5E, r25	; 0x802d5e <CmdQueue+0x1>
	CmdCompleteSema=xSemaphoreCreateBinary();
    6bce:	43 e0       	ldi	r20, 0x03	; 3
    6bd0:	60 e0       	ldi	r22, 0x00	; 0
    6bd2:	81 e0       	ldi	r24, 0x01	; 1
    6bd4:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <xQueueGenericCreate>
    6bd8:	80 93 5b 2d 	sts	0x2D5B, r24	; 0x802d5b <CmdCompleteSema>
    6bdc:	90 93 5c 2d 	sts	0x2D5C, r25	; 0x802d5c <CmdCompleteSema+0x1>
}
    6be0:	0f 91       	pop	r16
    6be2:	ff 90       	pop	r15
    6be4:	ef 90       	pop	r14
    6be6:	08 95       	ret

00006be8 <DriveStraight>:
		
	}
}

void DriveStraight(float Distance, float Speed)
{
    6be8:	cf 93       	push	r28
    6bea:	df 93       	push	r29
    6bec:	cd b7       	in	r28, 0x3d	; 61
    6bee:	de b7       	in	r29, 0x3e	; 62
    6bf0:	29 97       	sbiw	r28, 0x09	; 9
    6bf2:	cd bf       	out	0x3d, r28	; 61
    6bf4:	de bf       	out	0x3e, r29	; 62
	MotionCmdStruct MotionCmd;
	MotionCmd.Cmd=CMD_DRIVE_STRAIGHT;
    6bf6:	e1 e0       	ldi	r30, 0x01	; 1
    6bf8:	e9 83       	std	Y+1, r30	; 0x01
	MotionCmd.Params[0]=Distance;
    6bfa:	6a 83       	std	Y+2, r22	; 0x02
    6bfc:	7b 83       	std	Y+3, r23	; 0x03
    6bfe:	8c 83       	std	Y+4, r24	; 0x04
    6c00:	9d 83       	std	Y+5, r25	; 0x05
	MotionCmd.Params[1]=Speed;
    6c02:	2e 83       	std	Y+6, r18	; 0x06
    6c04:	3f 83       	std	Y+7, r19	; 0x07
    6c06:	48 87       	std	Y+8, r20	; 0x08
    6c08:	59 87       	std	Y+9, r21	; 0x09
	xQueueSendToBack(CmdQueue,&MotionCmd,portMAX_DELAY);	//Issue command
    6c0a:	20 e0       	ldi	r18, 0x00	; 0
    6c0c:	4f ef       	ldi	r20, 0xFF	; 255
    6c0e:	5f ef       	ldi	r21, 0xFF	; 255
    6c10:	be 01       	movw	r22, r28
    6c12:	6f 5f       	subi	r22, 0xFF	; 255
    6c14:	7f 4f       	sbci	r23, 0xFF	; 255
    6c16:	80 91 5d 2d 	lds	r24, 0x2D5D	; 0x802d5d <CmdQueue>
    6c1a:	90 91 5e 2d 	lds	r25, 0x2D5E	; 0x802d5e <CmdQueue+0x1>
    6c1e:	0e 94 27 20 	call	0x404e	; 0x404e <xQueueGenericSend>
	xSemaphoreTake(CmdCompleteSema,portMAX_DELAY);			//Block until command has been executed
    6c22:	6f ef       	ldi	r22, 0xFF	; 255
    6c24:	7f ef       	ldi	r23, 0xFF	; 255
    6c26:	80 91 5b 2d 	lds	r24, 0x2D5B	; 0x802d5b <CmdCompleteSema>
    6c2a:	90 91 5c 2d 	lds	r25, 0x2D5C	; 0x802d5c <CmdCompleteSema+0x1>
    6c2e:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <xQueueSemaphoreTake>
}
    6c32:	29 96       	adiw	r28, 0x09	; 9
    6c34:	cd bf       	out	0x3d, r28	; 61
    6c36:	de bf       	out	0x3e, r29	; 62
    6c38:	df 91       	pop	r29
    6c3a:	cf 91       	pop	r28
    6c3c:	08 95       	ret

00006c3e <DriveSegment>:
void DriveSegment(float Speed)
{
    6c3e:	cf 93       	push	r28
    6c40:	df 93       	push	r29
    6c42:	cd b7       	in	r28, 0x3d	; 61
    6c44:	de b7       	in	r29, 0x3e	; 62
    6c46:	29 97       	sbiw	r28, 0x09	; 9
    6c48:	cd bf       	out	0x3d, r28	; 61
    6c4a:	de bf       	out	0x3e, r29	; 62
	MotionCmdStruct MotionCmd;
	MotionCmd.Cmd=CMD_DRIVE_SEGMENT;
    6c4c:	22 e0       	ldi	r18, 0x02	; 2
    6c4e:	29 83       	std	Y+1, r18	; 0x01
	MotionCmd.Params[0]=Speed;
    6c50:	6a 83       	std	Y+2, r22	; 0x02
    6c52:	7b 83       	std	Y+3, r23	; 0x03
    6c54:	8c 83       	std	Y+4, r24	; 0x04
    6c56:	9d 83       	std	Y+5, r25	; 0x05
	xQueueSendToBack(CmdQueue,&MotionCmd,portMAX_DELAY);	//Issue command
    6c58:	20 e0       	ldi	r18, 0x00	; 0
    6c5a:	4f ef       	ldi	r20, 0xFF	; 255
    6c5c:	5f ef       	ldi	r21, 0xFF	; 255
    6c5e:	be 01       	movw	r22, r28
    6c60:	6f 5f       	subi	r22, 0xFF	; 255
    6c62:	7f 4f       	sbci	r23, 0xFF	; 255
    6c64:	80 91 5d 2d 	lds	r24, 0x2D5D	; 0x802d5d <CmdQueue>
    6c68:	90 91 5e 2d 	lds	r25, 0x2D5E	; 0x802d5e <CmdQueue+0x1>
    6c6c:	0e 94 27 20 	call	0x404e	; 0x404e <xQueueGenericSend>
	xSemaphoreTake(CmdCompleteSema,portMAX_DELAY);			//Block until command has been executed
    6c70:	6f ef       	ldi	r22, 0xFF	; 255
    6c72:	7f ef       	ldi	r23, 0xFF	; 255
    6c74:	80 91 5b 2d 	lds	r24, 0x2D5B	; 0x802d5b <CmdCompleteSema>
    6c78:	90 91 5c 2d 	lds	r25, 0x2D5C	; 0x802d5c <CmdCompleteSema+0x1>
    6c7c:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <xQueueSemaphoreTake>
}
    6c80:	29 96       	adiw	r28, 0x09	; 9
    6c82:	cd bf       	out	0x3d, r28	; 61
    6c84:	de bf       	out	0x3e, r29	; 62
    6c86:	df 91       	pop	r29
    6c88:	cf 91       	pop	r28
    6c8a:	08 95       	ret

00006c8c <RotateCenter>:
void RotateCenter(float Angle, float Speed)
{
    6c8c:	cf 93       	push	r28
    6c8e:	df 93       	push	r29
    6c90:	cd b7       	in	r28, 0x3d	; 61
    6c92:	de b7       	in	r29, 0x3e	; 62
    6c94:	29 97       	sbiw	r28, 0x09	; 9
    6c96:	cd bf       	out	0x3d, r28	; 61
    6c98:	de bf       	out	0x3e, r29	; 62
	MotionCmdStruct MotionCmd;
	MotionCmd.Cmd=CMD_ROTATE_CENTER;
    6c9a:	e3 e0       	ldi	r30, 0x03	; 3
    6c9c:	e9 83       	std	Y+1, r30	; 0x01
	MotionCmd.Params[0]=Angle;
    6c9e:	6a 83       	std	Y+2, r22	; 0x02
    6ca0:	7b 83       	std	Y+3, r23	; 0x03
    6ca2:	8c 83       	std	Y+4, r24	; 0x04
    6ca4:	9d 83       	std	Y+5, r25	; 0x05
	MotionCmd.Params[1]=Speed;
    6ca6:	2e 83       	std	Y+6, r18	; 0x06
    6ca8:	3f 83       	std	Y+7, r19	; 0x07
    6caa:	48 87       	std	Y+8, r20	; 0x08
    6cac:	59 87       	std	Y+9, r21	; 0x09
	xQueueSendToBack(CmdQueue,&MotionCmd,portMAX_DELAY);	//Issue command
    6cae:	20 e0       	ldi	r18, 0x00	; 0
    6cb0:	4f ef       	ldi	r20, 0xFF	; 255
    6cb2:	5f ef       	ldi	r21, 0xFF	; 255
    6cb4:	be 01       	movw	r22, r28
    6cb6:	6f 5f       	subi	r22, 0xFF	; 255
    6cb8:	7f 4f       	sbci	r23, 0xFF	; 255
    6cba:	80 91 5d 2d 	lds	r24, 0x2D5D	; 0x802d5d <CmdQueue>
    6cbe:	90 91 5e 2d 	lds	r25, 0x2D5E	; 0x802d5e <CmdQueue+0x1>
    6cc2:	0e 94 27 20 	call	0x404e	; 0x404e <xQueueGenericSend>
	xSemaphoreTake(CmdCompleteSema,portMAX_DELAY);			//Block until command has been executed
    6cc6:	6f ef       	ldi	r22, 0xFF	; 255
    6cc8:	7f ef       	ldi	r23, 0xFF	; 255
    6cca:	80 91 5b 2d 	lds	r24, 0x2D5B	; 0x802d5b <CmdCompleteSema>
    6cce:	90 91 5c 2d 	lds	r25, 0x2D5C	; 0x802d5c <CmdCompleteSema+0x1>
    6cd2:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <xQueueSemaphoreTake>
    6cd6:	29 96       	adiw	r28, 0x09	; 9
    6cd8:	cd bf       	out	0x3d, r28	; 61
    6cda:	de bf       	out	0x3e, r29	; 62
    6cdc:	df 91       	pop	r29
    6cde:	cf 91       	pop	r28
    6ce0:	08 95       	ret

00006ce2 <WorkerMotorPos>:
	IncSet.IncSet2=IncSet2;
	xQueueSend(IncSetQueue,&IncSet,portMAX_DELAY);
}

void WorkerMotorPos(void *pvParameters)
{
    6ce2:	cf 93       	push	r28
    6ce4:	df 93       	push	r29
    6ce6:	cd b7       	in	r28, 0x3d	; 61
    6ce8:	de b7       	in	r29, 0x3e	; 62
    6cea:	2c 97       	sbiw	r28, 0x0c	; 12
    6cec:	cd bf       	out	0x3d, r28	; 61
    6cee:	de bf       	out	0x3e, r29	; 62
	float Err1=0,Err2=0;
	
	IncSetStruct IncSet;
	EncoderStruct EncoderInfo;
	
	xLastWakeTime = xTaskGetTickCount();
    6cf0:	0e 94 ac 28 	call	0x5158	; 0x5158 <xTaskGetTickCount>
    6cf4:	80 93 5f 2d 	sts	0x2D5F, r24	; 0x802d5f <xLastWakeTime>
    6cf8:	90 93 60 2d 	sts	0x2D60, r25	; 0x802d60 <xLastWakeTime+0x1>
void WorkerMotorPos(void *pvParameters)
{
	
	const TickType_t xPeriod = 10;
	
	float Set1=0,Set2=0;
    6cfc:	19 86       	std	Y+9, r1	; 0x09
    6cfe:	1a 86       	std	Y+10, r1	; 0x0a
    6d00:	1b 86       	std	Y+11, r1	; 0x0b
    6d02:	1c 86       	std	Y+12, r1	; 0x0c
    6d04:	1d 82       	std	Y+5, r1	; 0x05
    6d06:	1e 82       	std	Y+6, r1	; 0x06
    6d08:	1f 82       	std	Y+7, r1	; 0x07
    6d0a:	18 86       	std	Y+8, r1	; 0x08
    6d0c:	77 c0       	rjmp	.+238    	; 0x6dfc <WorkerMotorPos+0x11a>
			//PID 1
			Err1=Set1-EncoderInfo.Cnt1;
			Out1=Err1*MOTPOS_KP;
			if (Out1>0) Out1+=MOTPOS_FF_OFFSET;
			if (Out1>4095) Out1=4095;
			if (Out1<0) Out1-=MOTPOS_FF_OFFSET;			
    6d0e:	20 e0       	ldi	r18, 0x00	; 0
    6d10:	30 e0       	ldi	r19, 0x00	; 0
    6d12:	a9 01       	movw	r20, r18
    6d14:	c7 01       	movw	r24, r14
    6d16:	b6 01       	movw	r22, r12
    6d18:	0e 94 90 42 	call	0x8520	; 0x8520 <__cmpsf2>
    6d1c:	87 ff       	sbrs	r24, 7
    6d1e:	0a c0       	rjmp	.+20     	; 0x6d34 <WorkerMotorPos+0x52>
    6d20:	20 e0       	ldi	r18, 0x00	; 0
    6d22:	30 e8       	ldi	r19, 0x80	; 128
    6d24:	4b eb       	ldi	r20, 0xBB	; 187
    6d26:	54 e4       	ldi	r21, 0x44	; 68
    6d28:	c7 01       	movw	r24, r14
    6d2a:	b6 01       	movw	r22, r12
    6d2c:	0e 94 23 42 	call	0x8446	; 0x8446 <__subsf3>
    6d30:	6b 01       	movw	r12, r22
    6d32:	7c 01       	movw	r14, r24
			if (Out1<-4095) Out1=-4095;
    6d34:	20 e0       	ldi	r18, 0x00	; 0
    6d36:	30 ef       	ldi	r19, 0xF0	; 240
    6d38:	4f e7       	ldi	r20, 0x7F	; 127
    6d3a:	55 ec       	ldi	r21, 0xC5	; 197
    6d3c:	c7 01       	movw	r24, r14
    6d3e:	b6 01       	movw	r22, r12
    6d40:	0e 94 90 42 	call	0x8520	; 0x8520 <__cmpsf2>
    6d44:	87 ff       	sbrs	r24, 7
    6d46:	b6 c0       	rjmp	.+364    	; 0x6eb4 <WorkerMotorPos+0x1d2>
    6d48:	01 e0       	ldi	r16, 0x01	; 1
    6d4a:	10 ef       	ldi	r17, 0xF0	; 240

			//PID 2
			Err2=Set2-EncoderInfo.Cnt2;
			Out2=Err2*MOTPOS_KP;
    6d4c:	c5 01       	movw	r24, r10
    6d4e:	b4 01       	movw	r22, r8
    6d50:	0e 94 3f 43 	call	0x867e	; 0x867e <__floatsisf>
    6d54:	9b 01       	movw	r18, r22
    6d56:	ac 01       	movw	r20, r24
    6d58:	69 85       	ldd	r22, Y+9	; 0x09
    6d5a:	7a 85       	ldd	r23, Y+10	; 0x0a
    6d5c:	8b 85       	ldd	r24, Y+11	; 0x0b
    6d5e:	9c 85       	ldd	r25, Y+12	; 0x0c
    6d60:	0e 94 23 42 	call	0x8446	; 0x8446 <__subsf3>
    6d64:	20 e0       	ldi	r18, 0x00	; 0
    6d66:	30 e0       	ldi	r19, 0x00	; 0
    6d68:	46 e9       	ldi	r20, 0x96	; 150
    6d6a:	53 e4       	ldi	r21, 0x43	; 67
    6d6c:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    6d70:	6b 01       	movw	r12, r22
    6d72:	7c 01       	movw	r14, r24
			if (Out2>0) Out2+=MOTPOS_FF_OFFSET;
    6d74:	20 e0       	ldi	r18, 0x00	; 0
    6d76:	30 e0       	ldi	r19, 0x00	; 0
    6d78:	a9 01       	movw	r20, r18
    6d7a:	0e 94 ef 43 	call	0x87de	; 0x87de <__gesf2>
    6d7e:	18 16       	cp	r1, r24
    6d80:	54 f4       	brge	.+20     	; 0x6d96 <WorkerMotorPos+0xb4>
    6d82:	20 e0       	ldi	r18, 0x00	; 0
    6d84:	30 e8       	ldi	r19, 0x80	; 128
    6d86:	4b eb       	ldi	r20, 0xBB	; 187
    6d88:	54 e4       	ldi	r21, 0x44	; 68
    6d8a:	c7 01       	movw	r24, r14
    6d8c:	b6 01       	movw	r22, r12
    6d8e:	0e 94 24 42 	call	0x8448	; 0x8448 <__addsf3>
    6d92:	6b 01       	movw	r12, r22
    6d94:	7c 01       	movw	r14, r24
			if (Out2>4095) Out2=4095;
    6d96:	20 e0       	ldi	r18, 0x00	; 0
    6d98:	30 ef       	ldi	r19, 0xF0	; 240
    6d9a:	4f e7       	ldi	r20, 0x7F	; 127
    6d9c:	55 e4       	ldi	r21, 0x45	; 69
    6d9e:	c7 01       	movw	r24, r14
    6da0:	b6 01       	movw	r22, r12
    6da2:	0e 94 ef 43 	call	0x87de	; 0x87de <__gesf2>
    6da6:	18 16       	cp	r1, r24
    6da8:	0c f4       	brge	.+2      	; 0x6dac <WorkerMotorPos+0xca>
    6daa:	8a c0       	rjmp	.+276    	; 0x6ec0 <WorkerMotorPos+0x1de>
			if (Out2<0) Out2-=MOTPOS_FF_OFFSET;
    6dac:	20 e0       	ldi	r18, 0x00	; 0
    6dae:	30 e0       	ldi	r19, 0x00	; 0
    6db0:	a9 01       	movw	r20, r18
    6db2:	c7 01       	movw	r24, r14
    6db4:	b6 01       	movw	r22, r12
    6db6:	0e 94 90 42 	call	0x8520	; 0x8520 <__cmpsf2>
    6dba:	87 ff       	sbrs	r24, 7
    6dbc:	0a c0       	rjmp	.+20     	; 0x6dd2 <WorkerMotorPos+0xf0>
    6dbe:	20 e0       	ldi	r18, 0x00	; 0
    6dc0:	30 e8       	ldi	r19, 0x80	; 128
    6dc2:	4b eb       	ldi	r20, 0xBB	; 187
    6dc4:	54 e4       	ldi	r21, 0x44	; 68
    6dc6:	c7 01       	movw	r24, r14
    6dc8:	b6 01       	movw	r22, r12
    6dca:	0e 94 23 42 	call	0x8446	; 0x8446 <__subsf3>
    6dce:	6b 01       	movw	r12, r22
    6dd0:	7c 01       	movw	r14, r24
			if (Out2<-4095) Out2=-4095;
    6dd2:	20 e0       	ldi	r18, 0x00	; 0
    6dd4:	30 ef       	ldi	r19, 0xF0	; 240
    6dd6:	4f e7       	ldi	r20, 0x7F	; 127
    6dd8:	55 ec       	ldi	r21, 0xC5	; 197
    6dda:	c7 01       	movw	r24, r14
    6ddc:	b6 01       	movw	r22, r12
    6dde:	0e 94 90 42 	call	0x8520	; 0x8520 <__cmpsf2>
    6de2:	87 ff       	sbrs	r24, 7
    6de4:	74 c0       	rjmp	.+232    	; 0x6ece <WorkerMotorPos+0x1ec>
    6de6:	61 e0       	ldi	r22, 0x01	; 1
    6de8:	70 ef       	ldi	r23, 0xF0	; 240
			
			//printf ("Err:%f   Out:%f\r\n",Err2 ,Out2);			
			
			DriverMotorSet(Out1,Out2);
    6dea:	c8 01       	movw	r24, r16
    6dec:	0e 94 f2 06 	call	0xde4	; 0xde4 <DriverMotorSet>
			
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
    6df0:	6a e0       	ldi	r22, 0x0A	; 10
    6df2:	70 e0       	ldi	r23, 0x00	; 0
    6df4:	8f e5       	ldi	r24, 0x5F	; 95
    6df6:	9d e2       	ldi	r25, 0x2D	; 45
    6df8:	0e 94 31 2a 	call	0x5462	; 0x5462 <vTaskDelayUntil>
	
	xLastWakeTime = xTaskGetTickCount();
	
	while (1)
	{		
			EncoderInfo=DriverMotorGetEncoder();
    6dfc:	0e 94 5d 07 	call	0xeba	; 0xeba <DriverMotorGetEncoder>
    6e00:	6b 01       	movw	r12, r22
    6e02:	7c 01       	movw	r14, r24

			//Process reset setpoint command
			if (xSemaphoreTake(ResetSetpointSema,0)==pdPASS)
    6e04:	60 e0       	ldi	r22, 0x00	; 0
    6e06:	70 e0       	ldi	r23, 0x00	; 0
    6e08:	80 91 65 2d 	lds	r24, 0x2D65	; 0x802d65 <ResetSetpointSema>
    6e0c:	90 91 66 2d 	lds	r25, 0x2D66	; 0x802d66 <ResetSetpointSema+0x1>
    6e10:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <xQueueSemaphoreTake>
			{
				Set1=EncoderInfo.Cnt1;
    6e14:	26 01       	movw	r4, r12
    6e16:	dd 0c       	add	r13, r13
    6e18:	66 08       	sbc	r6, r6
    6e1a:	77 08       	sbc	r7, r7
	while (1)
	{		
			EncoderInfo=DriverMotorGetEncoder();

			//Process reset setpoint command
			if (xSemaphoreTake(ResetSetpointSema,0)==pdPASS)
    6e1c:	81 30       	cpi	r24, 0x01	; 1
    6e1e:	09 f4       	brne	.+2      	; 0x6e22 <WorkerMotorPos+0x140>
    6e20:	90 c0       	rjmp	.+288    	; 0x6f42 <WorkerMotorPos+0x260>
    6e22:	47 01       	movw	r8, r14
    6e24:	ff 0c       	add	r15, r15
    6e26:	aa 08       	sbc	r10, r10
    6e28:	bb 08       	sbc	r11, r11
				Set1=EncoderInfo.Cnt1;
				Set2=EncoderInfo.Cnt2;
			}
			
			//Process setpoint increment data
			if (xQueueReceive(IncSetQueue,&IncSet,0)==pdPASS)
    6e2a:	40 e0       	ldi	r20, 0x00	; 0
    6e2c:	50 e0       	ldi	r21, 0x00	; 0
    6e2e:	be 01       	movw	r22, r28
    6e30:	6f 5f       	subi	r22, 0xFF	; 255
    6e32:	7f 4f       	sbci	r23, 0xFF	; 255
    6e34:	80 91 63 2d 	lds	r24, 0x2D63	; 0x802d63 <IncSetQueue>
    6e38:	90 91 64 2d 	lds	r25, 0x2D64	; 0x802d64 <IncSetQueue+0x1>
    6e3c:	0e 94 be 21 	call	0x437c	; 0x437c <xQueueReceive>
    6e40:	81 30       	cpi	r24, 0x01	; 1
    6e42:	09 f4       	brne	.+2      	; 0x6e46 <WorkerMotorPos+0x164>
    6e44:	49 c0       	rjmp	.+146    	; 0x6ed8 <WorkerMotorPos+0x1f6>
				Set2+=((float) IncSet.IncSet2)/100;
			}
			
			//PID 1
			Err1=Set1-EncoderInfo.Cnt1;
			Out1=Err1*MOTPOS_KP;
    6e46:	c3 01       	movw	r24, r6
    6e48:	b2 01       	movw	r22, r4
    6e4a:	0e 94 3f 43 	call	0x867e	; 0x867e <__floatsisf>
    6e4e:	9b 01       	movw	r18, r22
    6e50:	ac 01       	movw	r20, r24
    6e52:	6d 81       	ldd	r22, Y+5	; 0x05
    6e54:	7e 81       	ldd	r23, Y+6	; 0x06
    6e56:	8f 81       	ldd	r24, Y+7	; 0x07
    6e58:	98 85       	ldd	r25, Y+8	; 0x08
    6e5a:	0e 94 23 42 	call	0x8446	; 0x8446 <__subsf3>
    6e5e:	20 e0       	ldi	r18, 0x00	; 0
    6e60:	30 e0       	ldi	r19, 0x00	; 0
    6e62:	46 e9       	ldi	r20, 0x96	; 150
    6e64:	53 e4       	ldi	r21, 0x43	; 67
    6e66:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    6e6a:	6b 01       	movw	r12, r22
    6e6c:	7c 01       	movw	r14, r24
			if (Out1>0) Out1+=MOTPOS_FF_OFFSET;
    6e6e:	20 e0       	ldi	r18, 0x00	; 0
    6e70:	30 e0       	ldi	r19, 0x00	; 0
    6e72:	a9 01       	movw	r20, r18
    6e74:	0e 94 ef 43 	call	0x87de	; 0x87de <__gesf2>
    6e78:	18 16       	cp	r1, r24
    6e7a:	54 f4       	brge	.+20     	; 0x6e90 <WorkerMotorPos+0x1ae>
    6e7c:	20 e0       	ldi	r18, 0x00	; 0
    6e7e:	30 e8       	ldi	r19, 0x80	; 128
    6e80:	4b eb       	ldi	r20, 0xBB	; 187
    6e82:	54 e4       	ldi	r21, 0x44	; 68
    6e84:	c7 01       	movw	r24, r14
    6e86:	b6 01       	movw	r22, r12
    6e88:	0e 94 24 42 	call	0x8448	; 0x8448 <__addsf3>
    6e8c:	6b 01       	movw	r12, r22
    6e8e:	7c 01       	movw	r14, r24
			if (Out1>4095) Out1=4095;
    6e90:	20 e0       	ldi	r18, 0x00	; 0
    6e92:	30 ef       	ldi	r19, 0xF0	; 240
    6e94:	4f e7       	ldi	r20, 0x7F	; 127
    6e96:	55 e4       	ldi	r21, 0x45	; 69
    6e98:	c7 01       	movw	r24, r14
    6e9a:	b6 01       	movw	r22, r12
    6e9c:	0e 94 ef 43 	call	0x87de	; 0x87de <__gesf2>
    6ea0:	18 16       	cp	r1, r24
    6ea2:	0c f0       	brlt	.+2      	; 0x6ea6 <WorkerMotorPos+0x1c4>
    6ea4:	34 cf       	rjmp	.-408    	; 0x6d0e <WorkerMotorPos+0x2c>
    6ea6:	c1 2c       	mov	r12, r1
    6ea8:	90 ef       	ldi	r25, 0xF0	; 240
    6eaa:	d9 2e       	mov	r13, r25
    6eac:	9f e7       	ldi	r25, 0x7F	; 127
    6eae:	e9 2e       	mov	r14, r25
    6eb0:	95 e4       	ldi	r25, 0x45	; 69
    6eb2:	f9 2e       	mov	r15, r25
    6eb4:	c7 01       	movw	r24, r14
    6eb6:	b6 01       	movw	r22, r12
    6eb8:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
    6ebc:	8b 01       	movw	r16, r22
    6ebe:	46 cf       	rjmp	.-372    	; 0x6d4c <WorkerMotorPos+0x6a>

			//PID 2
			Err2=Set2-EncoderInfo.Cnt2;
			Out2=Err2*MOTPOS_KP;
			if (Out2>0) Out2+=MOTPOS_FF_OFFSET;
			if (Out2>4095) Out2=4095;
    6ec0:	c1 2c       	mov	r12, r1
    6ec2:	80 ef       	ldi	r24, 0xF0	; 240
    6ec4:	d8 2e       	mov	r13, r24
    6ec6:	8f e7       	ldi	r24, 0x7F	; 127
    6ec8:	e8 2e       	mov	r14, r24
    6eca:	85 e4       	ldi	r24, 0x45	; 69
    6ecc:	f8 2e       	mov	r15, r24
    6ece:	c7 01       	movw	r24, r14
    6ed0:	b6 01       	movw	r22, r12
    6ed2:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
    6ed6:	89 cf       	rjmp	.-238    	; 0x6dea <WorkerMotorPos+0x108>
			}
			
			//Process setpoint increment data
			if (xQueueReceive(IncSetQueue,&IncSet,0)==pdPASS)
			{
				Set1+=((float) IncSet.IncSet1)/100;
    6ed8:	69 81       	ldd	r22, Y+1	; 0x01
    6eda:	7a 81       	ldd	r23, Y+2	; 0x02
    6edc:	07 2e       	mov	r0, r23
    6ede:	00 0c       	add	r0, r0
    6ee0:	88 0b       	sbc	r24, r24
    6ee2:	99 0b       	sbc	r25, r25
    6ee4:	0e 94 3f 43 	call	0x867e	; 0x867e <__floatsisf>
    6ee8:	20 e0       	ldi	r18, 0x00	; 0
    6eea:	30 e0       	ldi	r19, 0x00	; 0
    6eec:	48 ec       	ldi	r20, 0xC8	; 200
    6eee:	52 e4       	ldi	r21, 0x42	; 66
    6ef0:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    6ef4:	9b 01       	movw	r18, r22
    6ef6:	ac 01       	movw	r20, r24
    6ef8:	6d 81       	ldd	r22, Y+5	; 0x05
    6efa:	7e 81       	ldd	r23, Y+6	; 0x06
    6efc:	8f 81       	ldd	r24, Y+7	; 0x07
    6efe:	98 85       	ldd	r25, Y+8	; 0x08
    6f00:	0e 94 24 42 	call	0x8448	; 0x8448 <__addsf3>
    6f04:	6d 83       	std	Y+5, r22	; 0x05
    6f06:	7e 83       	std	Y+6, r23	; 0x06
    6f08:	8f 83       	std	Y+7, r24	; 0x07
    6f0a:	98 87       	std	Y+8, r25	; 0x08
				Set2+=((float) IncSet.IncSet2)/100;
    6f0c:	6b 81       	ldd	r22, Y+3	; 0x03
    6f0e:	7c 81       	ldd	r23, Y+4	; 0x04
    6f10:	07 2e       	mov	r0, r23
    6f12:	00 0c       	add	r0, r0
    6f14:	88 0b       	sbc	r24, r24
    6f16:	99 0b       	sbc	r25, r25
    6f18:	0e 94 3f 43 	call	0x867e	; 0x867e <__floatsisf>
    6f1c:	20 e0       	ldi	r18, 0x00	; 0
    6f1e:	30 e0       	ldi	r19, 0x00	; 0
    6f20:	48 ec       	ldi	r20, 0xC8	; 200
    6f22:	52 e4       	ldi	r21, 0x42	; 66
    6f24:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    6f28:	9b 01       	movw	r18, r22
    6f2a:	ac 01       	movw	r20, r24
    6f2c:	69 85       	ldd	r22, Y+9	; 0x09
    6f2e:	7a 85       	ldd	r23, Y+10	; 0x0a
    6f30:	8b 85       	ldd	r24, Y+11	; 0x0b
    6f32:	9c 85       	ldd	r25, Y+12	; 0x0c
    6f34:	0e 94 24 42 	call	0x8448	; 0x8448 <__addsf3>
    6f38:	69 87       	std	Y+9, r22	; 0x09
    6f3a:	7a 87       	std	Y+10, r23	; 0x0a
    6f3c:	8b 87       	std	Y+11, r24	; 0x0b
    6f3e:	9c 87       	std	Y+12, r25	; 0x0c
    6f40:	82 cf       	rjmp	.-252    	; 0x6e46 <WorkerMotorPos+0x164>
			EncoderInfo=DriverMotorGetEncoder();

			//Process reset setpoint command
			if (xSemaphoreTake(ResetSetpointSema,0)==pdPASS)
			{
				Set1=EncoderInfo.Cnt1;
    6f42:	c3 01       	movw	r24, r6
    6f44:	b2 01       	movw	r22, r4
    6f46:	0e 94 3f 43 	call	0x867e	; 0x867e <__floatsisf>
    6f4a:	6d 83       	std	Y+5, r22	; 0x05
    6f4c:	7e 83       	std	Y+6, r23	; 0x06
    6f4e:	8f 83       	std	Y+7, r24	; 0x07
    6f50:	98 87       	std	Y+8, r25	; 0x08
				Set2=EncoderInfo.Cnt2;
    6f52:	47 01       	movw	r8, r14
    6f54:	ff 0c       	add	r15, r15
    6f56:	aa 08       	sbc	r10, r10
    6f58:	bb 08       	sbc	r11, r11
    6f5a:	c5 01       	movw	r24, r10
    6f5c:	b4 01       	movw	r22, r8
    6f5e:	0e 94 3f 43 	call	0x867e	; 0x867e <__floatsisf>
    6f62:	69 87       	std	Y+9, r22	; 0x09
    6f64:	7a 87       	std	Y+10, r23	; 0x0a
    6f66:	8b 87       	std	Y+11, r24	; 0x0b
    6f68:	9c 87       	std	Y+12, r25	; 0x0c
    6f6a:	5f cf       	rjmp	.-322    	; 0x6e2a <WorkerMotorPos+0x148>

00006f6c <EnableMotorPosTask>:
	vSemaphoreCreateBinary(ResetSetpointSema);
}

void EnableMotorPosTask()
{
	DriverMotorResetEncoder();
    6f6c:	0e 94 c8 09 	call	0x1390	; 0x1390 <DriverMotorResetEncoder>
	xSemaphoreGive(ResetSetpointSema);
    6f70:	20 e0       	ldi	r18, 0x00	; 0
    6f72:	40 e0       	ldi	r20, 0x00	; 0
    6f74:	50 e0       	ldi	r21, 0x00	; 0
    6f76:	60 e0       	ldi	r22, 0x00	; 0
    6f78:	70 e0       	ldi	r23, 0x00	; 0
    6f7a:	80 91 65 2d 	lds	r24, 0x2D65	; 0x802d65 <ResetSetpointSema>
    6f7e:	90 91 66 2d 	lds	r25, 0x2D66	; 0x802d66 <ResetSetpointSema+0x1>
    6f82:	0e 94 27 20 	call	0x404e	; 0x404e <xQueueGenericSend>
	xLastWakeTime = xTaskGetTickCount();
    6f86:	0e 94 ac 28 	call	0x5158	; 0x5158 <xTaskGetTickCount>
    6f8a:	80 93 5f 2d 	sts	0x2D5F, r24	; 0x802d5f <xLastWakeTime>
    6f8e:	90 93 60 2d 	sts	0x2D60, r25	; 0x802d60 <xLastWakeTime+0x1>
	vTaskResume(MotorPosTaskHandle);
    6f92:	80 91 61 2d 	lds	r24, 0x2D61	; 0x802d61 <MotorPosTaskHandle>
    6f96:	90 91 62 2d 	lds	r25, 0x2D62	; 0x802d62 <MotorPosTaskHandle+0x1>
    6f9a:	0c 94 1f 28 	jmp	0x503e	; 0x503e <vTaskResume>

00006f9e <DisableMotorPosTask>:
}

void DisableMotorPosTask()
{
	vTaskSuspend(MotorPosTaskHandle);
    6f9e:	80 91 61 2d 	lds	r24, 0x2D61	; 0x802d61 <MotorPosTaskHandle>
    6fa2:	90 91 62 2d 	lds	r25, 0x2D62	; 0x802d62 <MotorPosTaskHandle+0x1>
    6fa6:	0e 94 a2 27 	call	0x4f44	; 0x4f44 <vTaskSuspend>
	DriverMotorSet(0,0);
    6faa:	60 e0       	ldi	r22, 0x00	; 0
    6fac:	70 e0       	ldi	r23, 0x00	; 0
    6fae:	80 e0       	ldi	r24, 0x00	; 0
    6fb0:	90 e0       	ldi	r25, 0x00	; 0
    6fb2:	0c 94 f2 06 	jmp	0xde4	; 0xde4 <DriverMotorSet>

00006fb6 <InitMotorPosTask>:
//Private function prototypes
void WorkerMotorPos(void *pvParameters);

//Function definitions
void InitMotorPosTask()
{
    6fb6:	ef 92       	push	r14
    6fb8:	ff 92       	push	r15
    6fba:	0f 93       	push	r16
	DriverMotorInit();
    6fbc:	0e 94 c1 06 	call	0xd82	; 0xd82 <DriverMotorInit>
	xTaskCreate( WorkerMotorPos, "motpos", 256, NULL, tskIDLE_PRIORITY+3, &MotorPosTaskHandle );
    6fc0:	81 e6       	ldi	r24, 0x61	; 97
    6fc2:	e8 2e       	mov	r14, r24
    6fc4:	8d e2       	ldi	r24, 0x2D	; 45
    6fc6:	f8 2e       	mov	r15, r24
    6fc8:	03 e0       	ldi	r16, 0x03	; 3
    6fca:	20 e0       	ldi	r18, 0x00	; 0
    6fcc:	30 e0       	ldi	r19, 0x00	; 0
    6fce:	40 e0       	ldi	r20, 0x00	; 0
    6fd0:	51 e0       	ldi	r21, 0x01	; 1
    6fd2:	6f e1       	ldi	r22, 0x1F	; 31
    6fd4:	76 e2       	ldi	r23, 0x26	; 38
    6fd6:	81 e7       	ldi	r24, 0x71	; 113
    6fd8:	96 e3       	ldi	r25, 0x36	; 54
    6fda:	0e 94 20 26 	call	0x4c40	; 0x4c40 <xTaskCreate>
	DisableMotorPosTask(); 	
    6fde:	0e 94 cf 37 	call	0x6f9e	; 0x6f9e <DisableMotorPosTask>
	
	IncSetQueue=xQueueCreate(1,sizeof(IncSetStruct));
    6fe2:	40 e0       	ldi	r20, 0x00	; 0
    6fe4:	64 e0       	ldi	r22, 0x04	; 4
    6fe6:	81 e0       	ldi	r24, 0x01	; 1
    6fe8:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <xQueueGenericCreate>
    6fec:	80 93 63 2d 	sts	0x2D63, r24	; 0x802d63 <IncSetQueue>
    6ff0:	90 93 64 2d 	sts	0x2D64, r25	; 0x802d64 <IncSetQueue+0x1>
	vSemaphoreCreateBinary(ResetSetpointSema);
    6ff4:	43 e0       	ldi	r20, 0x03	; 3
    6ff6:	60 e0       	ldi	r22, 0x00	; 0
    6ff8:	81 e0       	ldi	r24, 0x01	; 1
    6ffa:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <xQueueGenericCreate>
    6ffe:	80 93 65 2d 	sts	0x2D65, r24	; 0x802d65 <ResetSetpointSema>
    7002:	90 93 66 2d 	sts	0x2D66, r25	; 0x802d66 <ResetSetpointSema+0x1>
    7006:	00 97       	sbiw	r24, 0x00	; 0
    7008:	51 f0       	breq	.+20     	; 0x701e <InitMotorPosTask+0x68>
    700a:	20 e0       	ldi	r18, 0x00	; 0
    700c:	40 e0       	ldi	r20, 0x00	; 0
    700e:	50 e0       	ldi	r21, 0x00	; 0
    7010:	60 e0       	ldi	r22, 0x00	; 0
    7012:	70 e0       	ldi	r23, 0x00	; 0
}
    7014:	0f 91       	pop	r16
    7016:	ff 90       	pop	r15
    7018:	ef 90       	pop	r14
	DriverMotorInit();
	xTaskCreate( WorkerMotorPos, "motpos", 256, NULL, tskIDLE_PRIORITY+3, &MotorPosTaskHandle );
	DisableMotorPosTask(); 	
	
	IncSetQueue=xQueueCreate(1,sizeof(IncSetStruct));
	vSemaphoreCreateBinary(ResetSetpointSema);
    701a:	0c 94 27 20 	jmp	0x404e	; 0x404e <xQueueGenericSend>
}
    701e:	0f 91       	pop	r16
    7020:	ff 90       	pop	r15
    7022:	ef 90       	pop	r14
    7024:	08 95       	ret

00007026 <MotorPosIncSet>:
	DriverMotorSet(0,0);
}


void MotorPosIncSet(int16_t IncSet1,int16_t IncSet2)
{
    7026:	cf 93       	push	r28
    7028:	df 93       	push	r29
    702a:	00 d0       	rcall	.+0      	; 0x702c <MotorPosIncSet+0x6>
    702c:	1f 92       	push	r1
    702e:	cd b7       	in	r28, 0x3d	; 61
    7030:	de b7       	in	r29, 0x3e	; 62
	IncSetStruct IncSet;
	IncSet.IncSet1=IncSet1;
    7032:	89 83       	std	Y+1, r24	; 0x01
    7034:	9a 83       	std	Y+2, r25	; 0x02
	IncSet.IncSet2=IncSet2;
    7036:	6b 83       	std	Y+3, r22	; 0x03
    7038:	7c 83       	std	Y+4, r23	; 0x04
	xQueueSend(IncSetQueue,&IncSet,portMAX_DELAY);
    703a:	20 e0       	ldi	r18, 0x00	; 0
    703c:	4f ef       	ldi	r20, 0xFF	; 255
    703e:	5f ef       	ldi	r21, 0xFF	; 255
    7040:	be 01       	movw	r22, r28
    7042:	6f 5f       	subi	r22, 0xFF	; 255
    7044:	7f 4f       	sbci	r23, 0xFF	; 255
    7046:	80 91 63 2d 	lds	r24, 0x2D63	; 0x802d63 <IncSetQueue>
    704a:	90 91 64 2d 	lds	r25, 0x2D64	; 0x802d64 <IncSetQueue+0x1>
    704e:	0e 94 27 20 	call	0x404e	; 0x404e <xQueueGenericSend>
}
    7052:	24 96       	adiw	r28, 0x04	; 4
    7054:	cd bf       	out	0x3d, r28	; 61
    7056:	de bf       	out	0x3e, r29	; 62
    7058:	df 91       	pop	r29
    705a:	cf 91       	pop	r28
    705c:	08 95       	ret

0000705e <WorkerMotorSpeed>:
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
	
}

void WorkerMotorSpeed(void *pvParameters)
{
    705e:	cf 93       	push	r28
    7060:	df 93       	push	r29
    7062:	00 d0       	rcall	.+0      	; 0x7064 <WorkerMotorSpeed+0x6>
    7064:	1f 92       	push	r1
    7066:	cd b7       	in	r28, 0x3d	; 61
    7068:	de b7       	in	r29, 0x3e	; 62
	const TickType_t xPeriod = 10;
	MotorSpeedStruct MotorSpeed;

	xLastWakeTime = xTaskGetTickCount();
    706a:	0e 94 ac 28 	call	0x5158	; 0x5158 <xTaskGetTickCount>
    706e:	80 93 67 2d 	sts	0x2D67, r24	; 0x802d67 <xLastWakeTime>
    7072:	90 93 68 2d 	sts	0x2D68, r25	; 0x802d68 <xLastWakeTime+0x1>
	
	while (1)
	{
			xQueuePeek(MotorSpeedQueue,&MotorSpeed,portMAX_DELAY);
    7076:	4f ef       	ldi	r20, 0xFF	; 255
    7078:	5f ef       	ldi	r21, 0xFF	; 255
    707a:	be 01       	movw	r22, r28
    707c:	6f 5f       	subi	r22, 0xFF	; 255
    707e:	7f 4f       	sbci	r23, 0xFF	; 255
    7080:	80 91 6b 2d 	lds	r24, 0x2D6B	; 0x802d6b <MotorSpeedQueue>
    7084:	90 91 6c 2d 	lds	r25, 0x2D6C	; 0x802d6c <MotorSpeedQueue+0x1>
    7088:	0e 94 75 23 	call	0x46ea	; 0x46ea <xQueuePeek>
			MotorPosIncSet(MotorSpeed.Speed1,MotorSpeed.Speed2);
    708c:	6b 81       	ldd	r22, Y+3	; 0x03
    708e:	7c 81       	ldd	r23, Y+4	; 0x04
    7090:	89 81       	ldd	r24, Y+1	; 0x01
    7092:	9a 81       	ldd	r25, Y+2	; 0x02
    7094:	0e 94 13 38 	call	0x7026	; 0x7026 <MotorPosIncSet>
			
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
    7098:	6a e0       	ldi	r22, 0x0A	; 10
    709a:	70 e0       	ldi	r23, 0x00	; 0
    709c:	87 e6       	ldi	r24, 0x67	; 103
    709e:	9d e2       	ldi	r25, 0x2D	; 45
    70a0:	0e 94 31 2a 	call	0x5462	; 0x5462 <vTaskDelayUntil>
    70a4:	e8 cf       	rjmp	.-48     	; 0x7076 <WorkerMotorSpeed+0x18>

000070a6 <InitMotorSpeedTask>:
//Private function prototypes
void WorkerMotorSpeed(void *pvParameters);

//Function definitions
void InitMotorSpeedTask()
{
    70a6:	ef 92       	push	r14
    70a8:	ff 92       	push	r15
    70aa:	0f 93       	push	r16
	xTaskCreate( WorkerMotorSpeed, "motspd", 256, NULL, tskIDLE_PRIORITY+3, &MotorSpeedTaskHandle );	
    70ac:	89 e6       	ldi	r24, 0x69	; 105
    70ae:	e8 2e       	mov	r14, r24
    70b0:	8d e2       	ldi	r24, 0x2D	; 45
    70b2:	f8 2e       	mov	r15, r24
    70b4:	03 e0       	ldi	r16, 0x03	; 3
    70b6:	20 e0       	ldi	r18, 0x00	; 0
    70b8:	30 e0       	ldi	r19, 0x00	; 0
    70ba:	40 e0       	ldi	r20, 0x00	; 0
    70bc:	51 e0       	ldi	r21, 0x01	; 1
    70be:	66 e2       	ldi	r22, 0x26	; 38
    70c0:	76 e2       	ldi	r23, 0x26	; 38
    70c2:	8f e2       	ldi	r24, 0x2F	; 47
    70c4:	98 e3       	ldi	r25, 0x38	; 56
    70c6:	0e 94 20 26 	call	0x4c40	; 0x4c40 <xTaskCreate>
	vTaskResume(MotorSpeedTaskHandle);
}

void DisableMotorSpeedTask()
{
	vTaskSuspend(MotorSpeedTaskHandle);
    70ca:	80 91 69 2d 	lds	r24, 0x2D69	; 0x802d69 <MotorSpeedTaskHandle>
    70ce:	90 91 6a 2d 	lds	r25, 0x2D6A	; 0x802d6a <MotorSpeedTaskHandle+0x1>
    70d2:	0e 94 a2 27 	call	0x4f44	; 0x4f44 <vTaskSuspend>
void InitMotorSpeedTask()
{
	xTaskCreate( WorkerMotorSpeed, "motspd", 256, NULL, tskIDLE_PRIORITY+3, &MotorSpeedTaskHandle );	
	DisableMotorSpeedTask();
	
	MotorSpeedQueue=xQueueCreate(1,sizeof(MotorSpeedStruct));
    70d6:	40 e0       	ldi	r20, 0x00	; 0
    70d8:	64 e0       	ldi	r22, 0x04	; 4
    70da:	81 e0       	ldi	r24, 0x01	; 1
    70dc:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <xQueueGenericCreate>
    70e0:	80 93 6b 2d 	sts	0x2D6B, r24	; 0x802d6b <MotorSpeedQueue>
    70e4:	90 93 6c 2d 	sts	0x2D6C, r25	; 0x802d6c <MotorSpeedQueue+0x1>
}

void MotorSpeedSet(int16_t Speed1,int16_t Speed2)
{
	
	MotorSpeed.Speed1=Speed1;
    70e8:	ed e6       	ldi	r30, 0x6D	; 109
    70ea:	fd e2       	ldi	r31, 0x2D	; 45
    70ec:	10 82       	st	Z, r1
    70ee:	11 82       	std	Z+1, r1	; 0x01
	MotorSpeed.Speed2=Speed2;
    70f0:	12 82       	std	Z+2, r1	; 0x02
    70f2:	13 82       	std	Z+3, r1	; 0x03
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
    70f4:	22 e0       	ldi	r18, 0x02	; 2
    70f6:	40 e0       	ldi	r20, 0x00	; 0
    70f8:	50 e0       	ldi	r21, 0x00	; 0
    70fa:	bf 01       	movw	r22, r30
	xTaskCreate( WorkerMotorSpeed, "motspd", 256, NULL, tskIDLE_PRIORITY+3, &MotorSpeedTaskHandle );	
	DisableMotorSpeedTask();
	
	MotorSpeedQueue=xQueueCreate(1,sizeof(MotorSpeedStruct));
	MotorSpeedSet(0,0);
}
    70fc:	0f 91       	pop	r16
    70fe:	ff 90       	pop	r15
    7100:	ef 90       	pop	r14
void MotorSpeedSet(int16_t Speed1,int16_t Speed2)
{
	
	MotorSpeed.Speed1=Speed1;
	MotorSpeed.Speed2=Speed2;
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
    7102:	0c 94 27 20 	jmp	0x404e	; 0x404e <xQueueGenericSend>

00007106 <EnableMotorSpeedTask>:
	MotorSpeedSet(0,0);
}

void EnableMotorSpeedTask()
{
	xLastWakeTime = xTaskGetTickCount();
    7106:	0e 94 ac 28 	call	0x5158	; 0x5158 <xTaskGetTickCount>
    710a:	80 93 67 2d 	sts	0x2D67, r24	; 0x802d67 <xLastWakeTime>
    710e:	90 93 68 2d 	sts	0x2D68, r25	; 0x802d68 <xLastWakeTime+0x1>
	vTaskResume(MotorSpeedTaskHandle);
    7112:	80 91 69 2d 	lds	r24, 0x2D69	; 0x802d69 <MotorSpeedTaskHandle>
    7116:	90 91 6a 2d 	lds	r25, 0x2D6A	; 0x802d6a <MotorSpeedTaskHandle+0x1>
    711a:	0c 94 1f 28 	jmp	0x503e	; 0x503e <vTaskResume>

0000711e <DisableMotorSpeedTask>:
}

void DisableMotorSpeedTask()
{
	vTaskSuspend(MotorSpeedTaskHandle);
    711e:	80 91 69 2d 	lds	r24, 0x2D69	; 0x802d69 <MotorSpeedTaskHandle>
    7122:	90 91 6a 2d 	lds	r25, 0x2D6A	; 0x802d6a <MotorSpeedTaskHandle+0x1>
    7126:	0c 94 a2 27 	jmp	0x4f44	; 0x4f44 <vTaskSuspend>

0000712a <MotorSpeedSet>:
}

void MotorSpeedSet(int16_t Speed1,int16_t Speed2)
{
	
	MotorSpeed.Speed1=Speed1;
    712a:	ed e6       	ldi	r30, 0x6D	; 109
    712c:	fd e2       	ldi	r31, 0x2D	; 45
    712e:	80 83       	st	Z, r24
    7130:	91 83       	std	Z+1, r25	; 0x01
	MotorSpeed.Speed2=Speed2;
    7132:	62 83       	std	Z+2, r22	; 0x02
    7134:	73 83       	std	Z+3, r23	; 0x03
	xQueueOverwrite(MotorSpeedQueue,&MotorSpeed);
    7136:	22 e0       	ldi	r18, 0x02	; 2
    7138:	40 e0       	ldi	r20, 0x00	; 0
    713a:	50 e0       	ldi	r21, 0x00	; 0
    713c:	bf 01       	movw	r22, r30
    713e:	80 91 6b 2d 	lds	r24, 0x2D6B	; 0x802d6b <MotorSpeedQueue>
    7142:	90 91 6c 2d 	lds	r25, 0x2D6C	; 0x802d6c <MotorSpeedQueue+0x1>
    7146:	0c 94 27 20 	jmp	0x404e	; 0x404e <xQueueGenericSend>

0000714a <InitOLEDMenuTask>:
}

void UpMenu()
{
	if (SelItem>0) SelItem--;
	if (SelItem<TopItem) TopItem=SelItem;
    714a:	ef 92       	push	r14
    714c:	ff 92       	push	r15
    714e:	0f 93       	push	r16
    7150:	e1 2c       	mov	r14, r1
    7152:	f1 2c       	mov	r15, r1
    7154:	02 e0       	ldi	r16, 0x02	; 2
    7156:	20 e0       	ldi	r18, 0x00	; 0
    7158:	30 e0       	ldi	r19, 0x00	; 0
    715a:	40 e0       	ldi	r20, 0x00	; 0
    715c:	54 e0       	ldi	r21, 0x04	; 4
    715e:	6d e2       	ldi	r22, 0x2D	; 45
    7160:	76 e2       	ldi	r23, 0x26	; 38
    7162:	8d e0       	ldi	r24, 0x0D	; 13
    7164:	9e e3       	ldi	r25, 0x3E	; 62
    7166:	0e 94 20 26 	call	0x4c40	; 0x4c40 <xTaskCreate>
    716a:	0f 91       	pop	r16
    716c:	ff 90       	pop	r15
    716e:	ef 90       	pop	r14
    7170:	08 95       	ret

00007172 <DrawMenu>:
    7172:	0f 93       	push	r16
    7174:	1f 93       	push	r17
    7176:	cf 93       	push	r28
    7178:	df 93       	push	r29
    717a:	d0 91 72 2d 	lds	r29, 0x2D72	; 0x802d72 <TopItem>
    717e:	15 e0       	ldi	r17, 0x05	; 5
    7180:	1d 0f       	add	r17, r29
    7182:	0e 94 c6 0c 	call	0x198c	; 0x198c <DriverOLEDClearScreen>
    7186:	1d 17       	cp	r17, r29
    7188:	78 f0       	brcs	.+30     	; 0x71a8 <DrawMenu+0x36>
    718a:	cd 2f       	mov	r28, r29
    718c:	04 e1       	ldi	r16, 0x14	; 20
    718e:	0c 9f       	mul	r16, r28
    7190:	b0 01       	movw	r22, r0
    7192:	11 24       	eor	r1, r1
    7194:	6a 5e       	subi	r22, 0xEA	; 234
    7196:	7f 4d       	sbci	r23, 0xDF	; 223
    7198:	40 e0       	ldi	r20, 0x00	; 0
    719a:	8c 2f       	mov	r24, r28
    719c:	8d 1b       	sub	r24, r29
    719e:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
    71a2:	cf 5f       	subi	r28, 0xFF	; 255
    71a4:	1c 17       	cp	r17, r28
    71a6:	98 f7       	brcc	.-26     	; 0x718e <DrawMenu+0x1c>
    71a8:	60 91 71 2d 	lds	r22, 0x2D71	; 0x802d71 <SelItem>
    71ac:	80 91 72 2d 	lds	r24, 0x2D72	; 0x802d72 <TopItem>
    71b0:	68 1b       	sub	r22, r24
    71b2:	20 e0       	ldi	r18, 0x00	; 0
    71b4:	4a e2       	ldi	r20, 0x2A	; 42
    71b6:	80 e0       	ldi	r24, 0x00	; 0
    71b8:	0e 94 56 0c 	call	0x18ac	; 0x18ac <DriverOLEDPrintSmChar>
    71bc:	df 91       	pop	r29
    71be:	cf 91       	pop	r28
    71c0:	1f 91       	pop	r17
    71c2:	0f 91       	pop	r16
    71c4:	0c 94 0b 0c 	jmp	0x1816	; 0x1816 <DriverOLEDUpdate>

000071c8 <PageCPUStatus>:
}

void PageCPUStatus()
{
    71c8:	2f 92       	push	r2
    71ca:	3f 92       	push	r3
    71cc:	4f 92       	push	r4
    71ce:	5f 92       	push	r5
    71d0:	6f 92       	push	r6
    71d2:	7f 92       	push	r7
    71d4:	8f 92       	push	r8
    71d6:	9f 92       	push	r9
    71d8:	af 92       	push	r10
    71da:	bf 92       	push	r11
    71dc:	cf 92       	push	r12
    71de:	df 92       	push	r13
    71e0:	ef 92       	push	r14
    71e2:	ff 92       	push	r15
    71e4:	0f 93       	push	r16
    71e6:	1f 93       	push	r17
    71e8:	cf 93       	push	r28
    71ea:	df 93       	push	r29
    71ec:	cd b7       	in	r28, 0x3d	; 61
    71ee:	de b7       	in	r29, 0x3e	; 62
    71f0:	c4 57       	subi	r28, 0x74	; 116
    71f2:	d1 40       	sbci	r29, 0x01	; 1
    71f4:	cd bf       	out	0x3d, r28	; 61
    71f6:	de bf       	out	0x3e, r29	; 62
	float Load;
	
	uint32_t IdleTime;
	uint32_t OldTotalRunTime=0,OldIdleTime=0;
	
	vTaskDelay(300);
    71f8:	8c e2       	ldi	r24, 0x2C	; 44
    71fa:	91 e0       	ldi	r25, 0x01	; 1
    71fc:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
	uint32_t TotalRunTime;
	int NumTasks;
	float Load;
	
	uint32_t IdleTime;
	uint32_t OldTotalRunTime=0,OldIdleTime=0;
    7200:	41 2c       	mov	r4, r1
    7202:	51 2c       	mov	r5, r1
    7204:	32 01       	movw	r6, r4
    7206:	81 2c       	mov	r8, r1
    7208:	91 2c       	mov	r9, r1
    720a:	54 01       	movw	r10, r8
		
		
		DriverOLEDClearScreen();
		
		DriverOLEDPrintSmText(0,"Mem free:",0);
		sprintf (s,"%6u/%6u",xPortGetFreeHeapSize(),configTOTAL_HEAP_SIZE);
    720c:	8f e3       	ldi	r24, 0x3F	; 63
    720e:	28 2e       	mov	r2, r24
    7210:	86 e2       	ldi	r24, 0x26	; 38
    7212:	38 2e       	mov	r3, r24
    7214:	8e 01       	movw	r16, r28
    7216:	0f 5b       	subi	r16, 0xBF	; 191
    7218:	1e 4f       	sbci	r17, 0xFE	; 254
    721a:	8f c0       	rjmp	.+286    	; 0x733a <PageCPUStatus+0x172>
	{
		Stick=DriverCursorStickGetFifo(300);
		if (Stick & CURSOR_PRESS) break;
		
		
		DriverOLEDClearScreen();
    721c:	0e 94 c6 0c 	call	0x198c	; 0x198c <DriverOLEDClearScreen>
		
		DriverOLEDPrintSmText(0,"Mem free:",0);
    7220:	40 e0       	ldi	r20, 0x00	; 0
    7222:	65 e3       	ldi	r22, 0x35	; 53
    7224:	76 e2       	ldi	r23, 0x26	; 38
    7226:	80 e0       	ldi	r24, 0x00	; 0
    7228:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		sprintf (s,"%6u/%6u",xPortGetFreeHeapSize(),configTOTAL_HEAP_SIZE);
    722c:	0e 94 47 1c 	call	0x388e	; 0x388e <xPortGetFreeHeapSize>
    7230:	20 e4       	ldi	r18, 0x40	; 64
    7232:	2f 93       	push	r18
    7234:	1f 92       	push	r1
    7236:	9f 93       	push	r25
    7238:	8f 93       	push	r24
    723a:	3f 92       	push	r3
    723c:	2f 92       	push	r2
    723e:	1f 93       	push	r17
    7240:	0f 93       	push	r16
    7242:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    7246:	40 e0       	ldi	r20, 0x00	; 0
    7248:	b8 01       	movw	r22, r16
    724a:	81 e0       	ldi	r24, 0x01	; 1
    724c:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		
		
		NumTasks=uxTaskGetSystemState(TaskStatusArray,MAX_TASKS,&TotalRunTime);
    7250:	ae 01       	movw	r20, r28
    7252:	4f 58       	subi	r20, 0x8F	; 143
    7254:	5e 4f       	sbci	r21, 0xFE	; 254
    7256:	64 e1       	ldi	r22, 0x14	; 20
    7258:	ce 01       	movw	r24, r28
    725a:	01 96       	adiw	r24, 0x01	; 1
    725c:	0e 94 da 2c 	call	0x59b4	; 0x59b4 <uxTaskGetSystemState>
		sprintf (s,"Number of tasks:%d",NumTasks);
    7260:	1f 92       	push	r1
    7262:	8f 93       	push	r24
    7264:	87 e4       	ldi	r24, 0x47	; 71
    7266:	96 e2       	ldi	r25, 0x26	; 38
    7268:	9f 93       	push	r25
    726a:	8f 93       	push	r24
    726c:	1f 93       	push	r17
    726e:	0f 93       	push	r16
    7270:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(2,s,0);
    7274:	40 e0       	ldi	r20, 0x00	; 0
    7276:	b8 01       	movw	r22, r16
    7278:	82 e0       	ldi	r24, 0x02	; 2
    727a:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		
		//Calculate system load
		vTaskGetTaskInfo(xTaskGetIdleTaskHandle(),&IdleTaskStatus,pdFALSE,eInvalid);
    727e:	0e 94 b6 28 	call	0x516c	; 0x516c <xTaskGetIdleTaskHandle>
    7282:	25 e0       	ldi	r18, 0x05	; 5
    7284:	40 e0       	ldi	r20, 0x00	; 0
    7286:	be 01       	movw	r22, r28
    7288:	6f 59       	subi	r22, 0x9F	; 159
    728a:	7e 4f       	sbci	r23, 0xFE	; 254
    728c:	0e 94 fa 2b 	call	0x57f4	; 0x57f4 <vTaskGetInfo>
		IdleTime=IdleTaskStatus.ulRunTimeCounter;
    7290:	c7 59       	subi	r28, 0x97	; 151
    7292:	de 4f       	sbci	r29, 0xFE	; 254
    7294:	c8 80       	ld	r12, Y
    7296:	d9 80       	ldd	r13, Y+1	; 0x01
    7298:	ea 80       	ldd	r14, Y+2	; 0x02
    729a:	fb 80       	ldd	r15, Y+3	; 0x03
    729c:	c9 56       	subi	r28, 0x69	; 105
    729e:	d1 40       	sbci	r29, 0x01	; 1
		Load=(1-((float) (IdleTime-OldIdleTime)/ (float)(TotalRunTime-OldTotalRunTime)))*100;
		sprintf(s,"CPU Load:%2.2f",Load);
    72a0:	c7 01       	movw	r24, r14
    72a2:	b6 01       	movw	r22, r12
    72a4:	64 19       	sub	r22, r4
    72a6:	75 09       	sbc	r23, r5
    72a8:	86 09       	sbc	r24, r6
    72aa:	97 09       	sbc	r25, r7
    72ac:	0e 94 3d 43 	call	0x867a	; 0x867a <__floatunsisf>
    72b0:	2b 01       	movw	r4, r22
    72b2:	3c 01       	movw	r6, r24
    72b4:	cf 58       	subi	r28, 0x8F	; 143
    72b6:	de 4f       	sbci	r29, 0xFE	; 254
    72b8:	88 81       	ld	r24, Y
    72ba:	99 81       	ldd	r25, Y+1	; 0x01
    72bc:	aa 81       	ldd	r26, Y+2	; 0x02
    72be:	bb 81       	ldd	r27, Y+3	; 0x03
    72c0:	c1 57       	subi	r28, 0x71	; 113
    72c2:	d1 40       	sbci	r29, 0x01	; 1
    72c4:	bc 01       	movw	r22, r24
    72c6:	cd 01       	movw	r24, r26
    72c8:	68 19       	sub	r22, r8
    72ca:	79 09       	sbc	r23, r9
    72cc:	8a 09       	sbc	r24, r10
    72ce:	9b 09       	sbc	r25, r11
    72d0:	0e 94 3d 43 	call	0x867a	; 0x867a <__floatunsisf>
    72d4:	9b 01       	movw	r18, r22
    72d6:	ac 01       	movw	r20, r24
    72d8:	c3 01       	movw	r24, r6
    72da:	b2 01       	movw	r22, r4
    72dc:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    72e0:	9b 01       	movw	r18, r22
    72e2:	ac 01       	movw	r20, r24
    72e4:	60 e0       	ldi	r22, 0x00	; 0
    72e6:	70 e0       	ldi	r23, 0x00	; 0
    72e8:	80 e8       	ldi	r24, 0x80	; 128
    72ea:	9f e3       	ldi	r25, 0x3F	; 63
    72ec:	0e 94 23 42 	call	0x8446	; 0x8446 <__subsf3>
    72f0:	20 e0       	ldi	r18, 0x00	; 0
    72f2:	30 e0       	ldi	r19, 0x00	; 0
    72f4:	48 ec       	ldi	r20, 0xC8	; 200
    72f6:	52 e4       	ldi	r21, 0x42	; 66
    72f8:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    72fc:	9f 93       	push	r25
    72fe:	8f 93       	push	r24
    7300:	7f 93       	push	r23
    7302:	6f 93       	push	r22
    7304:	8a e5       	ldi	r24, 0x5A	; 90
    7306:	96 e2       	ldi	r25, 0x26	; 38
    7308:	9f 93       	push	r25
    730a:	8f 93       	push	r24
    730c:	1f 93       	push	r17
    730e:	0f 93       	push	r16
    7310:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(3,s,0);
    7314:	40 e0       	ldi	r20, 0x00	; 0
    7316:	b8 01       	movw	r22, r16
    7318:	83 e0       	ldi	r24, 0x03	; 3
    731a:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		
		DriverOLEDUpdate();
    731e:	0e 94 0b 0c 	call	0x1816	; 0x1816 <DriverOLEDUpdate>
		OldIdleTime=IdleTime;
		OldTotalRunTime=TotalRunTime;
    7322:	cf 58       	subi	r28, 0x8F	; 143
    7324:	de 4f       	sbci	r29, 0xFE	; 254
    7326:	88 80       	ld	r8, Y
    7328:	99 80       	ldd	r9, Y+1	; 0x01
    732a:	aa 80       	ldd	r10, Y+2	; 0x02
    732c:	bb 80       	ldd	r11, Y+3	; 0x03
    732e:	c1 57       	subi	r28, 0x71	; 113
    7330:	d1 40       	sbci	r29, 0x01	; 1
		
	}
    7332:	cd bf       	out	0x3d, r28	; 61
    7334:	de bf       	out	0x3e, r29	; 62
		Load=(1-((float) (IdleTime-OldIdleTime)/ (float)(TotalRunTime-OldTotalRunTime)))*100;
		sprintf(s,"CPU Load:%2.2f",Load);
		DriverOLEDPrintSmText(3,s,0);
		
		DriverOLEDUpdate();
		OldIdleTime=IdleTime;
    7336:	26 01       	movw	r4, r12
    7338:	37 01       	movw	r6, r14
	uint32_t OldTotalRunTime=0,OldIdleTime=0;
	
	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    733a:	8c e2       	ldi	r24, 0x2C	; 44
    733c:	91 e0       	ldi	r25, 0x01	; 1
    733e:	0e 94 42 05 	call	0xa84	; 0xa84 <DriverCursorStickGetFifo>
		if (Stick & CURSOR_PRESS) break;
    7342:	80 ff       	sbrs	r24, 0
    7344:	6b cf       	rjmp	.-298    	; 0x721c <PageCPUStatus+0x54>
		OldIdleTime=IdleTime;
		OldTotalRunTime=TotalRunTime;
		
	}
	
}
    7346:	cc 58       	subi	r28, 0x8C	; 140
    7348:	de 4f       	sbci	r29, 0xFE	; 254
    734a:	cd bf       	out	0x3d, r28	; 61
    734c:	de bf       	out	0x3e, r29	; 62
    734e:	df 91       	pop	r29
    7350:	cf 91       	pop	r28
    7352:	1f 91       	pop	r17
    7354:	0f 91       	pop	r16
    7356:	ff 90       	pop	r15
    7358:	ef 90       	pop	r14
    735a:	df 90       	pop	r13
    735c:	cf 90       	pop	r12
    735e:	bf 90       	pop	r11
    7360:	af 90       	pop	r10
    7362:	9f 90       	pop	r9
    7364:	8f 90       	pop	r8
    7366:	7f 90       	pop	r7
    7368:	6f 90       	pop	r6
    736a:	5f 90       	pop	r5
    736c:	4f 90       	pop	r4
    736e:	3f 90       	pop	r3
    7370:	2f 90       	pop	r2
    7372:	08 95       	ret

00007374 <PageMotorSpeed>:

void PageMotorSpeed()
{
    7374:	2f 92       	push	r2
    7376:	3f 92       	push	r3
    7378:	4f 92       	push	r4
    737a:	5f 92       	push	r5
    737c:	6f 92       	push	r6
    737e:	7f 92       	push	r7
    7380:	8f 92       	push	r8
    7382:	9f 92       	push	r9
    7384:	af 92       	push	r10
    7386:	bf 92       	push	r11
    7388:	cf 92       	push	r12
    738a:	df 92       	push	r13
    738c:	ef 92       	push	r14
    738e:	ff 92       	push	r15
    7390:	0f 93       	push	r16
    7392:	1f 93       	push	r17
    7394:	cf 93       	push	r28
    7396:	df 93       	push	r29
    7398:	cd b7       	in	r28, 0x3d	; 61
    739a:	de b7       	in	r29, 0x3e	; 62
    739c:	c7 54       	subi	r28, 0x47	; 71
    739e:	d1 09       	sbc	r29, r1
    73a0:	cd bf       	out	0x3d, r28	; 61
    73a2:	de bf       	out	0x3e, r29	; 62
	float Phase2;
	
	EncoderStruct EncoderInfo;
	EncoderEventStruct Event;
			
	EnableMotorPosTask();	
    73a4:	0e 94 b6 37 	call	0x6f6c	; 0x6f6c <EnableMotorPosTask>
	EnableMotorSpeedTask();	
    73a8:	0e 94 83 38 	call	0x7106	; 0x7106 <EnableMotorSpeedTask>
}

void PageMotorSpeed()
{
	uint8_t Stick;
	int16_t Speed1=50,Speed2=50;
    73ac:	82 e3       	ldi	r24, 0x32	; 50
    73ae:	a8 2e       	mov	r10, r24
    73b0:	b1 2c       	mov	r11, r1
    73b2:	92 e3       	ldi	r25, 0x32	; 50
    73b4:	c9 2e       	mov	r12, r25
    73b6:	d1 2c       	mov	r13, r1
    73b8:	9e 01       	movw	r18, r28
    73ba:	2f 5f       	subi	r18, 0xFF	; 255
    73bc:	3f 4f       	sbci	r19, 0xFF	; 255
    73be:	79 01       	movw	r14, r18
		sprintf(s,"  A2:%d",EncoderInfo.Cnt2);
		DriverOLEDPrintSmText(3,s,0);
		
		sprintf(s,"  P1:%f",Phase1);
		DriverOLEDPrintSmText(4,s,0);
		sprintf(s,"  P2:%f",Phase2);
    73c0:	6a a6       	std	Y+42, r6	; 0x2a
    73c2:	32 01       	movw	r6, r4
    73c4:	21 01       	movw	r4, r2
			
	EnableMotorPosTask();	
	EnableMotorSpeedTask();	
	while (1)
	{
		EncoderInfo=DriverMotorGetEncoder();
    73c6:	0e 94 5d 07 	call	0xeba	; 0xeba <DriverMotorGetEncoder>
    73ca:	86 2e       	mov	r8, r22
    73cc:	37 2e       	mov	r3, r23
    73ce:	28 2e       	mov	r2, r24
    73d0:	99 2e       	mov	r9, r25

		EdgeIdx1=0; EdgeIdx2=0;
    73d2:	10 e0       	ldi	r17, 0x00	; 0
    73d4:	00 e0       	ldi	r16, 0x00	; 0
		while(1) 
		{
			Event=DriverMotorGetEncoderEvent();
    73d6:	0e 94 6d 07 	call	0xeda	; 0xeda <DriverMotorGetEncoderEvent>
    73da:	29 a3       	std	Y+33, r18	; 0x21
    73dc:	3a a3       	std	Y+34, r19	; 0x22
    73de:	4b a3       	std	Y+35, r20	; 0x23
    73e0:	5c a3       	std	Y+36, r21	; 0x24
    73e2:	89 a1       	ldd	r24, Y+33	; 0x21
    73e4:	9a a1       	ldd	r25, Y+34	; 0x22
    73e6:	ab a1       	ldd	r26, Y+35	; 0x23
    73e8:	bc a1       	ldd	r27, Y+36	; 0x24
			if (Event.Time==0) break; //No more events
    73ea:	00 97       	sbiw	r24, 0x00	; 0
    73ec:	a1 05       	cpc	r26, r1
    73ee:	b1 05       	cpc	r27, r1
    73f0:	09 f4       	brne	.+2      	; 0x73f4 <PageMotorSpeed+0x80>
    73f2:	40 c0       	rjmp	.+128    	; 0x7474 <PageMotorSpeed+0x100>
			
			//Parse events for encoder 1
			if (EdgeIdx1==0)
    73f4:	01 11       	cpse	r16, r1
    73f6:	0c c0       	rjmp	.+24     	; 0x7410 <PageMotorSpeed+0x9c>
			{
				if (Event.Event==RISING_1A)
    73f8:	61 30       	cpi	r22, 0x01	; 1
    73fa:	c1 f1       	breq	.+112    	; 0x746c <PageMotorSpeed+0xf8>
					EdgeIdx1++;
				}
			}

			//Parse events for encoder 2
			if (EdgeIdx2==0)
    73fc:	11 11       	cpse	r17, r1
    73fe:	17 c0       	rjmp	.+46     	; 0x742e <PageMotorSpeed+0xba>
			{
				if (Event.Event==RISING_2A)
    7400:	63 30       	cpi	r22, 0x03	; 3
    7402:	49 f7       	brne	.-46     	; 0x73d6 <PageMotorSpeed+0x62>
    7404:	8e a3       	std	Y+38, r24	; 0x26
    7406:	9f a3       	std	Y+39, r25	; 0x27
    7408:	a8 a7       	std	Y+40, r26	; 0x28
    740a:	b9 a7       	std	Y+41, r27	; 0x29
				{
					EdgeList2[0]=Event.Time;
					EdgeIdx2++;
    740c:	11 e0       	ldi	r17, 0x01	; 1
    740e:	e3 cf       	rjmp	.-58     	; 0x73d6 <PageMotorSpeed+0x62>
				{
					EdgeList1[0]=Event.Time;
					EdgeIdx1++;
				}
			}
			else if (EdgeIdx1==1)
    7410:	01 30       	cpi	r16, 0x01	; 1
    7412:	d9 f0       	breq	.+54     	; 0x744a <PageMotorSpeed+0xd6>
				{
					EdgeList1[1]=Event.Time;
					EdgeIdx1++;
				}
			}
			else if (EdgeIdx1==2)
    7414:	02 30       	cpi	r16, 0x02	; 2
    7416:	91 f7       	brne	.-28     	; 0x73fc <PageMotorSpeed+0x88>
			{
				if (Event.Event==RISING_1A)
    7418:	61 30       	cpi	r22, 0x01	; 1
    741a:	81 f7       	brne	.-32     	; 0x73fc <PageMotorSpeed+0x88>
    741c:	24 96       	adiw	r28, 0x04	; 4
    741e:	8c af       	std	Y+60, r24	; 0x3c
    7420:	9d af       	std	Y+61, r25	; 0x3d
    7422:	ae af       	std	Y+62, r26	; 0x3e
    7424:	bf af       	std	Y+63, r27	; 0x3f
    7426:	24 97       	sbiw	r28, 0x04	; 4
				{
					EdgeList1[2]=Event.Time;
					EdgeIdx1++;
    7428:	03 e0       	ldi	r16, 0x03	; 3
				}
			}

			//Parse events for encoder 2
			if (EdgeIdx2==0)
    742a:	11 23       	and	r17, r17
    742c:	a1 f2       	breq	.-88     	; 0x73d6 <PageMotorSpeed+0x62>
				{
					EdgeList2[0]=Event.Time;
					EdgeIdx2++;
				}
			}
			else if (EdgeIdx2==1)
    742e:	11 30       	cpi	r17, 0x01	; 1
    7430:	a1 f0       	breq	.+40     	; 0x745a <PageMotorSpeed+0xe6>
				{
					EdgeList2[1]=Event.Time;
					EdgeIdx2++;
				}
			}
			else if (EdgeIdx2==2)
    7432:	12 30       	cpi	r17, 0x02	; 2
    7434:	81 f6       	brne	.-96     	; 0x73d6 <PageMotorSpeed+0x62>
			{
				if (Event.Event==RISING_2A)
    7436:	63 30       	cpi	r22, 0x03	; 3
    7438:	71 f6       	brne	.-100    	; 0x73d6 <PageMotorSpeed+0x62>
    743a:	28 96       	adiw	r28, 0x08	; 8
    743c:	8c af       	std	Y+60, r24	; 0x3c
    743e:	9d af       	std	Y+61, r25	; 0x3d
    7440:	ae af       	std	Y+62, r26	; 0x3e
    7442:	bf af       	std	Y+63, r27	; 0x3f
    7444:	28 97       	sbiw	r28, 0x08	; 8
				{
					EdgeList2[2]=Event.Time;
					EdgeIdx2++;
    7446:	13 e0       	ldi	r17, 0x03	; 3
    7448:	c6 cf       	rjmp	.-116    	; 0x73d6 <PageMotorSpeed+0x62>
					EdgeIdx1++;
				}
			}
			else if (EdgeIdx1==1)
			{
				if (Event.Event==RISING_1B)
    744a:	62 30       	cpi	r22, 0x02	; 2
    744c:	b9 f6       	brne	.-82     	; 0x73fc <PageMotorSpeed+0x88>
    744e:	8c af       	std	Y+60, r24	; 0x3c
    7450:	9d af       	std	Y+61, r25	; 0x3d
    7452:	ae af       	std	Y+62, r26	; 0x3e
    7454:	bf af       	std	Y+63, r27	; 0x3f
				{
					EdgeList1[1]=Event.Time;
					EdgeIdx1++;
    7456:	02 e0       	ldi	r16, 0x02	; 2
    7458:	e8 cf       	rjmp	.-48     	; 0x742a <PageMotorSpeed+0xb6>
					EdgeIdx2++;
				}
			}
			else if (EdgeIdx2==1)
			{
				if (Event.Event==RISING_2B)
    745a:	64 30       	cpi	r22, 0x04	; 4
    745c:	09 f0       	breq	.+2      	; 0x7460 <PageMotorSpeed+0xec>
    745e:	bb cf       	rjmp	.-138    	; 0x73d6 <PageMotorSpeed+0x62>
    7460:	88 af       	std	Y+56, r24	; 0x38
    7462:	99 af       	std	Y+57, r25	; 0x39
    7464:	aa af       	std	Y+58, r26	; 0x3a
    7466:	bb af       	std	Y+59, r27	; 0x3b
				{
					EdgeList2[1]=Event.Time;
					EdgeIdx2++;
    7468:	12 e0       	ldi	r17, 0x02	; 2
    746a:	b5 cf       	rjmp	.-150    	; 0x73d6 <PageMotorSpeed+0x62>
    746c:	2c 01       	movw	r4, r24
    746e:	3d 01       	movw	r6, r26
			if (EdgeIdx1==0)
			{
				if (Event.Event==RISING_1A)
				{
					EdgeList1[0]=Event.Time;
					EdgeIdx1++;
    7470:	01 e0       	ldi	r16, 0x01	; 1
    7472:	db cf       	rjmp	.-74     	; 0x742a <PageMotorSpeed+0xb6>
					EdgeList2[2]=Event.Time;
					EdgeIdx2++;
				}
			}
		}
		if (EdgeIdx1==3) //All events needed are detected
    7474:	03 30       	cpi	r16, 0x03	; 3
    7476:	09 f4       	brne	.+2      	; 0x747a <PageMotorSpeed+0x106>
    7478:	c6 c0       	rjmp	.+396    	; 0x7606 <PageMotorSpeed+0x292>
		{
			Phase1=(float) ((EdgeList1[1]-EdgeList1[0])/ (float) (EdgeList1[2]-EdgeList1[0]))*180;
		}
		if (EdgeIdx2==3) //All events needed are detected
    747a:	13 30       	cpi	r17, 0x03	; 3
    747c:	09 f4       	brne	.+2      	; 0x7480 <PageMotorSpeed+0x10c>
    747e:	8e c0       	rjmp	.+284    	; 0x759c <PageMotorSpeed+0x228>
		{
			Phase2=(float) ((EdgeList2[1]-EdgeList2[0])/ (float) (EdgeList2[2]-EdgeList2[0]))*180;
		}
		
		
		Stick=DriverCursorStickGetFifo(300);
    7480:	8c e2       	ldi	r24, 0x2C	; 44
    7482:	91 e0       	ldi	r25, 0x01	; 1
    7484:	0e 94 42 05 	call	0xa84	; 0xa84 <DriverCursorStickGetFifo>
    7488:	18 2f       	mov	r17, r24
		
		DriverOLEDClearScreen();
    748a:	0e 94 c6 0c 	call	0x198c	; 0x198c <DriverOLEDClearScreen>
		
		sprintf(s,"  S1:%d",Speed1);
    748e:	df 92       	push	r13
    7490:	cf 92       	push	r12
    7492:	49 e6       	ldi	r20, 0x69	; 105
    7494:	56 e2       	ldi	r21, 0x26	; 38
    7496:	5f 93       	push	r21
    7498:	4f 93       	push	r20
    749a:	ff 92       	push	r15
    749c:	ef 92       	push	r14
    749e:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    74a2:	40 e0       	ldi	r20, 0x00	; 0
    74a4:	b7 01       	movw	r22, r14
    74a6:	80 e0       	ldi	r24, 0x00	; 0
    74a8:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		sprintf(s,"  S2:%d",Speed2);
    74ac:	bf 92       	push	r11
    74ae:	af 92       	push	r10
    74b0:	21 e7       	ldi	r18, 0x71	; 113
    74b2:	36 e2       	ldi	r19, 0x26	; 38
    74b4:	3f 93       	push	r19
    74b6:	2f 93       	push	r18
    74b8:	ff 92       	push	r15
    74ba:	ef 92       	push	r14
    74bc:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    74c0:	40 e0       	ldi	r20, 0x00	; 0
    74c2:	b7 01       	movw	r22, r14
    74c4:	81 e0       	ldi	r24, 0x01	; 1
    74c6:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>

		sprintf(s,"  A1:%d",EncoderInfo.Cnt1);
    74ca:	3f 92       	push	r3
    74cc:	8f 92       	push	r8
    74ce:	89 e7       	ldi	r24, 0x79	; 121
    74d0:	96 e2       	ldi	r25, 0x26	; 38
    74d2:	9f 93       	push	r25
    74d4:	8f 93       	push	r24
    74d6:	ff 92       	push	r15
    74d8:	ef 92       	push	r14
    74da:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(2,s,0);
    74de:	40 e0       	ldi	r20, 0x00	; 0
    74e0:	b7 01       	movw	r22, r14
    74e2:	82 e0       	ldi	r24, 0x02	; 2
    74e4:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		sprintf(s,"  A2:%d",EncoderInfo.Cnt2);
    74e8:	9f 92       	push	r9
    74ea:	2f 92       	push	r2
    74ec:	41 e8       	ldi	r20, 0x81	; 129
    74ee:	56 e2       	ldi	r21, 0x26	; 38
    74f0:	5f 93       	push	r21
    74f2:	4f 93       	push	r20
    74f4:	ff 92       	push	r15
    74f6:	ef 92       	push	r14
    74f8:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(3,s,0);
    74fc:	40 e0       	ldi	r20, 0x00	; 0
    74fe:	b7 01       	movw	r22, r14
    7500:	83 e0       	ldi	r24, 0x03	; 3
    7502:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		
		sprintf(s,"  P1:%f",Phase1);
    7506:	9c a9       	ldd	r25, Y+52	; 0x34
    7508:	9f 93       	push	r25
    750a:	2b a9       	ldd	r18, Y+51	; 0x33
    750c:	2f 93       	push	r18
    750e:	3a a9       	ldd	r19, Y+50	; 0x32
    7510:	3f 93       	push	r19
    7512:	4e a5       	ldd	r20, Y+46	; 0x2e
    7514:	4f 93       	push	r20
    7516:	89 e8       	ldi	r24, 0x89	; 137
    7518:	96 e2       	ldi	r25, 0x26	; 38
    751a:	9f 93       	push	r25
    751c:	8f 93       	push	r24
    751e:	ff 92       	push	r15
    7520:	ef 92       	push	r14
    7522:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(4,s,0);
    7526:	cd bf       	out	0x3d, r28	; 61
    7528:	de bf       	out	0x3e, r29	; 62
    752a:	40 e0       	ldi	r20, 0x00	; 0
    752c:	b7 01       	movw	r22, r14
    752e:	84 e0       	ldi	r24, 0x04	; 4
    7530:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		sprintf(s,"  P2:%f",Phase2);
    7534:	5a a5       	ldd	r21, Y+42	; 0x2a
    7536:	5f 93       	push	r21
    7538:	8f a9       	ldd	r24, Y+55	; 0x37
    753a:	8f 93       	push	r24
    753c:	9e a9       	ldd	r25, Y+54	; 0x36
    753e:	9f 93       	push	r25
    7540:	2d a9       	ldd	r18, Y+53	; 0x35
    7542:	2f 93       	push	r18
    7544:	41 e9       	ldi	r20, 0x91	; 145
    7546:	56 e2       	ldi	r21, 0x26	; 38
    7548:	5f 93       	push	r21
    754a:	4f 93       	push	r20
    754c:	ff 92       	push	r15
    754e:	ef 92       	push	r14
    7550:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(5,s,0);
    7554:	40 e0       	ldi	r20, 0x00	; 0
    7556:	b7 01       	movw	r22, r14
    7558:	85 e0       	ldi	r24, 0x05	; 5
    755a:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>

		
		if (Stick & CURSOR_UP) Speed1+=5;
    755e:	cd bf       	out	0x3d, r28	; 61
    7560:	de bf       	out	0x3e, r29	; 62
    7562:	14 ff       	sbrs	r17, 4
    7564:	03 c0       	rjmp	.+6      	; 0x756c <PageMotorSpeed+0x1f8>
    7566:	35 e0       	ldi	r19, 0x05	; 5
    7568:	c3 0e       	add	r12, r19
    756a:	d1 1c       	adc	r13, r1
		if (Stick & CURSOR_DOWN) Speed1-=5;
    756c:	12 ff       	sbrs	r17, 2
    756e:	03 c0       	rjmp	.+6      	; 0x7576 <PageMotorSpeed+0x202>
    7570:	45 e0       	ldi	r20, 0x05	; 5
    7572:	c4 1a       	sub	r12, r20
    7574:	d1 08       	sbc	r13, r1
		if (Stick & CURSOR_RIGHT) Speed2+=5;
    7576:	11 ff       	sbrs	r17, 1
    7578:	03 c0       	rjmp	.+6      	; 0x7580 <PageMotorSpeed+0x20c>
    757a:	55 e0       	ldi	r21, 0x05	; 5
    757c:	a5 0e       	add	r10, r21
    757e:	b1 1c       	adc	r11, r1
		if (Stick & CURSOR_LEFT) Speed2-=5;	
    7580:	13 ff       	sbrs	r17, 3
    7582:	03 c0       	rjmp	.+6      	; 0x758a <PageMotorSpeed+0x216>
    7584:	85 e0       	ldi	r24, 0x05	; 5
    7586:	a8 1a       	sub	r10, r24
    7588:	b1 08       	sbc	r11, r1
		if (Stick & CURSOR_PRESS)
    758a:	10 fd       	sbrc	r17, 0
    758c:	69 c0       	rjmp	.+210    	; 0x7660 <PageMotorSpeed+0x2ec>
			DisableMotorSpeedTask();
			DisableMotorPosTask();
			
			return;
		}	
		MotorSpeedSet(Speed1,Speed2);
    758e:	b5 01       	movw	r22, r10
    7590:	c6 01       	movw	r24, r12
    7592:	0e 94 95 38 	call	0x712a	; 0x712a <MotorSpeedSet>
		
		
		DriverOLEDUpdate();
    7596:	0e 94 0b 0c 	call	0x1816	; 0x1816 <DriverOLEDUpdate>
		
	}
    759a:	15 cf       	rjmp	.-470    	; 0x73c6 <PageMotorSpeed+0x52>
		{
			Phase1=(float) ((EdgeList1[1]-EdgeList1[0])/ (float) (EdgeList1[2]-EdgeList1[0]))*180;
		}
		if (EdgeIdx2==3) //All events needed are detected
		{
			Phase2=(float) ((EdgeList2[1]-EdgeList2[0])/ (float) (EdgeList2[2]-EdgeList2[0]))*180;
    759c:	68 ad       	ldd	r22, Y+56	; 0x38
    759e:	79 ad       	ldd	r23, Y+57	; 0x39
    75a0:	8a ad       	ldd	r24, Y+58	; 0x3a
    75a2:	9b ad       	ldd	r25, Y+59	; 0x3b
    75a4:	2e a1       	ldd	r18, Y+38	; 0x26
    75a6:	3f a1       	ldd	r19, Y+39	; 0x27
    75a8:	48 a5       	ldd	r20, Y+40	; 0x28
    75aa:	59 a5       	ldd	r21, Y+41	; 0x29
    75ac:	62 1b       	sub	r22, r18
    75ae:	73 0b       	sbc	r23, r19
    75b0:	84 0b       	sbc	r24, r20
    75b2:	95 0b       	sbc	r25, r21
    75b4:	0e 94 3d 43 	call	0x867a	; 0x867a <__floatunsisf>
    75b8:	6a a7       	std	Y+42, r22	; 0x2a
    75ba:	7b a7       	std	Y+43, r23	; 0x2b
    75bc:	8c a7       	std	Y+44, r24	; 0x2c
    75be:	9d a7       	std	Y+45, r25	; 0x2d
    75c0:	28 96       	adiw	r28, 0x08	; 8
    75c2:	6c ad       	ldd	r22, Y+60	; 0x3c
    75c4:	7d ad       	ldd	r23, Y+61	; 0x3d
    75c6:	8e ad       	ldd	r24, Y+62	; 0x3e
    75c8:	9f ad       	ldd	r25, Y+63	; 0x3f
    75ca:	28 97       	sbiw	r28, 0x08	; 8
    75cc:	2e a1       	ldd	r18, Y+38	; 0x26
    75ce:	3f a1       	ldd	r19, Y+39	; 0x27
    75d0:	48 a5       	ldd	r20, Y+40	; 0x28
    75d2:	59 a5       	ldd	r21, Y+41	; 0x29
    75d4:	62 1b       	sub	r22, r18
    75d6:	73 0b       	sbc	r23, r19
    75d8:	84 0b       	sbc	r24, r20
    75da:	95 0b       	sbc	r25, r21
    75dc:	0e 94 3d 43 	call	0x867a	; 0x867a <__floatunsisf>
    75e0:	9b 01       	movw	r18, r22
    75e2:	ac 01       	movw	r20, r24
    75e4:	6a a5       	ldd	r22, Y+42	; 0x2a
    75e6:	7b a5       	ldd	r23, Y+43	; 0x2b
    75e8:	8c a5       	ldd	r24, Y+44	; 0x2c
    75ea:	9d a5       	ldd	r25, Y+45	; 0x2d
    75ec:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    75f0:	20 e0       	ldi	r18, 0x00	; 0
    75f2:	30 e0       	ldi	r19, 0x00	; 0
    75f4:	44 e3       	ldi	r20, 0x34	; 52
    75f6:	53 e4       	ldi	r21, 0x43	; 67
    75f8:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    75fc:	6d ab       	std	Y+53, r22	; 0x35
    75fe:	7e ab       	std	Y+54, r23	; 0x36
    7600:	8f ab       	std	Y+55, r24	; 0x37
    7602:	9a a7       	std	Y+42, r25	; 0x2a
    7604:	3d cf       	rjmp	.-390    	; 0x7480 <PageMotorSpeed+0x10c>
				}
			}
		}
		if (EdgeIdx1==3) //All events needed are detected
		{
			Phase1=(float) ((EdgeList1[1]-EdgeList1[0])/ (float) (EdgeList1[2]-EdgeList1[0]))*180;
    7606:	6c ad       	ldd	r22, Y+60	; 0x3c
    7608:	7d ad       	ldd	r23, Y+61	; 0x3d
    760a:	8e ad       	ldd	r24, Y+62	; 0x3e
    760c:	9f ad       	ldd	r25, Y+63	; 0x3f
    760e:	64 19       	sub	r22, r4
    7610:	75 09       	sbc	r23, r5
    7612:	86 09       	sbc	r24, r6
    7614:	97 09       	sbc	r25, r7
    7616:	0e 94 3d 43 	call	0x867a	; 0x867a <__floatunsisf>
    761a:	6e a7       	std	Y+46, r22	; 0x2e
    761c:	7f a7       	std	Y+47, r23	; 0x2f
    761e:	88 ab       	std	Y+48, r24	; 0x30
    7620:	99 ab       	std	Y+49, r25	; 0x31
    7622:	24 96       	adiw	r28, 0x04	; 4
    7624:	6c ad       	ldd	r22, Y+60	; 0x3c
    7626:	7d ad       	ldd	r23, Y+61	; 0x3d
    7628:	8e ad       	ldd	r24, Y+62	; 0x3e
    762a:	9f ad       	ldd	r25, Y+63	; 0x3f
    762c:	24 97       	sbiw	r28, 0x04	; 4
    762e:	64 19       	sub	r22, r4
    7630:	75 09       	sbc	r23, r5
    7632:	86 09       	sbc	r24, r6
    7634:	97 09       	sbc	r25, r7
    7636:	0e 94 3d 43 	call	0x867a	; 0x867a <__floatunsisf>
    763a:	9b 01       	movw	r18, r22
    763c:	ac 01       	movw	r20, r24
    763e:	6e a5       	ldd	r22, Y+46	; 0x2e
    7640:	7f a5       	ldd	r23, Y+47	; 0x2f
    7642:	88 a9       	ldd	r24, Y+48	; 0x30
    7644:	99 a9       	ldd	r25, Y+49	; 0x31
    7646:	0e 94 95 42 	call	0x852a	; 0x852a <__divsf3>
    764a:	20 e0       	ldi	r18, 0x00	; 0
    764c:	30 e0       	ldi	r19, 0x00	; 0
    764e:	44 e3       	ldi	r20, 0x34	; 52
    7650:	53 e4       	ldi	r21, 0x43	; 67
    7652:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    7656:	6e a7       	std	Y+46, r22	; 0x2e
    7658:	7a ab       	std	Y+50, r23	; 0x32
    765a:	8b ab       	std	Y+51, r24	; 0x33
    765c:	9c ab       	std	Y+52, r25	; 0x34
    765e:	0d cf       	rjmp	.-486    	; 0x747a <PageMotorSpeed+0x106>
		if (Stick & CURSOR_DOWN) Speed1-=5;
		if (Stick & CURSOR_RIGHT) Speed2+=5;
		if (Stick & CURSOR_LEFT) Speed2-=5;	
		if (Stick & CURSOR_PRESS)
		{
			MotorSpeedSet(0,0);
    7660:	60 e0       	ldi	r22, 0x00	; 0
    7662:	70 e0       	ldi	r23, 0x00	; 0
    7664:	80 e0       	ldi	r24, 0x00	; 0
    7666:	90 e0       	ldi	r25, 0x00	; 0
    7668:	0e 94 95 38 	call	0x712a	; 0x712a <MotorSpeedSet>
			vTaskDelay(300);
    766c:	8c e2       	ldi	r24, 0x2C	; 44
    766e:	91 e0       	ldi	r25, 0x01	; 1
    7670:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
			DisableMotorSpeedTask();
    7674:	0e 94 8f 38 	call	0x711e	; 0x711e <DisableMotorSpeedTask>
			DisableMotorPosTask();
    7678:	0e 94 cf 37 	call	0x6f9e	; 0x6f9e <DisableMotorPosTask>
		
		DriverOLEDUpdate();
		
	}
		
}
    767c:	c9 5b       	subi	r28, 0xB9	; 185
    767e:	df 4f       	sbci	r29, 0xFF	; 255
    7680:	cd bf       	out	0x3d, r28	; 61
    7682:	de bf       	out	0x3e, r29	; 62
    7684:	df 91       	pop	r29
    7686:	cf 91       	pop	r28
    7688:	1f 91       	pop	r17
    768a:	0f 91       	pop	r16
    768c:	ff 90       	pop	r15
    768e:	ef 90       	pop	r14
    7690:	df 90       	pop	r13
    7692:	cf 90       	pop	r12
    7694:	bf 90       	pop	r11
    7696:	af 90       	pop	r10
    7698:	9f 90       	pop	r9
    769a:	8f 90       	pop	r8
    769c:	7f 90       	pop	r7
    769e:	6f 90       	pop	r6
    76a0:	5f 90       	pop	r5
    76a2:	4f 90       	pop	r4
    76a4:	3f 90       	pop	r3
    76a6:	2f 90       	pop	r2
    76a8:	08 95       	ret

000076aa <PageADPS9960>:

void PageADPS9960()
{
    76aa:	7f 92       	push	r7
    76ac:	8f 92       	push	r8
    76ae:	9f 92       	push	r9
    76b0:	af 92       	push	r10
    76b2:	bf 92       	push	r11
    76b4:	cf 92       	push	r12
    76b6:	df 92       	push	r13
    76b8:	ef 92       	push	r14
    76ba:	ff 92       	push	r15
    76bc:	0f 93       	push	r16
    76be:	1f 93       	push	r17
    76c0:	cf 93       	push	r28
    76c2:	df 93       	push	r29
    76c4:	cd b7       	in	r28, 0x3d	; 61
    76c6:	de b7       	in	r29, 0x3e	; 62
    76c8:	a8 97       	sbiw	r28, 0x28	; 40
    76ca:	cd bf       	out	0x3d, r28	; 61
    76cc:	de bf       	out	0x3e, r29	; 62
	uint8_t Stick;
	uint16_t C,R,G,B;
	char s[32];
	
	DriverLedSet(0b0010);
    76ce:	82 e0       	ldi	r24, 0x02	; 2
    76d0:	0e 94 9f 06 	call	0xd3e	; 0xd3e <DriverLedSet>
	vTaskDelay(300);
    76d4:	8c e2       	ldi	r24, 0x2C	; 44
    76d6:	91 e0       	ldi	r25, 0x01	; 1
    76d8:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
    76dc:	8e 01       	movw	r16, r28
    76de:	0f 5f       	subi	r16, 0xFF	; 255
    76e0:	1f 4f       	sbci	r17, 0xFF	; 255
		
		DriverOLEDClearScreen();
		
		DriverAdps9960Get(&C,&R,&G,&B);
		
		sprintf(s,"C:%u",C);
    76e2:	89 e9       	ldi	r24, 0x99	; 153
    76e4:	88 2e       	mov	r8, r24
    76e6:	86 e2       	ldi	r24, 0x26	; 38
    76e8:	98 2e       	mov	r9, r24
		DriverOLEDPrintSmText(0,s,0);

		sprintf(s,"R:%u",R);
    76ea:	9e e9       	ldi	r25, 0x9E	; 158
    76ec:	a9 2e       	mov	r10, r25
    76ee:	96 e2       	ldi	r25, 0x26	; 38
    76f0:	b9 2e       	mov	r11, r25
		DriverOLEDPrintSmText(1,s,0);
		
		sprintf(s,"G:%u",G);
    76f2:	23 ea       	ldi	r18, 0xA3	; 163
    76f4:	c2 2e       	mov	r12, r18
    76f6:	26 e2       	ldi	r18, 0x26	; 38
    76f8:	d2 2e       	mov	r13, r18
		DriverOLEDPrintSmText(2,s,0);
		
		sprintf(s,"B:%u",B);
    76fa:	38 ea       	ldi	r19, 0xA8	; 168
    76fc:	e3 2e       	mov	r14, r19
    76fe:	36 e2       	ldi	r19, 0x26	; 38
    7700:	f3 2e       	mov	r15, r19
    7702:	02 c0       	rjmp	.+4      	; 0x7708 <PageADPS9960+0x5e>
			vTaskDelay(300);
			DriverLedClear(0b0010);
			return;
		}
	
		DriverOLEDUpdate();
    7704:	0e 94 0b 0c 	call	0x1816	; 0x1816 <DriverOLEDUpdate>
	
	DriverLedSet(0b0010);
	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    7708:	8c e2       	ldi	r24, 0x2C	; 44
    770a:	91 e0       	ldi	r25, 0x01	; 1
    770c:	0e 94 42 05 	call	0xa84	; 0xa84 <DriverCursorStickGetFifo>
    7710:	78 2e       	mov	r7, r24
		
		
		DriverOLEDClearScreen();
    7712:	0e 94 c6 0c 	call	0x198c	; 0x198c <DriverOLEDClearScreen>
		
		DriverAdps9960Get(&C,&R,&G,&B);
    7716:	9e 01       	movw	r18, r28
    7718:	2f 5d       	subi	r18, 0xDF	; 223
    771a:	3f 4f       	sbci	r19, 0xFF	; 255
    771c:	ae 01       	movw	r20, r28
    771e:	4d 5d       	subi	r20, 0xDD	; 221
    7720:	5f 4f       	sbci	r21, 0xFF	; 255
    7722:	be 01       	movw	r22, r28
    7724:	6b 5d       	subi	r22, 0xDB	; 219
    7726:	7f 4f       	sbci	r23, 0xFF	; 255
    7728:	ce 01       	movw	r24, r28
    772a:	87 96       	adiw	r24, 0x27	; 39
    772c:	0e 94 93 04 	call	0x926	; 0x926 <DriverAdps9960Get>
		
		sprintf(s,"C:%u",C);
    7730:	88 a5       	ldd	r24, Y+40	; 0x28
    7732:	8f 93       	push	r24
    7734:	8f a1       	ldd	r24, Y+39	; 0x27
    7736:	8f 93       	push	r24
    7738:	9f 92       	push	r9
    773a:	8f 92       	push	r8
    773c:	1f 93       	push	r17
    773e:	0f 93       	push	r16
    7740:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    7744:	40 e0       	ldi	r20, 0x00	; 0
    7746:	b8 01       	movw	r22, r16
    7748:	80 e0       	ldi	r24, 0x00	; 0
    774a:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>

		sprintf(s,"R:%u",R);
    774e:	8e a1       	ldd	r24, Y+38	; 0x26
    7750:	8f 93       	push	r24
    7752:	8d a1       	ldd	r24, Y+37	; 0x25
    7754:	8f 93       	push	r24
    7756:	bf 92       	push	r11
    7758:	af 92       	push	r10
    775a:	1f 93       	push	r17
    775c:	0f 93       	push	r16
    775e:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    7762:	40 e0       	ldi	r20, 0x00	; 0
    7764:	b8 01       	movw	r22, r16
    7766:	81 e0       	ldi	r24, 0x01	; 1
    7768:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		
		sprintf(s,"G:%u",G);
    776c:	8c a1       	ldd	r24, Y+36	; 0x24
    776e:	8f 93       	push	r24
    7770:	8b a1       	ldd	r24, Y+35	; 0x23
    7772:	8f 93       	push	r24
    7774:	df 92       	push	r13
    7776:	cf 92       	push	r12
    7778:	1f 93       	push	r17
    777a:	0f 93       	push	r16
    777c:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(2,s,0);
    7780:	40 e0       	ldi	r20, 0x00	; 0
    7782:	b8 01       	movw	r22, r16
    7784:	82 e0       	ldi	r24, 0x02	; 2
    7786:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		
		sprintf(s,"B:%u",B);
    778a:	8a a1       	ldd	r24, Y+34	; 0x22
    778c:	8f 93       	push	r24
    778e:	89 a1       	ldd	r24, Y+33	; 0x21
    7790:	8f 93       	push	r24
    7792:	ff 92       	push	r15
    7794:	ef 92       	push	r14
    7796:	1f 93       	push	r17
    7798:	0f 93       	push	r16
    779a:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(3,s,0);
    779e:	40 e0       	ldi	r20, 0x00	; 0
    77a0:	b8 01       	movw	r22, r16
    77a2:	83 e0       	ldi	r24, 0x03	; 3
    77a4:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		
		if (Stick & CURSOR_UP);
		if (Stick & CURSOR_DOWN);
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
    77a8:	cd bf       	out	0x3d, r28	; 61
    77aa:	de bf       	out	0x3e, r29	; 62
    77ac:	70 fe       	sbrs	r7, 0
    77ae:	aa cf       	rjmp	.-172    	; 0x7704 <PageADPS9960+0x5a>
		{
			vTaskDelay(300);
    77b0:	8c e2       	ldi	r24, 0x2C	; 44
    77b2:	91 e0       	ldi	r25, 0x01	; 1
    77b4:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
			DriverLedClear(0b0010);
    77b8:	82 e0       	ldi	r24, 0x02	; 2
    77ba:	0e 94 af 06 	call	0xd5e	; 0xd5e <DriverLedClear>
		}
	
		DriverOLEDUpdate();
		
	}	
}
    77be:	a8 96       	adiw	r28, 0x28	; 40
    77c0:	cd bf       	out	0x3d, r28	; 61
    77c2:	de bf       	out	0x3e, r29	; 62
    77c4:	df 91       	pop	r29
    77c6:	cf 91       	pop	r28
    77c8:	1f 91       	pop	r17
    77ca:	0f 91       	pop	r16
    77cc:	ff 90       	pop	r15
    77ce:	ef 90       	pop	r14
    77d0:	df 90       	pop	r13
    77d2:	cf 90       	pop	r12
    77d4:	bf 90       	pop	r11
    77d6:	af 90       	pop	r10
    77d8:	9f 90       	pop	r9
    77da:	8f 90       	pop	r8
    77dc:	7f 90       	pop	r7
    77de:	08 95       	ret

000077e0 <PageADC>:

void PageADC()
{
    77e0:	2f 92       	push	r2
    77e2:	3f 92       	push	r3
    77e4:	4f 92       	push	r4
    77e6:	5f 92       	push	r5
    77e8:	6f 92       	push	r6
    77ea:	7f 92       	push	r7
    77ec:	8f 92       	push	r8
    77ee:	9f 92       	push	r9
    77f0:	af 92       	push	r10
    77f2:	bf 92       	push	r11
    77f4:	cf 92       	push	r12
    77f6:	df 92       	push	r13
    77f8:	ef 92       	push	r14
    77fa:	ff 92       	push	r15
    77fc:	0f 93       	push	r16
    77fe:	1f 93       	push	r17
    7800:	cf 93       	push	r28
    7802:	df 93       	push	r29
    7804:	cd b7       	in	r28, 0x3d	; 61
    7806:	de b7       	in	r29, 0x3e	; 62
    7808:	a9 97       	sbiw	r28, 0x29	; 41
    780a:	cd bf       	out	0x3d, r28	; 61
    780c:	de bf       	out	0x3e, r29	; 62
	uint8_t Stick;
	char s[32];
	ADCStruct ADCData;

	vTaskDelay(300);
    780e:	8c e2       	ldi	r24, 0x2C	; 44
    7810:	91 e0       	ldi	r25, 0x01	; 1
    7812:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
    7816:	8e 01       	movw	r16, r28
    7818:	0f 5f       	subi	r16, 0xFF	; 255
    781a:	1f 4f       	sbci	r17, 0xFF	; 255
		
		DriverOLEDClearScreen();
		ADCData=GetADCData();
		

		sprintf(s,"PHOTO1:%d",ADCData.PhotoL);
    781c:	8d ea       	ldi	r24, 0xAD	; 173
    781e:	88 2e       	mov	r8, r24
    7820:	86 e2       	ldi	r24, 0x26	; 38
    7822:	98 2e       	mov	r9, r24
		DriverOLEDPrintSmText(0,s,0);

		sprintf(s,"PHOTO2:%d",ADCData.PhotoM);
    7824:	97 eb       	ldi	r25, 0xB7	; 183
    7826:	a9 2e       	mov	r10, r25
    7828:	96 e2       	ldi	r25, 0x26	; 38
    782a:	b9 2e       	mov	r11, r25
		DriverOLEDPrintSmText(1,s,0);
		
		sprintf(s,"PHOTO3:%d",ADCData.PhotoR);
    782c:	21 ec       	ldi	r18, 0xC1	; 193
    782e:	62 2e       	mov	r6, r18
    7830:	26 e2       	ldi	r18, 0x26	; 38
    7832:	72 2e       	mov	r7, r18
		DriverOLEDPrintSmText(2,s,0);
		
		sprintf(s,"POT:%d",ADCData.Potmeter);
    7834:	3b ec       	ldi	r19, 0xCB	; 203
    7836:	43 2e       	mov	r4, r19
    7838:	36 e2       	ldi	r19, 0x26	; 38
    783a:	53 2e       	mov	r5, r19
		DriverOLEDPrintSmText(3,s,0);
		
		sprintf(s,"DIFF:%d",ADCData.PhotoL-ADCData.PhotoR);	
    783c:	42 ed       	ldi	r20, 0xD2	; 210
    783e:	24 2e       	mov	r2, r20
    7840:	46 e2       	ldi	r20, 0x26	; 38
    7842:	34 2e       	mov	r3, r20
    7844:	02 c0       	rjmp	.+4      	; 0x784a <PageADC+0x6a>
		{
			vTaskDelay(300);
			return;
		}
		
		DriverOLEDUpdate();
    7846:	0e 94 0b 0c 	call	0x1816	; 0x1816 <DriverOLEDUpdate>
	ADCStruct ADCData;

	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    784a:	8c e2       	ldi	r24, 0x2C	; 44
    784c:	91 e0       	ldi	r25, 0x01	; 1
    784e:	0e 94 42 05 	call	0xa84	; 0xa84 <DriverCursorStickGetFifo>
    7852:	89 a7       	std	Y+41, r24	; 0x29
		
		
		DriverOLEDClearScreen();
    7854:	0e 94 c6 0c 	call	0x198c	; 0x198c <DriverOLEDClearScreen>
		ADCData=GetADCData();
    7858:	0e 94 d2 31 	call	0x63a4	; 0x63a4 <GetADCData>
    785c:	29 a3       	std	Y+33, r18	; 0x21
    785e:	3a a3       	std	Y+34, r19	; 0x22
    7860:	4b a3       	std	Y+35, r20	; 0x23
    7862:	5c a3       	std	Y+36, r21	; 0x24
    7864:	6d a3       	std	Y+37, r22	; 0x25
    7866:	7e a3       	std	Y+38, r23	; 0x26
    7868:	8f a3       	std	Y+39, r24	; 0x27
    786a:	98 a7       	std	Y+40, r25	; 0x28
    786c:	e9 a0       	ldd	r14, Y+33	; 0x21
    786e:	fa a0       	ldd	r15, Y+34	; 0x22
    7870:	cd a0       	ldd	r12, Y+37	; 0x25
    7872:	de a0       	ldd	r13, Y+38	; 0x26
		

		sprintf(s,"PHOTO1:%d",ADCData.PhotoL);
    7874:	ff 92       	push	r15
    7876:	ef 92       	push	r14
    7878:	9f 92       	push	r9
    787a:	8f 92       	push	r8
    787c:	1f 93       	push	r17
    787e:	0f 93       	push	r16
    7880:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    7884:	40 e0       	ldi	r20, 0x00	; 0
    7886:	b8 01       	movw	r22, r16
    7888:	80 e0       	ldi	r24, 0x00	; 0
    788a:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>

		sprintf(s,"PHOTO2:%d",ADCData.PhotoM);
    788e:	8c a1       	ldd	r24, Y+36	; 0x24
    7890:	8f 93       	push	r24
    7892:	8b a1       	ldd	r24, Y+35	; 0x23
    7894:	8f 93       	push	r24
    7896:	bf 92       	push	r11
    7898:	af 92       	push	r10
    789a:	1f 93       	push	r17
    789c:	0f 93       	push	r16
    789e:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    78a2:	40 e0       	ldi	r20, 0x00	; 0
    78a4:	b8 01       	movw	r22, r16
    78a6:	81 e0       	ldi	r24, 0x01	; 1
    78a8:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		
		sprintf(s,"PHOTO3:%d",ADCData.PhotoR);
    78ac:	df 92       	push	r13
    78ae:	cf 92       	push	r12
    78b0:	7f 92       	push	r7
    78b2:	6f 92       	push	r6
    78b4:	1f 93       	push	r17
    78b6:	0f 93       	push	r16
    78b8:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(2,s,0);
    78bc:	40 e0       	ldi	r20, 0x00	; 0
    78be:	b8 01       	movw	r22, r16
    78c0:	82 e0       	ldi	r24, 0x02	; 2
    78c2:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		
		sprintf(s,"POT:%d",ADCData.Potmeter);
    78c6:	88 a5       	ldd	r24, Y+40	; 0x28
    78c8:	8f 93       	push	r24
    78ca:	8f a1       	ldd	r24, Y+39	; 0x27
    78cc:	8f 93       	push	r24
    78ce:	5f 92       	push	r5
    78d0:	4f 92       	push	r4
    78d2:	1f 93       	push	r17
    78d4:	0f 93       	push	r16
    78d6:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(3,s,0);
    78da:	40 e0       	ldi	r20, 0x00	; 0
    78dc:	b8 01       	movw	r22, r16
    78de:	83 e0       	ldi	r24, 0x03	; 3
    78e0:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		
		sprintf(s,"DIFF:%d",ADCData.PhotoL-ADCData.PhotoR);	
    78e4:	ec 18       	sub	r14, r12
    78e6:	fd 08       	sbc	r15, r13
    78e8:	ff 92       	push	r15
    78ea:	ef 92       	push	r14
    78ec:	3f 92       	push	r3
    78ee:	2f 92       	push	r2
    78f0:	1f 93       	push	r17
    78f2:	0f 93       	push	r16
    78f4:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(5,s,0);
    78f8:	40 e0       	ldi	r20, 0x00	; 0
    78fa:	b8 01       	movw	r22, r16
    78fc:	85 e0       	ldi	r24, 0x05	; 5
    78fe:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		
		if (Stick & CURSOR_UP);
		if (Stick & CURSOR_DOWN);
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
    7902:	cd bf       	out	0x3d, r28	; 61
    7904:	de bf       	out	0x3e, r29	; 62
    7906:	99 a5       	ldd	r25, Y+41	; 0x29
    7908:	90 ff       	sbrs	r25, 0
    790a:	9d cf       	rjmp	.-198    	; 0x7846 <PageADC+0x66>
		{
			vTaskDelay(300);
    790c:	8c e2       	ldi	r24, 0x2C	; 44
    790e:	91 e0       	ldi	r25, 0x01	; 1
    7910:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
		}
		
		DriverOLEDUpdate();
		
	}
}
    7914:	a9 96       	adiw	r28, 0x29	; 41
    7916:	cd bf       	out	0x3d, r28	; 61
    7918:	de bf       	out	0x3e, r29	; 62
    791a:	df 91       	pop	r29
    791c:	cf 91       	pop	r28
    791e:	1f 91       	pop	r17
    7920:	0f 91       	pop	r16
    7922:	ff 90       	pop	r15
    7924:	ef 90       	pop	r14
    7926:	df 90       	pop	r13
    7928:	cf 90       	pop	r12
    792a:	bf 90       	pop	r11
    792c:	af 90       	pop	r10
    792e:	9f 90       	pop	r9
    7930:	8f 90       	pop	r8
    7932:	7f 90       	pop	r7
    7934:	6f 90       	pop	r6
    7936:	5f 90       	pop	r5
    7938:	4f 90       	pop	r4
    793a:	3f 90       	pop	r3
    793c:	2f 90       	pop	r2
    793e:	08 95       	ret

00007940 <PageLineFollowSpeed>:

void PageLineFollowSpeed()
{
    7940:	cf 93       	push	r28
		uint8_t Stick;
		char s[32];
		
		EnableMotorPosTask();
    7942:	0e 94 b6 37 	call	0x6f6c	; 0x6f6c <EnableMotorPosTask>
		EnableMotorSpeedTask();
    7946:	0e 94 83 38 	call	0x7106	; 0x7106 <EnableMotorSpeedTask>
		StartLineFollower(40.0);
    794a:	60 e0       	ldi	r22, 0x00	; 0
    794c:	70 e0       	ldi	r23, 0x00	; 0
    794e:	80 e2       	ldi	r24, 0x20	; 32
    7950:	92 e4       	ldi	r25, 0x42	; 66
    7952:	0e 94 8d 33 	call	0x671a	; 0x671a <StartLineFollower>
		vTaskDelay(300);
    7956:	8c e2       	ldi	r24, 0x2C	; 44
    7958:	91 e0       	ldi	r25, 0x01	; 1
    795a:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
    795e:	02 c0       	rjmp	.+4      	; 0x7964 <PageLineFollowSpeed+0x24>
						
				vTaskDelay(300);
				return;
			}
			
			DriverOLEDUpdate();
    7960:	0e 94 0b 0c 	call	0x1816	; 0x1816 <DriverOLEDUpdate>
		EnableMotorSpeedTask();
		StartLineFollower(40.0);
		vTaskDelay(300);
		while (1)
		{
			Stick=DriverCursorStickGetFifo(300);
    7964:	8c e2       	ldi	r24, 0x2C	; 44
    7966:	91 e0       	ldi	r25, 0x01	; 1
    7968:	0e 94 42 05 	call	0xa84	; 0xa84 <DriverCursorStickGetFifo>
    796c:	c8 2f       	mov	r28, r24
					
			DriverOLEDClearScreen();
    796e:	0e 94 c6 0c 	call	0x198c	; 0x198c <DriverOLEDClearScreen>
		
			DriverOLEDPrintSmText(0,"Line follower active",0);
    7972:	40 e0       	ldi	r20, 0x00	; 0
    7974:	6a ed       	ldi	r22, 0xDA	; 218
    7976:	76 e2       	ldi	r23, 0x26	; 38
    7978:	80 e0       	ldi	r24, 0x00	; 0
    797a:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
			
			if (Stick & CURSOR_UP);
			if (Stick & CURSOR_DOWN);
			if (Stick & CURSOR_RIGHT);
			if (Stick & CURSOR_LEFT);
			if (Stick & CURSOR_PRESS)
    797e:	c0 ff       	sbrs	r28, 0
    7980:	ef cf       	rjmp	.-34     	; 0x7960 <PageLineFollowSpeed+0x20>
			{
				StopLineFollower();
    7982:	0e 94 a0 33 	call	0x6740	; 0x6740 <StopLineFollower>
				DisableMotorSpeedTask();
    7986:	0e 94 8f 38 	call	0x711e	; 0x711e <DisableMotorSpeedTask>
				DisableMotorPosTask();
    798a:	0e 94 cf 37 	call	0x6f9e	; 0x6f9e <DisableMotorPosTask>
						
				vTaskDelay(300);
    798e:	8c e2       	ldi	r24, 0x2C	; 44
    7990:	91 e0       	ldi	r25, 0x01	; 1
				return;
			}
			
			DriverOLEDUpdate();
		}	
}
    7992:	cf 91       	pop	r28
			{
				StopLineFollower();
				DisableMotorSpeedTask();
				DisableMotorPosTask();
						
				vTaskDelay(300);
    7994:	0c 94 87 2a 	jmp	0x550e	; 0x550e <vTaskDelay>

00007998 <PageLineFollowDirect>:
			DriverOLEDUpdate();
		}	
}

void PageLineFollowDirect()
{
    7998:	cf 93       	push	r28
	uint8_t Stick;
	char s[32];

	EnableLineFollowerDirectTask();
    799a:	0e 94 c9 32 	call	0x6592	; 0x6592 <EnableLineFollowerDirectTask>
	vTaskDelay(300);
    799e:	8c e2       	ldi	r24, 0x2C	; 44
    79a0:	91 e0       	ldi	r25, 0x01	; 1
    79a2:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
    79a6:	02 c0       	rjmp	.+4      	; 0x79ac <PageLineFollowDirect+0x14>
			vTaskDelay(300);
			DisableLineFollowerDirectTask();
			return;
		}
		
		DriverOLEDUpdate();
    79a8:	0e 94 0b 0c 	call	0x1816	; 0x1816 <DriverOLEDUpdate>

	EnableLineFollowerDirectTask();
	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    79ac:	8c e2       	ldi	r24, 0x2C	; 44
    79ae:	91 e0       	ldi	r25, 0x01	; 1
    79b0:	0e 94 42 05 	call	0xa84	; 0xa84 <DriverCursorStickGetFifo>
    79b4:	c8 2f       	mov	r28, r24
		
		DriverOLEDClearScreen();
    79b6:	0e 94 c6 0c 	call	0x198c	; 0x198c <DriverOLEDClearScreen>
		
		DriverOLEDPrintSmText(0,"Line follower active",0);
    79ba:	40 e0       	ldi	r20, 0x00	; 0
    79bc:	6a ed       	ldi	r22, 0xDA	; 218
    79be:	76 e2       	ldi	r23, 0x26	; 38
    79c0:	80 e0       	ldi	r24, 0x00	; 0
    79c2:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		
		if (Stick & CURSOR_UP);
		if (Stick & CURSOR_DOWN);
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
    79c6:	c0 ff       	sbrs	r28, 0
    79c8:	ef cf       	rjmp	.-34     	; 0x79a8 <PageLineFollowDirect+0x10>
		{
			vTaskDelay(300);
    79ca:	8c e2       	ldi	r24, 0x2C	; 44
    79cc:	91 e0       	ldi	r25, 0x01	; 1
    79ce:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
			return;
		}
		
		DriverOLEDUpdate();
	}
}
    79d2:	cf 91       	pop	r28
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
		{
			vTaskDelay(300);
			DisableLineFollowerDirectTask();
    79d4:	0c 94 cf 32 	jmp	0x659e	; 0x659e <DisableLineFollowerDirectTask>

000079d8 <PageRGB>:
		DriverOLEDUpdate();
	}
}

void PageRGB()
{
    79d8:	ef 92       	push	r14
    79da:	ff 92       	push	r15
    79dc:	0f 93       	push	r16
    79de:	1f 93       	push	r17
    79e0:	cf 93       	push	r28
    79e2:	df 93       	push	r29
	uint8_t BlinkLeft=0;
	uint8_t BlinkRight=0;
	uint8_t Brake=0;
	uint8_t Effect=0;

	vTaskDelay(300);
    79e4:	8c e2       	ldi	r24, 0x2C	; 44
    79e6:	91 e0       	ldi	r25, 0x01	; 1
    79e8:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
	uint8_t Stick;
	uint8_t Light=0;
	uint8_t BlinkLeft=0;
	uint8_t BlinkRight=0;
	uint8_t Brake=0;
	uint8_t Effect=0;
    79ec:	d0 e0       	ldi	r29, 0x00	; 0
{
	uint8_t Stick;
	uint8_t Light=0;
	uint8_t BlinkLeft=0;
	uint8_t BlinkRight=0;
	uint8_t Brake=0;
    79ee:	e1 2c       	mov	r14, r1
void PageRGB()
{
	uint8_t Stick;
	uint8_t Light=0;
	uint8_t BlinkLeft=0;
	uint8_t BlinkRight=0;
    79f0:	f1 2c       	mov	r15, r1

void PageRGB()
{
	uint8_t Stick;
	uint8_t Light=0;
	uint8_t BlinkLeft=0;
    79f2:	00 e0       	ldi	r16, 0x00	; 0
}

void PageRGB()
{
	uint8_t Stick;
	uint8_t Light=0;
    79f4:	10 e0       	ldi	r17, 0x00	; 0
    79f6:	11 c0       	rjmp	.+34     	; 0x7a1a <PageRGB+0x42>
			vTaskDelay(300);
			return;
		}
		
		if (Light==0) Effect=RGB_NONE;
		if (Light==1) Effect=RGB_HEADLIGHT_LOW;
    79f8:	11 30       	cpi	r17, 0x01	; 1
    79fa:	09 f0       	breq	.+2      	; 0x79fe <PageRGB+0x26>
    79fc:	4d c0       	rjmp	.+154    	; 0x7a98 <PageRGB+0xc0>
    79fe:	d1 e0       	ldi	r29, 0x01	; 1
		if (Light==2) Effect=RGB_HEADLIGHT_HIGH;
		if (Brake==1) Effect|=RGB_BRAKE;
    7a00:	81 e0       	ldi	r24, 0x01	; 1
    7a02:	e8 16       	cp	r14, r24
    7a04:	09 f4       	brne	.+2      	; 0x7a08 <PageRGB+0x30>
    7a06:	44 c0       	rjmp	.+136    	; 0x7a90 <PageRGB+0xb8>
		if (BlinkLeft) Effect|=RGB_BLINK_LEFT;
    7a08:	01 11       	cpse	r16, r1
    7a0a:	d4 60       	ori	r29, 0x04	; 4
		if (BlinkRight) Effect|=RGB_BLINK_RIGHT;
    7a0c:	f1 10       	cpse	r15, r1
    7a0e:	d8 60       	ori	r29, 0x08	; 8
		SetRGB(Effect);
    7a10:	8d 2f       	mov	r24, r29
    7a12:	0e 94 26 3f 	call	0x7e4c	; 0x7e4c <SetRGB>
		
		DriverOLEDUpdate();
    7a16:	0e 94 0b 0c 	call	0x1816	; 0x1816 <DriverOLEDUpdate>
	uint8_t Effect=0;

	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    7a1a:	8c e2       	ldi	r24, 0x2C	; 44
    7a1c:	91 e0       	ldi	r25, 0x01	; 1
    7a1e:	0e 94 42 05 	call	0xa84	; 0xa84 <DriverCursorStickGetFifo>
    7a22:	c8 2f       	mov	r28, r24
		
		DriverOLEDClearScreen();
    7a24:	0e 94 c6 0c 	call	0x198c	; 0x198c <DriverOLEDClearScreen>
		
		DriverOLEDPrintSmText(0,"Left:toggle blink",0);
    7a28:	40 e0       	ldi	r20, 0x00	; 0
    7a2a:	6f ee       	ldi	r22, 0xEF	; 239
    7a2c:	76 e2       	ldi	r23, 0x26	; 38
    7a2e:	80 e0       	ldi	r24, 0x00	; 0
    7a30:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		DriverOLEDPrintSmText(1,"Right:toggle blink",0);
    7a34:	40 e0       	ldi	r20, 0x00	; 0
    7a36:	61 e0       	ldi	r22, 0x01	; 1
    7a38:	77 e2       	ldi	r23, 0x27	; 39
    7a3a:	81 e0       	ldi	r24, 0x01	; 1
    7a3c:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		DriverOLEDPrintSmText(2,"Down:toggle brake",0);
    7a40:	40 e0       	ldi	r20, 0x00	; 0
    7a42:	64 e1       	ldi	r22, 0x14	; 20
    7a44:	77 e2       	ldi	r23, 0x27	; 39
    7a46:	82 e0       	ldi	r24, 0x02	; 2
    7a48:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		DriverOLEDPrintSmText(3,"Up:toggle light",0);		
    7a4c:	40 e0       	ldi	r20, 0x00	; 0
    7a4e:	66 e2       	ldi	r22, 0x26	; 38
    7a50:	77 e2       	ldi	r23, 0x27	; 39
    7a52:	83 e0       	ldi	r24, 0x03	; 3
    7a54:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>


		
		if (Stick & CURSOR_UP)
    7a58:	c4 ff       	sbrs	r28, 4
    7a5a:	06 c0       	rjmp	.+12     	; 0x7a68 <PageRGB+0x90>
		{
			if (Light==0) Light=1;
    7a5c:	11 23       	and	r17, r17
    7a5e:	d1 f0       	breq	.+52     	; 0x7a94 <PageRGB+0xbc>
			else if (Light==1) Light=2;
    7a60:	11 30       	cpi	r17, 0x01	; 1
    7a62:	49 f1       	breq	.+82     	; 0x7ab6 <PageRGB+0xde>
			else if (Light==2) Light=0;
    7a64:	12 30       	cpi	r17, 0x02	; 2
    7a66:	49 f1       	breq	.+82     	; 0x7aba <PageRGB+0xe2>
		}
		if (Stick & CURSOR_DOWN)
    7a68:	c2 ff       	sbrs	r28, 2
    7a6a:	02 c0       	rjmp	.+4      	; 0x7a70 <PageRGB+0x98>
    7a6c:	81 e0       	ldi	r24, 0x01	; 1
    7a6e:	e8 26       	eor	r14, r24
		{
			if (Brake==0) Brake=1;
			else Brake=0;
		}
		if (Stick & CURSOR_RIGHT)
    7a70:	c1 ff       	sbrs	r28, 1
    7a72:	02 c0       	rjmp	.+4      	; 0x7a78 <PageRGB+0xa0>
    7a74:	81 e0       	ldi	r24, 0x01	; 1
    7a76:	f8 26       	eor	r15, r24
		{
			if (BlinkRight==0) BlinkRight=1;
			else BlinkRight=0;
		}
		if (Stick & CURSOR_LEFT)
    7a78:	c3 ff       	sbrs	r28, 3
    7a7a:	02 c0       	rjmp	.+4      	; 0x7a80 <PageRGB+0xa8>
    7a7c:	81 e0       	ldi	r24, 0x01	; 1
    7a7e:	08 27       	eor	r16, r24
		{
			if (BlinkLeft==0) BlinkLeft=1;
			else BlinkLeft=0;
		}
		if (Stick & CURSOR_PRESS)
    7a80:	c0 fd       	sbrc	r28, 0
    7a82:	0f c0       	rjmp	.+30     	; 0x7aa2 <PageRGB+0xca>
		{
			vTaskDelay(300);
			return;
		}
		
		if (Light==0) Effect=RGB_NONE;
    7a84:	11 11       	cpse	r17, r1
    7a86:	b8 cf       	rjmp	.-144    	; 0x79f8 <PageRGB+0x20>
    7a88:	d0 e0       	ldi	r29, 0x00	; 0
		if (Light==1) Effect=RGB_HEADLIGHT_LOW;
		if (Light==2) Effect=RGB_HEADLIGHT_HIGH;
		if (Brake==1) Effect|=RGB_BRAKE;
    7a8a:	81 e0       	ldi	r24, 0x01	; 1
    7a8c:	e8 12       	cpse	r14, r24
    7a8e:	bc cf       	rjmp	.-136    	; 0x7a08 <PageRGB+0x30>
    7a90:	d0 61       	ori	r29, 0x10	; 16
    7a92:	ba cf       	rjmp	.-140    	; 0x7a08 <PageRGB+0x30>


		
		if (Stick & CURSOR_UP)
		{
			if (Light==0) Light=1;
    7a94:	11 e0       	ldi	r17, 0x01	; 1
    7a96:	e8 cf       	rjmp	.-48     	; 0x7a68 <PageRGB+0x90>
			return;
		}
		
		if (Light==0) Effect=RGB_NONE;
		if (Light==1) Effect=RGB_HEADLIGHT_LOW;
		if (Light==2) Effect=RGB_HEADLIGHT_HIGH;
    7a98:	12 30       	cpi	r17, 0x02	; 2
    7a9a:	09 f0       	breq	.+2      	; 0x7a9e <PageRGB+0xc6>
    7a9c:	b1 cf       	rjmp	.-158    	; 0x7a00 <PageRGB+0x28>
    7a9e:	d2 e0       	ldi	r29, 0x02	; 2
    7aa0:	af cf       	rjmp	.-162    	; 0x7a00 <PageRGB+0x28>
			if (BlinkLeft==0) BlinkLeft=1;
			else BlinkLeft=0;
		}
		if (Stick & CURSOR_PRESS)
		{
			vTaskDelay(300);
    7aa2:	8c e2       	ldi	r24, 0x2C	; 44
    7aa4:	91 e0       	ldi	r25, 0x01	; 1
		
		DriverOLEDUpdate();

		
	}	
}
    7aa6:	df 91       	pop	r29
    7aa8:	cf 91       	pop	r28
    7aaa:	1f 91       	pop	r17
    7aac:	0f 91       	pop	r16
    7aae:	ff 90       	pop	r15
    7ab0:	ef 90       	pop	r14
			if (BlinkLeft==0) BlinkLeft=1;
			else BlinkLeft=0;
		}
		if (Stick & CURSOR_PRESS)
		{
			vTaskDelay(300);
    7ab2:	0c 94 87 2a 	jmp	0x550e	; 0x550e <vTaskDelay>

		
		if (Stick & CURSOR_UP)
		{
			if (Light==0) Light=1;
			else if (Light==1) Light=2;
    7ab6:	12 e0       	ldi	r17, 0x02	; 2
    7ab8:	d7 cf       	rjmp	.-82     	; 0x7a68 <PageRGB+0x90>
			else if (Light==2) Light=0;
    7aba:	10 e0       	ldi	r17, 0x00	; 0
    7abc:	d5 cf       	rjmp	.-86     	; 0x7a68 <PageRGB+0x90>

00007abe <PageGyro>:
		
	}	
}

void PageGyro()
{
    7abe:	bf 92       	push	r11
    7ac0:	cf 92       	push	r12
    7ac2:	df 92       	push	r13
    7ac4:	ef 92       	push	r14
    7ac6:	ff 92       	push	r15
    7ac8:	0f 93       	push	r16
    7aca:	1f 93       	push	r17
    7acc:	cf 93       	push	r28
    7ace:	df 93       	push	r29
    7ad0:	cd b7       	in	r28, 0x3d	; 61
    7ad2:	de b7       	in	r29, 0x3e	; 62
    7ad4:	a8 97       	sbiw	r28, 0x28	; 40
    7ad6:	cd bf       	out	0x3d, r28	; 61
    7ad8:	de bf       	out	0x3e, r29	; 62
	uint8_t Stick;
	int16_t x,y,z;
	char s[32];
	float Yaw,YawRate;
	
	vTaskDelay(300);
    7ada:	8c e2       	ldi	r24, 0x2C	; 44
    7adc:	91 e0       	ldi	r25, 0x01	; 1
    7ade:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
    7ae2:	8e 01       	movw	r16, r28
    7ae4:	0f 5f       	subi	r16, 0xFF	; 255
    7ae6:	1f 4f       	sbci	r17, 0xFF	; 255
		
		DriverOLEDClearScreen();
		
		GyroGet(&YawRate,&Yaw);
		
		sprintf(s,"Yaw:%f",Yaw);
    7ae8:	86 e3       	ldi	r24, 0x36	; 54
    7aea:	c8 2e       	mov	r12, r24
    7aec:	87 e2       	ldi	r24, 0x27	; 39
    7aee:	d8 2e       	mov	r13, r24
		DriverOLEDPrintSmText(0,s,0);

		sprintf(s,"YawRate:%f",YawRate);
    7af0:	9d e3       	ldi	r25, 0x3D	; 61
    7af2:	e9 2e       	mov	r14, r25
    7af4:	97 e2       	ldi	r25, 0x27	; 39
    7af6:	f9 2e       	mov	r15, r25
    7af8:	02 c0       	rjmp	.+4      	; 0x7afe <PageGyro+0x40>
		{
			vTaskDelay(300);
			return;
		}
		
		DriverOLEDUpdate();
    7afa:	0e 94 0b 0c 	call	0x1816	; 0x1816 <DriverOLEDUpdate>
	float Yaw,YawRate;
	
	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    7afe:	8c e2       	ldi	r24, 0x2C	; 44
    7b00:	91 e0       	ldi	r25, 0x01	; 1
    7b02:	0e 94 42 05 	call	0xa84	; 0xa84 <DriverCursorStickGetFifo>
    7b06:	b8 2e       	mov	r11, r24
		
		
		DriverOLEDClearScreen();
    7b08:	0e 94 c6 0c 	call	0x198c	; 0x198c <DriverOLEDClearScreen>
		
		GyroGet(&YawRate,&Yaw);
    7b0c:	be 01       	movw	r22, r28
    7b0e:	6b 5d       	subi	r22, 0xDB	; 219
    7b10:	7f 4f       	sbci	r23, 0xFF	; 255
    7b12:	ce 01       	movw	r24, r28
    7b14:	81 96       	adiw	r24, 0x21	; 33
    7b16:	0e 94 fb 31 	call	0x63f6	; 0x63f6 <GyroGet>
		
		sprintf(s,"Yaw:%f",Yaw);
    7b1a:	88 a5       	ldd	r24, Y+40	; 0x28
    7b1c:	8f 93       	push	r24
    7b1e:	8f a1       	ldd	r24, Y+39	; 0x27
    7b20:	8f 93       	push	r24
    7b22:	8e a1       	ldd	r24, Y+38	; 0x26
    7b24:	8f 93       	push	r24
    7b26:	8d a1       	ldd	r24, Y+37	; 0x25
    7b28:	8f 93       	push	r24
    7b2a:	df 92       	push	r13
    7b2c:	cf 92       	push	r12
    7b2e:	1f 93       	push	r17
    7b30:	0f 93       	push	r16
    7b32:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    7b36:	40 e0       	ldi	r20, 0x00	; 0
    7b38:	b8 01       	movw	r22, r16
    7b3a:	80 e0       	ldi	r24, 0x00	; 0
    7b3c:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>

		sprintf(s,"YawRate:%f",YawRate);
    7b40:	8c a1       	ldd	r24, Y+36	; 0x24
    7b42:	8f 93       	push	r24
    7b44:	8b a1       	ldd	r24, Y+35	; 0x23
    7b46:	8f 93       	push	r24
    7b48:	8a a1       	ldd	r24, Y+34	; 0x22
    7b4a:	8f 93       	push	r24
    7b4c:	89 a1       	ldd	r24, Y+33	; 0x21
    7b4e:	8f 93       	push	r24
    7b50:	ff 92       	push	r15
    7b52:	ef 92       	push	r14
    7b54:	1f 93       	push	r17
    7b56:	0f 93       	push	r16
    7b58:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(1,s,0);
    7b5c:	40 e0       	ldi	r20, 0x00	; 0
    7b5e:	b8 01       	movw	r22, r16
    7b60:	81 e0       	ldi	r24, 0x01	; 1
    7b62:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		
		if (Stick & CURSOR_UP);
		if (Stick & CURSOR_DOWN);
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
    7b66:	cd bf       	out	0x3d, r28	; 61
    7b68:	de bf       	out	0x3e, r29	; 62
    7b6a:	b0 fe       	sbrs	r11, 0
    7b6c:	c6 cf       	rjmp	.-116    	; 0x7afa <PageGyro+0x3c>
		{
			vTaskDelay(300);
    7b6e:	8c e2       	ldi	r24, 0x2C	; 44
    7b70:	91 e0       	ldi	r25, 0x01	; 1
    7b72:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
		}
		
		DriverOLEDUpdate();
		
	}
}
    7b76:	a8 96       	adiw	r28, 0x28	; 40
    7b78:	cd bf       	out	0x3d, r28	; 61
    7b7a:	de bf       	out	0x3e, r29	; 62
    7b7c:	df 91       	pop	r29
    7b7e:	cf 91       	pop	r28
    7b80:	1f 91       	pop	r17
    7b82:	0f 91       	pop	r16
    7b84:	ff 90       	pop	r15
    7b86:	ef 90       	pop	r14
    7b88:	df 90       	pop	r13
    7b8a:	cf 90       	pop	r12
    7b8c:	bf 90       	pop	r11
    7b8e:	08 95       	ret

00007b90 <PageRanger>:

void PageRanger()
{
    7b90:	df 92       	push	r13
    7b92:	ef 92       	push	r14
    7b94:	ff 92       	push	r15
    7b96:	0f 93       	push	r16
    7b98:	1f 93       	push	r17
    7b9a:	cf 93       	push	r28
    7b9c:	df 93       	push	r29
    7b9e:	cd b7       	in	r28, 0x3d	; 61
    7ba0:	de b7       	in	r29, 0x3e	; 62
    7ba2:	a0 97       	sbiw	r28, 0x20	; 32
    7ba4:	cd bf       	out	0x3d, r28	; 61
    7ba6:	de bf       	out	0x3e, r29	; 62
	uint8_t Stick;
	uint16_t Distance;
	char s[32];
	
	vTaskDelay(300);
    7ba8:	8c e2       	ldi	r24, 0x2C	; 44
    7baa:	91 e0       	ldi	r25, 0x01	; 1
    7bac:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
    7bb0:	ce 01       	movw	r24, r28
    7bb2:	01 96       	adiw	r24, 0x01	; 1
    7bb4:	7c 01       	movw	r14, r24
		
		DriverOLEDClearScreen();
		
		Distance=DriverVL53L0XReadSingle();
		
		sprintf(s,"Range:%u",Distance);
    7bb6:	08 e4       	ldi	r16, 0x48	; 72
    7bb8:	17 e2       	ldi	r17, 0x27	; 39
    7bba:	02 c0       	rjmp	.+4      	; 0x7bc0 <PageRanger+0x30>
		{
			vTaskDelay(300);
			return;
		}
		
		DriverOLEDUpdate();
    7bbc:	0e 94 0b 0c 	call	0x1816	; 0x1816 <DriverOLEDUpdate>
	char s[32];
	
	vTaskDelay(300);
	while (1)
	{
		Stick=DriverCursorStickGetFifo(300);
    7bc0:	8c e2       	ldi	r24, 0x2C	; 44
    7bc2:	91 e0       	ldi	r25, 0x01	; 1
    7bc4:	0e 94 42 05 	call	0xa84	; 0xa84 <DriverCursorStickGetFifo>
    7bc8:	d8 2e       	mov	r13, r24
		
		
		DriverOLEDClearScreen();
    7bca:	0e 94 c6 0c 	call	0x198c	; 0x198c <DriverOLEDClearScreen>
		
		Distance=DriverVL53L0XReadSingle();
    7bce:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <DriverVL53L0XReadSingle>
		
		sprintf(s,"Range:%u",Distance);
    7bd2:	9f 93       	push	r25
    7bd4:	8f 93       	push	r24
    7bd6:	1f 93       	push	r17
    7bd8:	0f 93       	push	r16
    7bda:	ff 92       	push	r15
    7bdc:	ef 92       	push	r14
    7bde:	0e 94 c4 4d 	call	0x9b88	; 0x9b88 <sprintf>
		DriverOLEDPrintSmText(0,s,0);
    7be2:	40 e0       	ldi	r20, 0x00	; 0
    7be4:	b7 01       	movw	r22, r14
    7be6:	80 e0       	ldi	r24, 0x00	; 0
    7be8:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <DriverOLEDPrintSmText>
		
		if (Stick & CURSOR_UP);
		if (Stick & CURSOR_DOWN);
		if (Stick & CURSOR_RIGHT);
		if (Stick & CURSOR_LEFT);
		if (Stick & CURSOR_PRESS)
    7bec:	0f 90       	pop	r0
    7bee:	0f 90       	pop	r0
    7bf0:	0f 90       	pop	r0
    7bf2:	0f 90       	pop	r0
    7bf4:	0f 90       	pop	r0
    7bf6:	0f 90       	pop	r0
    7bf8:	d0 fe       	sbrs	r13, 0
    7bfa:	e0 cf       	rjmp	.-64     	; 0x7bbc <PageRanger+0x2c>
		{
			vTaskDelay(300);
    7bfc:	8c e2       	ldi	r24, 0x2C	; 44
    7bfe:	91 e0       	ldi	r25, 0x01	; 1
    7c00:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
		}
		
		DriverOLEDUpdate();
		
	}
    7c04:	a0 96       	adiw	r28, 0x20	; 32
    7c06:	cd bf       	out	0x3d, r28	; 61
    7c08:	de bf       	out	0x3e, r29	; 62
    7c0a:	df 91       	pop	r29
    7c0c:	cf 91       	pop	r28
    7c0e:	1f 91       	pop	r17
    7c10:	0f 91       	pop	r16
    7c12:	ff 90       	pop	r15
    7c14:	ef 90       	pop	r14
    7c16:	df 90       	pop	r13
    7c18:	08 95       	ret

00007c1a <WorkerOLEDMenu>:
{
	uint8_t Stick;
	
	while(1)
	{
		Stick=DriverCursorStickGetFifo(300);
    7c1a:	8c e2       	ldi	r24, 0x2C	; 44
    7c1c:	91 e0       	ldi	r25, 0x01	; 1
    7c1e:	0e 94 42 05 	call	0xa84	; 0xa84 <DriverCursorStickGetFifo>
}


void DownMenu()
{
	if (SelItem<NUM_LINES-1) SelItem++;
    7c22:	60 91 71 2d 	lds	r22, 0x2D71	; 0x802d71 <SelItem>
	uint8_t Stick;
	
	while(1)
	{
		Stick=DriverCursorStickGetFifo(300);
		if (Stick & CURSOR_DOWN) DownMenu();
    7c26:	82 ff       	sbrs	r24, 2
    7c28:	1f c0       	rjmp	.+62     	; 0x7c68 <WorkerOLEDMenu+0x4e>
}


void DownMenu()
{
	if (SelItem<NUM_LINES-1) SelItem++;
    7c2a:	69 30       	cpi	r22, 0x09	; 9
    7c2c:	18 f4       	brcc	.+6      	; 0x7c34 <WorkerOLEDMenu+0x1a>
    7c2e:	6f 5f       	subi	r22, 0xFF	; 255
    7c30:	60 93 71 2d 	sts	0x2D71, r22	; 0x802d71 <SelItem>
	if (SelItem>=TopItem+DISPLAYED_LINES) TopItem++;
    7c34:	20 91 72 2d 	lds	r18, 0x2D72	; 0x802d72 <TopItem>
    7c38:	82 2f       	mov	r24, r18
    7c3a:	90 e0       	ldi	r25, 0x00	; 0
    7c3c:	70 e0       	ldi	r23, 0x00	; 0
    7c3e:	ac 01       	movw	r20, r24
    7c40:	4b 5f       	subi	r20, 0xFB	; 251
    7c42:	5f 4f       	sbci	r21, 0xFF	; 255
    7c44:	46 17       	cp	r20, r22
    7c46:	57 07       	cpc	r21, r23
    7c48:	2c f4       	brge	.+10     	; 0x7c54 <WorkerOLEDMenu+0x3a>
    7c4a:	2f 5f       	subi	r18, 0xFF	; 255
    7c4c:	20 93 72 2d 	sts	0x2D72, r18	; 0x802d72 <TopItem>
    7c50:	82 2f       	mov	r24, r18
    7c52:	90 e0       	ldi	r25, 0x00	; 0
			else if (SelItem==7) PageGyro();	
			else if (SelItem==8) PageRanger();
			else if (SelItem==9) configASSERT(false); //Force halt
		}
		
		DrawMenu(TopItem,SelItem);
    7c54:	0e 94 b9 38 	call	0x7172	; 0x7172 <DrawMenu>
{
	uint8_t Stick;
	
	while(1)
	{
		Stick=DriverCursorStickGetFifo(300);
    7c58:	8c e2       	ldi	r24, 0x2C	; 44
    7c5a:	91 e0       	ldi	r25, 0x01	; 1
    7c5c:	0e 94 42 05 	call	0xa84	; 0xa84 <DriverCursorStickGetFifo>
}


void DownMenu()
{
	if (SelItem<NUM_LINES-1) SelItem++;
    7c60:	60 91 71 2d 	lds	r22, 0x2D71	; 0x802d71 <SelItem>
	uint8_t Stick;
	
	while(1)
	{
		Stick=DriverCursorStickGetFifo(300);
		if (Stick & CURSOR_DOWN) DownMenu();
    7c64:	82 fd       	sbrc	r24, 2
    7c66:	e1 cf       	rjmp	.-62     	; 0x7c2a <WorkerOLEDMenu+0x10>
		else if (Stick & CURSOR_UP) UpMenu();
    7c68:	84 ff       	sbrs	r24, 4
    7c6a:	10 c0       	rjmp	.+32     	; 0x7c8c <WorkerOLEDMenu+0x72>
	if (SelItem>=TopItem+DISPLAYED_LINES) TopItem++;
}

void UpMenu()
{
	if (SelItem>0) SelItem--;
    7c6c:	66 23       	and	r22, r22
    7c6e:	19 f0       	breq	.+6      	; 0x7c76 <WorkerOLEDMenu+0x5c>
    7c70:	61 50       	subi	r22, 0x01	; 1
    7c72:	60 93 71 2d 	sts	0x2D71, r22	; 0x802d71 <SelItem>
	if (SelItem<TopItem) TopItem=SelItem;
    7c76:	80 91 72 2d 	lds	r24, 0x2D72	; 0x802d72 <TopItem>
    7c7a:	68 17       	cp	r22, r24
    7c7c:	60 f5       	brcc	.+88     	; 0x7cd6 <WorkerOLEDMenu+0xbc>
    7c7e:	60 93 72 2d 	sts	0x2D72, r22	; 0x802d72 <TopItem>
    7c82:	70 e0       	ldi	r23, 0x00	; 0
    7c84:	cb 01       	movw	r24, r22
			else if (SelItem==7) PageGyro();	
			else if (SelItem==8) PageRanger();
			else if (SelItem==9) configASSERT(false); //Force halt
		}
		
		DrawMenu(TopItem,SelItem);
    7c86:	0e 94 b9 38 	call	0x7172	; 0x7172 <DrawMenu>
    7c8a:	e6 cf       	rjmp	.-52     	; 0x7c58 <WorkerOLEDMenu+0x3e>
	while(1)
	{
		Stick=DriverCursorStickGetFifo(300);
		if (Stick & CURSOR_DOWN) DownMenu();
		else if (Stick & CURSOR_UP) UpMenu();
		else if (Stick & CURSOR_PRESS)
    7c8c:	80 ff       	sbrs	r24, 0
    7c8e:	1c c0       	rjmp	.+56     	; 0x7cc8 <WorkerOLEDMenu+0xae>
		{
			if (SelItem==0) PageCPUStatus();
    7c90:	66 23       	and	r22, r22
    7c92:	49 f1       	breq	.+82     	; 0x7ce6 <WorkerOLEDMenu+0xcc>
			else if (SelItem==1) PageMotorSpeed();
    7c94:	61 30       	cpi	r22, 0x01	; 1
    7c96:	51 f1       	breq	.+84     	; 0x7cec <WorkerOLEDMenu+0xd2>
			else if (SelItem==2) PageADPS9960();
    7c98:	62 30       	cpi	r22, 0x02	; 2
    7c9a:	59 f1       	breq	.+86     	; 0x7cf2 <WorkerOLEDMenu+0xd8>
			else if (SelItem==3) PageADC();
    7c9c:	63 30       	cpi	r22, 0x03	; 3
    7c9e:	61 f1       	breq	.+88     	; 0x7cf8 <WorkerOLEDMenu+0xde>
			else if (SelItem==4) PageLineFollowSpeed();
    7ca0:	64 30       	cpi	r22, 0x04	; 4
    7ca2:	f1 f0       	breq	.+60     	; 0x7ce0 <WorkerOLEDMenu+0xc6>
			else if (SelItem==5) PageLineFollowDirect();
    7ca4:	65 30       	cpi	r22, 0x05	; 5
    7ca6:	59 f1       	breq	.+86     	; 0x7cfe <WorkerOLEDMenu+0xe4>
			else if (SelItem==6) PageRGB();
    7ca8:	66 30       	cpi	r22, 0x06	; 6
    7caa:	61 f1       	breq	.+88     	; 0x7d04 <WorkerOLEDMenu+0xea>
			else if (SelItem==7) PageGyro();	
    7cac:	67 30       	cpi	r22, 0x07	; 7
    7cae:	69 f1       	breq	.+90     	; 0x7d0a <WorkerOLEDMenu+0xf0>
			else if (SelItem==8) PageRanger();
    7cb0:	68 30       	cpi	r22, 0x08	; 8
    7cb2:	71 f1       	breq	.+92     	; 0x7d10 <WorkerOLEDMenu+0xf6>
			else if (SelItem==9) configASSERT(false); //Force halt
    7cb4:	69 30       	cpi	r22, 0x09	; 9
    7cb6:	41 f4       	brne	.+16     	; 0x7cc8 <WorkerOLEDMenu+0xae>
    7cb8:	67 e5       	ldi	r22, 0x57	; 87
    7cba:	70 e0       	ldi	r23, 0x00	; 0
    7cbc:	81 e5       	ldi	r24, 0x51	; 81
    7cbe:	97 e2       	ldi	r25, 0x27	; 39
    7cc0:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <vAssertCalled>
    7cc4:	60 91 71 2d 	lds	r22, 0x2D71	; 0x802d71 <SelItem>
    7cc8:	70 e0       	ldi	r23, 0x00	; 0
    7cca:	80 91 72 2d 	lds	r24, 0x2D72	; 0x802d72 <TopItem>
    7cce:	90 e0       	ldi	r25, 0x00	; 0
		}
		
		DrawMenu(TopItem,SelItem);
    7cd0:	0e 94 b9 38 	call	0x7172	; 0x7172 <DrawMenu>
    7cd4:	c1 cf       	rjmp	.-126    	; 0x7c58 <WorkerOLEDMenu+0x3e>
    7cd6:	70 e0       	ldi	r23, 0x00	; 0
    7cd8:	90 e0       	ldi	r25, 0x00	; 0
    7cda:	0e 94 b9 38 	call	0x7172	; 0x7172 <DrawMenu>
    7cde:	bc cf       	rjmp	.-136    	; 0x7c58 <WorkerOLEDMenu+0x3e>
		{
			if (SelItem==0) PageCPUStatus();
			else if (SelItem==1) PageMotorSpeed();
			else if (SelItem==2) PageADPS9960();
			else if (SelItem==3) PageADC();
			else if (SelItem==4) PageLineFollowSpeed();
    7ce0:	0e 94 a0 3c 	call	0x7940	; 0x7940 <PageLineFollowSpeed>
    7ce4:	ef cf       	rjmp	.-34     	; 0x7cc4 <WorkerOLEDMenu+0xaa>
		Stick=DriverCursorStickGetFifo(300);
		if (Stick & CURSOR_DOWN) DownMenu();
		else if (Stick & CURSOR_UP) UpMenu();
		else if (Stick & CURSOR_PRESS)
		{
			if (SelItem==0) PageCPUStatus();
    7ce6:	0e 94 e4 38 	call	0x71c8	; 0x71c8 <PageCPUStatus>
    7cea:	ec cf       	rjmp	.-40     	; 0x7cc4 <WorkerOLEDMenu+0xaa>
			else if (SelItem==1) PageMotorSpeed();
    7cec:	0e 94 ba 39 	call	0x7374	; 0x7374 <PageMotorSpeed>
    7cf0:	e9 cf       	rjmp	.-46     	; 0x7cc4 <WorkerOLEDMenu+0xaa>
			else if (SelItem==2) PageADPS9960();
    7cf2:	0e 94 55 3b 	call	0x76aa	; 0x76aa <PageADPS9960>
    7cf6:	e6 cf       	rjmp	.-52     	; 0x7cc4 <WorkerOLEDMenu+0xaa>
			else if (SelItem==3) PageADC();
    7cf8:	0e 94 f0 3b 	call	0x77e0	; 0x77e0 <PageADC>
    7cfc:	e3 cf       	rjmp	.-58     	; 0x7cc4 <WorkerOLEDMenu+0xaa>
			else if (SelItem==4) PageLineFollowSpeed();
			else if (SelItem==5) PageLineFollowDirect();
    7cfe:	0e 94 cc 3c 	call	0x7998	; 0x7998 <PageLineFollowDirect>
    7d02:	e0 cf       	rjmp	.-64     	; 0x7cc4 <WorkerOLEDMenu+0xaa>
			else if (SelItem==6) PageRGB();
    7d04:	0e 94 ec 3c 	call	0x79d8	; 0x79d8 <PageRGB>
    7d08:	dd cf       	rjmp	.-70     	; 0x7cc4 <WorkerOLEDMenu+0xaa>
			else if (SelItem==7) PageGyro();	
    7d0a:	0e 94 5f 3d 	call	0x7abe	; 0x7abe <PageGyro>
    7d0e:	da cf       	rjmp	.-76     	; 0x7cc4 <WorkerOLEDMenu+0xaa>
			else if (SelItem==8) PageRanger();
    7d10:	0e 94 c8 3d 	call	0x7b90	; 0x7b90 <PageRanger>
    7d14:	d7 cf       	rjmp	.-82     	; 0x7cc4 <WorkerOLEDMenu+0xaa>

00007d16 <WorkerRGB>:
	xQueueOverwrite(EffectQueue,&Effect);
	
}

void WorkerRGB(void *pvParameters)
{
    7d16:	cf 93       	push	r28
    7d18:	df 93       	push	r29
    7d1a:	1f 92       	push	r1
    7d1c:	cd b7       	in	r28, 0x3d	; 61
    7d1e:	de b7       	in	r29, 0x3e	; 62
    7d20:	4a c0       	rjmp	.+148    	; 0x7db6 <WorkerRGB+0xa0>
		
		//Time slot 1
		if (Effect & RGB_HEADLIGHT_HIGH)
		{
			FrontRight=PL9823_RGB(255,255,255);
			FrontLeft=PL9823_RGB(255,255,255);
    7d22:	66 24       	eor	r6, r6
    7d24:	6a 94       	dec	r6
    7d26:	77 24       	eor	r7, r7
    7d28:	7a 94       	dec	r7
    7d2a:	88 24       	eor	r8, r8
    7d2c:	8a 94       	dec	r8
    7d2e:	91 2c       	mov	r9, r1
		}
		if (Effect & RGB_HEADLIGHT_LOW)
    7d30:	80 ff       	sbrs	r24, 0
    7d32:	07 c0       	rjmp	.+14     	; 0x7d42 <WorkerRGB+0x2c>
		{
			FrontRight=PL9823_RGB(128,128,128);
			FrontLeft=PL9823_RGB(128,128,128);
    7d34:	90 e8       	ldi	r25, 0x80	; 128
    7d36:	69 2e       	mov	r6, r25
    7d38:	20 e8       	ldi	r18, 0x80	; 128
    7d3a:	72 2e       	mov	r7, r18
    7d3c:	30 e8       	ldi	r19, 0x80	; 128
    7d3e:	83 2e       	mov	r8, r19
    7d40:	91 2c       	mov	r9, r1
		}
		if (Effect & RGB_BRAKE)
    7d42:	84 ff       	sbrs	r24, 4
    7d44:	4b c0       	rjmp	.+150    	; 0x7ddc <WorkerRGB+0xc6>
		{
			RearRight=PL9823_RED;
    7d46:	22 24       	eor	r2, r2
    7d48:	2a 94       	dec	r2
    7d4a:	31 2c       	mov	r3, r1
    7d4c:	41 2c       	mov	r4, r1
    7d4e:	51 2c       	mov	r5, r1
			RearLeft=PL9823_RED;
		}

		DriverPL9823Set(FrontLeft,FrontRight,RearRight,RearLeft);
    7d50:	51 01       	movw	r10, r2
    7d52:	62 01       	movw	r12, r4
    7d54:	71 01       	movw	r14, r2
    7d56:	82 01       	movw	r16, r4
    7d58:	93 01       	movw	r18, r6
    7d5a:	a4 01       	movw	r20, r8
    7d5c:	b3 01       	movw	r22, r6
    7d5e:	c4 01       	movw	r24, r8
    7d60:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <DriverPL9823Set>
		vTaskDelay(250); 
    7d64:	8a ef       	ldi	r24, 0xFA	; 250
    7d66:	90 e0       	ldi	r25, 0x00	; 0
    7d68:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
		
		//Time slot 2
		if (Effect & RGB_BLINK_LEFT)
    7d6c:	29 81       	ldd	r18, Y+1	; 0x01
    7d6e:	22 ff       	sbrs	r18, 2
    7d70:	3a c0       	rjmp	.+116    	; 0x7de6 <WorkerRGB+0xd0>
		{
			FrontLeft=PL9823_YELLOW;
			RearLeft=PL9823_YELLOW;
    7d72:	aa 24       	eor	r10, r10
    7d74:	aa 94       	dec	r10
    7d76:	bb 24       	eor	r11, r11
    7d78:	ba 94       	dec	r11
    7d7a:	c1 2c       	mov	r12, r1
    7d7c:	d1 2c       	mov	r13, r1
		vTaskDelay(250); 
		
		//Time slot 2
		if (Effect & RGB_BLINK_LEFT)
		{
			FrontLeft=PL9823_YELLOW;
    7d7e:	6f ef       	ldi	r22, 0xFF	; 255
    7d80:	7f ef       	ldi	r23, 0xFF	; 255
    7d82:	80 e0       	ldi	r24, 0x00	; 0
    7d84:	90 e0       	ldi	r25, 0x00	; 0
			RearLeft=PL9823_YELLOW;
		}
		if (Effect & RGB_BLINK_RIGHT)
    7d86:	23 ff       	sbrs	r18, 3
    7d88:	0c c0       	rjmp	.+24     	; 0x7da2 <WorkerRGB+0x8c>
		{
			FrontRight=PL9823_YELLOW;
			RearRight=PL9823_YELLOW;
    7d8a:	22 24       	eor	r2, r2
    7d8c:	2a 94       	dec	r2
    7d8e:	33 24       	eor	r3, r3
    7d90:	3a 94       	dec	r3
    7d92:	41 2c       	mov	r4, r1
    7d94:	51 2c       	mov	r5, r1
			FrontLeft=PL9823_YELLOW;
			RearLeft=PL9823_YELLOW;
		}
		if (Effect & RGB_BLINK_RIGHT)
		{
			FrontRight=PL9823_YELLOW;
    7d96:	66 24       	eor	r6, r6
    7d98:	6a 94       	dec	r6
    7d9a:	77 24       	eor	r7, r7
    7d9c:	7a 94       	dec	r7
    7d9e:	81 2c       	mov	r8, r1
    7da0:	91 2c       	mov	r9, r1
			RearRight=PL9823_YELLOW;
		}
		DriverPL9823Set(FrontLeft,FrontRight,RearRight,RearLeft);
    7da2:	71 01       	movw	r14, r2
    7da4:	82 01       	movw	r16, r4
    7da6:	93 01       	movw	r18, r6
    7da8:	a4 01       	movw	r20, r8
    7daa:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <DriverPL9823Set>
		vTaskDelay(250);
    7dae:	8a ef       	ldi	r24, 0xFA	; 250
    7db0:	90 e0       	ldi	r25, 0x00	; 0
    7db2:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
	{
		FrontLeft=PL9823_BLANK;
		FrontRight=PL9823_BLANK;
		RearLeft=PL9823_BLANK;
		RearRight=PL9823_BLANK;	
		xQueuePeek(EffectQueue,&Effect,0);
    7db6:	40 e0       	ldi	r20, 0x00	; 0
    7db8:	50 e0       	ldi	r21, 0x00	; 0
    7dba:	be 01       	movw	r22, r28
    7dbc:	6f 5f       	subi	r22, 0xFF	; 255
    7dbe:	7f 4f       	sbci	r23, 0xFF	; 255
    7dc0:	80 91 8d 2d 	lds	r24, 0x2D8D	; 0x802d8d <EffectQueue>
    7dc4:	90 91 8e 2d 	lds	r25, 0x2D8E	; 0x802d8e <EffectQueue+0x1>
    7dc8:	0e 94 75 23 	call	0x46ea	; 0x46ea <xQueuePeek>
		
		
		
		//Time slot 1
		if (Effect & RGB_HEADLIGHT_HIGH)
    7dcc:	89 81       	ldd	r24, Y+1	; 0x01
    7dce:	81 fd       	sbrc	r24, 1
    7dd0:	a8 cf       	rjmp	.-176    	; 0x7d22 <WorkerRGB+0xc>
	uint8_t Effect;
	uint32_t FrontLeft,FrontRight,RearRight,RearLeft;
	
	while(1)
	{
		FrontLeft=PL9823_BLANK;
    7dd2:	61 2c       	mov	r6, r1
    7dd4:	71 2c       	mov	r7, r1
    7dd6:	81 2c       	mov	r8, r1
    7dd8:	91 2c       	mov	r9, r1
    7dda:	aa cf       	rjmp	.-172    	; 0x7d30 <WorkerRGB+0x1a>
		FrontRight=PL9823_BLANK;
		RearLeft=PL9823_BLANK;
		RearRight=PL9823_BLANK;	
    7ddc:	21 2c       	mov	r2, r1
    7dde:	31 2c       	mov	r3, r1
    7de0:	41 2c       	mov	r4, r1
    7de2:	51 2c       	mov	r5, r1
    7de4:	b5 cf       	rjmp	.-150    	; 0x7d50 <WorkerRGB+0x3a>
    7de6:	51 01       	movw	r10, r2
    7de8:	62 01       	movw	r12, r4
    7dea:	b3 01       	movw	r22, r6
    7dec:	c4 01       	movw	r24, r8
    7dee:	cb cf       	rjmp	.-106    	; 0x7d86 <WorkerRGB+0x70>

00007df0 <InitRGBTask>:
void WorkerRGB(void *pvParameters);


//Function definitions
void InitRGBTask()
{
    7df0:	ef 92       	push	r14
    7df2:	ff 92       	push	r15
    7df4:	0f 93       	push	r16
    7df6:	cf 93       	push	r28
    7df8:	df 93       	push	r29
    7dfa:	1f 92       	push	r1
    7dfc:	cd b7       	in	r28, 0x3d	; 61
    7dfe:	de b7       	in	r29, 0x3e	; 62
	EffectQueue=xQueueCreate(1,sizeof(uint8_t));
    7e00:	40 e0       	ldi	r20, 0x00	; 0
    7e02:	61 e0       	ldi	r22, 0x01	; 1
    7e04:	81 e0       	ldi	r24, 0x01	; 1
    7e06:	0e 94 e3 1f 	call	0x3fc6	; 0x3fc6 <xQueueGenericCreate>
    7e0a:	80 93 8d 2d 	sts	0x2D8D, r24	; 0x802d8d <EffectQueue>
    7e0e:	90 93 8e 2d 	sts	0x2D8E, r25	; 0x802d8e <EffectQueue+0x1>
    7e12:	19 82       	std	Y+1, r1	; 0x01
	xTaskCreate( WorkerRGB, "rgb", 512, NULL, tskIDLE_PRIORITY+4, NULL );	
}

void SetRGB(uint8_t Effect)
{
	xQueueOverwrite(EffectQueue,&Effect);
    7e14:	22 e0       	ldi	r18, 0x02	; 2
    7e16:	40 e0       	ldi	r20, 0x00	; 0
    7e18:	50 e0       	ldi	r21, 0x00	; 0
    7e1a:	be 01       	movw	r22, r28
    7e1c:	6f 5f       	subi	r22, 0xFF	; 255
    7e1e:	7f 4f       	sbci	r23, 0xFF	; 255
    7e20:	0e 94 27 20 	call	0x404e	; 0x404e <xQueueGenericSend>
//Function definitions
void InitRGBTask()
{
	EffectQueue=xQueueCreate(1,sizeof(uint8_t));
	SetRGB(RGB_NONE);
	xTaskCreate( WorkerRGB, "rgb", 512, NULL, tskIDLE_PRIORITY+4, NULL );	
    7e24:	e1 2c       	mov	r14, r1
    7e26:	f1 2c       	mov	r15, r1
    7e28:	04 e0       	ldi	r16, 0x04	; 4
    7e2a:	20 e0       	ldi	r18, 0x00	; 0
    7e2c:	30 e0       	ldi	r19, 0x00	; 0
    7e2e:	40 e0       	ldi	r20, 0x00	; 0
    7e30:	52 e0       	ldi	r21, 0x02	; 2
    7e32:	64 ec       	ldi	r22, 0xC4	; 196
    7e34:	77 e2       	ldi	r23, 0x27	; 39
    7e36:	8b e8       	ldi	r24, 0x8B	; 139
    7e38:	9e e3       	ldi	r25, 0x3E	; 62
    7e3a:	0e 94 20 26 	call	0x4c40	; 0x4c40 <xTaskCreate>
}
    7e3e:	0f 90       	pop	r0
    7e40:	df 91       	pop	r29
    7e42:	cf 91       	pop	r28
    7e44:	0f 91       	pop	r16
    7e46:	ff 90       	pop	r15
    7e48:	ef 90       	pop	r14
    7e4a:	08 95       	ret

00007e4c <SetRGB>:

void SetRGB(uint8_t Effect)
{
    7e4c:	cf 93       	push	r28
    7e4e:	df 93       	push	r29
    7e50:	1f 92       	push	r1
    7e52:	cd b7       	in	r28, 0x3d	; 61
    7e54:	de b7       	in	r29, 0x3e	; 62
    7e56:	89 83       	std	Y+1, r24	; 0x01
	xQueueOverwrite(EffectQueue,&Effect);
    7e58:	22 e0       	ldi	r18, 0x02	; 2
    7e5a:	40 e0       	ldi	r20, 0x00	; 0
    7e5c:	50 e0       	ldi	r21, 0x00	; 0
    7e5e:	be 01       	movw	r22, r28
    7e60:	6f 5f       	subi	r22, 0xFF	; 255
    7e62:	7f 4f       	sbci	r23, 0xFF	; 255
    7e64:	80 91 8d 2d 	lds	r24, 0x2D8D	; 0x802d8d <EffectQueue>
    7e68:	90 91 8e 2d 	lds	r25, 0x2D8E	; 0x802d8e <EffectQueue+0x1>
    7e6c:	0e 94 27 20 	call	0x404e	; 0x404e <xQueueGenericSend>
	
}
    7e70:	0f 90       	pop	r0
    7e72:	df 91       	pop	r29
    7e74:	cf 91       	pop	r28
    7e76:	08 95       	ret

00007e78 <WorkerStartup>:

static void WorkerStartup(void *pvParameters)
{
	int res;
	
	DriverPowerVccAuxSet(1);//Enable Auxillary power line
    7e78:	81 e0       	ldi	r24, 0x01	; 1
    7e7a:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <DriverPowerVccAuxSet>
	DriverCursorstickInit();//Initialize cursor stick
    7e7e:	0e 94 11 05 	call	0xa22	; 0xa22 <DriverCursorstickInit>
	DriverLedInit();		//Initialize LED's
    7e82:	0e 94 91 06 	call	0xd22	; 0xd22 <DriverLedInit>
	DriverUSARTInit();		//USART init and link to stdio
    7e86:	0e 94 cb 10 	call	0x2196	; 0x2196 <DriverUSARTInit>
	DriverPowerInit();		//Initialize aux power driver
    7e8a:	0e 94 d2 0e 	call	0x1da4	; 0x1da4 <DriverPowerInit>
	
	DriverTWIMInit();		//Initialize TWI in master mode
    7e8e:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <DriverTWIMInit>
	DriverPL9823Init();		//Initialize PL9823 LEDs
    7e92:	0e 94 37 0e 	call	0x1c6e	; 0x1c6e <DriverPL9823Init>
	DriverAdcInit();		//Initialize ADC driver
    7e96:	0e 94 91 03 	call	0x722	; 0x722 <DriverAdcInit>
	
	DriverOLEDInit(2);		//Initialize OLED display
    7e9a:	82 e0       	ldi	r24, 0x02	; 2
    7e9c:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <DriverOLEDInit>
	DriverAdps9960Init();	//Initialize color sensor	
    7ea0:	0e 94 4b 04 	call	0x896	; 0x896 <DriverAdps9960Init>
	DriverVL53L0XInit();	//Initialize rangefinder
    7ea4:	0e 94 37 14 	call	0x286e	; 0x286e <DriverVL53L0XInit>

	
	vTaskDelay(50);
    7ea8:	82 e3       	ldi	r24, 0x32	; 50
    7eaa:	90 e0       	ldi	r25, 0x00	; 0
    7eac:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
	
	//Enable test output (T21)
	PORTA.DIRSET=1<<5;	
    7eb0:	80 e2       	ldi	r24, 0x20	; 32
    7eb2:	80 93 01 06 	sts	0x0601, r24	; 0x800601 <__TEXT_REGION_LENGTH__+0x700601>
	//Initialize application tasks			
	
	InitOLEDMenuTask();
    7eb6:	0e 94 a5 38 	call	0x714a	; 0x714a <InitOLEDMenuTask>
	InitADCTask();
    7eba:	0e 94 b5 31 	call	0x636a	; 0x636a <InitADCTask>
	InitMotorPosTask();
    7ebe:	0e 94 db 37 	call	0x6fb6	; 0x6fb6 <InitMotorPosTask>
	InitMotorSpeedTask();
    7ec2:	0e 94 53 38 	call	0x70a6	; 0x70a6 <InitMotorSpeedTask>
	InitLineFollowerSpeedTask();
    7ec6:	0e 94 67 33 	call	0x66ce	; 0x66ce <InitLineFollowerSpeedTask>
	InitLineFollowerDirectTask();
    7eca:	0e 94 ae 32 	call	0x655c	; 0x655c <InitLineFollowerDirectTask>
	InitRGBTask();
    7ece:	0e 94 f8 3e 	call	0x7df0	; 0x7df0 <InitRGBTask>
	//InitGyroTask();
	InitTerminalTask();
    7ed2:	0e 94 0f 42 	call	0x841e	; 0x841e <InitTerminalTask>
	InitMotionTask();
    7ed6:	0e 94 ce 35 	call	0x6b9c	; 0x6b9c <InitMotionTask>
	
	vTaskSuspend(NULL);
    7eda:	80 e0       	ldi	r24, 0x00	; 0
    7edc:	90 e0       	ldi	r25, 0x00	; 0
    7ede:	0c 94 a2 27 	jmp	0x4f44	; 0x4f44 <vTaskSuspend>

00007ee2 <InitStartupTask>:
//Private function prototypes
static void WorkerStartup(void *pvParameters);

//Function definitions
void InitStartupTask()
{
    7ee2:	ef 92       	push	r14
    7ee4:	ff 92       	push	r15
    7ee6:	0f 93       	push	r16
	xTaskCreate( WorkerStartup, "startup", 256, NULL, tskIDLE_PRIORITY+3, NULL );	
    7ee8:	e1 2c       	mov	r14, r1
    7eea:	f1 2c       	mov	r15, r1
    7eec:	03 e0       	ldi	r16, 0x03	; 3
    7eee:	20 e0       	ldi	r18, 0x00	; 0
    7ef0:	30 e0       	ldi	r19, 0x00	; 0
    7ef2:	40 e0       	ldi	r20, 0x00	; 0
    7ef4:	51 e0       	ldi	r21, 0x01	; 1
    7ef6:	69 e6       	ldi	r22, 0x69	; 105
    7ef8:	77 e2       	ldi	r23, 0x27	; 39
    7efa:	8c e3       	ldi	r24, 0x3C	; 60
    7efc:	9f e3       	ldi	r25, 0x3F	; 63
    7efe:	0e 94 20 26 	call	0x4c40	; 0x4c40 <xTaskCreate>
}
    7f02:	0f 91       	pop	r16
    7f04:	ff 90       	pop	r15
    7f06:	ef 90       	pop	r14
    7f08:	08 95       	ret

00007f0a <WorkerTerminal>:
	*/

}

static void WorkerTerminal(void *pvParameters)
{
    7f0a:	cf 93       	push	r28
    7f0c:	df 93       	push	r29
    7f0e:	cd b7       	in	r28, 0x3d	; 61
    7f10:	de b7       	in	r29, 0x3e	; 62
    7f12:	cc 51       	subi	r28, 0x1C	; 28
    7f14:	d1 40       	sbci	r29, 0x01	; 1
    7f16:	cd bf       	out	0x3d, r28	; 61
    7f18:	de bf       	out	0x3e, r29	; 62
		SplitCmd(sbuf,Cmd,Pars);
		
		//Task list command
		if (strstr(Cmd,"help"))
		{
			printf_P (PSTR("Command list:\r\n"));
    7f1a:	8c ec       	ldi	r24, 0xCC	; 204
    7f1c:	e8 2e       	mov	r14, r24
    7f1e:	86 e0       	ldi	r24, 0x06	; 6
    7f20:	f8 2e       	mov	r15, r24
			printf_P (PSTR("help :this help page\r\n"));
    7f22:	05 eb       	ldi	r16, 0xB5	; 181
    7f24:	16 e0       	ldi	r17, 0x06	; 6
			printf_P (PSTR("tsklst :list FreeRTOS tasks\r\n"));
    7f26:	97 e9       	ldi	r25, 0x97	; 151
    7f28:	c9 2e       	mov	r12, r25
    7f2a:	96 e0       	ldi	r25, 0x06	; 6
    7f2c:	d9 2e       	mov	r13, r25
			printf_P (PSTR("memmap :show memory map\r\n"));
    7f2e:	2d e7       	ldi	r18, 0x7D	; 125
    7f30:	22 2e       	mov	r2, r18
    7f32:	26 e0       	ldi	r18, 0x06	; 6
    7f34:	32 2e       	mov	r3, r18
	char Cmd[64];
	uint16_t c,r,g,b;
	
	while (1)
	{
		printf ("C>\r\n");
    7f36:	81 e7       	ldi	r24, 0x71	; 113
    7f38:	97 e2       	ldi	r25, 0x27	; 39
    7f3a:	0e 94 94 4d 	call	0x9b28	; 0x9b28 <puts>
		fgets(sbuf,199,stdin);
    7f3e:	40 91 93 2d 	lds	r20, 0x2D93	; 0x802d93 <__iob>
    7f42:	50 91 94 2d 	lds	r21, 0x2D94	; 0x802d94 <__iob+0x1>
    7f46:	67 ec       	ldi	r22, 0xC7	; 199
    7f48:	70 e0       	ldi	r23, 0x00	; 0
    7f4a:	ce 01       	movw	r24, r28
    7f4c:	01 96       	adiw	r24, 0x01	; 1
    7f4e:	0e 94 ea 4c 	call	0x99d4	; 0x99d4 <fgets>
static void SplitCmd(char *Data,char *Cmd,float *Pars)
{
	uint8_t a;
	char *ss;
	
	ss=strtok(Data," ");
    7f52:	6e e0       	ldi	r22, 0x0E	; 14
    7f54:	74 e2       	ldi	r23, 0x24	; 36
    7f56:	ce 01       	movw	r24, r28
    7f58:	01 96       	adiw	r24, 0x01	; 1
    7f5a:	0e 94 83 4c 	call	0x9906	; 0x9906 <strtok>
	if (ss!=NULL) strcpy(Cmd,ss);
    7f5e:	00 97       	sbiw	r24, 0x00	; 0
    7f60:	31 f0       	breq	.+12     	; 0x7f6e <WorkerTerminal+0x64>
    7f62:	bc 01       	movw	r22, r24
    7f64:	ce 01       	movw	r24, r28
    7f66:	87 53       	subi	r24, 0x37	; 55
    7f68:	9f 4f       	sbci	r25, 0xFF	; 255
    7f6a:	0e 94 97 4c 	call	0x992e	; 0x992e <strcpy>
	for (a=0;a<MAX_PARS;a++) 
	{
		ss=strtok(NULL," ");
    7f6e:	6e e0       	ldi	r22, 0x0E	; 14
    7f70:	74 e2       	ldi	r23, 0x24	; 36
    7f72:	80 e0       	ldi	r24, 0x00	; 0
    7f74:	90 e0       	ldi	r25, 0x00	; 0
    7f76:	0e 94 83 4c 	call	0x9906	; 0x9906 <strtok>
		if (ss!=NULL)
    7f7a:	00 97       	sbiw	r24, 0x00	; 0
    7f7c:	09 f4       	brne	.+2      	; 0x7f80 <WorkerTerminal+0x76>
    7f7e:	70 c0       	rjmp	.+224    	; 0x8060 <WorkerTerminal+0x156>
		{
			Pars[a]=atof(ss);
    7f80:	0e 94 9c 4b 	call	0x9738	; 0x9738 <atof>
    7f84:	4b 01       	movw	r8, r22
    7f86:	5c 01       	movw	r10, r24
	
	ss=strtok(Data," ");
	if (ss!=NULL) strcpy(Cmd,ss);
	for (a=0;a<MAX_PARS;a++) 
	{
		ss=strtok(NULL," ");
    7f88:	6e e0       	ldi	r22, 0x0E	; 14
    7f8a:	74 e2       	ldi	r23, 0x24	; 36
    7f8c:	80 e0       	ldi	r24, 0x00	; 0
    7f8e:	90 e0       	ldi	r25, 0x00	; 0
    7f90:	0e 94 83 4c 	call	0x9906	; 0x9906 <strtok>
		if (ss!=NULL)
    7f94:	00 97       	sbiw	r24, 0x00	; 0
    7f96:	09 f4       	brne	.+2      	; 0x7f9a <WorkerTerminal+0x90>
    7f98:	6f c0       	rjmp	.+222    	; 0x8078 <WorkerTerminal+0x16e>
		{
			Pars[a]=atof(ss);
    7f9a:	0e 94 9c 4b 	call	0x9738	; 0x9738 <atof>
    7f9e:	2b 01       	movw	r4, r22
    7fa0:	3c 01       	movw	r6, r24
		printf ("C>\r\n");
		fgets(sbuf,199,stdin);
		SplitCmd(sbuf,Cmd,Pars);
		
		//Task list command
		if (strstr(Cmd,"help"))
    7fa2:	65 e7       	ldi	r22, 0x75	; 117
    7fa4:	77 e2       	ldi	r23, 0x27	; 39
    7fa6:	ce 01       	movw	r24, r28
    7fa8:	87 53       	subi	r24, 0x37	; 55
    7faa:	9f 4f       	sbci	r25, 0xFF	; 255
    7fac:	0e 94 a9 4c 	call	0x9952	; 0x9952 <strstr>
    7fb0:	89 2b       	or	r24, r25
    7fb2:	09 f4       	brne	.+2      	; 0x7fb6 <WorkerTerminal+0xac>
    7fb4:	65 c0       	rjmp	.+202    	; 0x8080 <WorkerTerminal+0x176>
		{
			printf_P (PSTR("Command list:\r\n"));
    7fb6:	ff 92       	push	r15
    7fb8:	ef 92       	push	r14
    7fba:	0e 94 6c 4d 	call	0x9ad8	; 0x9ad8 <printf_P>
			printf_P (PSTR("help :this help page\r\n"));
    7fbe:	1f 93       	push	r17
    7fc0:	0f 93       	push	r16
    7fc2:	0e 94 6c 4d 	call	0x9ad8	; 0x9ad8 <printf_P>
			printf_P (PSTR("tsklst :list FreeRTOS tasks\r\n"));
    7fc6:	df 92       	push	r13
    7fc8:	cf 92       	push	r12
    7fca:	0e 94 6c 4d 	call	0x9ad8	; 0x9ad8 <printf_P>
			printf_P (PSTR("memmap :show memory map\r\n"));
    7fce:	3f 92       	push	r3
    7fd0:	2f 92       	push	r2
    7fd2:	0e 94 6c 4d 	call	0x9ad8	; 0x9ad8 <printf_P>
			printf_P (PSTR("drvstr distance speed :Drive straight over 'distance' mm at a speed of 'speed' mm/s\r\n"));
    7fd6:	87 e2       	ldi	r24, 0x27	; 39
    7fd8:	96 e0       	ldi	r25, 0x06	; 6
    7fda:	9f 93       	push	r25
    7fdc:	8f 93       	push	r24
    7fde:	0e 94 6c 4d 	call	0x9ad8	; 0x9ad8 <printf_P>
			printf_P (PSTR("rotctr angle speed :rotate 'angle' degrees around center of robot at a speed of 'speed' mm/s\r\n"));
    7fe2:	88 ec       	ldi	r24, 0xC8	; 200
    7fe4:	95 e0       	ldi	r25, 0x05	; 5
    7fe6:	9f 93       	push	r25
    7fe8:	8f 93       	push	r24
    7fea:	0e 94 6c 4d 	call	0x9ad8	; 0x9ad8 <printf_P>
			printf_P (PSTR("drvseg speed :follow line segment until end at a speed of 'speed' mm/s\r\n"));
    7fee:	8f e7       	ldi	r24, 0x7F	; 127
    7ff0:	95 e0       	ldi	r25, 0x05	; 5
    7ff2:	9f 93       	push	r25
    7ff4:	8f 93       	push	r24
    7ff6:	0e 94 6c 4d 	call	0x9ad8	; 0x9ad8 <printf_P>
			printf_P (PSTR("setled effect :set RGB led effect (see RGBTask.h)\r\n"));
    7ffa:	8b e4       	ldi	r24, 0x4B	; 75
    7ffc:	95 e0       	ldi	r25, 0x05	; 5
    7ffe:	9f 93       	push	r25
    8000:	8f 93       	push	r24
    8002:	0e 94 6c 4d 	call	0x9ad8	; 0x9ad8 <printf_P>
			printf_P (PSTR("setmot leftmotor_pwm rightmotor_pwm :directly control motor pwm signal. Pwm is in a range of -4095 to 4095\r\n"));
    8006:	8e ed       	ldi	r24, 0xDE	; 222
    8008:	94 e0       	ldi	r25, 0x04	; 4
    800a:	9f 93       	push	r25
    800c:	8f 93       	push	r24
    800e:	0e 94 6c 4d 	call	0x9ad8	; 0x9ad8 <printf_P>
			printf_P (PSTR("getenc :get motor encoder values\r\n"));
    8012:	8b eb       	ldi	r24, 0xBB	; 187
    8014:	94 e0       	ldi	r25, 0x04	; 4
    8016:	9f 93       	push	r25
    8018:	8f 93       	push	r24
    801a:	0e 94 6c 4d 	call	0x9ad8	; 0x9ad8 <printf_P>
			printf_P (PSTR("getrgb :returns RGB light sensor values\r\n"));
    801e:	81 e9       	ldi	r24, 0x91	; 145
    8020:	94 e0       	ldi	r25, 0x04	; 4
    8022:	9f 93       	push	r25
    8024:	8f 93       	push	r24
    8026:	0e 94 6c 4d 	call	0x9ad8	; 0x9ad8 <printf_P>
			printf_P (PSTR("getgyr :returns gyroscope info in format 'yawrate (deg/s) yaw(deg)\r\n"));
    802a:	8c e4       	ldi	r24, 0x4C	; 76
    802c:	94 e0       	ldi	r25, 0x04	; 4
    802e:	9f 93       	push	r25
    8030:	8f 93       	push	r24
    8032:	0e 94 6c 4d 	call	0x9ad8	; 0x9ad8 <printf_P>
			printf_P (PSTR("getadc :returns Analog channels in format 'left_line_sensor mid_line_sensor right_line_sensor potentiometer\r\n"));
    8036:	8e ed       	ldi	r24, 0xDE	; 222
    8038:	93 e0       	ldi	r25, 0x03	; 3
    803a:	9f 93       	push	r25
    803c:	8f 93       	push	r24
    803e:	0e 94 6c 4d 	call	0x9ad8	; 0x9ad8 <printf_P>
			printf_P (PSTR("auxpwr state:'state'=1: turn on aux power net, 'state'=0: turn off aux power net\r\n"));
    8042:	8b e8       	ldi	r24, 0x8B	; 139
    8044:	93 e0       	ldi	r25, 0x03	; 3
    8046:	9f 93       	push	r25
    8048:	8f 93       	push	r24
    804a:	0e 94 6c 4d 	call	0x9ad8	; 0x9ad8 <printf_P>
			printf_P (PSTR("sleep :enter sleep mode\r\n"));
    804e:	81 e7       	ldi	r24, 0x71	; 113
    8050:	93 e0       	ldi	r25, 0x03	; 3
    8052:	9f 93       	push	r25
    8054:	8f 93       	push	r24
    8056:	0e 94 6c 4d 	call	0x9ad8	; 0x9ad8 <printf_P>
    805a:	cd bf       	out	0x3d, r28	; 61
    805c:	de bf       	out	0x3e, r29	; 62
    805e:	6b cf       	rjmp	.-298    	; 0x7f36 <WorkerTerminal+0x2c>
		if (ss!=NULL)
		{
			Pars[a]=atof(ss);
		}
		else
			Pars[a]=0.0;
    8060:	81 2c       	mov	r8, r1
    8062:	91 2c       	mov	r9, r1
    8064:	54 01       	movw	r10, r8
	
	ss=strtok(Data," ");
	if (ss!=NULL) strcpy(Cmd,ss);
	for (a=0;a<MAX_PARS;a++) 
	{
		ss=strtok(NULL," ");
    8066:	6e e0       	ldi	r22, 0x0E	; 14
    8068:	74 e2       	ldi	r23, 0x24	; 36
    806a:	80 e0       	ldi	r24, 0x00	; 0
    806c:	90 e0       	ldi	r25, 0x00	; 0
    806e:	0e 94 83 4c 	call	0x9906	; 0x9906 <strtok>
		if (ss!=NULL)
    8072:	00 97       	sbiw	r24, 0x00	; 0
    8074:	09 f0       	breq	.+2      	; 0x8078 <WorkerTerminal+0x16e>
    8076:	91 cf       	rjmp	.-222    	; 0x7f9a <WorkerTerminal+0x90>
		{
			Pars[a]=atof(ss);
		}
		else
			Pars[a]=0.0;
    8078:	41 2c       	mov	r4, r1
    807a:	51 2c       	mov	r5, r1
    807c:	32 01       	movw	r6, r4
    807e:	91 cf       	rjmp	.-222    	; 0x7fa2 <WorkerTerminal+0x98>
			printf_P (PSTR("getgyr :returns gyroscope info in format 'yawrate (deg/s) yaw(deg)\r\n"));
			printf_P (PSTR("getadc :returns Analog channels in format 'left_line_sensor mid_line_sensor right_line_sensor potentiometer\r\n"));
			printf_P (PSTR("auxpwr state:'state'=1: turn on aux power net, 'state'=0: turn off aux power net\r\n"));
			printf_P (PSTR("sleep :enter sleep mode\r\n"));
		}
		else if (strstr(Cmd,"tsklst"))
    8080:	6a e7       	ldi	r22, 0x7A	; 122
    8082:	77 e2       	ldi	r23, 0x27	; 39
    8084:	ce 01       	movw	r24, r28
    8086:	87 53       	subi	r24, 0x37	; 55
    8088:	9f 4f       	sbci	r25, 0xFF	; 255
    808a:	0e 94 a9 4c 	call	0x9952	; 0x9952 <strstr>
    808e:	89 2b       	or	r24, r25
    8090:	49 f0       	breq	.+18     	; 0x80a4 <WorkerTerminal+0x19a>
		{
			vTaskGetRunTimeStats(sbuf);
    8092:	ce 01       	movw	r24, r28
    8094:	01 96       	adiw	r24, 0x01	; 1
    8096:	0e 94 cd 2e 	call	0x5d9a	; 0x5d9a <vTaskGetRunTimeStats>
			puts(sbuf);
    809a:	ce 01       	movw	r24, r28
    809c:	01 96       	adiw	r24, 0x01	; 1
    809e:	0e 94 94 4d 	call	0x9b28	; 0x9b28 <puts>
    80a2:	49 cf       	rjmp	.-366    	; 0x7f36 <WorkerTerminal+0x2c>
		}
		else if (strstr(Cmd,"memmap"))
    80a4:	61 e8       	ldi	r22, 0x81	; 129
    80a6:	77 e2       	ldi	r23, 0x27	; 39
    80a8:	ce 01       	movw	r24, r28
    80aa:	87 53       	subi	r24, 0x37	; 55
    80ac:	9f 4f       	sbci	r25, 0xFF	; 255
    80ae:	0e 94 a9 4c 	call	0x9952	; 0x9952 <strstr>
    80b2:	89 2b       	or	r24, r25
    80b4:	19 f0       	breq	.+6      	; 0x80bc <WorkerTerminal+0x1b2>
		{
			MemMap();
    80b6:	0e 94 3d 30 	call	0x607a	; 0x607a <MemMap>
    80ba:	3d cf       	rjmp	.-390    	; 0x7f36 <WorkerTerminal+0x2c>
		}
		else if (strstr(Cmd,"drvstr"))
    80bc:	68 e8       	ldi	r22, 0x88	; 136
    80be:	77 e2       	ldi	r23, 0x27	; 39
    80c0:	ce 01       	movw	r24, r28
    80c2:	87 53       	subi	r24, 0x37	; 55
    80c4:	9f 4f       	sbci	r25, 0xFF	; 255
    80c6:	0e 94 a9 4c 	call	0x9952	; 0x9952 <strstr>
    80ca:	89 2b       	or	r24, r25
    80cc:	59 f0       	breq	.+22     	; 0x80e4 <WorkerTerminal+0x1da>
		{
			DriveStraight(Pars[0],Pars[1]);
    80ce:	a3 01       	movw	r20, r6
    80d0:	92 01       	movw	r18, r4
    80d2:	c5 01       	movw	r24, r10
    80d4:	b4 01       	movw	r22, r8
    80d6:	0e 94 f4 35 	call	0x6be8	; 0x6be8 <DriveStraight>
			printf ("OK\r\n");
    80da:	8f e8       	ldi	r24, 0x8F	; 143
    80dc:	97 e2       	ldi	r25, 0x27	; 39
    80de:	0e 94 94 4d 	call	0x9b28	; 0x9b28 <puts>
    80e2:	29 cf       	rjmp	.-430    	; 0x7f36 <WorkerTerminal+0x2c>
		}
		else if (strstr(Cmd,"drvseg"))
    80e4:	63 e9       	ldi	r22, 0x93	; 147
    80e6:	77 e2       	ldi	r23, 0x27	; 39
    80e8:	ce 01       	movw	r24, r28
    80ea:	87 53       	subi	r24, 0x37	; 55
    80ec:	9f 4f       	sbci	r25, 0xFF	; 255
    80ee:	0e 94 a9 4c 	call	0x9952	; 0x9952 <strstr>
    80f2:	89 2b       	or	r24, r25
    80f4:	49 f0       	breq	.+18     	; 0x8108 <WorkerTerminal+0x1fe>
		{
			DriveSegment(Pars[0]);
    80f6:	c5 01       	movw	r24, r10
    80f8:	b4 01       	movw	r22, r8
    80fa:	0e 94 1f 36 	call	0x6c3e	; 0x6c3e <DriveSegment>
			printf ("OK\r\n");
    80fe:	8f e8       	ldi	r24, 0x8F	; 143
    8100:	97 e2       	ldi	r25, 0x27	; 39
    8102:	0e 94 94 4d 	call	0x9b28	; 0x9b28 <puts>
    8106:	17 cf       	rjmp	.-466    	; 0x7f36 <WorkerTerminal+0x2c>
		}
		else if (strstr(Cmd,"rotctr"))
    8108:	6a e9       	ldi	r22, 0x9A	; 154
    810a:	77 e2       	ldi	r23, 0x27	; 39
    810c:	ce 01       	movw	r24, r28
    810e:	87 53       	subi	r24, 0x37	; 55
    8110:	9f 4f       	sbci	r25, 0xFF	; 255
    8112:	0e 94 a9 4c 	call	0x9952	; 0x9952 <strstr>
    8116:	89 2b       	or	r24, r25
    8118:	59 f0       	breq	.+22     	; 0x8130 <WorkerTerminal+0x226>
		{
			RotateCenter(Pars[0],Pars[1]);
    811a:	a3 01       	movw	r20, r6
    811c:	92 01       	movw	r18, r4
    811e:	c5 01       	movw	r24, r10
    8120:	b4 01       	movw	r22, r8
    8122:	0e 94 46 36 	call	0x6c8c	; 0x6c8c <RotateCenter>
			printf ("OK\r\n");
    8126:	8f e8       	ldi	r24, 0x8F	; 143
    8128:	97 e2       	ldi	r25, 0x27	; 39
    812a:	0e 94 94 4d 	call	0x9b28	; 0x9b28 <puts>
    812e:	03 cf       	rjmp	.-506    	; 0x7f36 <WorkerTerminal+0x2c>
		}
		else if (strstr(Cmd,"setled"))
    8130:	61 ea       	ldi	r22, 0xA1	; 161
    8132:	77 e2       	ldi	r23, 0x27	; 39
    8134:	ce 01       	movw	r24, r28
    8136:	87 53       	subi	r24, 0x37	; 55
    8138:	9f 4f       	sbci	r25, 0xFF	; 255
    813a:	0e 94 a9 4c 	call	0x9952	; 0x9952 <strstr>
    813e:	89 2b       	or	r24, r25
    8140:	61 f0       	breq	.+24     	; 0x815a <WorkerTerminal+0x250>
		{
			SetRGB(Pars[0]);
    8142:	c5 01       	movw	r24, r10
    8144:	b4 01       	movw	r22, r8
    8146:	0e 94 0e 43 	call	0x861c	; 0x861c <__fixunssfsi>
    814a:	86 2f       	mov	r24, r22
    814c:	0e 94 26 3f 	call	0x7e4c	; 0x7e4c <SetRGB>
			printf ("OK\r\n");
    8150:	8f e8       	ldi	r24, 0x8F	; 143
    8152:	97 e2       	ldi	r25, 0x27	; 39
    8154:	0e 94 94 4d 	call	0x9b28	; 0x9b28 <puts>
    8158:	ee ce       	rjmp	.-548    	; 0x7f36 <WorkerTerminal+0x2c>
		}
		else if (strstr(Cmd,"setmot"))
    815a:	68 ea       	ldi	r22, 0xA8	; 168
    815c:	77 e2       	ldi	r23, 0x27	; 39
    815e:	ce 01       	movw	r24, r28
    8160:	87 53       	subi	r24, 0x37	; 55
    8162:	9f 4f       	sbci	r25, 0xFF	; 255
    8164:	0e 94 a9 4c 	call	0x9952	; 0x9952 <strstr>
    8168:	89 2b       	or	r24, r25
    816a:	a1 f0       	breq	.+40     	; 0x8194 <WorkerTerminal+0x28a>
		{
			DriverMotorSet((int16_t) Pars[0],(int16_t) Pars[1]);
    816c:	c3 01       	movw	r24, r6
    816e:	b2 01       	movw	r22, r4
    8170:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
    8174:	2b 01       	movw	r4, r22
    8176:	3c 01       	movw	r6, r24
    8178:	c5 01       	movw	r24, r10
    817a:	b4 01       	movw	r22, r8
    817c:	0e 94 07 43 	call	0x860e	; 0x860e <__fixsfsi>
    8180:	dc 01       	movw	r26, r24
    8182:	cb 01       	movw	r24, r22
    8184:	b2 01       	movw	r22, r4
    8186:	0e 94 f2 06 	call	0xde4	; 0xde4 <DriverMotorSet>
			printf ("OK\r\n");
    818a:	8f e8       	ldi	r24, 0x8F	; 143
    818c:	97 e2       	ldi	r25, 0x27	; 39
    818e:	0e 94 94 4d 	call	0x9b28	; 0x9b28 <puts>
    8192:	d1 ce       	rjmp	.-606    	; 0x7f36 <WorkerTerminal+0x2c>
		}
		else if (strstr(Cmd,"getenc"))
    8194:	6f ea       	ldi	r22, 0xAF	; 175
    8196:	77 e2       	ldi	r23, 0x27	; 39
    8198:	ce 01       	movw	r24, r28
    819a:	87 53       	subi	r24, 0x37	; 55
    819c:	9f 4f       	sbci	r25, 0xFF	; 255
    819e:	0e 94 a9 4c 	call	0x9952	; 0x9952 <strstr>
    81a2:	89 2b       	or	r24, r25
    81a4:	99 f0       	breq	.+38     	; 0x81cc <WorkerTerminal+0x2c2>
		{	
			EncoderStruct Encoder;
			Encoder=DriverMotorGetEncoder();
    81a6:	0e 94 5d 07 	call	0xeba	; 0xeba <DriverMotorGetEncoder>
			printf ("OK %d %d\r\n",Encoder.Cnt1,Encoder.Cnt2);
    81aa:	9f 93       	push	r25
    81ac:	8f 93       	push	r24
    81ae:	7f 93       	push	r23
    81b0:	6f 93       	push	r22
    81b2:	86 eb       	ldi	r24, 0xB6	; 182
    81b4:	97 e2       	ldi	r25, 0x27	; 39
    81b6:	9f 93       	push	r25
    81b8:	8f 93       	push	r24
    81ba:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
    81be:	0f 90       	pop	r0
    81c0:	0f 90       	pop	r0
    81c2:	0f 90       	pop	r0
    81c4:	0f 90       	pop	r0
    81c6:	0f 90       	pop	r0
    81c8:	0f 90       	pop	r0
    81ca:	b5 ce       	rjmp	.-662    	; 0x7f36 <WorkerTerminal+0x2c>
		}		
		else if (strstr(Cmd,"getrgb"))
    81cc:	61 ec       	ldi	r22, 0xC1	; 193
    81ce:	77 e2       	ldi	r23, 0x27	; 39
    81d0:	ce 01       	movw	r24, r28
    81d2:	87 53       	subi	r24, 0x37	; 55
    81d4:	9f 4f       	sbci	r25, 0xFF	; 255
    81d6:	0e 94 a9 4c 	call	0x9952	; 0x9952 <strstr>
    81da:	89 2b       	or	r24, r25
    81dc:	09 f4       	brne	.+2      	; 0x81e0 <WorkerTerminal+0x2d6>
    81de:	47 c0       	rjmp	.+142    	; 0x826e <WorkerTerminal+0x364>
		{
			DriverAdps9960Get(&c,&r,&g,&b);
    81e0:	9e 01       	movw	r18, r28
    81e2:	2b 5e       	subi	r18, 0xEB	; 235
    81e4:	3e 4f       	sbci	r19, 0xFE	; 254
    81e6:	ae 01       	movw	r20, r28
    81e8:	49 5e       	subi	r20, 0xE9	; 233
    81ea:	5e 4f       	sbci	r21, 0xFE	; 254
    81ec:	be 01       	movw	r22, r28
    81ee:	67 5e       	subi	r22, 0xE7	; 231
    81f0:	7e 4f       	sbci	r23, 0xFE	; 254
    81f2:	ce 01       	movw	r24, r28
    81f4:	85 5e       	subi	r24, 0xE5	; 229
    81f6:	9e 4f       	sbci	r25, 0xFE	; 254
    81f8:	0e 94 93 04 	call	0x926	; 0x926 <DriverAdps9960Get>
			printf ("OK %d %d %d %d\r\n",c,r,g,b);
    81fc:	ca 5e       	subi	r28, 0xEA	; 234
    81fe:	de 4f       	sbci	r29, 0xFE	; 254
    8200:	88 81       	ld	r24, Y
    8202:	c6 51       	subi	r28, 0x16	; 22
    8204:	d1 40       	sbci	r29, 0x01	; 1
    8206:	8f 93       	push	r24
    8208:	cb 5e       	subi	r28, 0xEB	; 235
    820a:	de 4f       	sbci	r29, 0xFE	; 254
    820c:	88 81       	ld	r24, Y
    820e:	c5 51       	subi	r28, 0x15	; 21
    8210:	d1 40       	sbci	r29, 0x01	; 1
    8212:	8f 93       	push	r24
    8214:	c8 5e       	subi	r28, 0xE8	; 232
    8216:	de 4f       	sbci	r29, 0xFE	; 254
    8218:	88 81       	ld	r24, Y
    821a:	c8 51       	subi	r28, 0x18	; 24
    821c:	d1 40       	sbci	r29, 0x01	; 1
    821e:	8f 93       	push	r24
    8220:	c9 5e       	subi	r28, 0xE9	; 233
    8222:	de 4f       	sbci	r29, 0xFE	; 254
    8224:	88 81       	ld	r24, Y
    8226:	c7 51       	subi	r28, 0x17	; 23
    8228:	d1 40       	sbci	r29, 0x01	; 1
    822a:	8f 93       	push	r24
    822c:	c6 5e       	subi	r28, 0xE6	; 230
    822e:	de 4f       	sbci	r29, 0xFE	; 254
    8230:	88 81       	ld	r24, Y
    8232:	ca 51       	subi	r28, 0x1A	; 26
    8234:	d1 40       	sbci	r29, 0x01	; 1
    8236:	8f 93       	push	r24
    8238:	c7 5e       	subi	r28, 0xE7	; 231
    823a:	de 4f       	sbci	r29, 0xFE	; 254
    823c:	88 81       	ld	r24, Y
    823e:	c9 51       	subi	r28, 0x19	; 25
    8240:	d1 40       	sbci	r29, 0x01	; 1
    8242:	8f 93       	push	r24
    8244:	c4 5e       	subi	r28, 0xE4	; 228
    8246:	de 4f       	sbci	r29, 0xFE	; 254
    8248:	88 81       	ld	r24, Y
    824a:	cc 51       	subi	r28, 0x1C	; 28
    824c:	d1 40       	sbci	r29, 0x01	; 1
    824e:	8f 93       	push	r24
    8250:	c5 5e       	subi	r28, 0xE5	; 229
    8252:	de 4f       	sbci	r29, 0xFE	; 254
    8254:	88 81       	ld	r24, Y
    8256:	cb 51       	subi	r28, 0x1B	; 27
    8258:	d1 40       	sbci	r29, 0x01	; 1
    825a:	8f 93       	push	r24
    825c:	88 ec       	ldi	r24, 0xC8	; 200
    825e:	97 e2       	ldi	r25, 0x27	; 39
		}
		else if (strstr(Cmd,"getgyr"))
		{
			float YawRate,Yaw;
			GyroGet(&YawRate,&Yaw);
			printf ("OK %f %f\r\n",YawRate,Yaw);
    8260:	9f 93       	push	r25
    8262:	8f 93       	push	r24
    8264:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
    8268:	cd bf       	out	0x3d, r28	; 61
    826a:	de bf       	out	0x3e, r29	; 62
    826c:	64 ce       	rjmp	.-824    	; 0x7f36 <WorkerTerminal+0x2c>
		else if (strstr(Cmd,"getrgb"))
		{
			DriverAdps9960Get(&c,&r,&g,&b);
			printf ("OK %d %d %d %d\r\n",c,r,g,b);
		}
		else if (strstr(Cmd,"getgyr"))
    826e:	69 ed       	ldi	r22, 0xD9	; 217
    8270:	77 e2       	ldi	r23, 0x27	; 39
    8272:	ce 01       	movw	r24, r28
    8274:	87 53       	subi	r24, 0x37	; 55
    8276:	9f 4f       	sbci	r25, 0xFF	; 255
    8278:	0e 94 a9 4c 	call	0x9952	; 0x9952 <strstr>
    827c:	89 2b       	or	r24, r25
    827e:	d9 f1       	breq	.+118    	; 0x82f6 <WorkerTerminal+0x3ec>
		{
			float YawRate,Yaw;
			GyroGet(&YawRate,&Yaw);
    8280:	be 01       	movw	r22, r28
    8282:	67 5f       	subi	r22, 0xF7	; 247
    8284:	7e 4f       	sbci	r23, 0xFE	; 254
    8286:	ce 01       	movw	r24, r28
    8288:	8f 5e       	subi	r24, 0xEF	; 239
    828a:	9e 4f       	sbci	r25, 0xFE	; 254
    828c:	0e 94 fb 31 	call	0x63f6	; 0x63f6 <GyroGet>
			printf ("OK %f %f\r\n",YawRate,Yaw);
    8290:	c4 5f       	subi	r28, 0xF4	; 244
    8292:	de 4f       	sbci	r29, 0xFE	; 254
    8294:	88 81       	ld	r24, Y
    8296:	cc 50       	subi	r28, 0x0C	; 12
    8298:	d1 40       	sbci	r29, 0x01	; 1
    829a:	8f 93       	push	r24
    829c:	c5 5f       	subi	r28, 0xF5	; 245
    829e:	de 4f       	sbci	r29, 0xFE	; 254
    82a0:	88 81       	ld	r24, Y
    82a2:	cb 50       	subi	r28, 0x0B	; 11
    82a4:	d1 40       	sbci	r29, 0x01	; 1
    82a6:	8f 93       	push	r24
    82a8:	c6 5f       	subi	r28, 0xF6	; 246
    82aa:	de 4f       	sbci	r29, 0xFE	; 254
    82ac:	88 81       	ld	r24, Y
    82ae:	ca 50       	subi	r28, 0x0A	; 10
    82b0:	d1 40       	sbci	r29, 0x01	; 1
    82b2:	8f 93       	push	r24
    82b4:	c7 5f       	subi	r28, 0xF7	; 247
    82b6:	de 4f       	sbci	r29, 0xFE	; 254
    82b8:	88 81       	ld	r24, Y
    82ba:	c9 50       	subi	r28, 0x09	; 9
    82bc:	d1 40       	sbci	r29, 0x01	; 1
    82be:	8f 93       	push	r24
    82c0:	cc 5e       	subi	r28, 0xEC	; 236
    82c2:	de 4f       	sbci	r29, 0xFE	; 254
    82c4:	88 81       	ld	r24, Y
    82c6:	c4 51       	subi	r28, 0x14	; 20
    82c8:	d1 40       	sbci	r29, 0x01	; 1
    82ca:	8f 93       	push	r24
    82cc:	cd 5e       	subi	r28, 0xED	; 237
    82ce:	de 4f       	sbci	r29, 0xFE	; 254
    82d0:	88 81       	ld	r24, Y
    82d2:	c3 51       	subi	r28, 0x13	; 19
    82d4:	d1 40       	sbci	r29, 0x01	; 1
    82d6:	8f 93       	push	r24
    82d8:	ce 5e       	subi	r28, 0xEE	; 238
    82da:	de 4f       	sbci	r29, 0xFE	; 254
    82dc:	88 81       	ld	r24, Y
    82de:	c2 51       	subi	r28, 0x12	; 18
    82e0:	d1 40       	sbci	r29, 0x01	; 1
    82e2:	8f 93       	push	r24
    82e4:	cf 5e       	subi	r28, 0xEF	; 239
    82e6:	de 4f       	sbci	r29, 0xFE	; 254
    82e8:	88 81       	ld	r24, Y
    82ea:	c1 51       	subi	r28, 0x11	; 17
    82ec:	d1 40       	sbci	r29, 0x01	; 1
    82ee:	8f 93       	push	r24
    82f0:	80 ee       	ldi	r24, 0xE0	; 224
    82f2:	97 e2       	ldi	r25, 0x27	; 39
    82f4:	b5 cf       	rjmp	.-150    	; 0x8260 <WorkerTerminal+0x356>
		}
		else if (strstr(Cmd,"getadc"))
    82f6:	6b ee       	ldi	r22, 0xEB	; 235
    82f8:	77 e2       	ldi	r23, 0x27	; 39
    82fa:	ce 01       	movw	r24, r28
    82fc:	87 53       	subi	r24, 0x37	; 55
    82fe:	9f 4f       	sbci	r25, 0xFF	; 255
    8300:	0e 94 a9 4c 	call	0x9952	; 0x9952 <strstr>
    8304:	89 2b       	or	r24, r25
    8306:	09 f4       	brne	.+2      	; 0x830a <WorkerTerminal+0x400>
    8308:	58 c0       	rjmp	.+176    	; 0x83ba <WorkerTerminal+0x4b0>
		{
			ADCStruct ADCData;
			ADCData=GetADCData();
    830a:	0e 94 d2 31 	call	0x63a4	; 0x63a4 <GetADCData>
    830e:	c7 5f       	subi	r28, 0xF7	; 247
    8310:	de 4f       	sbci	r29, 0xFE	; 254
    8312:	28 83       	st	Y, r18
    8314:	c9 50       	subi	r28, 0x09	; 9
    8316:	d1 40       	sbci	r29, 0x01	; 1
    8318:	c6 5f       	subi	r28, 0xF6	; 246
    831a:	de 4f       	sbci	r29, 0xFE	; 254
    831c:	38 83       	st	Y, r19
    831e:	ca 50       	subi	r28, 0x0A	; 10
    8320:	d1 40       	sbci	r29, 0x01	; 1
    8322:	c5 5f       	subi	r28, 0xF5	; 245
    8324:	de 4f       	sbci	r29, 0xFE	; 254
    8326:	48 83       	st	Y, r20
    8328:	cb 50       	subi	r28, 0x0B	; 11
    832a:	d1 40       	sbci	r29, 0x01	; 1
    832c:	c4 5f       	subi	r28, 0xF4	; 244
    832e:	de 4f       	sbci	r29, 0xFE	; 254
    8330:	58 83       	st	Y, r21
    8332:	cc 50       	subi	r28, 0x0C	; 12
    8334:	d1 40       	sbci	r29, 0x01	; 1
    8336:	c3 5f       	subi	r28, 0xF3	; 243
    8338:	de 4f       	sbci	r29, 0xFE	; 254
    833a:	68 83       	st	Y, r22
    833c:	cd 50       	subi	r28, 0x0D	; 13
    833e:	d1 40       	sbci	r29, 0x01	; 1
    8340:	c2 5f       	subi	r28, 0xF2	; 242
    8342:	de 4f       	sbci	r29, 0xFE	; 254
    8344:	78 83       	st	Y, r23
    8346:	ce 50       	subi	r28, 0x0E	; 14
    8348:	d1 40       	sbci	r29, 0x01	; 1
    834a:	c1 5f       	subi	r28, 0xF1	; 241
    834c:	de 4f       	sbci	r29, 0xFE	; 254
    834e:	88 83       	st	Y, r24
    8350:	cf 50       	subi	r28, 0x0F	; 15
    8352:	d1 40       	sbci	r29, 0x01	; 1
    8354:	c0 5f       	subi	r28, 0xF0	; 240
    8356:	de 4f       	sbci	r29, 0xFE	; 254
    8358:	98 83       	st	Y, r25
    835a:	c0 51       	subi	r28, 0x10	; 16
    835c:	d1 40       	sbci	r29, 0x01	; 1
			printf ("OK %d %d %d %d\r\n",ADCData.PhotoL,ADCData.PhotoM,ADCData.PhotoR,ADCData.Potmeter);
    835e:	9f 93       	push	r25
    8360:	c1 5f       	subi	r28, 0xF1	; 241
    8362:	de 4f       	sbci	r29, 0xFE	; 254
    8364:	88 81       	ld	r24, Y
    8366:	cf 50       	subi	r28, 0x0F	; 15
    8368:	d1 40       	sbci	r29, 0x01	; 1
    836a:	8f 93       	push	r24
    836c:	c2 5f       	subi	r28, 0xF2	; 242
    836e:	de 4f       	sbci	r29, 0xFE	; 254
    8370:	88 81       	ld	r24, Y
    8372:	ce 50       	subi	r28, 0x0E	; 14
    8374:	d1 40       	sbci	r29, 0x01	; 1
    8376:	8f 93       	push	r24
    8378:	c3 5f       	subi	r28, 0xF3	; 243
    837a:	de 4f       	sbci	r29, 0xFE	; 254
    837c:	88 81       	ld	r24, Y
    837e:	cd 50       	subi	r28, 0x0D	; 13
    8380:	d1 40       	sbci	r29, 0x01	; 1
    8382:	8f 93       	push	r24
    8384:	c4 5f       	subi	r28, 0xF4	; 244
    8386:	de 4f       	sbci	r29, 0xFE	; 254
    8388:	88 81       	ld	r24, Y
    838a:	cc 50       	subi	r28, 0x0C	; 12
    838c:	d1 40       	sbci	r29, 0x01	; 1
    838e:	8f 93       	push	r24
    8390:	c5 5f       	subi	r28, 0xF5	; 245
    8392:	de 4f       	sbci	r29, 0xFE	; 254
    8394:	88 81       	ld	r24, Y
    8396:	cb 50       	subi	r28, 0x0B	; 11
    8398:	d1 40       	sbci	r29, 0x01	; 1
    839a:	8f 93       	push	r24
    839c:	c6 5f       	subi	r28, 0xF6	; 246
    839e:	de 4f       	sbci	r29, 0xFE	; 254
    83a0:	88 81       	ld	r24, Y
    83a2:	ca 50       	subi	r28, 0x0A	; 10
    83a4:	d1 40       	sbci	r29, 0x01	; 1
    83a6:	8f 93       	push	r24
    83a8:	c7 5f       	subi	r28, 0xF7	; 247
    83aa:	de 4f       	sbci	r29, 0xFE	; 254
    83ac:	88 81       	ld	r24, Y
    83ae:	c9 50       	subi	r28, 0x09	; 9
    83b0:	d1 40       	sbci	r29, 0x01	; 1
    83b2:	8f 93       	push	r24
    83b4:	88 ec       	ldi	r24, 0xC8	; 200
    83b6:	97 e2       	ldi	r25, 0x27	; 39
    83b8:	53 cf       	rjmp	.-346    	; 0x8260 <WorkerTerminal+0x356>
		}
		else if (strstr(Cmd,"auxpwr"))
    83ba:	62 ef       	ldi	r22, 0xF2	; 242
    83bc:	77 e2       	ldi	r23, 0x27	; 39
    83be:	ce 01       	movw	r24, r28
    83c0:	87 53       	subi	r24, 0x37	; 55
    83c2:	9f 4f       	sbci	r25, 0xFF	; 255
    83c4:	0e 94 a9 4c 	call	0x9952	; 0x9952 <strstr>
    83c8:	89 2b       	or	r24, r25
    83ca:	61 f0       	breq	.+24     	; 0x83e4 <WorkerTerminal+0x4da>
		{
			DriverPowerVccAuxSet((uint8_t) Pars[0]);
    83cc:	c5 01       	movw	r24, r10
    83ce:	b4 01       	movw	r22, r8
    83d0:	0e 94 0e 43 	call	0x861c	; 0x861c <__fixunssfsi>
    83d4:	86 2f       	mov	r24, r22
    83d6:	0e 94 d6 0e 	call	0x1dac	; 0x1dac <DriverPowerVccAuxSet>
			printf ("OK\r\n");
    83da:	8f e8       	ldi	r24, 0x8F	; 143
    83dc:	97 e2       	ldi	r25, 0x27	; 39
    83de:	0e 94 94 4d 	call	0x9b28	; 0x9b28 <puts>
    83e2:	a9 cd       	rjmp	.-1198   	; 0x7f36 <WorkerTerminal+0x2c>
		}
		else if (strstr(Cmd, "sleep"))
    83e4:	69 ef       	ldi	r22, 0xF9	; 249
    83e6:	77 e2       	ldi	r23, 0x27	; 39
    83e8:	ce 01       	movw	r24, r28
    83ea:	87 53       	subi	r24, 0x37	; 55
    83ec:	9f 4f       	sbci	r25, 0xFF	; 255
    83ee:	0e 94 a9 4c 	call	0x9952	; 0x9952 <strstr>
    83f2:	89 2b       	or	r24, r25
    83f4:	79 f0       	breq	.+30     	; 0x8414 <WorkerTerminal+0x50a>
		{
			printf("Grrrrrr mimimimi");
    83f6:	8f ef       	ldi	r24, 0xFF	; 255
    83f8:	97 e2       	ldi	r25, 0x27	; 39
    83fa:	9f 93       	push	r25
    83fc:	8f 93       	push	r24
    83fe:	0e 94 58 4d 	call	0x9ab0	; 0x9ab0 <printf>
			fflush(stdout);
			vTaskDelay(50/portTICK_PERIOD_MS);
    8402:	82 e3       	ldi	r24, 0x32	; 50
    8404:	90 e0       	ldi	r25, 0x00	; 0
    8406:	0e 94 87 2a 	call	0x550e	; 0x550e <vTaskDelay>
			enterSleepMode();
    840a:	0e 94 5a 1b 	call	0x36b4	; 0x36b4 <enterSleepMode>
    840e:	0f 90       	pop	r0
    8410:	0f 90       	pop	r0
    8412:	91 cd       	rjmp	.-1246   	; 0x7f36 <WorkerTerminal+0x2c>
		}
		else
		printf ("Unknown command\r\n");
    8414:	80 e1       	ldi	r24, 0x10	; 16
    8416:	98 e2       	ldi	r25, 0x28	; 40
    8418:	0e 94 94 4d 	call	0x9b28	; 0x9b28 <puts>
    841c:	8c cd       	rjmp	.-1256   	; 0x7f36 <WorkerTerminal+0x2c>

0000841e <InitTerminalTask>:
static void WorkerTerminal(void *pvParameters);
static void SplitCmd(char *Data,char *Cmd,float *Pars);

//Function definitions
void InitTerminalTask()
{
    841e:	ef 92       	push	r14
    8420:	ff 92       	push	r15
    8422:	0f 93       	push	r16
	xTaskCreate( WorkerTerminal, "term", 1024, NULL, tskIDLE_PRIORITY+1, NULL );	
    8424:	e1 2c       	mov	r14, r1
    8426:	f1 2c       	mov	r15, r1
    8428:	01 e0       	ldi	r16, 0x01	; 1
    842a:	20 e0       	ldi	r18, 0x00	; 0
    842c:	30 e0       	ldi	r19, 0x00	; 0
    842e:	40 e0       	ldi	r20, 0x00	; 0
    8430:	54 e0       	ldi	r21, 0x04	; 4
    8432:	61 e2       	ldi	r22, 0x21	; 33
    8434:	78 e2       	ldi	r23, 0x28	; 40
    8436:	85 e8       	ldi	r24, 0x85	; 133
    8438:	9f e3       	ldi	r25, 0x3F	; 63
    843a:	0e 94 20 26 	call	0x4c40	; 0x4c40 <xTaskCreate>
}
    843e:	0f 91       	pop	r16
    8440:	ff 90       	pop	r15
    8442:	ef 90       	pop	r14
    8444:	08 95       	ret

00008446 <__subsf3>:
    8446:	50 58       	subi	r21, 0x80	; 128

00008448 <__addsf3>:
    8448:	bb 27       	eor	r27, r27
    844a:	aa 27       	eor	r26, r26
    844c:	0e 94 3b 42 	call	0x8476	; 0x8476 <__addsf3x>
    8450:	0c 94 b5 43 	jmp	0x876a	; 0x876a <__fp_round>
    8454:	0e 94 a7 43 	call	0x874e	; 0x874e <__fp_pscA>
    8458:	38 f0       	brcs	.+14     	; 0x8468 <__addsf3+0x20>
    845a:	0e 94 ae 43 	call	0x875c	; 0x875c <__fp_pscB>
    845e:	20 f0       	brcs	.+8      	; 0x8468 <__addsf3+0x20>
    8460:	39 f4       	brne	.+14     	; 0x8470 <__addsf3+0x28>
    8462:	9f 3f       	cpi	r25, 0xFF	; 255
    8464:	19 f4       	brne	.+6      	; 0x846c <__addsf3+0x24>
    8466:	26 f4       	brtc	.+8      	; 0x8470 <__addsf3+0x28>
    8468:	0c 94 a4 43 	jmp	0x8748	; 0x8748 <__fp_nan>
    846c:	0e f4       	brtc	.+2      	; 0x8470 <__addsf3+0x28>
    846e:	e0 95       	com	r30
    8470:	e7 fb       	bst	r30, 7
    8472:	0c 94 9e 43 	jmp	0x873c	; 0x873c <__fp_inf>

00008476 <__addsf3x>:
    8476:	e9 2f       	mov	r30, r25
    8478:	0e 94 c6 43 	call	0x878c	; 0x878c <__fp_split3>
    847c:	58 f3       	brcs	.-42     	; 0x8454 <__addsf3+0xc>
    847e:	ba 17       	cp	r27, r26
    8480:	62 07       	cpc	r22, r18
    8482:	73 07       	cpc	r23, r19
    8484:	84 07       	cpc	r24, r20
    8486:	95 07       	cpc	r25, r21
    8488:	20 f0       	brcs	.+8      	; 0x8492 <__addsf3x+0x1c>
    848a:	79 f4       	brne	.+30     	; 0x84aa <__addsf3x+0x34>
    848c:	a6 f5       	brtc	.+104    	; 0x84f6 <__addsf3x+0x80>
    848e:	0c 94 e8 43 	jmp	0x87d0	; 0x87d0 <__fp_zero>
    8492:	0e f4       	brtc	.+2      	; 0x8496 <__addsf3x+0x20>
    8494:	e0 95       	com	r30
    8496:	0b 2e       	mov	r0, r27
    8498:	ba 2f       	mov	r27, r26
    849a:	a0 2d       	mov	r26, r0
    849c:	0b 01       	movw	r0, r22
    849e:	b9 01       	movw	r22, r18
    84a0:	90 01       	movw	r18, r0
    84a2:	0c 01       	movw	r0, r24
    84a4:	ca 01       	movw	r24, r20
    84a6:	a0 01       	movw	r20, r0
    84a8:	11 24       	eor	r1, r1
    84aa:	ff 27       	eor	r31, r31
    84ac:	59 1b       	sub	r21, r25
    84ae:	99 f0       	breq	.+38     	; 0x84d6 <__addsf3x+0x60>
    84b0:	59 3f       	cpi	r21, 0xF9	; 249
    84b2:	50 f4       	brcc	.+20     	; 0x84c8 <__addsf3x+0x52>
    84b4:	50 3e       	cpi	r21, 0xE0	; 224
    84b6:	68 f1       	brcs	.+90     	; 0x8512 <__addsf3x+0x9c>
    84b8:	1a 16       	cp	r1, r26
    84ba:	f0 40       	sbci	r31, 0x00	; 0
    84bc:	a2 2f       	mov	r26, r18
    84be:	23 2f       	mov	r18, r19
    84c0:	34 2f       	mov	r19, r20
    84c2:	44 27       	eor	r20, r20
    84c4:	58 5f       	subi	r21, 0xF8	; 248
    84c6:	f3 cf       	rjmp	.-26     	; 0x84ae <__addsf3x+0x38>
    84c8:	46 95       	lsr	r20
    84ca:	37 95       	ror	r19
    84cc:	27 95       	ror	r18
    84ce:	a7 95       	ror	r26
    84d0:	f0 40       	sbci	r31, 0x00	; 0
    84d2:	53 95       	inc	r21
    84d4:	c9 f7       	brne	.-14     	; 0x84c8 <__addsf3x+0x52>
    84d6:	7e f4       	brtc	.+30     	; 0x84f6 <__addsf3x+0x80>
    84d8:	1f 16       	cp	r1, r31
    84da:	ba 0b       	sbc	r27, r26
    84dc:	62 0b       	sbc	r22, r18
    84de:	73 0b       	sbc	r23, r19
    84e0:	84 0b       	sbc	r24, r20
    84e2:	ba f0       	brmi	.+46     	; 0x8512 <__addsf3x+0x9c>
    84e4:	91 50       	subi	r25, 0x01	; 1
    84e6:	a1 f0       	breq	.+40     	; 0x8510 <__addsf3x+0x9a>
    84e8:	ff 0f       	add	r31, r31
    84ea:	bb 1f       	adc	r27, r27
    84ec:	66 1f       	adc	r22, r22
    84ee:	77 1f       	adc	r23, r23
    84f0:	88 1f       	adc	r24, r24
    84f2:	c2 f7       	brpl	.-16     	; 0x84e4 <__addsf3x+0x6e>
    84f4:	0e c0       	rjmp	.+28     	; 0x8512 <__addsf3x+0x9c>
    84f6:	ba 0f       	add	r27, r26
    84f8:	62 1f       	adc	r22, r18
    84fa:	73 1f       	adc	r23, r19
    84fc:	84 1f       	adc	r24, r20
    84fe:	48 f4       	brcc	.+18     	; 0x8512 <__addsf3x+0x9c>
    8500:	87 95       	ror	r24
    8502:	77 95       	ror	r23
    8504:	67 95       	ror	r22
    8506:	b7 95       	ror	r27
    8508:	f7 95       	ror	r31
    850a:	9e 3f       	cpi	r25, 0xFE	; 254
    850c:	08 f0       	brcs	.+2      	; 0x8510 <__addsf3x+0x9a>
    850e:	b0 cf       	rjmp	.-160    	; 0x8470 <__addsf3+0x28>
    8510:	93 95       	inc	r25
    8512:	88 0f       	add	r24, r24
    8514:	08 f0       	brcs	.+2      	; 0x8518 <__addsf3x+0xa2>
    8516:	99 27       	eor	r25, r25
    8518:	ee 0f       	add	r30, r30
    851a:	97 95       	ror	r25
    851c:	87 95       	ror	r24
    851e:	08 95       	ret

00008520 <__cmpsf2>:
    8520:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__fp_cmp>
    8524:	08 f4       	brcc	.+2      	; 0x8528 <__cmpsf2+0x8>
    8526:	81 e0       	ldi	r24, 0x01	; 1
    8528:	08 95       	ret

0000852a <__divsf3>:
    852a:	0e 94 a9 42 	call	0x8552	; 0x8552 <__divsf3x>
    852e:	0c 94 b5 43 	jmp	0x876a	; 0x876a <__fp_round>
    8532:	0e 94 ae 43 	call	0x875c	; 0x875c <__fp_pscB>
    8536:	58 f0       	brcs	.+22     	; 0x854e <__divsf3+0x24>
    8538:	0e 94 a7 43 	call	0x874e	; 0x874e <__fp_pscA>
    853c:	40 f0       	brcs	.+16     	; 0x854e <__divsf3+0x24>
    853e:	29 f4       	brne	.+10     	; 0x854a <__divsf3+0x20>
    8540:	5f 3f       	cpi	r21, 0xFF	; 255
    8542:	29 f0       	breq	.+10     	; 0x854e <__divsf3+0x24>
    8544:	0c 94 9e 43 	jmp	0x873c	; 0x873c <__fp_inf>
    8548:	51 11       	cpse	r21, r1
    854a:	0c 94 e9 43 	jmp	0x87d2	; 0x87d2 <__fp_szero>
    854e:	0c 94 a4 43 	jmp	0x8748	; 0x8748 <__fp_nan>

00008552 <__divsf3x>:
    8552:	0e 94 c6 43 	call	0x878c	; 0x878c <__fp_split3>
    8556:	68 f3       	brcs	.-38     	; 0x8532 <__divsf3+0x8>

00008558 <__divsf3_pse>:
    8558:	99 23       	and	r25, r25
    855a:	b1 f3       	breq	.-20     	; 0x8548 <__divsf3+0x1e>
    855c:	55 23       	and	r21, r21
    855e:	91 f3       	breq	.-28     	; 0x8544 <__divsf3+0x1a>
    8560:	95 1b       	sub	r25, r21
    8562:	55 0b       	sbc	r21, r21
    8564:	bb 27       	eor	r27, r27
    8566:	aa 27       	eor	r26, r26
    8568:	62 17       	cp	r22, r18
    856a:	73 07       	cpc	r23, r19
    856c:	84 07       	cpc	r24, r20
    856e:	38 f0       	brcs	.+14     	; 0x857e <__divsf3_pse+0x26>
    8570:	9f 5f       	subi	r25, 0xFF	; 255
    8572:	5f 4f       	sbci	r21, 0xFF	; 255
    8574:	22 0f       	add	r18, r18
    8576:	33 1f       	adc	r19, r19
    8578:	44 1f       	adc	r20, r20
    857a:	aa 1f       	adc	r26, r26
    857c:	a9 f3       	breq	.-22     	; 0x8568 <__divsf3_pse+0x10>
    857e:	35 d0       	rcall	.+106    	; 0x85ea <__divsf3_pse+0x92>
    8580:	0e 2e       	mov	r0, r30
    8582:	3a f0       	brmi	.+14     	; 0x8592 <__divsf3_pse+0x3a>
    8584:	e0 e8       	ldi	r30, 0x80	; 128
    8586:	32 d0       	rcall	.+100    	; 0x85ec <__divsf3_pse+0x94>
    8588:	91 50       	subi	r25, 0x01	; 1
    858a:	50 40       	sbci	r21, 0x00	; 0
    858c:	e6 95       	lsr	r30
    858e:	00 1c       	adc	r0, r0
    8590:	ca f7       	brpl	.-14     	; 0x8584 <__divsf3_pse+0x2c>
    8592:	2b d0       	rcall	.+86     	; 0x85ea <__divsf3_pse+0x92>
    8594:	fe 2f       	mov	r31, r30
    8596:	29 d0       	rcall	.+82     	; 0x85ea <__divsf3_pse+0x92>
    8598:	66 0f       	add	r22, r22
    859a:	77 1f       	adc	r23, r23
    859c:	88 1f       	adc	r24, r24
    859e:	bb 1f       	adc	r27, r27
    85a0:	26 17       	cp	r18, r22
    85a2:	37 07       	cpc	r19, r23
    85a4:	48 07       	cpc	r20, r24
    85a6:	ab 07       	cpc	r26, r27
    85a8:	b0 e8       	ldi	r27, 0x80	; 128
    85aa:	09 f0       	breq	.+2      	; 0x85ae <__divsf3_pse+0x56>
    85ac:	bb 0b       	sbc	r27, r27
    85ae:	80 2d       	mov	r24, r0
    85b0:	bf 01       	movw	r22, r30
    85b2:	ff 27       	eor	r31, r31
    85b4:	93 58       	subi	r25, 0x83	; 131
    85b6:	5f 4f       	sbci	r21, 0xFF	; 255
    85b8:	3a f0       	brmi	.+14     	; 0x85c8 <__divsf3_pse+0x70>
    85ba:	9e 3f       	cpi	r25, 0xFE	; 254
    85bc:	51 05       	cpc	r21, r1
    85be:	78 f0       	brcs	.+30     	; 0x85de <__divsf3_pse+0x86>
    85c0:	0c 94 9e 43 	jmp	0x873c	; 0x873c <__fp_inf>
    85c4:	0c 94 e9 43 	jmp	0x87d2	; 0x87d2 <__fp_szero>
    85c8:	5f 3f       	cpi	r21, 0xFF	; 255
    85ca:	e4 f3       	brlt	.-8      	; 0x85c4 <__divsf3_pse+0x6c>
    85cc:	98 3e       	cpi	r25, 0xE8	; 232
    85ce:	d4 f3       	brlt	.-12     	; 0x85c4 <__divsf3_pse+0x6c>
    85d0:	86 95       	lsr	r24
    85d2:	77 95       	ror	r23
    85d4:	67 95       	ror	r22
    85d6:	b7 95       	ror	r27
    85d8:	f7 95       	ror	r31
    85da:	9f 5f       	subi	r25, 0xFF	; 255
    85dc:	c9 f7       	brne	.-14     	; 0x85d0 <__divsf3_pse+0x78>
    85de:	88 0f       	add	r24, r24
    85e0:	91 1d       	adc	r25, r1
    85e2:	96 95       	lsr	r25
    85e4:	87 95       	ror	r24
    85e6:	97 f9       	bld	r25, 7
    85e8:	08 95       	ret
    85ea:	e1 e0       	ldi	r30, 0x01	; 1
    85ec:	66 0f       	add	r22, r22
    85ee:	77 1f       	adc	r23, r23
    85f0:	88 1f       	adc	r24, r24
    85f2:	bb 1f       	adc	r27, r27
    85f4:	62 17       	cp	r22, r18
    85f6:	73 07       	cpc	r23, r19
    85f8:	84 07       	cpc	r24, r20
    85fa:	ba 07       	cpc	r27, r26
    85fc:	20 f0       	brcs	.+8      	; 0x8606 <__divsf3_pse+0xae>
    85fe:	62 1b       	sub	r22, r18
    8600:	73 0b       	sbc	r23, r19
    8602:	84 0b       	sbc	r24, r20
    8604:	ba 0b       	sbc	r27, r26
    8606:	ee 1f       	adc	r30, r30
    8608:	88 f7       	brcc	.-30     	; 0x85ec <__divsf3_pse+0x94>
    860a:	e0 95       	com	r30
    860c:	08 95       	ret

0000860e <__fixsfsi>:
    860e:	0e 94 0e 43 	call	0x861c	; 0x861c <__fixunssfsi>
    8612:	68 94       	set
    8614:	b1 11       	cpse	r27, r1
    8616:	0c 94 e9 43 	jmp	0x87d2	; 0x87d2 <__fp_szero>
    861a:	08 95       	ret

0000861c <__fixunssfsi>:
    861c:	0e 94 ce 43 	call	0x879c	; 0x879c <__fp_splitA>
    8620:	88 f0       	brcs	.+34     	; 0x8644 <__fixunssfsi+0x28>
    8622:	9f 57       	subi	r25, 0x7F	; 127
    8624:	98 f0       	brcs	.+38     	; 0x864c <__fixunssfsi+0x30>
    8626:	b9 2f       	mov	r27, r25
    8628:	99 27       	eor	r25, r25
    862a:	b7 51       	subi	r27, 0x17	; 23
    862c:	b0 f0       	brcs	.+44     	; 0x865a <__fixunssfsi+0x3e>
    862e:	e1 f0       	breq	.+56     	; 0x8668 <__fixunssfsi+0x4c>
    8630:	66 0f       	add	r22, r22
    8632:	77 1f       	adc	r23, r23
    8634:	88 1f       	adc	r24, r24
    8636:	99 1f       	adc	r25, r25
    8638:	1a f0       	brmi	.+6      	; 0x8640 <__fixunssfsi+0x24>
    863a:	ba 95       	dec	r27
    863c:	c9 f7       	brne	.-14     	; 0x8630 <__fixunssfsi+0x14>
    863e:	14 c0       	rjmp	.+40     	; 0x8668 <__fixunssfsi+0x4c>
    8640:	b1 30       	cpi	r27, 0x01	; 1
    8642:	91 f0       	breq	.+36     	; 0x8668 <__fixunssfsi+0x4c>
    8644:	0e 94 e8 43 	call	0x87d0	; 0x87d0 <__fp_zero>
    8648:	b1 e0       	ldi	r27, 0x01	; 1
    864a:	08 95       	ret
    864c:	0c 94 e8 43 	jmp	0x87d0	; 0x87d0 <__fp_zero>
    8650:	67 2f       	mov	r22, r23
    8652:	78 2f       	mov	r23, r24
    8654:	88 27       	eor	r24, r24
    8656:	b8 5f       	subi	r27, 0xF8	; 248
    8658:	39 f0       	breq	.+14     	; 0x8668 <__fixunssfsi+0x4c>
    865a:	b9 3f       	cpi	r27, 0xF9	; 249
    865c:	cc f3       	brlt	.-14     	; 0x8650 <__fixunssfsi+0x34>
    865e:	86 95       	lsr	r24
    8660:	77 95       	ror	r23
    8662:	67 95       	ror	r22
    8664:	b3 95       	inc	r27
    8666:	d9 f7       	brne	.-10     	; 0x865e <__fixunssfsi+0x42>
    8668:	3e f4       	brtc	.+14     	; 0x8678 <__fixunssfsi+0x5c>
    866a:	90 95       	com	r25
    866c:	80 95       	com	r24
    866e:	70 95       	com	r23
    8670:	61 95       	neg	r22
    8672:	7f 4f       	sbci	r23, 0xFF	; 255
    8674:	8f 4f       	sbci	r24, 0xFF	; 255
    8676:	9f 4f       	sbci	r25, 0xFF	; 255
    8678:	08 95       	ret

0000867a <__floatunsisf>:
    867a:	e8 94       	clt
    867c:	09 c0       	rjmp	.+18     	; 0x8690 <__floatsisf+0x12>

0000867e <__floatsisf>:
    867e:	97 fb       	bst	r25, 7
    8680:	3e f4       	brtc	.+14     	; 0x8690 <__floatsisf+0x12>
    8682:	90 95       	com	r25
    8684:	80 95       	com	r24
    8686:	70 95       	com	r23
    8688:	61 95       	neg	r22
    868a:	7f 4f       	sbci	r23, 0xFF	; 255
    868c:	8f 4f       	sbci	r24, 0xFF	; 255
    868e:	9f 4f       	sbci	r25, 0xFF	; 255
    8690:	99 23       	and	r25, r25
    8692:	a9 f0       	breq	.+42     	; 0x86be <__floatsisf+0x40>
    8694:	f9 2f       	mov	r31, r25
    8696:	96 e9       	ldi	r25, 0x96	; 150
    8698:	bb 27       	eor	r27, r27
    869a:	93 95       	inc	r25
    869c:	f6 95       	lsr	r31
    869e:	87 95       	ror	r24
    86a0:	77 95       	ror	r23
    86a2:	67 95       	ror	r22
    86a4:	b7 95       	ror	r27
    86a6:	f1 11       	cpse	r31, r1
    86a8:	f8 cf       	rjmp	.-16     	; 0x869a <__floatsisf+0x1c>
    86aa:	fa f4       	brpl	.+62     	; 0x86ea <__floatsisf+0x6c>
    86ac:	bb 0f       	add	r27, r27
    86ae:	11 f4       	brne	.+4      	; 0x86b4 <__floatsisf+0x36>
    86b0:	60 ff       	sbrs	r22, 0
    86b2:	1b c0       	rjmp	.+54     	; 0x86ea <__floatsisf+0x6c>
    86b4:	6f 5f       	subi	r22, 0xFF	; 255
    86b6:	7f 4f       	sbci	r23, 0xFF	; 255
    86b8:	8f 4f       	sbci	r24, 0xFF	; 255
    86ba:	9f 4f       	sbci	r25, 0xFF	; 255
    86bc:	16 c0       	rjmp	.+44     	; 0x86ea <__floatsisf+0x6c>
    86be:	88 23       	and	r24, r24
    86c0:	11 f0       	breq	.+4      	; 0x86c6 <__floatsisf+0x48>
    86c2:	96 e9       	ldi	r25, 0x96	; 150
    86c4:	11 c0       	rjmp	.+34     	; 0x86e8 <__floatsisf+0x6a>
    86c6:	77 23       	and	r23, r23
    86c8:	21 f0       	breq	.+8      	; 0x86d2 <__floatsisf+0x54>
    86ca:	9e e8       	ldi	r25, 0x8E	; 142
    86cc:	87 2f       	mov	r24, r23
    86ce:	76 2f       	mov	r23, r22
    86d0:	05 c0       	rjmp	.+10     	; 0x86dc <__floatsisf+0x5e>
    86d2:	66 23       	and	r22, r22
    86d4:	71 f0       	breq	.+28     	; 0x86f2 <__floatsisf+0x74>
    86d6:	96 e8       	ldi	r25, 0x86	; 134
    86d8:	86 2f       	mov	r24, r22
    86da:	70 e0       	ldi	r23, 0x00	; 0
    86dc:	60 e0       	ldi	r22, 0x00	; 0
    86de:	2a f0       	brmi	.+10     	; 0x86ea <__floatsisf+0x6c>
    86e0:	9a 95       	dec	r25
    86e2:	66 0f       	add	r22, r22
    86e4:	77 1f       	adc	r23, r23
    86e6:	88 1f       	adc	r24, r24
    86e8:	da f7       	brpl	.-10     	; 0x86e0 <__floatsisf+0x62>
    86ea:	88 0f       	add	r24, r24
    86ec:	96 95       	lsr	r25
    86ee:	87 95       	ror	r24
    86f0:	97 f9       	bld	r25, 7
    86f2:	08 95       	ret

000086f4 <__fp_cmp>:
    86f4:	99 0f       	add	r25, r25
    86f6:	00 08       	sbc	r0, r0
    86f8:	55 0f       	add	r21, r21
    86fa:	aa 0b       	sbc	r26, r26
    86fc:	e0 e8       	ldi	r30, 0x80	; 128
    86fe:	fe ef       	ldi	r31, 0xFE	; 254
    8700:	16 16       	cp	r1, r22
    8702:	17 06       	cpc	r1, r23
    8704:	e8 07       	cpc	r30, r24
    8706:	f9 07       	cpc	r31, r25
    8708:	c0 f0       	brcs	.+48     	; 0x873a <__fp_cmp+0x46>
    870a:	12 16       	cp	r1, r18
    870c:	13 06       	cpc	r1, r19
    870e:	e4 07       	cpc	r30, r20
    8710:	f5 07       	cpc	r31, r21
    8712:	98 f0       	brcs	.+38     	; 0x873a <__fp_cmp+0x46>
    8714:	62 1b       	sub	r22, r18
    8716:	73 0b       	sbc	r23, r19
    8718:	84 0b       	sbc	r24, r20
    871a:	95 0b       	sbc	r25, r21
    871c:	39 f4       	brne	.+14     	; 0x872c <__fp_cmp+0x38>
    871e:	0a 26       	eor	r0, r26
    8720:	61 f0       	breq	.+24     	; 0x873a <__fp_cmp+0x46>
    8722:	23 2b       	or	r18, r19
    8724:	24 2b       	or	r18, r20
    8726:	25 2b       	or	r18, r21
    8728:	21 f4       	brne	.+8      	; 0x8732 <__fp_cmp+0x3e>
    872a:	08 95       	ret
    872c:	0a 26       	eor	r0, r26
    872e:	09 f4       	brne	.+2      	; 0x8732 <__fp_cmp+0x3e>
    8730:	a1 40       	sbci	r26, 0x01	; 1
    8732:	a6 95       	lsr	r26
    8734:	8f ef       	ldi	r24, 0xFF	; 255
    8736:	81 1d       	adc	r24, r1
    8738:	81 1d       	adc	r24, r1
    873a:	08 95       	ret

0000873c <__fp_inf>:
    873c:	97 f9       	bld	r25, 7
    873e:	9f 67       	ori	r25, 0x7F	; 127
    8740:	80 e8       	ldi	r24, 0x80	; 128
    8742:	70 e0       	ldi	r23, 0x00	; 0
    8744:	60 e0       	ldi	r22, 0x00	; 0
    8746:	08 95       	ret

00008748 <__fp_nan>:
    8748:	9f ef       	ldi	r25, 0xFF	; 255
    874a:	80 ec       	ldi	r24, 0xC0	; 192
    874c:	08 95       	ret

0000874e <__fp_pscA>:
    874e:	00 24       	eor	r0, r0
    8750:	0a 94       	dec	r0
    8752:	16 16       	cp	r1, r22
    8754:	17 06       	cpc	r1, r23
    8756:	18 06       	cpc	r1, r24
    8758:	09 06       	cpc	r0, r25
    875a:	08 95       	ret

0000875c <__fp_pscB>:
    875c:	00 24       	eor	r0, r0
    875e:	0a 94       	dec	r0
    8760:	12 16       	cp	r1, r18
    8762:	13 06       	cpc	r1, r19
    8764:	14 06       	cpc	r1, r20
    8766:	05 06       	cpc	r0, r21
    8768:	08 95       	ret

0000876a <__fp_round>:
    876a:	09 2e       	mov	r0, r25
    876c:	03 94       	inc	r0
    876e:	00 0c       	add	r0, r0
    8770:	11 f4       	brne	.+4      	; 0x8776 <__fp_round+0xc>
    8772:	88 23       	and	r24, r24
    8774:	52 f0       	brmi	.+20     	; 0x878a <__fp_round+0x20>
    8776:	bb 0f       	add	r27, r27
    8778:	40 f4       	brcc	.+16     	; 0x878a <__fp_round+0x20>
    877a:	bf 2b       	or	r27, r31
    877c:	11 f4       	brne	.+4      	; 0x8782 <__fp_round+0x18>
    877e:	60 ff       	sbrs	r22, 0
    8780:	04 c0       	rjmp	.+8      	; 0x878a <__fp_round+0x20>
    8782:	6f 5f       	subi	r22, 0xFF	; 255
    8784:	7f 4f       	sbci	r23, 0xFF	; 255
    8786:	8f 4f       	sbci	r24, 0xFF	; 255
    8788:	9f 4f       	sbci	r25, 0xFF	; 255
    878a:	08 95       	ret

0000878c <__fp_split3>:
    878c:	57 fd       	sbrc	r21, 7
    878e:	90 58       	subi	r25, 0x80	; 128
    8790:	44 0f       	add	r20, r20
    8792:	55 1f       	adc	r21, r21
    8794:	59 f0       	breq	.+22     	; 0x87ac <__fp_splitA+0x10>
    8796:	5f 3f       	cpi	r21, 0xFF	; 255
    8798:	71 f0       	breq	.+28     	; 0x87b6 <__fp_splitA+0x1a>
    879a:	47 95       	ror	r20

0000879c <__fp_splitA>:
    879c:	88 0f       	add	r24, r24
    879e:	97 fb       	bst	r25, 7
    87a0:	99 1f       	adc	r25, r25
    87a2:	61 f0       	breq	.+24     	; 0x87bc <__fp_splitA+0x20>
    87a4:	9f 3f       	cpi	r25, 0xFF	; 255
    87a6:	79 f0       	breq	.+30     	; 0x87c6 <__fp_splitA+0x2a>
    87a8:	87 95       	ror	r24
    87aa:	08 95       	ret
    87ac:	12 16       	cp	r1, r18
    87ae:	13 06       	cpc	r1, r19
    87b0:	14 06       	cpc	r1, r20
    87b2:	55 1f       	adc	r21, r21
    87b4:	f2 cf       	rjmp	.-28     	; 0x879a <__fp_split3+0xe>
    87b6:	46 95       	lsr	r20
    87b8:	f1 df       	rcall	.-30     	; 0x879c <__fp_splitA>
    87ba:	08 c0       	rjmp	.+16     	; 0x87cc <__fp_splitA+0x30>
    87bc:	16 16       	cp	r1, r22
    87be:	17 06       	cpc	r1, r23
    87c0:	18 06       	cpc	r1, r24
    87c2:	99 1f       	adc	r25, r25
    87c4:	f1 cf       	rjmp	.-30     	; 0x87a8 <__fp_splitA+0xc>
    87c6:	86 95       	lsr	r24
    87c8:	71 05       	cpc	r23, r1
    87ca:	61 05       	cpc	r22, r1
    87cc:	08 94       	sec
    87ce:	08 95       	ret

000087d0 <__fp_zero>:
    87d0:	e8 94       	clt

000087d2 <__fp_szero>:
    87d2:	bb 27       	eor	r27, r27
    87d4:	66 27       	eor	r22, r22
    87d6:	77 27       	eor	r23, r23
    87d8:	cb 01       	movw	r24, r22
    87da:	97 f9       	bld	r25, 7
    87dc:	08 95       	ret

000087de <__gesf2>:
    87de:	0e 94 7a 43 	call	0x86f4	; 0x86f4 <__fp_cmp>
    87e2:	08 f4       	brcc	.+2      	; 0x87e6 <__gesf2+0x8>
    87e4:	8f ef       	ldi	r24, 0xFF	; 255
    87e6:	08 95       	ret

000087e8 <__mulsf3>:
    87e8:	0e 94 07 44 	call	0x880e	; 0x880e <__mulsf3x>
    87ec:	0c 94 b5 43 	jmp	0x876a	; 0x876a <__fp_round>
    87f0:	0e 94 a7 43 	call	0x874e	; 0x874e <__fp_pscA>
    87f4:	38 f0       	brcs	.+14     	; 0x8804 <__mulsf3+0x1c>
    87f6:	0e 94 ae 43 	call	0x875c	; 0x875c <__fp_pscB>
    87fa:	20 f0       	brcs	.+8      	; 0x8804 <__mulsf3+0x1c>
    87fc:	95 23       	and	r25, r21
    87fe:	11 f0       	breq	.+4      	; 0x8804 <__mulsf3+0x1c>
    8800:	0c 94 9e 43 	jmp	0x873c	; 0x873c <__fp_inf>
    8804:	0c 94 a4 43 	jmp	0x8748	; 0x8748 <__fp_nan>
    8808:	11 24       	eor	r1, r1
    880a:	0c 94 e9 43 	jmp	0x87d2	; 0x87d2 <__fp_szero>

0000880e <__mulsf3x>:
    880e:	0e 94 c6 43 	call	0x878c	; 0x878c <__fp_split3>
    8812:	70 f3       	brcs	.-36     	; 0x87f0 <__mulsf3+0x8>

00008814 <__mulsf3_pse>:
    8814:	95 9f       	mul	r25, r21
    8816:	c1 f3       	breq	.-16     	; 0x8808 <__mulsf3+0x20>
    8818:	95 0f       	add	r25, r21
    881a:	50 e0       	ldi	r21, 0x00	; 0
    881c:	55 1f       	adc	r21, r21
    881e:	62 9f       	mul	r22, r18
    8820:	f0 01       	movw	r30, r0
    8822:	72 9f       	mul	r23, r18
    8824:	bb 27       	eor	r27, r27
    8826:	f0 0d       	add	r31, r0
    8828:	b1 1d       	adc	r27, r1
    882a:	63 9f       	mul	r22, r19
    882c:	aa 27       	eor	r26, r26
    882e:	f0 0d       	add	r31, r0
    8830:	b1 1d       	adc	r27, r1
    8832:	aa 1f       	adc	r26, r26
    8834:	64 9f       	mul	r22, r20
    8836:	66 27       	eor	r22, r22
    8838:	b0 0d       	add	r27, r0
    883a:	a1 1d       	adc	r26, r1
    883c:	66 1f       	adc	r22, r22
    883e:	82 9f       	mul	r24, r18
    8840:	22 27       	eor	r18, r18
    8842:	b0 0d       	add	r27, r0
    8844:	a1 1d       	adc	r26, r1
    8846:	62 1f       	adc	r22, r18
    8848:	73 9f       	mul	r23, r19
    884a:	b0 0d       	add	r27, r0
    884c:	a1 1d       	adc	r26, r1
    884e:	62 1f       	adc	r22, r18
    8850:	83 9f       	mul	r24, r19
    8852:	a0 0d       	add	r26, r0
    8854:	61 1d       	adc	r22, r1
    8856:	22 1f       	adc	r18, r18
    8858:	74 9f       	mul	r23, r20
    885a:	33 27       	eor	r19, r19
    885c:	a0 0d       	add	r26, r0
    885e:	61 1d       	adc	r22, r1
    8860:	23 1f       	adc	r18, r19
    8862:	84 9f       	mul	r24, r20
    8864:	60 0d       	add	r22, r0
    8866:	21 1d       	adc	r18, r1
    8868:	82 2f       	mov	r24, r18
    886a:	76 2f       	mov	r23, r22
    886c:	6a 2f       	mov	r22, r26
    886e:	11 24       	eor	r1, r1
    8870:	9f 57       	subi	r25, 0x7F	; 127
    8872:	50 40       	sbci	r21, 0x00	; 0
    8874:	9a f0       	brmi	.+38     	; 0x889c <__mulsf3_pse+0x88>
    8876:	f1 f0       	breq	.+60     	; 0x88b4 <__mulsf3_pse+0xa0>
    8878:	88 23       	and	r24, r24
    887a:	4a f0       	brmi	.+18     	; 0x888e <__mulsf3_pse+0x7a>
    887c:	ee 0f       	add	r30, r30
    887e:	ff 1f       	adc	r31, r31
    8880:	bb 1f       	adc	r27, r27
    8882:	66 1f       	adc	r22, r22
    8884:	77 1f       	adc	r23, r23
    8886:	88 1f       	adc	r24, r24
    8888:	91 50       	subi	r25, 0x01	; 1
    888a:	50 40       	sbci	r21, 0x00	; 0
    888c:	a9 f7       	brne	.-22     	; 0x8878 <__mulsf3_pse+0x64>
    888e:	9e 3f       	cpi	r25, 0xFE	; 254
    8890:	51 05       	cpc	r21, r1
    8892:	80 f0       	brcs	.+32     	; 0x88b4 <__mulsf3_pse+0xa0>
    8894:	0c 94 9e 43 	jmp	0x873c	; 0x873c <__fp_inf>
    8898:	0c 94 e9 43 	jmp	0x87d2	; 0x87d2 <__fp_szero>
    889c:	5f 3f       	cpi	r21, 0xFF	; 255
    889e:	e4 f3       	brlt	.-8      	; 0x8898 <__mulsf3_pse+0x84>
    88a0:	98 3e       	cpi	r25, 0xE8	; 232
    88a2:	d4 f3       	brlt	.-12     	; 0x8898 <__mulsf3_pse+0x84>
    88a4:	86 95       	lsr	r24
    88a6:	77 95       	ror	r23
    88a8:	67 95       	ror	r22
    88aa:	b7 95       	ror	r27
    88ac:	f7 95       	ror	r31
    88ae:	e7 95       	ror	r30
    88b0:	9f 5f       	subi	r25, 0xFF	; 255
    88b2:	c1 f7       	brne	.-16     	; 0x88a4 <__mulsf3_pse+0x90>
    88b4:	fe 2b       	or	r31, r30
    88b6:	88 0f       	add	r24, r24
    88b8:	91 1d       	adc	r25, r1
    88ba:	96 95       	lsr	r25
    88bc:	87 95       	ror	r24
    88be:	97 f9       	bld	r25, 7
    88c0:	08 95       	ret

000088c2 <vfprintf>:
    88c2:	2f 92       	push	r2
    88c4:	3f 92       	push	r3
    88c6:	4f 92       	push	r4
    88c8:	5f 92       	push	r5
    88ca:	6f 92       	push	r6
    88cc:	7f 92       	push	r7
    88ce:	8f 92       	push	r8
    88d0:	9f 92       	push	r9
    88d2:	af 92       	push	r10
    88d4:	bf 92       	push	r11
    88d6:	cf 92       	push	r12
    88d8:	df 92       	push	r13
    88da:	ef 92       	push	r14
    88dc:	ff 92       	push	r15
    88de:	0f 93       	push	r16
    88e0:	1f 93       	push	r17
    88e2:	cf 93       	push	r28
    88e4:	df 93       	push	r29
    88e6:	cd b7       	in	r28, 0x3d	; 61
    88e8:	de b7       	in	r29, 0x3e	; 62
    88ea:	60 97       	sbiw	r28, 0x10	; 16
    88ec:	cd bf       	out	0x3d, r28	; 61
    88ee:	de bf       	out	0x3e, r29	; 62
    88f0:	7c 01       	movw	r14, r24
    88f2:	1b 01       	movw	r2, r22
    88f4:	6a 01       	movw	r12, r20
    88f6:	fc 01       	movw	r30, r24
    88f8:	16 82       	std	Z+6, r1	; 0x06
    88fa:	17 82       	std	Z+7, r1	; 0x07
    88fc:	83 81       	ldd	r24, Z+3	; 0x03
    88fe:	81 ff       	sbrs	r24, 1
    8900:	44 c3       	rjmp	.+1672   	; 0x8f8a <vfprintf+0x6c8>
    8902:	9e 01       	movw	r18, r28
    8904:	2f 5f       	subi	r18, 0xFF	; 255
    8906:	3f 4f       	sbci	r19, 0xFF	; 255
    8908:	39 01       	movw	r6, r18
    890a:	f7 01       	movw	r30, r14
    890c:	93 81       	ldd	r25, Z+3	; 0x03
    890e:	f1 01       	movw	r30, r2
    8910:	93 fd       	sbrc	r25, 3
    8912:	85 91       	lpm	r24, Z+
    8914:	93 ff       	sbrs	r25, 3
    8916:	81 91       	ld	r24, Z+
    8918:	1f 01       	movw	r2, r30
    891a:	88 23       	and	r24, r24
    891c:	09 f4       	brne	.+2      	; 0x8920 <vfprintf+0x5e>
    891e:	31 c3       	rjmp	.+1634   	; 0x8f82 <vfprintf+0x6c0>
    8920:	85 32       	cpi	r24, 0x25	; 37
    8922:	39 f4       	brne	.+14     	; 0x8932 <vfprintf+0x70>
    8924:	93 fd       	sbrc	r25, 3
    8926:	85 91       	lpm	r24, Z+
    8928:	93 ff       	sbrs	r25, 3
    892a:	81 91       	ld	r24, Z+
    892c:	1f 01       	movw	r2, r30
    892e:	85 32       	cpi	r24, 0x25	; 37
    8930:	39 f4       	brne	.+14     	; 0x8940 <vfprintf+0x7e>
    8932:	b7 01       	movw	r22, r14
    8934:	90 e0       	ldi	r25, 0x00	; 0
    8936:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    893a:	56 01       	movw	r10, r12
    893c:	65 01       	movw	r12, r10
    893e:	e5 cf       	rjmp	.-54     	; 0x890a <vfprintf+0x48>
    8940:	10 e0       	ldi	r17, 0x00	; 0
    8942:	51 2c       	mov	r5, r1
    8944:	91 2c       	mov	r9, r1
    8946:	ff e1       	ldi	r31, 0x1F	; 31
    8948:	f9 15       	cp	r31, r9
    894a:	d8 f0       	brcs	.+54     	; 0x8982 <vfprintf+0xc0>
    894c:	8b 32       	cpi	r24, 0x2B	; 43
    894e:	79 f0       	breq	.+30     	; 0x896e <vfprintf+0xac>
    8950:	38 f4       	brcc	.+14     	; 0x8960 <vfprintf+0x9e>
    8952:	80 32       	cpi	r24, 0x20	; 32
    8954:	79 f0       	breq	.+30     	; 0x8974 <vfprintf+0xb2>
    8956:	83 32       	cpi	r24, 0x23	; 35
    8958:	a1 f4       	brne	.+40     	; 0x8982 <vfprintf+0xc0>
    895a:	f9 2d       	mov	r31, r9
    895c:	f0 61       	ori	r31, 0x10	; 16
    895e:	2e c0       	rjmp	.+92     	; 0x89bc <vfprintf+0xfa>
    8960:	8d 32       	cpi	r24, 0x2D	; 45
    8962:	61 f0       	breq	.+24     	; 0x897c <vfprintf+0xba>
    8964:	80 33       	cpi	r24, 0x30	; 48
    8966:	69 f4       	brne	.+26     	; 0x8982 <vfprintf+0xc0>
    8968:	29 2d       	mov	r18, r9
    896a:	21 60       	ori	r18, 0x01	; 1
    896c:	2d c0       	rjmp	.+90     	; 0x89c8 <vfprintf+0x106>
    896e:	39 2d       	mov	r19, r9
    8970:	32 60       	ori	r19, 0x02	; 2
    8972:	93 2e       	mov	r9, r19
    8974:	89 2d       	mov	r24, r9
    8976:	84 60       	ori	r24, 0x04	; 4
    8978:	98 2e       	mov	r9, r24
    897a:	2a c0       	rjmp	.+84     	; 0x89d0 <vfprintf+0x10e>
    897c:	e9 2d       	mov	r30, r9
    897e:	e8 60       	ori	r30, 0x08	; 8
    8980:	15 c0       	rjmp	.+42     	; 0x89ac <vfprintf+0xea>
    8982:	97 fc       	sbrc	r9, 7
    8984:	2d c0       	rjmp	.+90     	; 0x89e0 <vfprintf+0x11e>
    8986:	20 ed       	ldi	r18, 0xD0	; 208
    8988:	28 0f       	add	r18, r24
    898a:	2a 30       	cpi	r18, 0x0A	; 10
    898c:	88 f4       	brcc	.+34     	; 0x89b0 <vfprintf+0xee>
    898e:	96 fe       	sbrs	r9, 6
    8990:	06 c0       	rjmp	.+12     	; 0x899e <vfprintf+0xdc>
    8992:	3a e0       	ldi	r19, 0x0A	; 10
    8994:	13 9f       	mul	r17, r19
    8996:	20 0d       	add	r18, r0
    8998:	11 24       	eor	r1, r1
    899a:	12 2f       	mov	r17, r18
    899c:	19 c0       	rjmp	.+50     	; 0x89d0 <vfprintf+0x10e>
    899e:	8a e0       	ldi	r24, 0x0A	; 10
    89a0:	58 9e       	mul	r5, r24
    89a2:	20 0d       	add	r18, r0
    89a4:	11 24       	eor	r1, r1
    89a6:	52 2e       	mov	r5, r18
    89a8:	e9 2d       	mov	r30, r9
    89aa:	e0 62       	ori	r30, 0x20	; 32
    89ac:	9e 2e       	mov	r9, r30
    89ae:	10 c0       	rjmp	.+32     	; 0x89d0 <vfprintf+0x10e>
    89b0:	8e 32       	cpi	r24, 0x2E	; 46
    89b2:	31 f4       	brne	.+12     	; 0x89c0 <vfprintf+0xfe>
    89b4:	96 fc       	sbrc	r9, 6
    89b6:	e5 c2       	rjmp	.+1482   	; 0x8f82 <vfprintf+0x6c0>
    89b8:	f9 2d       	mov	r31, r9
    89ba:	f0 64       	ori	r31, 0x40	; 64
    89bc:	9f 2e       	mov	r9, r31
    89be:	08 c0       	rjmp	.+16     	; 0x89d0 <vfprintf+0x10e>
    89c0:	8c 36       	cpi	r24, 0x6C	; 108
    89c2:	21 f4       	brne	.+8      	; 0x89cc <vfprintf+0x10a>
    89c4:	29 2d       	mov	r18, r9
    89c6:	20 68       	ori	r18, 0x80	; 128
    89c8:	92 2e       	mov	r9, r18
    89ca:	02 c0       	rjmp	.+4      	; 0x89d0 <vfprintf+0x10e>
    89cc:	88 36       	cpi	r24, 0x68	; 104
    89ce:	41 f4       	brne	.+16     	; 0x89e0 <vfprintf+0x11e>
    89d0:	f1 01       	movw	r30, r2
    89d2:	93 fd       	sbrc	r25, 3
    89d4:	85 91       	lpm	r24, Z+
    89d6:	93 ff       	sbrs	r25, 3
    89d8:	81 91       	ld	r24, Z+
    89da:	1f 01       	movw	r2, r30
    89dc:	81 11       	cpse	r24, r1
    89de:	b3 cf       	rjmp	.-154    	; 0x8946 <vfprintf+0x84>
    89e0:	9b eb       	ldi	r25, 0xBB	; 187
    89e2:	98 0f       	add	r25, r24
    89e4:	93 30       	cpi	r25, 0x03	; 3
    89e6:	20 f4       	brcc	.+8      	; 0x89f0 <vfprintf+0x12e>
    89e8:	99 2d       	mov	r25, r9
    89ea:	90 61       	ori	r25, 0x10	; 16
    89ec:	80 5e       	subi	r24, 0xE0	; 224
    89ee:	07 c0       	rjmp	.+14     	; 0x89fe <vfprintf+0x13c>
    89f0:	9b e9       	ldi	r25, 0x9B	; 155
    89f2:	98 0f       	add	r25, r24
    89f4:	93 30       	cpi	r25, 0x03	; 3
    89f6:	08 f0       	brcs	.+2      	; 0x89fa <vfprintf+0x138>
    89f8:	66 c1       	rjmp	.+716    	; 0x8cc6 <vfprintf+0x404>
    89fa:	99 2d       	mov	r25, r9
    89fc:	9f 7e       	andi	r25, 0xEF	; 239
    89fe:	96 ff       	sbrs	r25, 6
    8a00:	16 e0       	ldi	r17, 0x06	; 6
    8a02:	9f 73       	andi	r25, 0x3F	; 63
    8a04:	99 2e       	mov	r9, r25
    8a06:	85 36       	cpi	r24, 0x65	; 101
    8a08:	19 f4       	brne	.+6      	; 0x8a10 <vfprintf+0x14e>
    8a0a:	90 64       	ori	r25, 0x40	; 64
    8a0c:	99 2e       	mov	r9, r25
    8a0e:	08 c0       	rjmp	.+16     	; 0x8a20 <vfprintf+0x15e>
    8a10:	86 36       	cpi	r24, 0x66	; 102
    8a12:	21 f4       	brne	.+8      	; 0x8a1c <vfprintf+0x15a>
    8a14:	39 2f       	mov	r19, r25
    8a16:	30 68       	ori	r19, 0x80	; 128
    8a18:	93 2e       	mov	r9, r19
    8a1a:	02 c0       	rjmp	.+4      	; 0x8a20 <vfprintf+0x15e>
    8a1c:	11 11       	cpse	r17, r1
    8a1e:	11 50       	subi	r17, 0x01	; 1
    8a20:	97 fe       	sbrs	r9, 7
    8a22:	07 c0       	rjmp	.+14     	; 0x8a32 <vfprintf+0x170>
    8a24:	1c 33       	cpi	r17, 0x3C	; 60
    8a26:	50 f4       	brcc	.+20     	; 0x8a3c <vfprintf+0x17a>
    8a28:	44 24       	eor	r4, r4
    8a2a:	43 94       	inc	r4
    8a2c:	41 0e       	add	r4, r17
    8a2e:	27 e0       	ldi	r18, 0x07	; 7
    8a30:	0b c0       	rjmp	.+22     	; 0x8a48 <vfprintf+0x186>
    8a32:	18 30       	cpi	r17, 0x08	; 8
    8a34:	38 f0       	brcs	.+14     	; 0x8a44 <vfprintf+0x182>
    8a36:	27 e0       	ldi	r18, 0x07	; 7
    8a38:	17 e0       	ldi	r17, 0x07	; 7
    8a3a:	05 c0       	rjmp	.+10     	; 0x8a46 <vfprintf+0x184>
    8a3c:	27 e0       	ldi	r18, 0x07	; 7
    8a3e:	9c e3       	ldi	r25, 0x3C	; 60
    8a40:	49 2e       	mov	r4, r25
    8a42:	02 c0       	rjmp	.+4      	; 0x8a48 <vfprintf+0x186>
    8a44:	21 2f       	mov	r18, r17
    8a46:	41 2c       	mov	r4, r1
    8a48:	56 01       	movw	r10, r12
    8a4a:	84 e0       	ldi	r24, 0x04	; 4
    8a4c:	a8 0e       	add	r10, r24
    8a4e:	b1 1c       	adc	r11, r1
    8a50:	f6 01       	movw	r30, r12
    8a52:	60 81       	ld	r22, Z
    8a54:	71 81       	ldd	r23, Z+1	; 0x01
    8a56:	82 81       	ldd	r24, Z+2	; 0x02
    8a58:	93 81       	ldd	r25, Z+3	; 0x03
    8a5a:	04 2d       	mov	r16, r4
    8a5c:	a3 01       	movw	r20, r6
    8a5e:	0e 94 a0 4b 	call	0x9740	; 0x9740 <__ftoa_engine>
    8a62:	6c 01       	movw	r12, r24
    8a64:	f9 81       	ldd	r31, Y+1	; 0x01
    8a66:	fc 87       	std	Y+12, r31	; 0x0c
    8a68:	f0 ff       	sbrs	r31, 0
    8a6a:	02 c0       	rjmp	.+4      	; 0x8a70 <vfprintf+0x1ae>
    8a6c:	f3 ff       	sbrs	r31, 3
    8a6e:	06 c0       	rjmp	.+12     	; 0x8a7c <vfprintf+0x1ba>
    8a70:	91 fc       	sbrc	r9, 1
    8a72:	06 c0       	rjmp	.+12     	; 0x8a80 <vfprintf+0x1be>
    8a74:	92 fe       	sbrs	r9, 2
    8a76:	06 c0       	rjmp	.+12     	; 0x8a84 <vfprintf+0x1c2>
    8a78:	00 e2       	ldi	r16, 0x20	; 32
    8a7a:	05 c0       	rjmp	.+10     	; 0x8a86 <vfprintf+0x1c4>
    8a7c:	0d e2       	ldi	r16, 0x2D	; 45
    8a7e:	03 c0       	rjmp	.+6      	; 0x8a86 <vfprintf+0x1c4>
    8a80:	0b e2       	ldi	r16, 0x2B	; 43
    8a82:	01 c0       	rjmp	.+2      	; 0x8a86 <vfprintf+0x1c4>
    8a84:	00 e0       	ldi	r16, 0x00	; 0
    8a86:	8c 85       	ldd	r24, Y+12	; 0x0c
    8a88:	8c 70       	andi	r24, 0x0C	; 12
    8a8a:	19 f0       	breq	.+6      	; 0x8a92 <vfprintf+0x1d0>
    8a8c:	01 11       	cpse	r16, r1
    8a8e:	5a c2       	rjmp	.+1204   	; 0x8f44 <vfprintf+0x682>
    8a90:	9b c2       	rjmp	.+1334   	; 0x8fc8 <vfprintf+0x706>
    8a92:	97 fe       	sbrs	r9, 7
    8a94:	10 c0       	rjmp	.+32     	; 0x8ab6 <vfprintf+0x1f4>
    8a96:	4c 0c       	add	r4, r12
    8a98:	fc 85       	ldd	r31, Y+12	; 0x0c
    8a9a:	f4 ff       	sbrs	r31, 4
    8a9c:	04 c0       	rjmp	.+8      	; 0x8aa6 <vfprintf+0x1e4>
    8a9e:	8a 81       	ldd	r24, Y+2	; 0x02
    8aa0:	81 33       	cpi	r24, 0x31	; 49
    8aa2:	09 f4       	brne	.+2      	; 0x8aa6 <vfprintf+0x1e4>
    8aa4:	4a 94       	dec	r4
    8aa6:	14 14       	cp	r1, r4
    8aa8:	74 f5       	brge	.+92     	; 0x8b06 <vfprintf+0x244>
    8aaa:	28 e0       	ldi	r18, 0x08	; 8
    8aac:	24 15       	cp	r18, r4
    8aae:	78 f5       	brcc	.+94     	; 0x8b0e <vfprintf+0x24c>
    8ab0:	88 e0       	ldi	r24, 0x08	; 8
    8ab2:	48 2e       	mov	r4, r24
    8ab4:	2c c0       	rjmp	.+88     	; 0x8b0e <vfprintf+0x24c>
    8ab6:	96 fc       	sbrc	r9, 6
    8ab8:	2a c0       	rjmp	.+84     	; 0x8b0e <vfprintf+0x24c>
    8aba:	81 2f       	mov	r24, r17
    8abc:	90 e0       	ldi	r25, 0x00	; 0
    8abe:	8c 15       	cp	r24, r12
    8ac0:	9d 05       	cpc	r25, r13
    8ac2:	9c f0       	brlt	.+38     	; 0x8aea <vfprintf+0x228>
    8ac4:	3c ef       	ldi	r19, 0xFC	; 252
    8ac6:	c3 16       	cp	r12, r19
    8ac8:	3f ef       	ldi	r19, 0xFF	; 255
    8aca:	d3 06       	cpc	r13, r19
    8acc:	74 f0       	brlt	.+28     	; 0x8aea <vfprintf+0x228>
    8ace:	89 2d       	mov	r24, r9
    8ad0:	80 68       	ori	r24, 0x80	; 128
    8ad2:	98 2e       	mov	r9, r24
    8ad4:	0a c0       	rjmp	.+20     	; 0x8aea <vfprintf+0x228>
    8ad6:	e2 e0       	ldi	r30, 0x02	; 2
    8ad8:	f0 e0       	ldi	r31, 0x00	; 0
    8ada:	ec 0f       	add	r30, r28
    8adc:	fd 1f       	adc	r31, r29
    8ade:	e1 0f       	add	r30, r17
    8ae0:	f1 1d       	adc	r31, r1
    8ae2:	80 81       	ld	r24, Z
    8ae4:	80 33       	cpi	r24, 0x30	; 48
    8ae6:	19 f4       	brne	.+6      	; 0x8aee <vfprintf+0x22c>
    8ae8:	11 50       	subi	r17, 0x01	; 1
    8aea:	11 11       	cpse	r17, r1
    8aec:	f4 cf       	rjmp	.-24     	; 0x8ad6 <vfprintf+0x214>
    8aee:	97 fe       	sbrs	r9, 7
    8af0:	0e c0       	rjmp	.+28     	; 0x8b0e <vfprintf+0x24c>
    8af2:	44 24       	eor	r4, r4
    8af4:	43 94       	inc	r4
    8af6:	41 0e       	add	r4, r17
    8af8:	81 2f       	mov	r24, r17
    8afa:	90 e0       	ldi	r25, 0x00	; 0
    8afc:	c8 16       	cp	r12, r24
    8afe:	d9 06       	cpc	r13, r25
    8b00:	2c f4       	brge	.+10     	; 0x8b0c <vfprintf+0x24a>
    8b02:	1c 19       	sub	r17, r12
    8b04:	04 c0       	rjmp	.+8      	; 0x8b0e <vfprintf+0x24c>
    8b06:	44 24       	eor	r4, r4
    8b08:	43 94       	inc	r4
    8b0a:	01 c0       	rjmp	.+2      	; 0x8b0e <vfprintf+0x24c>
    8b0c:	10 e0       	ldi	r17, 0x00	; 0
    8b0e:	97 fe       	sbrs	r9, 7
    8b10:	06 c0       	rjmp	.+12     	; 0x8b1e <vfprintf+0x25c>
    8b12:	1c 14       	cp	r1, r12
    8b14:	1d 04       	cpc	r1, r13
    8b16:	34 f4       	brge	.+12     	; 0x8b24 <vfprintf+0x262>
    8b18:	c6 01       	movw	r24, r12
    8b1a:	01 96       	adiw	r24, 0x01	; 1
    8b1c:	05 c0       	rjmp	.+10     	; 0x8b28 <vfprintf+0x266>
    8b1e:	85 e0       	ldi	r24, 0x05	; 5
    8b20:	90 e0       	ldi	r25, 0x00	; 0
    8b22:	02 c0       	rjmp	.+4      	; 0x8b28 <vfprintf+0x266>
    8b24:	81 e0       	ldi	r24, 0x01	; 1
    8b26:	90 e0       	ldi	r25, 0x00	; 0
    8b28:	01 11       	cpse	r16, r1
    8b2a:	01 96       	adiw	r24, 0x01	; 1
    8b2c:	11 23       	and	r17, r17
    8b2e:	31 f0       	breq	.+12     	; 0x8b3c <vfprintf+0x27a>
    8b30:	21 2f       	mov	r18, r17
    8b32:	30 e0       	ldi	r19, 0x00	; 0
    8b34:	2f 5f       	subi	r18, 0xFF	; 255
    8b36:	3f 4f       	sbci	r19, 0xFF	; 255
    8b38:	82 0f       	add	r24, r18
    8b3a:	93 1f       	adc	r25, r19
    8b3c:	25 2d       	mov	r18, r5
    8b3e:	30 e0       	ldi	r19, 0x00	; 0
    8b40:	82 17       	cp	r24, r18
    8b42:	93 07       	cpc	r25, r19
    8b44:	14 f4       	brge	.+4      	; 0x8b4a <vfprintf+0x288>
    8b46:	58 1a       	sub	r5, r24
    8b48:	01 c0       	rjmp	.+2      	; 0x8b4c <vfprintf+0x28a>
    8b4a:	51 2c       	mov	r5, r1
    8b4c:	89 2d       	mov	r24, r9
    8b4e:	89 70       	andi	r24, 0x09	; 9
    8b50:	49 f4       	brne	.+18     	; 0x8b64 <vfprintf+0x2a2>
    8b52:	55 20       	and	r5, r5
    8b54:	39 f0       	breq	.+14     	; 0x8b64 <vfprintf+0x2a2>
    8b56:	b7 01       	movw	r22, r14
    8b58:	80 e2       	ldi	r24, 0x20	; 32
    8b5a:	90 e0       	ldi	r25, 0x00	; 0
    8b5c:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8b60:	5a 94       	dec	r5
    8b62:	f7 cf       	rjmp	.-18     	; 0x8b52 <vfprintf+0x290>
    8b64:	00 23       	and	r16, r16
    8b66:	29 f0       	breq	.+10     	; 0x8b72 <vfprintf+0x2b0>
    8b68:	b7 01       	movw	r22, r14
    8b6a:	80 2f       	mov	r24, r16
    8b6c:	90 e0       	ldi	r25, 0x00	; 0
    8b6e:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8b72:	93 fc       	sbrc	r9, 3
    8b74:	09 c0       	rjmp	.+18     	; 0x8b88 <vfprintf+0x2c6>
    8b76:	55 20       	and	r5, r5
    8b78:	39 f0       	breq	.+14     	; 0x8b88 <vfprintf+0x2c6>
    8b7a:	b7 01       	movw	r22, r14
    8b7c:	80 e3       	ldi	r24, 0x30	; 48
    8b7e:	90 e0       	ldi	r25, 0x00	; 0
    8b80:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8b84:	5a 94       	dec	r5
    8b86:	f7 cf       	rjmp	.-18     	; 0x8b76 <vfprintf+0x2b4>
    8b88:	97 fe       	sbrs	r9, 7
    8b8a:	4c c0       	rjmp	.+152    	; 0x8c24 <vfprintf+0x362>
    8b8c:	46 01       	movw	r8, r12
    8b8e:	d7 fe       	sbrs	r13, 7
    8b90:	02 c0       	rjmp	.+4      	; 0x8b96 <vfprintf+0x2d4>
    8b92:	81 2c       	mov	r8, r1
    8b94:	91 2c       	mov	r9, r1
    8b96:	c6 01       	movw	r24, r12
    8b98:	88 19       	sub	r24, r8
    8b9a:	99 09       	sbc	r25, r9
    8b9c:	f3 01       	movw	r30, r6
    8b9e:	e8 0f       	add	r30, r24
    8ba0:	f9 1f       	adc	r31, r25
    8ba2:	ed 87       	std	Y+13, r30	; 0x0d
    8ba4:	fe 87       	std	Y+14, r31	; 0x0e
    8ba6:	96 01       	movw	r18, r12
    8ba8:	24 19       	sub	r18, r4
    8baa:	31 09       	sbc	r19, r1
    8bac:	2f 87       	std	Y+15, r18	; 0x0f
    8bae:	38 8b       	std	Y+16, r19	; 0x10
    8bb0:	01 2f       	mov	r16, r17
    8bb2:	10 e0       	ldi	r17, 0x00	; 0
    8bb4:	11 95       	neg	r17
    8bb6:	01 95       	neg	r16
    8bb8:	11 09       	sbc	r17, r1
    8bba:	3f ef       	ldi	r19, 0xFF	; 255
    8bbc:	83 16       	cp	r8, r19
    8bbe:	93 06       	cpc	r9, r19
    8bc0:	29 f4       	brne	.+10     	; 0x8bcc <vfprintf+0x30a>
    8bc2:	b7 01       	movw	r22, r14
    8bc4:	8e e2       	ldi	r24, 0x2E	; 46
    8bc6:	90 e0       	ldi	r25, 0x00	; 0
    8bc8:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8bcc:	c8 14       	cp	r12, r8
    8bce:	d9 04       	cpc	r13, r9
    8bd0:	4c f0       	brlt	.+18     	; 0x8be4 <vfprintf+0x322>
    8bd2:	8f 85       	ldd	r24, Y+15	; 0x0f
    8bd4:	98 89       	ldd	r25, Y+16	; 0x10
    8bd6:	88 15       	cp	r24, r8
    8bd8:	99 05       	cpc	r25, r9
    8bda:	24 f4       	brge	.+8      	; 0x8be4 <vfprintf+0x322>
    8bdc:	ed 85       	ldd	r30, Y+13	; 0x0d
    8bde:	fe 85       	ldd	r31, Y+14	; 0x0e
    8be0:	81 81       	ldd	r24, Z+1	; 0x01
    8be2:	01 c0       	rjmp	.+2      	; 0x8be6 <vfprintf+0x324>
    8be4:	80 e3       	ldi	r24, 0x30	; 48
    8be6:	f1 e0       	ldi	r31, 0x01	; 1
    8be8:	8f 1a       	sub	r8, r31
    8bea:	91 08       	sbc	r9, r1
    8bec:	2d 85       	ldd	r18, Y+13	; 0x0d
    8bee:	3e 85       	ldd	r19, Y+14	; 0x0e
    8bf0:	2f 5f       	subi	r18, 0xFF	; 255
    8bf2:	3f 4f       	sbci	r19, 0xFF	; 255
    8bf4:	2d 87       	std	Y+13, r18	; 0x0d
    8bf6:	3e 87       	std	Y+14, r19	; 0x0e
    8bf8:	80 16       	cp	r8, r16
    8bfa:	91 06       	cpc	r9, r17
    8bfc:	2c f0       	brlt	.+10     	; 0x8c08 <vfprintf+0x346>
    8bfe:	b7 01       	movw	r22, r14
    8c00:	90 e0       	ldi	r25, 0x00	; 0
    8c02:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8c06:	d9 cf       	rjmp	.-78     	; 0x8bba <vfprintf+0x2f8>
    8c08:	c8 14       	cp	r12, r8
    8c0a:	d9 04       	cpc	r13, r9
    8c0c:	41 f4       	brne	.+16     	; 0x8c1e <vfprintf+0x35c>
    8c0e:	9a 81       	ldd	r25, Y+2	; 0x02
    8c10:	96 33       	cpi	r25, 0x36	; 54
    8c12:	20 f4       	brcc	.+8      	; 0x8c1c <vfprintf+0x35a>
    8c14:	95 33       	cpi	r25, 0x35	; 53
    8c16:	19 f4       	brne	.+6      	; 0x8c1e <vfprintf+0x35c>
    8c18:	3c 85       	ldd	r19, Y+12	; 0x0c
    8c1a:	34 ff       	sbrs	r19, 4
    8c1c:	81 e3       	ldi	r24, 0x31	; 49
    8c1e:	b7 01       	movw	r22, r14
    8c20:	90 e0       	ldi	r25, 0x00	; 0
    8c22:	4e c0       	rjmp	.+156    	; 0x8cc0 <vfprintf+0x3fe>
    8c24:	8a 81       	ldd	r24, Y+2	; 0x02
    8c26:	81 33       	cpi	r24, 0x31	; 49
    8c28:	19 f0       	breq	.+6      	; 0x8c30 <vfprintf+0x36e>
    8c2a:	9c 85       	ldd	r25, Y+12	; 0x0c
    8c2c:	9f 7e       	andi	r25, 0xEF	; 239
    8c2e:	9c 87       	std	Y+12, r25	; 0x0c
    8c30:	b7 01       	movw	r22, r14
    8c32:	90 e0       	ldi	r25, 0x00	; 0
    8c34:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8c38:	11 11       	cpse	r17, r1
    8c3a:	05 c0       	rjmp	.+10     	; 0x8c46 <vfprintf+0x384>
    8c3c:	94 fc       	sbrc	r9, 4
    8c3e:	18 c0       	rjmp	.+48     	; 0x8c70 <vfprintf+0x3ae>
    8c40:	85 e6       	ldi	r24, 0x65	; 101
    8c42:	90 e0       	ldi	r25, 0x00	; 0
    8c44:	17 c0       	rjmp	.+46     	; 0x8c74 <vfprintf+0x3b2>
    8c46:	b7 01       	movw	r22, r14
    8c48:	8e e2       	ldi	r24, 0x2E	; 46
    8c4a:	90 e0       	ldi	r25, 0x00	; 0
    8c4c:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8c50:	1e 5f       	subi	r17, 0xFE	; 254
    8c52:	82 e0       	ldi	r24, 0x02	; 2
    8c54:	01 e0       	ldi	r16, 0x01	; 1
    8c56:	08 0f       	add	r16, r24
    8c58:	f3 01       	movw	r30, r6
    8c5a:	e8 0f       	add	r30, r24
    8c5c:	f1 1d       	adc	r31, r1
    8c5e:	80 81       	ld	r24, Z
    8c60:	b7 01       	movw	r22, r14
    8c62:	90 e0       	ldi	r25, 0x00	; 0
    8c64:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8c68:	80 2f       	mov	r24, r16
    8c6a:	01 13       	cpse	r16, r17
    8c6c:	f3 cf       	rjmp	.-26     	; 0x8c54 <vfprintf+0x392>
    8c6e:	e6 cf       	rjmp	.-52     	; 0x8c3c <vfprintf+0x37a>
    8c70:	85 e4       	ldi	r24, 0x45	; 69
    8c72:	90 e0       	ldi	r25, 0x00	; 0
    8c74:	b7 01       	movw	r22, r14
    8c76:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8c7a:	d7 fc       	sbrc	r13, 7
    8c7c:	06 c0       	rjmp	.+12     	; 0x8c8a <vfprintf+0x3c8>
    8c7e:	c1 14       	cp	r12, r1
    8c80:	d1 04       	cpc	r13, r1
    8c82:	41 f4       	brne	.+16     	; 0x8c94 <vfprintf+0x3d2>
    8c84:	ec 85       	ldd	r30, Y+12	; 0x0c
    8c86:	e4 ff       	sbrs	r30, 4
    8c88:	05 c0       	rjmp	.+10     	; 0x8c94 <vfprintf+0x3d2>
    8c8a:	d1 94       	neg	r13
    8c8c:	c1 94       	neg	r12
    8c8e:	d1 08       	sbc	r13, r1
    8c90:	8d e2       	ldi	r24, 0x2D	; 45
    8c92:	01 c0       	rjmp	.+2      	; 0x8c96 <vfprintf+0x3d4>
    8c94:	8b e2       	ldi	r24, 0x2B	; 43
    8c96:	b7 01       	movw	r22, r14
    8c98:	90 e0       	ldi	r25, 0x00	; 0
    8c9a:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8c9e:	80 e3       	ldi	r24, 0x30	; 48
    8ca0:	2a e0       	ldi	r18, 0x0A	; 10
    8ca2:	c2 16       	cp	r12, r18
    8ca4:	d1 04       	cpc	r13, r1
    8ca6:	2c f0       	brlt	.+10     	; 0x8cb2 <vfprintf+0x3f0>
    8ca8:	8f 5f       	subi	r24, 0xFF	; 255
    8caa:	fa e0       	ldi	r31, 0x0A	; 10
    8cac:	cf 1a       	sub	r12, r31
    8cae:	d1 08       	sbc	r13, r1
    8cb0:	f7 cf       	rjmp	.-18     	; 0x8ca0 <vfprintf+0x3de>
    8cb2:	b7 01       	movw	r22, r14
    8cb4:	90 e0       	ldi	r25, 0x00	; 0
    8cb6:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8cba:	b7 01       	movw	r22, r14
    8cbc:	c6 01       	movw	r24, r12
    8cbe:	c0 96       	adiw	r24, 0x30	; 48
    8cc0:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8cc4:	54 c1       	rjmp	.+680    	; 0x8f6e <vfprintf+0x6ac>
    8cc6:	83 36       	cpi	r24, 0x63	; 99
    8cc8:	31 f0       	breq	.+12     	; 0x8cd6 <vfprintf+0x414>
    8cca:	83 37       	cpi	r24, 0x73	; 115
    8ccc:	79 f0       	breq	.+30     	; 0x8cec <vfprintf+0x42a>
    8cce:	83 35       	cpi	r24, 0x53	; 83
    8cd0:	09 f0       	breq	.+2      	; 0x8cd4 <vfprintf+0x412>
    8cd2:	56 c0       	rjmp	.+172    	; 0x8d80 <vfprintf+0x4be>
    8cd4:	20 c0       	rjmp	.+64     	; 0x8d16 <vfprintf+0x454>
    8cd6:	56 01       	movw	r10, r12
    8cd8:	32 e0       	ldi	r19, 0x02	; 2
    8cda:	a3 0e       	add	r10, r19
    8cdc:	b1 1c       	adc	r11, r1
    8cde:	f6 01       	movw	r30, r12
    8ce0:	80 81       	ld	r24, Z
    8ce2:	89 83       	std	Y+1, r24	; 0x01
    8ce4:	01 e0       	ldi	r16, 0x01	; 1
    8ce6:	10 e0       	ldi	r17, 0x00	; 0
    8ce8:	63 01       	movw	r12, r6
    8cea:	12 c0       	rjmp	.+36     	; 0x8d10 <vfprintf+0x44e>
    8cec:	56 01       	movw	r10, r12
    8cee:	f2 e0       	ldi	r31, 0x02	; 2
    8cf0:	af 0e       	add	r10, r31
    8cf2:	b1 1c       	adc	r11, r1
    8cf4:	f6 01       	movw	r30, r12
    8cf6:	c0 80       	ld	r12, Z
    8cf8:	d1 80       	ldd	r13, Z+1	; 0x01
    8cfa:	96 fe       	sbrs	r9, 6
    8cfc:	03 c0       	rjmp	.+6      	; 0x8d04 <vfprintf+0x442>
    8cfe:	61 2f       	mov	r22, r17
    8d00:	70 e0       	ldi	r23, 0x00	; 0
    8d02:	02 c0       	rjmp	.+4      	; 0x8d08 <vfprintf+0x446>
    8d04:	6f ef       	ldi	r22, 0xFF	; 255
    8d06:	7f ef       	ldi	r23, 0xFF	; 255
    8d08:	c6 01       	movw	r24, r12
    8d0a:	0e 94 9e 4c 	call	0x993c	; 0x993c <strnlen>
    8d0e:	8c 01       	movw	r16, r24
    8d10:	f9 2d       	mov	r31, r9
    8d12:	ff 77       	andi	r31, 0x7F	; 127
    8d14:	14 c0       	rjmp	.+40     	; 0x8d3e <vfprintf+0x47c>
    8d16:	56 01       	movw	r10, r12
    8d18:	22 e0       	ldi	r18, 0x02	; 2
    8d1a:	a2 0e       	add	r10, r18
    8d1c:	b1 1c       	adc	r11, r1
    8d1e:	f6 01       	movw	r30, r12
    8d20:	c0 80       	ld	r12, Z
    8d22:	d1 80       	ldd	r13, Z+1	; 0x01
    8d24:	96 fe       	sbrs	r9, 6
    8d26:	03 c0       	rjmp	.+6      	; 0x8d2e <vfprintf+0x46c>
    8d28:	61 2f       	mov	r22, r17
    8d2a:	70 e0       	ldi	r23, 0x00	; 0
    8d2c:	02 c0       	rjmp	.+4      	; 0x8d32 <vfprintf+0x470>
    8d2e:	6f ef       	ldi	r22, 0xFF	; 255
    8d30:	7f ef       	ldi	r23, 0xFF	; 255
    8d32:	c6 01       	movw	r24, r12
    8d34:	0e 94 78 4c 	call	0x98f0	; 0x98f0 <strnlen_P>
    8d38:	8c 01       	movw	r16, r24
    8d3a:	f9 2d       	mov	r31, r9
    8d3c:	f0 68       	ori	r31, 0x80	; 128
    8d3e:	9f 2e       	mov	r9, r31
    8d40:	f3 fd       	sbrc	r31, 3
    8d42:	1a c0       	rjmp	.+52     	; 0x8d78 <vfprintf+0x4b6>
    8d44:	85 2d       	mov	r24, r5
    8d46:	90 e0       	ldi	r25, 0x00	; 0
    8d48:	08 17       	cp	r16, r24
    8d4a:	19 07       	cpc	r17, r25
    8d4c:	a8 f4       	brcc	.+42     	; 0x8d78 <vfprintf+0x4b6>
    8d4e:	b7 01       	movw	r22, r14
    8d50:	80 e2       	ldi	r24, 0x20	; 32
    8d52:	90 e0       	ldi	r25, 0x00	; 0
    8d54:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8d58:	5a 94       	dec	r5
    8d5a:	f4 cf       	rjmp	.-24     	; 0x8d44 <vfprintf+0x482>
    8d5c:	f6 01       	movw	r30, r12
    8d5e:	97 fc       	sbrc	r9, 7
    8d60:	85 91       	lpm	r24, Z+
    8d62:	97 fe       	sbrs	r9, 7
    8d64:	81 91       	ld	r24, Z+
    8d66:	6f 01       	movw	r12, r30
    8d68:	b7 01       	movw	r22, r14
    8d6a:	90 e0       	ldi	r25, 0x00	; 0
    8d6c:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8d70:	51 10       	cpse	r5, r1
    8d72:	5a 94       	dec	r5
    8d74:	01 50       	subi	r16, 0x01	; 1
    8d76:	11 09       	sbc	r17, r1
    8d78:	01 15       	cp	r16, r1
    8d7a:	11 05       	cpc	r17, r1
    8d7c:	79 f7       	brne	.-34     	; 0x8d5c <vfprintf+0x49a>
    8d7e:	f7 c0       	rjmp	.+494    	; 0x8f6e <vfprintf+0x6ac>
    8d80:	84 36       	cpi	r24, 0x64	; 100
    8d82:	11 f0       	breq	.+4      	; 0x8d88 <vfprintf+0x4c6>
    8d84:	89 36       	cpi	r24, 0x69	; 105
    8d86:	61 f5       	brne	.+88     	; 0x8de0 <vfprintf+0x51e>
    8d88:	56 01       	movw	r10, r12
    8d8a:	97 fe       	sbrs	r9, 7
    8d8c:	09 c0       	rjmp	.+18     	; 0x8da0 <vfprintf+0x4de>
    8d8e:	24 e0       	ldi	r18, 0x04	; 4
    8d90:	a2 0e       	add	r10, r18
    8d92:	b1 1c       	adc	r11, r1
    8d94:	f6 01       	movw	r30, r12
    8d96:	60 81       	ld	r22, Z
    8d98:	71 81       	ldd	r23, Z+1	; 0x01
    8d9a:	82 81       	ldd	r24, Z+2	; 0x02
    8d9c:	93 81       	ldd	r25, Z+3	; 0x03
    8d9e:	0a c0       	rjmp	.+20     	; 0x8db4 <vfprintf+0x4f2>
    8da0:	f2 e0       	ldi	r31, 0x02	; 2
    8da2:	af 0e       	add	r10, r31
    8da4:	b1 1c       	adc	r11, r1
    8da6:	f6 01       	movw	r30, r12
    8da8:	60 81       	ld	r22, Z
    8daa:	71 81       	ldd	r23, Z+1	; 0x01
    8dac:	07 2e       	mov	r0, r23
    8dae:	00 0c       	add	r0, r0
    8db0:	88 0b       	sbc	r24, r24
    8db2:	99 0b       	sbc	r25, r25
    8db4:	f9 2d       	mov	r31, r9
    8db6:	ff 76       	andi	r31, 0x6F	; 111
    8db8:	9f 2e       	mov	r9, r31
    8dba:	97 ff       	sbrs	r25, 7
    8dbc:	09 c0       	rjmp	.+18     	; 0x8dd0 <vfprintf+0x50e>
    8dbe:	90 95       	com	r25
    8dc0:	80 95       	com	r24
    8dc2:	70 95       	com	r23
    8dc4:	61 95       	neg	r22
    8dc6:	7f 4f       	sbci	r23, 0xFF	; 255
    8dc8:	8f 4f       	sbci	r24, 0xFF	; 255
    8dca:	9f 4f       	sbci	r25, 0xFF	; 255
    8dcc:	f0 68       	ori	r31, 0x80	; 128
    8dce:	9f 2e       	mov	r9, r31
    8dd0:	2a e0       	ldi	r18, 0x0A	; 10
    8dd2:	30 e0       	ldi	r19, 0x00	; 0
    8dd4:	a3 01       	movw	r20, r6
    8dd6:	0e 94 ed 4d 	call	0x9bda	; 0x9bda <__ultoa_invert>
    8dda:	c8 2e       	mov	r12, r24
    8ddc:	c6 18       	sub	r12, r6
    8dde:	3f c0       	rjmp	.+126    	; 0x8e5e <vfprintf+0x59c>
    8de0:	09 2d       	mov	r16, r9
    8de2:	85 37       	cpi	r24, 0x75	; 117
    8de4:	21 f4       	brne	.+8      	; 0x8dee <vfprintf+0x52c>
    8de6:	0f 7e       	andi	r16, 0xEF	; 239
    8de8:	2a e0       	ldi	r18, 0x0A	; 10
    8dea:	30 e0       	ldi	r19, 0x00	; 0
    8dec:	1d c0       	rjmp	.+58     	; 0x8e28 <vfprintf+0x566>
    8dee:	09 7f       	andi	r16, 0xF9	; 249
    8df0:	8f 36       	cpi	r24, 0x6F	; 111
    8df2:	91 f0       	breq	.+36     	; 0x8e18 <vfprintf+0x556>
    8df4:	18 f4       	brcc	.+6      	; 0x8dfc <vfprintf+0x53a>
    8df6:	88 35       	cpi	r24, 0x58	; 88
    8df8:	59 f0       	breq	.+22     	; 0x8e10 <vfprintf+0x54e>
    8dfa:	c3 c0       	rjmp	.+390    	; 0x8f82 <vfprintf+0x6c0>
    8dfc:	80 37       	cpi	r24, 0x70	; 112
    8dfe:	19 f0       	breq	.+6      	; 0x8e06 <vfprintf+0x544>
    8e00:	88 37       	cpi	r24, 0x78	; 120
    8e02:	11 f0       	breq	.+4      	; 0x8e08 <vfprintf+0x546>
    8e04:	be c0       	rjmp	.+380    	; 0x8f82 <vfprintf+0x6c0>
    8e06:	00 61       	ori	r16, 0x10	; 16
    8e08:	04 ff       	sbrs	r16, 4
    8e0a:	09 c0       	rjmp	.+18     	; 0x8e1e <vfprintf+0x55c>
    8e0c:	04 60       	ori	r16, 0x04	; 4
    8e0e:	07 c0       	rjmp	.+14     	; 0x8e1e <vfprintf+0x55c>
    8e10:	94 fe       	sbrs	r9, 4
    8e12:	08 c0       	rjmp	.+16     	; 0x8e24 <vfprintf+0x562>
    8e14:	06 60       	ori	r16, 0x06	; 6
    8e16:	06 c0       	rjmp	.+12     	; 0x8e24 <vfprintf+0x562>
    8e18:	28 e0       	ldi	r18, 0x08	; 8
    8e1a:	30 e0       	ldi	r19, 0x00	; 0
    8e1c:	05 c0       	rjmp	.+10     	; 0x8e28 <vfprintf+0x566>
    8e1e:	20 e1       	ldi	r18, 0x10	; 16
    8e20:	30 e0       	ldi	r19, 0x00	; 0
    8e22:	02 c0       	rjmp	.+4      	; 0x8e28 <vfprintf+0x566>
    8e24:	20 e1       	ldi	r18, 0x10	; 16
    8e26:	32 e0       	ldi	r19, 0x02	; 2
    8e28:	56 01       	movw	r10, r12
    8e2a:	07 ff       	sbrs	r16, 7
    8e2c:	09 c0       	rjmp	.+18     	; 0x8e40 <vfprintf+0x57e>
    8e2e:	84 e0       	ldi	r24, 0x04	; 4
    8e30:	a8 0e       	add	r10, r24
    8e32:	b1 1c       	adc	r11, r1
    8e34:	f6 01       	movw	r30, r12
    8e36:	60 81       	ld	r22, Z
    8e38:	71 81       	ldd	r23, Z+1	; 0x01
    8e3a:	82 81       	ldd	r24, Z+2	; 0x02
    8e3c:	93 81       	ldd	r25, Z+3	; 0x03
    8e3e:	08 c0       	rjmp	.+16     	; 0x8e50 <vfprintf+0x58e>
    8e40:	f2 e0       	ldi	r31, 0x02	; 2
    8e42:	af 0e       	add	r10, r31
    8e44:	b1 1c       	adc	r11, r1
    8e46:	f6 01       	movw	r30, r12
    8e48:	60 81       	ld	r22, Z
    8e4a:	71 81       	ldd	r23, Z+1	; 0x01
    8e4c:	80 e0       	ldi	r24, 0x00	; 0
    8e4e:	90 e0       	ldi	r25, 0x00	; 0
    8e50:	a3 01       	movw	r20, r6
    8e52:	0e 94 ed 4d 	call	0x9bda	; 0x9bda <__ultoa_invert>
    8e56:	c8 2e       	mov	r12, r24
    8e58:	c6 18       	sub	r12, r6
    8e5a:	0f 77       	andi	r16, 0x7F	; 127
    8e5c:	90 2e       	mov	r9, r16
    8e5e:	96 fe       	sbrs	r9, 6
    8e60:	0b c0       	rjmp	.+22     	; 0x8e78 <vfprintf+0x5b6>
    8e62:	09 2d       	mov	r16, r9
    8e64:	0e 7f       	andi	r16, 0xFE	; 254
    8e66:	c1 16       	cp	r12, r17
    8e68:	50 f4       	brcc	.+20     	; 0x8e7e <vfprintf+0x5bc>
    8e6a:	94 fe       	sbrs	r9, 4
    8e6c:	0a c0       	rjmp	.+20     	; 0x8e82 <vfprintf+0x5c0>
    8e6e:	92 fc       	sbrc	r9, 2
    8e70:	08 c0       	rjmp	.+16     	; 0x8e82 <vfprintf+0x5c0>
    8e72:	09 2d       	mov	r16, r9
    8e74:	0e 7e       	andi	r16, 0xEE	; 238
    8e76:	05 c0       	rjmp	.+10     	; 0x8e82 <vfprintf+0x5c0>
    8e78:	dc 2c       	mov	r13, r12
    8e7a:	09 2d       	mov	r16, r9
    8e7c:	03 c0       	rjmp	.+6      	; 0x8e84 <vfprintf+0x5c2>
    8e7e:	dc 2c       	mov	r13, r12
    8e80:	01 c0       	rjmp	.+2      	; 0x8e84 <vfprintf+0x5c2>
    8e82:	d1 2e       	mov	r13, r17
    8e84:	04 ff       	sbrs	r16, 4
    8e86:	0d c0       	rjmp	.+26     	; 0x8ea2 <vfprintf+0x5e0>
    8e88:	fe 01       	movw	r30, r28
    8e8a:	ec 0d       	add	r30, r12
    8e8c:	f1 1d       	adc	r31, r1
    8e8e:	80 81       	ld	r24, Z
    8e90:	80 33       	cpi	r24, 0x30	; 48
    8e92:	11 f4       	brne	.+4      	; 0x8e98 <vfprintf+0x5d6>
    8e94:	09 7e       	andi	r16, 0xE9	; 233
    8e96:	09 c0       	rjmp	.+18     	; 0x8eaa <vfprintf+0x5e8>
    8e98:	02 ff       	sbrs	r16, 2
    8e9a:	06 c0       	rjmp	.+12     	; 0x8ea8 <vfprintf+0x5e6>
    8e9c:	d3 94       	inc	r13
    8e9e:	d3 94       	inc	r13
    8ea0:	04 c0       	rjmp	.+8      	; 0x8eaa <vfprintf+0x5e8>
    8ea2:	80 2f       	mov	r24, r16
    8ea4:	86 78       	andi	r24, 0x86	; 134
    8ea6:	09 f0       	breq	.+2      	; 0x8eaa <vfprintf+0x5e8>
    8ea8:	d3 94       	inc	r13
    8eaa:	03 fd       	sbrc	r16, 3
    8eac:	11 c0       	rjmp	.+34     	; 0x8ed0 <vfprintf+0x60e>
    8eae:	00 ff       	sbrs	r16, 0
    8eb0:	06 c0       	rjmp	.+12     	; 0x8ebe <vfprintf+0x5fc>
    8eb2:	1c 2d       	mov	r17, r12
    8eb4:	d5 14       	cp	r13, r5
    8eb6:	80 f4       	brcc	.+32     	; 0x8ed8 <vfprintf+0x616>
    8eb8:	15 0d       	add	r17, r5
    8eba:	1d 19       	sub	r17, r13
    8ebc:	0d c0       	rjmp	.+26     	; 0x8ed8 <vfprintf+0x616>
    8ebe:	d5 14       	cp	r13, r5
    8ec0:	58 f4       	brcc	.+22     	; 0x8ed8 <vfprintf+0x616>
    8ec2:	b7 01       	movw	r22, r14
    8ec4:	80 e2       	ldi	r24, 0x20	; 32
    8ec6:	90 e0       	ldi	r25, 0x00	; 0
    8ec8:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8ecc:	d3 94       	inc	r13
    8ece:	f7 cf       	rjmp	.-18     	; 0x8ebe <vfprintf+0x5fc>
    8ed0:	d5 14       	cp	r13, r5
    8ed2:	10 f4       	brcc	.+4      	; 0x8ed8 <vfprintf+0x616>
    8ed4:	5d 18       	sub	r5, r13
    8ed6:	01 c0       	rjmp	.+2      	; 0x8eda <vfprintf+0x618>
    8ed8:	51 2c       	mov	r5, r1
    8eda:	04 ff       	sbrs	r16, 4
    8edc:	10 c0       	rjmp	.+32     	; 0x8efe <vfprintf+0x63c>
    8ede:	b7 01       	movw	r22, r14
    8ee0:	80 e3       	ldi	r24, 0x30	; 48
    8ee2:	90 e0       	ldi	r25, 0x00	; 0
    8ee4:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8ee8:	02 ff       	sbrs	r16, 2
    8eea:	17 c0       	rjmp	.+46     	; 0x8f1a <vfprintf+0x658>
    8eec:	01 fd       	sbrc	r16, 1
    8eee:	03 c0       	rjmp	.+6      	; 0x8ef6 <vfprintf+0x634>
    8ef0:	88 e7       	ldi	r24, 0x78	; 120
    8ef2:	90 e0       	ldi	r25, 0x00	; 0
    8ef4:	02 c0       	rjmp	.+4      	; 0x8efa <vfprintf+0x638>
    8ef6:	88 e5       	ldi	r24, 0x58	; 88
    8ef8:	90 e0       	ldi	r25, 0x00	; 0
    8efa:	b7 01       	movw	r22, r14
    8efc:	0c c0       	rjmp	.+24     	; 0x8f16 <vfprintf+0x654>
    8efe:	80 2f       	mov	r24, r16
    8f00:	86 78       	andi	r24, 0x86	; 134
    8f02:	59 f0       	breq	.+22     	; 0x8f1a <vfprintf+0x658>
    8f04:	01 ff       	sbrs	r16, 1
    8f06:	02 c0       	rjmp	.+4      	; 0x8f0c <vfprintf+0x64a>
    8f08:	8b e2       	ldi	r24, 0x2B	; 43
    8f0a:	01 c0       	rjmp	.+2      	; 0x8f0e <vfprintf+0x64c>
    8f0c:	80 e2       	ldi	r24, 0x20	; 32
    8f0e:	07 fd       	sbrc	r16, 7
    8f10:	8d e2       	ldi	r24, 0x2D	; 45
    8f12:	b7 01       	movw	r22, r14
    8f14:	90 e0       	ldi	r25, 0x00	; 0
    8f16:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8f1a:	c1 16       	cp	r12, r17
    8f1c:	38 f4       	brcc	.+14     	; 0x8f2c <vfprintf+0x66a>
    8f1e:	b7 01       	movw	r22, r14
    8f20:	80 e3       	ldi	r24, 0x30	; 48
    8f22:	90 e0       	ldi	r25, 0x00	; 0
    8f24:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8f28:	11 50       	subi	r17, 0x01	; 1
    8f2a:	f7 cf       	rjmp	.-18     	; 0x8f1a <vfprintf+0x658>
    8f2c:	ca 94       	dec	r12
    8f2e:	f3 01       	movw	r30, r6
    8f30:	ec 0d       	add	r30, r12
    8f32:	f1 1d       	adc	r31, r1
    8f34:	80 81       	ld	r24, Z
    8f36:	b7 01       	movw	r22, r14
    8f38:	90 e0       	ldi	r25, 0x00	; 0
    8f3a:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8f3e:	c1 10       	cpse	r12, r1
    8f40:	f5 cf       	rjmp	.-22     	; 0x8f2c <vfprintf+0x66a>
    8f42:	15 c0       	rjmp	.+42     	; 0x8f6e <vfprintf+0x6ac>
    8f44:	f4 e0       	ldi	r31, 0x04	; 4
    8f46:	f5 15       	cp	r31, r5
    8f48:	60 f5       	brcc	.+88     	; 0x8fa2 <vfprintf+0x6e0>
    8f4a:	84 e0       	ldi	r24, 0x04	; 4
    8f4c:	58 1a       	sub	r5, r24
    8f4e:	93 fe       	sbrs	r9, 3
    8f50:	1f c0       	rjmp	.+62     	; 0x8f90 <vfprintf+0x6ce>
    8f52:	01 11       	cpse	r16, r1
    8f54:	27 c0       	rjmp	.+78     	; 0x8fa4 <vfprintf+0x6e2>
    8f56:	2c 85       	ldd	r18, Y+12	; 0x0c
    8f58:	23 ff       	sbrs	r18, 3
    8f5a:	2a c0       	rjmp	.+84     	; 0x8fb0 <vfprintf+0x6ee>
    8f5c:	04 e3       	ldi	r16, 0x34	; 52
    8f5e:	12 e0       	ldi	r17, 0x02	; 2
    8f60:	39 2d       	mov	r19, r9
    8f62:	30 71       	andi	r19, 0x10	; 16
    8f64:	93 2e       	mov	r9, r19
    8f66:	f8 01       	movw	r30, r16
    8f68:	84 91       	lpm	r24, Z
    8f6a:	81 11       	cpse	r24, r1
    8f6c:	24 c0       	rjmp	.+72     	; 0x8fb6 <vfprintf+0x6f4>
    8f6e:	55 20       	and	r5, r5
    8f70:	09 f4       	brne	.+2      	; 0x8f74 <vfprintf+0x6b2>
    8f72:	e4 cc       	rjmp	.-1592   	; 0x893c <vfprintf+0x7a>
    8f74:	b7 01       	movw	r22, r14
    8f76:	80 e2       	ldi	r24, 0x20	; 32
    8f78:	90 e0       	ldi	r25, 0x00	; 0
    8f7a:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8f7e:	5a 94       	dec	r5
    8f80:	f6 cf       	rjmp	.-20     	; 0x8f6e <vfprintf+0x6ac>
    8f82:	f7 01       	movw	r30, r14
    8f84:	86 81       	ldd	r24, Z+6	; 0x06
    8f86:	97 81       	ldd	r25, Z+7	; 0x07
    8f88:	26 c0       	rjmp	.+76     	; 0x8fd6 <vfprintf+0x714>
    8f8a:	8f ef       	ldi	r24, 0xFF	; 255
    8f8c:	9f ef       	ldi	r25, 0xFF	; 255
    8f8e:	23 c0       	rjmp	.+70     	; 0x8fd6 <vfprintf+0x714>
    8f90:	b7 01       	movw	r22, r14
    8f92:	80 e2       	ldi	r24, 0x20	; 32
    8f94:	90 e0       	ldi	r25, 0x00	; 0
    8f96:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8f9a:	5a 94       	dec	r5
    8f9c:	51 10       	cpse	r5, r1
    8f9e:	f8 cf       	rjmp	.-16     	; 0x8f90 <vfprintf+0x6ce>
    8fa0:	d8 cf       	rjmp	.-80     	; 0x8f52 <vfprintf+0x690>
    8fa2:	51 2c       	mov	r5, r1
    8fa4:	b7 01       	movw	r22, r14
    8fa6:	80 2f       	mov	r24, r16
    8fa8:	90 e0       	ldi	r25, 0x00	; 0
    8faa:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8fae:	d3 cf       	rjmp	.-90     	; 0x8f56 <vfprintf+0x694>
    8fb0:	08 e3       	ldi	r16, 0x38	; 56
    8fb2:	12 e0       	ldi	r17, 0x02	; 2
    8fb4:	d5 cf       	rjmp	.-86     	; 0x8f60 <vfprintf+0x69e>
    8fb6:	91 10       	cpse	r9, r1
    8fb8:	80 52       	subi	r24, 0x20	; 32
    8fba:	b7 01       	movw	r22, r14
    8fbc:	90 e0       	ldi	r25, 0x00	; 0
    8fbe:	0e 94 1c 4d 	call	0x9a38	; 0x9a38 <fputc>
    8fc2:	0f 5f       	subi	r16, 0xFF	; 255
    8fc4:	1f 4f       	sbci	r17, 0xFF	; 255
    8fc6:	cf cf       	rjmp	.-98     	; 0x8f66 <vfprintf+0x6a4>
    8fc8:	23 e0       	ldi	r18, 0x03	; 3
    8fca:	25 15       	cp	r18, r5
    8fcc:	10 f4       	brcc	.+4      	; 0x8fd2 <vfprintf+0x710>
    8fce:	83 e0       	ldi	r24, 0x03	; 3
    8fd0:	bd cf       	rjmp	.-134    	; 0x8f4c <vfprintf+0x68a>
    8fd2:	51 2c       	mov	r5, r1
    8fd4:	c0 cf       	rjmp	.-128    	; 0x8f56 <vfprintf+0x694>
    8fd6:	60 96       	adiw	r28, 0x10	; 16
    8fd8:	cd bf       	out	0x3d, r28	; 61
    8fda:	de bf       	out	0x3e, r29	; 62
    8fdc:	df 91       	pop	r29
    8fde:	cf 91       	pop	r28
    8fe0:	1f 91       	pop	r17
    8fe2:	0f 91       	pop	r16
    8fe4:	ff 90       	pop	r15
    8fe6:	ef 90       	pop	r14
    8fe8:	df 90       	pop	r13
    8fea:	cf 90       	pop	r12
    8fec:	bf 90       	pop	r11
    8fee:	af 90       	pop	r10
    8ff0:	9f 90       	pop	r9
    8ff2:	8f 90       	pop	r8
    8ff4:	7f 90       	pop	r7
    8ff6:	6f 90       	pop	r6
    8ff8:	5f 90       	pop	r5
    8ffa:	4f 90       	pop	r4
    8ffc:	3f 90       	pop	r3
    8ffe:	2f 90       	pop	r2
    9000:	08 95       	ret

00009002 <__udivmodhi4>:
    9002:	aa 1b       	sub	r26, r26
    9004:	bb 1b       	sub	r27, r27
    9006:	51 e1       	ldi	r21, 0x11	; 17
    9008:	07 c0       	rjmp	.+14     	; 0x9018 <__udivmodhi4_ep>

0000900a <__udivmodhi4_loop>:
    900a:	aa 1f       	adc	r26, r26
    900c:	bb 1f       	adc	r27, r27
    900e:	a6 17       	cp	r26, r22
    9010:	b7 07       	cpc	r27, r23
    9012:	10 f0       	brcs	.+4      	; 0x9018 <__udivmodhi4_ep>
    9014:	a6 1b       	sub	r26, r22
    9016:	b7 0b       	sbc	r27, r23

00009018 <__udivmodhi4_ep>:
    9018:	88 1f       	adc	r24, r24
    901a:	99 1f       	adc	r25, r25
    901c:	5a 95       	dec	r21
    901e:	a9 f7       	brne	.-22     	; 0x900a <__udivmodhi4_loop>
    9020:	80 95       	com	r24
    9022:	90 95       	com	r25
    9024:	bc 01       	movw	r22, r24
    9026:	cd 01       	movw	r24, r26
    9028:	08 95       	ret

0000902a <__divmodhi4>:
    902a:	97 fb       	bst	r25, 7
    902c:	07 2e       	mov	r0, r23
    902e:	16 f4       	brtc	.+4      	; 0x9034 <__divmodhi4+0xa>
    9030:	00 94       	com	r0
    9032:	07 d0       	rcall	.+14     	; 0x9042 <__divmodhi4_neg1>
    9034:	77 fd       	sbrc	r23, 7
    9036:	09 d0       	rcall	.+18     	; 0x904a <__divmodhi4_neg2>
    9038:	0e 94 01 48 	call	0x9002	; 0x9002 <__udivmodhi4>
    903c:	07 fc       	sbrc	r0, 7
    903e:	05 d0       	rcall	.+10     	; 0x904a <__divmodhi4_neg2>
    9040:	3e f4       	brtc	.+14     	; 0x9050 <__divmodhi4_exit>

00009042 <__divmodhi4_neg1>:
    9042:	90 95       	com	r25
    9044:	81 95       	neg	r24
    9046:	9f 4f       	sbci	r25, 0xFF	; 255
    9048:	08 95       	ret

0000904a <__divmodhi4_neg2>:
    904a:	70 95       	com	r23
    904c:	61 95       	neg	r22
    904e:	7f 4f       	sbci	r23, 0xFF	; 255

00009050 <__divmodhi4_exit>:
    9050:	08 95       	ret

00009052 <__udivmodsi4>:
    9052:	a1 e2       	ldi	r26, 0x21	; 33
    9054:	1a 2e       	mov	r1, r26
    9056:	aa 1b       	sub	r26, r26
    9058:	bb 1b       	sub	r27, r27
    905a:	fd 01       	movw	r30, r26
    905c:	0d c0       	rjmp	.+26     	; 0x9078 <__udivmodsi4_ep>

0000905e <__udivmodsi4_loop>:
    905e:	aa 1f       	adc	r26, r26
    9060:	bb 1f       	adc	r27, r27
    9062:	ee 1f       	adc	r30, r30
    9064:	ff 1f       	adc	r31, r31
    9066:	a2 17       	cp	r26, r18
    9068:	b3 07       	cpc	r27, r19
    906a:	e4 07       	cpc	r30, r20
    906c:	f5 07       	cpc	r31, r21
    906e:	20 f0       	brcs	.+8      	; 0x9078 <__udivmodsi4_ep>
    9070:	a2 1b       	sub	r26, r18
    9072:	b3 0b       	sbc	r27, r19
    9074:	e4 0b       	sbc	r30, r20
    9076:	f5 0b       	sbc	r31, r21

00009078 <__udivmodsi4_ep>:
    9078:	66 1f       	adc	r22, r22
    907a:	77 1f       	adc	r23, r23
    907c:	88 1f       	adc	r24, r24
    907e:	99 1f       	adc	r25, r25
    9080:	1a 94       	dec	r1
    9082:	69 f7       	brne	.-38     	; 0x905e <__udivmodsi4_loop>
    9084:	60 95       	com	r22
    9086:	70 95       	com	r23
    9088:	80 95       	com	r24
    908a:	90 95       	com	r25
    908c:	9b 01       	movw	r18, r22
    908e:	ac 01       	movw	r20, r24
    9090:	bd 01       	movw	r22, r26
    9092:	cf 01       	movw	r24, r30
    9094:	08 95       	ret

00009096 <__umulhisi3>:
    9096:	a2 9f       	mul	r26, r18
    9098:	b0 01       	movw	r22, r0
    909a:	b3 9f       	mul	r27, r19
    909c:	c0 01       	movw	r24, r0
    909e:	a3 9f       	mul	r26, r19
    90a0:	70 0d       	add	r23, r0
    90a2:	81 1d       	adc	r24, r1
    90a4:	11 24       	eor	r1, r1
    90a6:	91 1d       	adc	r25, r1
    90a8:	b2 9f       	mul	r27, r18
    90aa:	70 0d       	add	r23, r0
    90ac:	81 1d       	adc	r24, r1
    90ae:	11 24       	eor	r1, r1
    90b0:	91 1d       	adc	r25, r1
    90b2:	08 95       	ret

000090b4 <__muluhisi3>:
    90b4:	0e 94 4b 48 	call	0x9096	; 0x9096 <__umulhisi3>
    90b8:	a5 9f       	mul	r26, r21
    90ba:	90 0d       	add	r25, r0
    90bc:	b4 9f       	mul	r27, r20
    90be:	90 0d       	add	r25, r0
    90c0:	a4 9f       	mul	r26, r20
    90c2:	80 0d       	add	r24, r0
    90c4:	91 1d       	adc	r25, r1
    90c6:	11 24       	eor	r1, r1
    90c8:	08 95       	ret

000090ca <__mulshisi3>:
    90ca:	b7 ff       	sbrs	r27, 7
    90cc:	0c 94 5a 48 	jmp	0x90b4	; 0x90b4 <__muluhisi3>

000090d0 <__mulohisi3>:
    90d0:	0e 94 5a 48 	call	0x90b4	; 0x90b4 <__muluhisi3>
    90d4:	82 1b       	sub	r24, r18
    90d6:	93 0b       	sbc	r25, r19
    90d8:	08 95       	ret

000090da <malloc>:
    90da:	0f 93       	push	r16
    90dc:	1f 93       	push	r17
    90de:	cf 93       	push	r28
    90e0:	df 93       	push	r29
    90e2:	82 30       	cpi	r24, 0x02	; 2
    90e4:	91 05       	cpc	r25, r1
    90e6:	10 f4       	brcc	.+4      	; 0x90ec <malloc+0x12>
    90e8:	82 e0       	ldi	r24, 0x02	; 2
    90ea:	90 e0       	ldi	r25, 0x00	; 0
    90ec:	e0 91 91 2d 	lds	r30, 0x2D91	; 0x802d91 <__flp>
    90f0:	f0 91 92 2d 	lds	r31, 0x2D92	; 0x802d92 <__flp+0x1>
    90f4:	20 e0       	ldi	r18, 0x00	; 0
    90f6:	30 e0       	ldi	r19, 0x00	; 0
    90f8:	a0 e0       	ldi	r26, 0x00	; 0
    90fa:	b0 e0       	ldi	r27, 0x00	; 0
    90fc:	30 97       	sbiw	r30, 0x00	; 0
    90fe:	19 f1       	breq	.+70     	; 0x9146 <malloc+0x6c>
    9100:	40 81       	ld	r20, Z
    9102:	51 81       	ldd	r21, Z+1	; 0x01
    9104:	02 81       	ldd	r16, Z+2	; 0x02
    9106:	13 81       	ldd	r17, Z+3	; 0x03
    9108:	48 17       	cp	r20, r24
    910a:	59 07       	cpc	r21, r25
    910c:	c8 f0       	brcs	.+50     	; 0x9140 <malloc+0x66>
    910e:	84 17       	cp	r24, r20
    9110:	95 07       	cpc	r25, r21
    9112:	69 f4       	brne	.+26     	; 0x912e <malloc+0x54>
    9114:	10 97       	sbiw	r26, 0x00	; 0
    9116:	31 f0       	breq	.+12     	; 0x9124 <malloc+0x4a>
    9118:	12 96       	adiw	r26, 0x02	; 2
    911a:	0c 93       	st	X, r16
    911c:	12 97       	sbiw	r26, 0x02	; 2
    911e:	13 96       	adiw	r26, 0x03	; 3
    9120:	1c 93       	st	X, r17
    9122:	27 c0       	rjmp	.+78     	; 0x9172 <malloc+0x98>
    9124:	00 93 91 2d 	sts	0x2D91, r16	; 0x802d91 <__flp>
    9128:	10 93 92 2d 	sts	0x2D92, r17	; 0x802d92 <__flp+0x1>
    912c:	22 c0       	rjmp	.+68     	; 0x9172 <malloc+0x98>
    912e:	21 15       	cp	r18, r1
    9130:	31 05       	cpc	r19, r1
    9132:	19 f0       	breq	.+6      	; 0x913a <malloc+0x60>
    9134:	42 17       	cp	r20, r18
    9136:	53 07       	cpc	r21, r19
    9138:	18 f4       	brcc	.+6      	; 0x9140 <malloc+0x66>
    913a:	9a 01       	movw	r18, r20
    913c:	bd 01       	movw	r22, r26
    913e:	ef 01       	movw	r28, r30
    9140:	df 01       	movw	r26, r30
    9142:	f8 01       	movw	r30, r16
    9144:	db cf       	rjmp	.-74     	; 0x90fc <malloc+0x22>
    9146:	21 15       	cp	r18, r1
    9148:	31 05       	cpc	r19, r1
    914a:	f9 f0       	breq	.+62     	; 0x918a <malloc+0xb0>
    914c:	28 1b       	sub	r18, r24
    914e:	39 0b       	sbc	r19, r25
    9150:	24 30       	cpi	r18, 0x04	; 4
    9152:	31 05       	cpc	r19, r1
    9154:	80 f4       	brcc	.+32     	; 0x9176 <malloc+0x9c>
    9156:	8a 81       	ldd	r24, Y+2	; 0x02
    9158:	9b 81       	ldd	r25, Y+3	; 0x03
    915a:	61 15       	cp	r22, r1
    915c:	71 05       	cpc	r23, r1
    915e:	21 f0       	breq	.+8      	; 0x9168 <malloc+0x8e>
    9160:	fb 01       	movw	r30, r22
    9162:	82 83       	std	Z+2, r24	; 0x02
    9164:	93 83       	std	Z+3, r25	; 0x03
    9166:	04 c0       	rjmp	.+8      	; 0x9170 <malloc+0x96>
    9168:	80 93 91 2d 	sts	0x2D91, r24	; 0x802d91 <__flp>
    916c:	90 93 92 2d 	sts	0x2D92, r25	; 0x802d92 <__flp+0x1>
    9170:	fe 01       	movw	r30, r28
    9172:	32 96       	adiw	r30, 0x02	; 2
    9174:	44 c0       	rjmp	.+136    	; 0x91fe <malloc+0x124>
    9176:	fe 01       	movw	r30, r28
    9178:	e2 0f       	add	r30, r18
    917a:	f3 1f       	adc	r31, r19
    917c:	81 93       	st	Z+, r24
    917e:	91 93       	st	Z+, r25
    9180:	22 50       	subi	r18, 0x02	; 2
    9182:	31 09       	sbc	r19, r1
    9184:	28 83       	st	Y, r18
    9186:	39 83       	std	Y+1, r19	; 0x01
    9188:	3a c0       	rjmp	.+116    	; 0x91fe <malloc+0x124>
    918a:	20 91 8f 2d 	lds	r18, 0x2D8F	; 0x802d8f <__brkval>
    918e:	30 91 90 2d 	lds	r19, 0x2D90	; 0x802d90 <__brkval+0x1>
    9192:	23 2b       	or	r18, r19
    9194:	41 f4       	brne	.+16     	; 0x91a6 <malloc+0xcc>
    9196:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    919a:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    919e:	20 93 8f 2d 	sts	0x2D8F, r18	; 0x802d8f <__brkval>
    91a2:	30 93 90 2d 	sts	0x2D90, r19	; 0x802d90 <__brkval+0x1>
    91a6:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
    91aa:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
    91ae:	21 15       	cp	r18, r1
    91b0:	31 05       	cpc	r19, r1
    91b2:	41 f4       	brne	.+16     	; 0x91c4 <malloc+0xea>
    91b4:	2d b7       	in	r18, 0x3d	; 61
    91b6:	3e b7       	in	r19, 0x3e	; 62
    91b8:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    91bc:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    91c0:	24 1b       	sub	r18, r20
    91c2:	35 0b       	sbc	r19, r21
    91c4:	e0 91 8f 2d 	lds	r30, 0x2D8F	; 0x802d8f <__brkval>
    91c8:	f0 91 90 2d 	lds	r31, 0x2D90	; 0x802d90 <__brkval+0x1>
    91cc:	e2 17       	cp	r30, r18
    91ce:	f3 07       	cpc	r31, r19
    91d0:	a0 f4       	brcc	.+40     	; 0x91fa <malloc+0x120>
    91d2:	2e 1b       	sub	r18, r30
    91d4:	3f 0b       	sbc	r19, r31
    91d6:	28 17       	cp	r18, r24
    91d8:	39 07       	cpc	r19, r25
    91da:	78 f0       	brcs	.+30     	; 0x91fa <malloc+0x120>
    91dc:	ac 01       	movw	r20, r24
    91de:	4e 5f       	subi	r20, 0xFE	; 254
    91e0:	5f 4f       	sbci	r21, 0xFF	; 255
    91e2:	24 17       	cp	r18, r20
    91e4:	35 07       	cpc	r19, r21
    91e6:	48 f0       	brcs	.+18     	; 0x91fa <malloc+0x120>
    91e8:	4e 0f       	add	r20, r30
    91ea:	5f 1f       	adc	r21, r31
    91ec:	40 93 8f 2d 	sts	0x2D8F, r20	; 0x802d8f <__brkval>
    91f0:	50 93 90 2d 	sts	0x2D90, r21	; 0x802d90 <__brkval+0x1>
    91f4:	81 93       	st	Z+, r24
    91f6:	91 93       	st	Z+, r25
    91f8:	02 c0       	rjmp	.+4      	; 0x91fe <malloc+0x124>
    91fa:	e0 e0       	ldi	r30, 0x00	; 0
    91fc:	f0 e0       	ldi	r31, 0x00	; 0
    91fe:	cf 01       	movw	r24, r30
    9200:	df 91       	pop	r29
    9202:	cf 91       	pop	r28
    9204:	1f 91       	pop	r17
    9206:	0f 91       	pop	r16
    9208:	08 95       	ret

0000920a <free>:
    920a:	cf 93       	push	r28
    920c:	df 93       	push	r29
    920e:	00 97       	sbiw	r24, 0x00	; 0
    9210:	09 f4       	brne	.+2      	; 0x9214 <free+0xa>
    9212:	81 c0       	rjmp	.+258    	; 0x9316 <free+0x10c>
    9214:	fc 01       	movw	r30, r24
    9216:	32 97       	sbiw	r30, 0x02	; 2
    9218:	12 82       	std	Z+2, r1	; 0x02
    921a:	13 82       	std	Z+3, r1	; 0x03
    921c:	a0 91 91 2d 	lds	r26, 0x2D91	; 0x802d91 <__flp>
    9220:	b0 91 92 2d 	lds	r27, 0x2D92	; 0x802d92 <__flp+0x1>
    9224:	10 97       	sbiw	r26, 0x00	; 0
    9226:	81 f4       	brne	.+32     	; 0x9248 <free+0x3e>
    9228:	20 81       	ld	r18, Z
    922a:	31 81       	ldd	r19, Z+1	; 0x01
    922c:	82 0f       	add	r24, r18
    922e:	93 1f       	adc	r25, r19
    9230:	20 91 8f 2d 	lds	r18, 0x2D8F	; 0x802d8f <__brkval>
    9234:	30 91 90 2d 	lds	r19, 0x2D90	; 0x802d90 <__brkval+0x1>
    9238:	28 17       	cp	r18, r24
    923a:	39 07       	cpc	r19, r25
    923c:	51 f5       	brne	.+84     	; 0x9292 <free+0x88>
    923e:	e0 93 8f 2d 	sts	0x2D8F, r30	; 0x802d8f <__brkval>
    9242:	f0 93 90 2d 	sts	0x2D90, r31	; 0x802d90 <__brkval+0x1>
    9246:	67 c0       	rjmp	.+206    	; 0x9316 <free+0x10c>
    9248:	ed 01       	movw	r28, r26
    924a:	20 e0       	ldi	r18, 0x00	; 0
    924c:	30 e0       	ldi	r19, 0x00	; 0
    924e:	ce 17       	cp	r28, r30
    9250:	df 07       	cpc	r29, r31
    9252:	40 f4       	brcc	.+16     	; 0x9264 <free+0x5a>
    9254:	4a 81       	ldd	r20, Y+2	; 0x02
    9256:	5b 81       	ldd	r21, Y+3	; 0x03
    9258:	9e 01       	movw	r18, r28
    925a:	41 15       	cp	r20, r1
    925c:	51 05       	cpc	r21, r1
    925e:	f1 f0       	breq	.+60     	; 0x929c <free+0x92>
    9260:	ea 01       	movw	r28, r20
    9262:	f5 cf       	rjmp	.-22     	; 0x924e <free+0x44>
    9264:	c2 83       	std	Z+2, r28	; 0x02
    9266:	d3 83       	std	Z+3, r29	; 0x03
    9268:	40 81       	ld	r20, Z
    926a:	51 81       	ldd	r21, Z+1	; 0x01
    926c:	84 0f       	add	r24, r20
    926e:	95 1f       	adc	r25, r21
    9270:	c8 17       	cp	r28, r24
    9272:	d9 07       	cpc	r29, r25
    9274:	59 f4       	brne	.+22     	; 0x928c <free+0x82>
    9276:	88 81       	ld	r24, Y
    9278:	99 81       	ldd	r25, Y+1	; 0x01
    927a:	84 0f       	add	r24, r20
    927c:	95 1f       	adc	r25, r21
    927e:	02 96       	adiw	r24, 0x02	; 2
    9280:	80 83       	st	Z, r24
    9282:	91 83       	std	Z+1, r25	; 0x01
    9284:	8a 81       	ldd	r24, Y+2	; 0x02
    9286:	9b 81       	ldd	r25, Y+3	; 0x03
    9288:	82 83       	std	Z+2, r24	; 0x02
    928a:	93 83       	std	Z+3, r25	; 0x03
    928c:	21 15       	cp	r18, r1
    928e:	31 05       	cpc	r19, r1
    9290:	29 f4       	brne	.+10     	; 0x929c <free+0x92>
    9292:	e0 93 91 2d 	sts	0x2D91, r30	; 0x802d91 <__flp>
    9296:	f0 93 92 2d 	sts	0x2D92, r31	; 0x802d92 <__flp+0x1>
    929a:	3d c0       	rjmp	.+122    	; 0x9316 <free+0x10c>
    929c:	e9 01       	movw	r28, r18
    929e:	ea 83       	std	Y+2, r30	; 0x02
    92a0:	fb 83       	std	Y+3, r31	; 0x03
    92a2:	49 91       	ld	r20, Y+
    92a4:	59 91       	ld	r21, Y+
    92a6:	c4 0f       	add	r28, r20
    92a8:	d5 1f       	adc	r29, r21
    92aa:	ec 17       	cp	r30, r28
    92ac:	fd 07       	cpc	r31, r29
    92ae:	61 f4       	brne	.+24     	; 0x92c8 <free+0xbe>
    92b0:	80 81       	ld	r24, Z
    92b2:	91 81       	ldd	r25, Z+1	; 0x01
    92b4:	84 0f       	add	r24, r20
    92b6:	95 1f       	adc	r25, r21
    92b8:	02 96       	adiw	r24, 0x02	; 2
    92ba:	e9 01       	movw	r28, r18
    92bc:	88 83       	st	Y, r24
    92be:	99 83       	std	Y+1, r25	; 0x01
    92c0:	82 81       	ldd	r24, Z+2	; 0x02
    92c2:	93 81       	ldd	r25, Z+3	; 0x03
    92c4:	8a 83       	std	Y+2, r24	; 0x02
    92c6:	9b 83       	std	Y+3, r25	; 0x03
    92c8:	e0 e0       	ldi	r30, 0x00	; 0
    92ca:	f0 e0       	ldi	r31, 0x00	; 0
    92cc:	12 96       	adiw	r26, 0x02	; 2
    92ce:	8d 91       	ld	r24, X+
    92d0:	9c 91       	ld	r25, X
    92d2:	13 97       	sbiw	r26, 0x03	; 3
    92d4:	00 97       	sbiw	r24, 0x00	; 0
    92d6:	19 f0       	breq	.+6      	; 0x92de <free+0xd4>
    92d8:	fd 01       	movw	r30, r26
    92da:	dc 01       	movw	r26, r24
    92dc:	f7 cf       	rjmp	.-18     	; 0x92cc <free+0xc2>
    92de:	8d 91       	ld	r24, X+
    92e0:	9c 91       	ld	r25, X
    92e2:	11 97       	sbiw	r26, 0x01	; 1
    92e4:	9d 01       	movw	r18, r26
    92e6:	2e 5f       	subi	r18, 0xFE	; 254
    92e8:	3f 4f       	sbci	r19, 0xFF	; 255
    92ea:	82 0f       	add	r24, r18
    92ec:	93 1f       	adc	r25, r19
    92ee:	20 91 8f 2d 	lds	r18, 0x2D8F	; 0x802d8f <__brkval>
    92f2:	30 91 90 2d 	lds	r19, 0x2D90	; 0x802d90 <__brkval+0x1>
    92f6:	28 17       	cp	r18, r24
    92f8:	39 07       	cpc	r19, r25
    92fa:	69 f4       	brne	.+26     	; 0x9316 <free+0x10c>
    92fc:	30 97       	sbiw	r30, 0x00	; 0
    92fe:	29 f4       	brne	.+10     	; 0x930a <free+0x100>
    9300:	10 92 91 2d 	sts	0x2D91, r1	; 0x802d91 <__flp>
    9304:	10 92 92 2d 	sts	0x2D92, r1	; 0x802d92 <__flp+0x1>
    9308:	02 c0       	rjmp	.+4      	; 0x930e <free+0x104>
    930a:	12 82       	std	Z+2, r1	; 0x02
    930c:	13 82       	std	Z+3, r1	; 0x03
    930e:	a0 93 8f 2d 	sts	0x2D8F, r26	; 0x802d8f <__brkval>
    9312:	b0 93 90 2d 	sts	0x2D90, r27	; 0x802d90 <__brkval+0x1>
    9316:	df 91       	pop	r29
    9318:	cf 91       	pop	r28
    931a:	08 95       	ret

0000931c <swapfunc>:
    931c:	dc 01       	movw	r26, r24
    931e:	fb 01       	movw	r30, r22
    9320:	8c 91       	ld	r24, X
    9322:	90 81       	ld	r25, Z
    9324:	9d 93       	st	X+, r25
    9326:	81 93       	st	Z+, r24
    9328:	41 50       	subi	r20, 0x01	; 1
    932a:	51 09       	sbc	r21, r1
    932c:	14 16       	cp	r1, r20
    932e:	15 06       	cpc	r1, r21
    9330:	bc f3       	brlt	.-18     	; 0x9320 <swapfunc+0x4>
    9332:	08 95       	ret

00009334 <med3>:
    9334:	cf 92       	push	r12
    9336:	df 92       	push	r13
    9338:	ef 92       	push	r14
    933a:	ff 92       	push	r15
    933c:	0f 93       	push	r16
    933e:	1f 93       	push	r17
    9340:	cf 93       	push	r28
    9342:	df 93       	push	r29
    9344:	7c 01       	movw	r14, r24
    9346:	6b 01       	movw	r12, r22
    9348:	d4 2f       	mov	r29, r20
    934a:	c5 2f       	mov	r28, r21
    934c:	89 01       	movw	r16, r18
    934e:	f9 01       	movw	r30, r18
    9350:	19 95       	eicall
    9352:	6d 2f       	mov	r22, r29
    9354:	7c 2f       	mov	r23, r28
    9356:	97 ff       	sbrs	r25, 7
    9358:	10 c0       	rjmp	.+32     	; 0x937a <med3+0x46>
    935a:	c6 01       	movw	r24, r12
    935c:	f8 01       	movw	r30, r16
    935e:	19 95       	eicall
    9360:	97 ff       	sbrs	r25, 7
    9362:	02 c0       	rjmp	.+4      	; 0x9368 <med3+0x34>
    9364:	c6 01       	movw	r24, r12
    9366:	18 c0       	rjmp	.+48     	; 0x9398 <med3+0x64>
    9368:	6d 2f       	mov	r22, r29
    936a:	7c 2f       	mov	r23, r28
    936c:	c7 01       	movw	r24, r14
    936e:	f8 01       	movw	r30, r16
    9370:	19 95       	eicall
    9372:	97 fd       	sbrc	r25, 7
    9374:	0f c0       	rjmp	.+30     	; 0x9394 <med3+0x60>
    9376:	c7 01       	movw	r24, r14
    9378:	0f c0       	rjmp	.+30     	; 0x9398 <med3+0x64>
    937a:	c6 01       	movw	r24, r12
    937c:	f8 01       	movw	r30, r16
    937e:	19 95       	eicall
    9380:	18 16       	cp	r1, r24
    9382:	19 06       	cpc	r1, r25
    9384:	7c f3       	brlt	.-34     	; 0x9364 <med3+0x30>
    9386:	6d 2f       	mov	r22, r29
    9388:	7c 2f       	mov	r23, r28
    938a:	c7 01       	movw	r24, r14
    938c:	f8 01       	movw	r30, r16
    938e:	19 95       	eicall
    9390:	97 fd       	sbrc	r25, 7
    9392:	f1 cf       	rjmp	.-30     	; 0x9376 <med3+0x42>
    9394:	8d 2f       	mov	r24, r29
    9396:	9c 2f       	mov	r25, r28
    9398:	df 91       	pop	r29
    939a:	cf 91       	pop	r28
    939c:	1f 91       	pop	r17
    939e:	0f 91       	pop	r16
    93a0:	ff 90       	pop	r15
    93a2:	ef 90       	pop	r14
    93a4:	df 90       	pop	r13
    93a6:	cf 90       	pop	r12
    93a8:	08 95       	ret

000093aa <qsort>:
    93aa:	2f 92       	push	r2
    93ac:	3f 92       	push	r3
    93ae:	4f 92       	push	r4
    93b0:	5f 92       	push	r5
    93b2:	6f 92       	push	r6
    93b4:	7f 92       	push	r7
    93b6:	8f 92       	push	r8
    93b8:	9f 92       	push	r9
    93ba:	af 92       	push	r10
    93bc:	bf 92       	push	r11
    93be:	cf 92       	push	r12
    93c0:	df 92       	push	r13
    93c2:	ef 92       	push	r14
    93c4:	ff 92       	push	r15
    93c6:	0f 93       	push	r16
    93c8:	1f 93       	push	r17
    93ca:	cf 93       	push	r28
    93cc:	df 93       	push	r29
    93ce:	cd b7       	in	r28, 0x3d	; 61
    93d0:	de b7       	in	r29, 0x3e	; 62
    93d2:	2a 97       	sbiw	r28, 0x0a	; 10
    93d4:	cd bf       	out	0x3d, r28	; 61
    93d6:	de bf       	out	0x3e, r29	; 62
    93d8:	8c 01       	movw	r16, r24
    93da:	7b 01       	movw	r14, r22
    93dc:	49 87       	std	Y+9, r20	; 0x09
    93de:	5a 87       	std	Y+10, r21	; 0x0a
    93e0:	69 01       	movw	r12, r18
    93e2:	29 85       	ldd	r18, Y+9	; 0x09
    93e4:	3a 85       	ldd	r19, Y+10	; 0x0a
    93e6:	20 0f       	add	r18, r16
    93e8:	31 1f       	adc	r19, r17
    93ea:	29 83       	std	Y+1, r18	; 0x01
    93ec:	3a 83       	std	Y+2, r19	; 0x02
    93ee:	37 e0       	ldi	r19, 0x07	; 7
    93f0:	e3 16       	cp	r14, r19
    93f2:	f1 04       	cpc	r15, r1
    93f4:	70 f5       	brcc	.+92     	; 0x9452 <qsort+0xa8>
    93f6:	69 80       	ldd	r6, Y+1	; 0x01
    93f8:	7a 80       	ldd	r7, Y+2	; 0x02
    93fa:	49 85       	ldd	r20, Y+9	; 0x09
    93fc:	5a 85       	ldd	r21, Y+10	; 0x0a
    93fe:	e4 9e       	mul	r14, r20
    9400:	50 01       	movw	r10, r0
    9402:	e5 9e       	mul	r14, r21
    9404:	b0 0c       	add	r11, r0
    9406:	f4 9e       	mul	r15, r20
    9408:	b0 0c       	add	r11, r0
    940a:	11 24       	eor	r1, r1
    940c:	a0 0e       	add	r10, r16
    940e:	b1 1e       	adc	r11, r17
    9410:	6a 14       	cp	r6, r10
    9412:	7b 04       	cpc	r7, r11
    9414:	08 f0       	brcs	.+2      	; 0x9418 <qsort+0x6e>
    9416:	7a c1       	rjmp	.+756    	; 0x970c <qsort+0x362>
    9418:	73 01       	movw	r14, r6
    941a:	0e 15       	cp	r16, r14
    941c:	1f 05       	cpc	r17, r15
    941e:	28 f0       	brcs	.+10     	; 0x942a <qsort+0x80>
    9420:	89 85       	ldd	r24, Y+9	; 0x09
    9422:	9a 85       	ldd	r25, Y+10	; 0x0a
    9424:	68 0e       	add	r6, r24
    9426:	79 1e       	adc	r7, r25
    9428:	f3 cf       	rjmp	.-26     	; 0x9410 <qsort+0x66>
    942a:	47 01       	movw	r8, r14
    942c:	e9 85       	ldd	r30, Y+9	; 0x09
    942e:	fa 85       	ldd	r31, Y+10	; 0x0a
    9430:	8e 1a       	sub	r8, r30
    9432:	9f 0a       	sbc	r9, r31
    9434:	b7 01       	movw	r22, r14
    9436:	c4 01       	movw	r24, r8
    9438:	f6 01       	movw	r30, r12
    943a:	19 95       	eicall
    943c:	18 16       	cp	r1, r24
    943e:	19 06       	cpc	r1, r25
    9440:	7c f7       	brge	.-34     	; 0x9420 <qsort+0x76>
    9442:	49 85       	ldd	r20, Y+9	; 0x09
    9444:	5a 85       	ldd	r21, Y+10	; 0x0a
    9446:	b4 01       	movw	r22, r8
    9448:	c7 01       	movw	r24, r14
    944a:	0e 94 8e 49 	call	0x931c	; 0x931c <swapfunc>
    944e:	74 01       	movw	r14, r8
    9450:	e4 cf       	rjmp	.-56     	; 0x941a <qsort+0x70>
    9452:	c7 01       	movw	r24, r14
    9454:	96 95       	lsr	r25
    9456:	87 95       	ror	r24
    9458:	29 85       	ldd	r18, Y+9	; 0x09
    945a:	3a 85       	ldd	r19, Y+10	; 0x0a
    945c:	82 9f       	mul	r24, r18
    945e:	50 01       	movw	r10, r0
    9460:	83 9f       	mul	r24, r19
    9462:	b0 0c       	add	r11, r0
    9464:	92 9f       	mul	r25, r18
    9466:	b0 0c       	add	r11, r0
    9468:	11 24       	eor	r1, r1
    946a:	a0 0e       	add	r10, r16
    946c:	b1 1e       	adc	r11, r17
    946e:	a7 01       	movw	r20, r14
    9470:	41 50       	subi	r20, 0x01	; 1
    9472:	51 09       	sbc	r21, r1
    9474:	4b 83       	std	Y+3, r20	; 0x03
    9476:	5c 83       	std	Y+4, r21	; 0x04
    9478:	57 e0       	ldi	r21, 0x07	; 7
    947a:	e5 16       	cp	r14, r21
    947c:	f1 04       	cpc	r15, r1
    947e:	09 f4       	brne	.+2      	; 0x9482 <qsort+0xd8>
    9480:	4c c0       	rjmp	.+152    	; 0x951a <qsort+0x170>
    9482:	8b 81       	ldd	r24, Y+3	; 0x03
    9484:	9c 81       	ldd	r25, Y+4	; 0x04
    9486:	82 9f       	mul	r24, r18
    9488:	30 01       	movw	r6, r0
    948a:	83 9f       	mul	r24, r19
    948c:	70 0c       	add	r7, r0
    948e:	92 9f       	mul	r25, r18
    9490:	70 0c       	add	r7, r0
    9492:	11 24       	eor	r1, r1
    9494:	60 0e       	add	r6, r16
    9496:	71 1e       	adc	r7, r17
    9498:	99 e2       	ldi	r25, 0x29	; 41
    949a:	e9 16       	cp	r14, r25
    949c:	f1 04       	cpc	r15, r1
    949e:	a8 f1       	brcs	.+106    	; 0x950a <qsort+0x160>
    94a0:	c7 01       	movw	r24, r14
    94a2:	43 e0       	ldi	r20, 0x03	; 3
    94a4:	96 95       	lsr	r25
    94a6:	87 95       	ror	r24
    94a8:	4a 95       	dec	r20
    94aa:	e1 f7       	brne	.-8      	; 0x94a4 <qsort+0xfa>
    94ac:	82 9f       	mul	r24, r18
    94ae:	40 01       	movw	r8, r0
    94b0:	83 9f       	mul	r24, r19
    94b2:	90 0c       	add	r9, r0
    94b4:	92 9f       	mul	r25, r18
    94b6:	90 0c       	add	r9, r0
    94b8:	11 24       	eor	r1, r1
    94ba:	14 01       	movw	r2, r8
    94bc:	22 0c       	add	r2, r2
    94be:	33 1c       	adc	r3, r3
    94c0:	a8 01       	movw	r20, r16
    94c2:	42 0d       	add	r20, r2
    94c4:	53 1d       	adc	r21, r3
    94c6:	b8 01       	movw	r22, r16
    94c8:	68 0d       	add	r22, r8
    94ca:	79 1d       	adc	r23, r9
    94cc:	96 01       	movw	r18, r12
    94ce:	c8 01       	movw	r24, r16
    94d0:	0e 94 9a 49 	call	0x9334	; 0x9334 <med3>
    94d4:	2c 01       	movw	r4, r24
    94d6:	a5 01       	movw	r20, r10
    94d8:	48 0d       	add	r20, r8
    94da:	59 1d       	adc	r21, r9
    94dc:	91 94       	neg	r9
    94de:	81 94       	neg	r8
    94e0:	91 08       	sbc	r9, r1
    94e2:	96 01       	movw	r18, r12
    94e4:	b5 01       	movw	r22, r10
    94e6:	c5 01       	movw	r24, r10
    94e8:	88 0d       	add	r24, r8
    94ea:	99 1d       	adc	r25, r9
    94ec:	0e 94 9a 49 	call	0x9334	; 0x9334 <med3>
    94f0:	5c 01       	movw	r10, r24
    94f2:	b3 01       	movw	r22, r6
    94f4:	68 0d       	add	r22, r8
    94f6:	79 1d       	adc	r23, r9
    94f8:	96 01       	movw	r18, r12
    94fa:	a3 01       	movw	r20, r6
    94fc:	c3 01       	movw	r24, r6
    94fe:	82 19       	sub	r24, r2
    9500:	93 09       	sbc	r25, r3
    9502:	0e 94 9a 49 	call	0x9334	; 0x9334 <med3>
    9506:	3c 01       	movw	r6, r24
    9508:	01 c0       	rjmp	.+2      	; 0x950c <qsort+0x162>
    950a:	28 01       	movw	r4, r16
    950c:	96 01       	movw	r18, r12
    950e:	a3 01       	movw	r20, r6
    9510:	b5 01       	movw	r22, r10
    9512:	c2 01       	movw	r24, r4
    9514:	0e 94 9a 49 	call	0x9334	; 0x9334 <med3>
    9518:	5c 01       	movw	r10, r24
    951a:	49 85       	ldd	r20, Y+9	; 0x09
    951c:	5a 85       	ldd	r21, Y+10	; 0x0a
    951e:	b5 01       	movw	r22, r10
    9520:	c8 01       	movw	r24, r16
    9522:	0e 94 8e 49 	call	0x931c	; 0x931c <swapfunc>
    9526:	69 80       	ldd	r6, Y+1	; 0x01
    9528:	7a 80       	ldd	r7, Y+2	; 0x02
    952a:	2b 81       	ldd	r18, Y+3	; 0x03
    952c:	3c 81       	ldd	r19, Y+4	; 0x04
    952e:	49 85       	ldd	r20, Y+9	; 0x09
    9530:	5a 85       	ldd	r21, Y+10	; 0x0a
    9532:	24 9f       	mul	r18, r20
    9534:	f0 01       	movw	r30, r0
    9536:	25 9f       	mul	r18, r21
    9538:	f0 0d       	add	r31, r0
    953a:	34 9f       	mul	r19, r20
    953c:	f0 0d       	add	r31, r0
    953e:	11 24       	eor	r1, r1
    9540:	ed 83       	std	Y+5, r30	; 0x05
    9542:	fe 83       	std	Y+6, r31	; 0x06
    9544:	5f 01       	movw	r10, r30
    9546:	a0 0e       	add	r10, r16
    9548:	b1 1e       	adc	r11, r17
    954a:	46 0d       	add	r20, r6
    954c:	57 1d       	adc	r21, r7
    954e:	4b 83       	std	Y+3, r20	; 0x03
    9550:	5c 83       	std	Y+4, r21	; 0x04
    9552:	25 01       	movw	r4, r10
    9554:	13 01       	movw	r2, r6
    9556:	19 82       	std	Y+1, r1	; 0x01
    9558:	1a 82       	std	Y+2, r1	; 0x02
    955a:	8b 80       	ldd	r8, Y+3	; 0x03
    955c:	9c 80       	ldd	r9, Y+4	; 0x04
    955e:	89 85       	ldd	r24, Y+9	; 0x09
    9560:	9a 85       	ldd	r25, Y+10	; 0x0a
    9562:	88 1a       	sub	r8, r24
    9564:	99 0a       	sbc	r9, r25
    9566:	a8 14       	cp	r10, r8
    9568:	b9 04       	cpc	r11, r9
    956a:	08 f4       	brcc	.+2      	; 0x956e <qsort+0x1c4>
    956c:	50 c0       	rjmp	.+160    	; 0x960e <qsort+0x264>
    956e:	b8 01       	movw	r22, r16
    9570:	c4 01       	movw	r24, r8
    9572:	f6 01       	movw	r30, r12
    9574:	19 95       	eicall
    9576:	18 16       	cp	r1, r24
    9578:	19 06       	cpc	r1, r25
    957a:	c4 f1       	brlt	.+112    	; 0x95ec <qsort+0x242>
    957c:	89 2b       	or	r24, r25
    957e:	71 f4       	brne	.+28     	; 0x959c <qsort+0x1f2>
    9580:	49 85       	ldd	r20, Y+9	; 0x09
    9582:	5a 85       	ldd	r21, Y+10	; 0x0a
    9584:	b4 01       	movw	r22, r8
    9586:	c1 01       	movw	r24, r2
    9588:	0e 94 8e 49 	call	0x931c	; 0x931c <swapfunc>
    958c:	89 85       	ldd	r24, Y+9	; 0x09
    958e:	9a 85       	ldd	r25, Y+10	; 0x0a
    9590:	28 0e       	add	r2, r24
    9592:	39 1e       	adc	r3, r25
    9594:	e1 e0       	ldi	r30, 0x01	; 1
    9596:	f0 e0       	ldi	r31, 0x00	; 0
    9598:	e9 83       	std	Y+1, r30	; 0x01
    959a:	fa 83       	std	Y+2, r31	; 0x02
    959c:	2b 81       	ldd	r18, Y+3	; 0x03
    959e:	3c 81       	ldd	r19, Y+4	; 0x04
    95a0:	49 85       	ldd	r20, Y+9	; 0x09
    95a2:	5a 85       	ldd	r21, Y+10	; 0x0a
    95a4:	24 0f       	add	r18, r20
    95a6:	35 1f       	adc	r19, r21
    95a8:	2b 83       	std	Y+3, r18	; 0x03
    95aa:	3c 83       	std	Y+4, r19	; 0x04
    95ac:	d6 cf       	rjmp	.-84     	; 0x955a <qsort+0x1b0>
    95ae:	b8 01       	movw	r22, r16
    95b0:	c5 01       	movw	r24, r10
    95b2:	f6 01       	movw	r30, r12
    95b4:	19 95       	eicall
    95b6:	95 01       	movw	r18, r10
    95b8:	49 85       	ldd	r20, Y+9	; 0x09
    95ba:	5a 85       	ldd	r21, Y+10	; 0x0a
    95bc:	24 1b       	sub	r18, r20
    95be:	35 0b       	sbc	r19, r21
    95c0:	2f 83       	std	Y+7, r18	; 0x07
    95c2:	38 87       	std	Y+8, r19	; 0x08
    95c4:	97 fd       	sbrc	r25, 7
    95c6:	16 c0       	rjmp	.+44     	; 0x95f4 <qsort+0x24a>
    95c8:	89 2b       	or	r24, r25
    95ca:	71 f4       	brne	.+28     	; 0x95e8 <qsort+0x23e>
    95cc:	49 85       	ldd	r20, Y+9	; 0x09
    95ce:	5a 85       	ldd	r21, Y+10	; 0x0a
    95d0:	b2 01       	movw	r22, r4
    95d2:	c5 01       	movw	r24, r10
    95d4:	0e 94 8e 49 	call	0x931c	; 0x931c <swapfunc>
    95d8:	29 85       	ldd	r18, Y+9	; 0x09
    95da:	3a 85       	ldd	r19, Y+10	; 0x0a
    95dc:	42 1a       	sub	r4, r18
    95de:	53 0a       	sbc	r5, r19
    95e0:	41 e0       	ldi	r20, 0x01	; 1
    95e2:	50 e0       	ldi	r21, 0x00	; 0
    95e4:	49 83       	std	Y+1, r20	; 0x01
    95e6:	5a 83       	std	Y+2, r21	; 0x02
    95e8:	af 80       	ldd	r10, Y+7	; 0x07
    95ea:	b8 84       	ldd	r11, Y+8	; 0x08
    95ec:	a8 14       	cp	r10, r8
    95ee:	b9 04       	cpc	r11, r9
    95f0:	f0 f6       	brcc	.-68     	; 0x95ae <qsort+0x204>
    95f2:	0d c0       	rjmp	.+26     	; 0x960e <qsort+0x264>
    95f4:	49 85       	ldd	r20, Y+9	; 0x09
    95f6:	5a 85       	ldd	r21, Y+10	; 0x0a
    95f8:	b5 01       	movw	r22, r10
    95fa:	c4 01       	movw	r24, r8
    95fc:	0e 94 8e 49 	call	0x931c	; 0x931c <swapfunc>
    9600:	af 80       	ldd	r10, Y+7	; 0x07
    9602:	b8 84       	ldd	r11, Y+8	; 0x08
    9604:	41 e0       	ldi	r20, 0x01	; 1
    9606:	50 e0       	ldi	r21, 0x00	; 0
    9608:	49 83       	std	Y+1, r20	; 0x01
    960a:	5a 83       	std	Y+2, r21	; 0x02
    960c:	c7 cf       	rjmp	.-114    	; 0x959c <qsort+0x1f2>
    960e:	89 81       	ldd	r24, Y+1	; 0x01
    9610:	9a 81       	ldd	r25, Y+2	; 0x02
    9612:	89 2b       	or	r24, r25
    9614:	09 f4       	brne	.+2      	; 0x9618 <qsort+0x26e>
    9616:	4f c0       	rjmp	.+158    	; 0x96b6 <qsort+0x30c>
    9618:	6d 80       	ldd	r6, Y+5	; 0x05
    961a:	7e 80       	ldd	r7, Y+6	; 0x06
    961c:	29 85       	ldd	r18, Y+9	; 0x09
    961e:	3a 85       	ldd	r19, Y+10	; 0x0a
    9620:	62 0e       	add	r6, r18
    9622:	73 1e       	adc	r7, r19
    9624:	60 0e       	add	r6, r16
    9626:	71 1e       	adc	r7, r17
    9628:	74 01       	movw	r14, r8
    962a:	e2 18       	sub	r14, r2
    962c:	f3 08       	sbc	r15, r3
    962e:	a1 01       	movw	r20, r2
    9630:	40 1b       	sub	r20, r16
    9632:	51 0b       	sbc	r21, r17
    9634:	e4 16       	cp	r14, r20
    9636:	f5 06       	cpc	r15, r21
    9638:	0c f4       	brge	.+2      	; 0x963c <qsort+0x292>
    963a:	a7 01       	movw	r20, r14
    963c:	14 16       	cp	r1, r20
    963e:	15 06       	cpc	r1, r21
    9640:	34 f4       	brge	.+12     	; 0x964e <qsort+0x2a4>
    9642:	b4 01       	movw	r22, r8
    9644:	64 1b       	sub	r22, r20
    9646:	75 0b       	sbc	r23, r21
    9648:	c8 01       	movw	r24, r16
    964a:	0e 94 8e 49 	call	0x931c	; 0x931c <swapfunc>
    964e:	a2 01       	movw	r20, r4
    9650:	4a 19       	sub	r20, r10
    9652:	5b 09       	sbc	r21, r11
    9654:	5a 01       	movw	r10, r20
    9656:	a3 01       	movw	r20, r6
    9658:	44 19       	sub	r20, r4
    965a:	55 09       	sbc	r21, r5
    965c:	89 85       	ldd	r24, Y+9	; 0x09
    965e:	9a 85       	ldd	r25, Y+10	; 0x0a
    9660:	48 1b       	sub	r20, r24
    9662:	59 0b       	sbc	r21, r25
    9664:	a4 16       	cp	r10, r20
    9666:	b5 06       	cpc	r11, r21
    9668:	08 f4       	brcc	.+2      	; 0x966c <qsort+0x2c2>
    966a:	a5 01       	movw	r20, r10
    966c:	14 16       	cp	r1, r20
    966e:	15 06       	cpc	r1, r21
    9670:	34 f4       	brge	.+12     	; 0x967e <qsort+0x2d4>
    9672:	b3 01       	movw	r22, r6
    9674:	64 1b       	sub	r22, r20
    9676:	75 0b       	sbc	r23, r21
    9678:	c4 01       	movw	r24, r8
    967a:	0e 94 8e 49 	call	0x931c	; 0x931c <swapfunc>
    967e:	e9 85       	ldd	r30, Y+9	; 0x09
    9680:	fa 85       	ldd	r31, Y+10	; 0x0a
    9682:	ee 15       	cp	r30, r14
    9684:	ff 05       	cpc	r31, r15
    9686:	48 f4       	brcc	.+18     	; 0x969a <qsort+0x2f0>
    9688:	c7 01       	movw	r24, r14
    968a:	bf 01       	movw	r22, r30
    968c:	0e 94 01 48 	call	0x9002	; 0x9002 <__udivmodhi4>
    9690:	96 01       	movw	r18, r12
    9692:	af 01       	movw	r20, r30
    9694:	c8 01       	movw	r24, r16
    9696:	0e 94 d5 49 	call	0x93aa	; 0x93aa <qsort>
    969a:	29 85       	ldd	r18, Y+9	; 0x09
    969c:	3a 85       	ldd	r19, Y+10	; 0x0a
    969e:	2a 15       	cp	r18, r10
    96a0:	3b 05       	cpc	r19, r11
    96a2:	a0 f5       	brcc	.+104    	; 0x970c <qsort+0x362>
    96a4:	83 01       	movw	r16, r6
    96a6:	0a 19       	sub	r16, r10
    96a8:	1b 09       	sbc	r17, r11
    96aa:	c5 01       	movw	r24, r10
    96ac:	b9 01       	movw	r22, r18
    96ae:	0e 94 01 48 	call	0x9002	; 0x9002 <__udivmodhi4>
    96b2:	7b 01       	movw	r14, r22
    96b4:	96 ce       	rjmp	.-724    	; 0x93e2 <qsort+0x38>
    96b6:	e9 85       	ldd	r30, Y+9	; 0x09
    96b8:	fa 85       	ldd	r31, Y+10	; 0x0a
    96ba:	ee 9e       	mul	r14, r30
    96bc:	50 01       	movw	r10, r0
    96be:	ef 9e       	mul	r14, r31
    96c0:	b0 0c       	add	r11, r0
    96c2:	fe 9e       	mul	r15, r30
    96c4:	b0 0c       	add	r11, r0
    96c6:	11 24       	eor	r1, r1
    96c8:	a0 0e       	add	r10, r16
    96ca:	b1 1e       	adc	r11, r17
    96cc:	6a 14       	cp	r6, r10
    96ce:	7b 04       	cpc	r7, r11
    96d0:	e8 f4       	brcc	.+58     	; 0x970c <qsort+0x362>
    96d2:	73 01       	movw	r14, r6
    96d4:	0e 15       	cp	r16, r14
    96d6:	1f 05       	cpc	r17, r15
    96d8:	28 f0       	brcs	.+10     	; 0x96e4 <qsort+0x33a>
    96da:	89 85       	ldd	r24, Y+9	; 0x09
    96dc:	9a 85       	ldd	r25, Y+10	; 0x0a
    96de:	68 0e       	add	r6, r24
    96e0:	79 1e       	adc	r7, r25
    96e2:	f4 cf       	rjmp	.-24     	; 0x96cc <qsort+0x322>
    96e4:	47 01       	movw	r8, r14
    96e6:	e9 85       	ldd	r30, Y+9	; 0x09
    96e8:	fa 85       	ldd	r31, Y+10	; 0x0a
    96ea:	8e 1a       	sub	r8, r30
    96ec:	9f 0a       	sbc	r9, r31
    96ee:	b7 01       	movw	r22, r14
    96f0:	c4 01       	movw	r24, r8
    96f2:	f6 01       	movw	r30, r12
    96f4:	19 95       	eicall
    96f6:	18 16       	cp	r1, r24
    96f8:	19 06       	cpc	r1, r25
    96fa:	7c f7       	brge	.-34     	; 0x96da <qsort+0x330>
    96fc:	49 85       	ldd	r20, Y+9	; 0x09
    96fe:	5a 85       	ldd	r21, Y+10	; 0x0a
    9700:	b4 01       	movw	r22, r8
    9702:	c7 01       	movw	r24, r14
    9704:	0e 94 8e 49 	call	0x931c	; 0x931c <swapfunc>
    9708:	74 01       	movw	r14, r8
    970a:	e4 cf       	rjmp	.-56     	; 0x96d4 <qsort+0x32a>
    970c:	2a 96       	adiw	r28, 0x0a	; 10
    970e:	cd bf       	out	0x3d, r28	; 61
    9710:	de bf       	out	0x3e, r29	; 62
    9712:	df 91       	pop	r29
    9714:	cf 91       	pop	r28
    9716:	1f 91       	pop	r17
    9718:	0f 91       	pop	r16
    971a:	ff 90       	pop	r15
    971c:	ef 90       	pop	r14
    971e:	df 90       	pop	r13
    9720:	cf 90       	pop	r12
    9722:	bf 90       	pop	r11
    9724:	af 90       	pop	r10
    9726:	9f 90       	pop	r9
    9728:	8f 90       	pop	r8
    972a:	7f 90       	pop	r7
    972c:	6f 90       	pop	r6
    972e:	5f 90       	pop	r5
    9730:	4f 90       	pop	r4
    9732:	3f 90       	pop	r3
    9734:	2f 90       	pop	r2
    9736:	08 95       	ret

00009738 <atof>:
    9738:	66 27       	eor	r22, r22
    973a:	77 27       	eor	r23, r23
    973c:	0c 94 4b 4e 	jmp	0x9c96	; 0x9c96 <strtod>

00009740 <__ftoa_engine>:
    9740:	28 30       	cpi	r18, 0x08	; 8
    9742:	08 f0       	brcs	.+2      	; 0x9746 <__ftoa_engine+0x6>
    9744:	27 e0       	ldi	r18, 0x07	; 7
    9746:	33 27       	eor	r19, r19
    9748:	da 01       	movw	r26, r20
    974a:	99 0f       	add	r25, r25
    974c:	31 1d       	adc	r19, r1
    974e:	87 fd       	sbrc	r24, 7
    9750:	91 60       	ori	r25, 0x01	; 1
    9752:	00 96       	adiw	r24, 0x00	; 0
    9754:	61 05       	cpc	r22, r1
    9756:	71 05       	cpc	r23, r1
    9758:	39 f4       	brne	.+14     	; 0x9768 <__ftoa_engine+0x28>
    975a:	32 60       	ori	r19, 0x02	; 2
    975c:	2e 5f       	subi	r18, 0xFE	; 254
    975e:	3d 93       	st	X+, r19
    9760:	30 e3       	ldi	r19, 0x30	; 48
    9762:	2a 95       	dec	r18
    9764:	e1 f7       	brne	.-8      	; 0x975e <__ftoa_engine+0x1e>
    9766:	08 95       	ret
    9768:	9f 3f       	cpi	r25, 0xFF	; 255
    976a:	30 f0       	brcs	.+12     	; 0x9778 <__ftoa_engine+0x38>
    976c:	80 38       	cpi	r24, 0x80	; 128
    976e:	71 05       	cpc	r23, r1
    9770:	61 05       	cpc	r22, r1
    9772:	09 f0       	breq	.+2      	; 0x9776 <__ftoa_engine+0x36>
    9774:	3c 5f       	subi	r19, 0xFC	; 252
    9776:	3c 5f       	subi	r19, 0xFC	; 252
    9778:	3d 93       	st	X+, r19
    977a:	91 30       	cpi	r25, 0x01	; 1
    977c:	08 f0       	brcs	.+2      	; 0x9780 <__ftoa_engine+0x40>
    977e:	80 68       	ori	r24, 0x80	; 128
    9780:	91 1d       	adc	r25, r1
    9782:	df 93       	push	r29
    9784:	cf 93       	push	r28
    9786:	1f 93       	push	r17
    9788:	0f 93       	push	r16
    978a:	ff 92       	push	r15
    978c:	ef 92       	push	r14
    978e:	19 2f       	mov	r17, r25
    9790:	98 7f       	andi	r25, 0xF8	; 248
    9792:	96 95       	lsr	r25
    9794:	e9 2f       	mov	r30, r25
    9796:	96 95       	lsr	r25
    9798:	96 95       	lsr	r25
    979a:	e9 0f       	add	r30, r25
    979c:	ff 27       	eor	r31, r31
    979e:	ea 56       	subi	r30, 0x6A	; 106
    97a0:	fd 4f       	sbci	r31, 0xFD	; 253
    97a2:	99 27       	eor	r25, r25
    97a4:	33 27       	eor	r19, r19
    97a6:	ee 24       	eor	r14, r14
    97a8:	ff 24       	eor	r15, r15
    97aa:	a7 01       	movw	r20, r14
    97ac:	e7 01       	movw	r28, r14
    97ae:	05 90       	lpm	r0, Z+
    97b0:	08 94       	sec
    97b2:	07 94       	ror	r0
    97b4:	28 f4       	brcc	.+10     	; 0x97c0 <__ftoa_engine+0x80>
    97b6:	36 0f       	add	r19, r22
    97b8:	e7 1e       	adc	r14, r23
    97ba:	f8 1e       	adc	r15, r24
    97bc:	49 1f       	adc	r20, r25
    97be:	51 1d       	adc	r21, r1
    97c0:	66 0f       	add	r22, r22
    97c2:	77 1f       	adc	r23, r23
    97c4:	88 1f       	adc	r24, r24
    97c6:	99 1f       	adc	r25, r25
    97c8:	06 94       	lsr	r0
    97ca:	a1 f7       	brne	.-24     	; 0x97b4 <__ftoa_engine+0x74>
    97cc:	05 90       	lpm	r0, Z+
    97ce:	07 94       	ror	r0
    97d0:	28 f4       	brcc	.+10     	; 0x97dc <__ftoa_engine+0x9c>
    97d2:	e7 0e       	add	r14, r23
    97d4:	f8 1e       	adc	r15, r24
    97d6:	49 1f       	adc	r20, r25
    97d8:	56 1f       	adc	r21, r22
    97da:	c1 1d       	adc	r28, r1
    97dc:	77 0f       	add	r23, r23
    97de:	88 1f       	adc	r24, r24
    97e0:	99 1f       	adc	r25, r25
    97e2:	66 1f       	adc	r22, r22
    97e4:	06 94       	lsr	r0
    97e6:	a1 f7       	brne	.-24     	; 0x97d0 <__ftoa_engine+0x90>
    97e8:	05 90       	lpm	r0, Z+
    97ea:	07 94       	ror	r0
    97ec:	28 f4       	brcc	.+10     	; 0x97f8 <__ftoa_engine+0xb8>
    97ee:	f8 0e       	add	r15, r24
    97f0:	49 1f       	adc	r20, r25
    97f2:	56 1f       	adc	r21, r22
    97f4:	c7 1f       	adc	r28, r23
    97f6:	d1 1d       	adc	r29, r1
    97f8:	88 0f       	add	r24, r24
    97fa:	99 1f       	adc	r25, r25
    97fc:	66 1f       	adc	r22, r22
    97fe:	77 1f       	adc	r23, r23
    9800:	06 94       	lsr	r0
    9802:	a1 f7       	brne	.-24     	; 0x97ec <__ftoa_engine+0xac>
    9804:	05 90       	lpm	r0, Z+
    9806:	07 94       	ror	r0
    9808:	20 f4       	brcc	.+8      	; 0x9812 <__ftoa_engine+0xd2>
    980a:	49 0f       	add	r20, r25
    980c:	56 1f       	adc	r21, r22
    980e:	c7 1f       	adc	r28, r23
    9810:	d8 1f       	adc	r29, r24
    9812:	99 0f       	add	r25, r25
    9814:	66 1f       	adc	r22, r22
    9816:	77 1f       	adc	r23, r23
    9818:	88 1f       	adc	r24, r24
    981a:	06 94       	lsr	r0
    981c:	a9 f7       	brne	.-22     	; 0x9808 <__ftoa_engine+0xc8>
    981e:	84 91       	lpm	r24, Z
    9820:	10 95       	com	r17
    9822:	17 70       	andi	r17, 0x07	; 7
    9824:	41 f0       	breq	.+16     	; 0x9836 <__ftoa_engine+0xf6>
    9826:	d6 95       	lsr	r29
    9828:	c7 95       	ror	r28
    982a:	57 95       	ror	r21
    982c:	47 95       	ror	r20
    982e:	f7 94       	ror	r15
    9830:	e7 94       	ror	r14
    9832:	1a 95       	dec	r17
    9834:	c1 f7       	brne	.-16     	; 0x9826 <__ftoa_engine+0xe6>
    9836:	ec e3       	ldi	r30, 0x3C	; 60
    9838:	f2 e0       	ldi	r31, 0x02	; 2
    983a:	68 94       	set
    983c:	15 90       	lpm	r1, Z+
    983e:	15 91       	lpm	r17, Z+
    9840:	35 91       	lpm	r19, Z+
    9842:	65 91       	lpm	r22, Z+
    9844:	95 91       	lpm	r25, Z+
    9846:	05 90       	lpm	r0, Z+
    9848:	7f e2       	ldi	r23, 0x2F	; 47
    984a:	73 95       	inc	r23
    984c:	e1 18       	sub	r14, r1
    984e:	f1 0a       	sbc	r15, r17
    9850:	43 0b       	sbc	r20, r19
    9852:	56 0b       	sbc	r21, r22
    9854:	c9 0b       	sbc	r28, r25
    9856:	d0 09       	sbc	r29, r0
    9858:	c0 f7       	brcc	.-16     	; 0x984a <__ftoa_engine+0x10a>
    985a:	e1 0c       	add	r14, r1
    985c:	f1 1e       	adc	r15, r17
    985e:	43 1f       	adc	r20, r19
    9860:	56 1f       	adc	r21, r22
    9862:	c9 1f       	adc	r28, r25
    9864:	d0 1d       	adc	r29, r0
    9866:	7e f4       	brtc	.+30     	; 0x9886 <__ftoa_engine+0x146>
    9868:	70 33       	cpi	r23, 0x30	; 48
    986a:	11 f4       	brne	.+4      	; 0x9870 <__ftoa_engine+0x130>
    986c:	8a 95       	dec	r24
    986e:	e6 cf       	rjmp	.-52     	; 0x983c <__ftoa_engine+0xfc>
    9870:	e8 94       	clt
    9872:	01 50       	subi	r16, 0x01	; 1
    9874:	30 f0       	brcs	.+12     	; 0x9882 <__ftoa_engine+0x142>
    9876:	08 0f       	add	r16, r24
    9878:	0a f4       	brpl	.+2      	; 0x987c <__ftoa_engine+0x13c>
    987a:	00 27       	eor	r16, r16
    987c:	02 17       	cp	r16, r18
    987e:	08 f4       	brcc	.+2      	; 0x9882 <__ftoa_engine+0x142>
    9880:	20 2f       	mov	r18, r16
    9882:	23 95       	inc	r18
    9884:	02 2f       	mov	r16, r18
    9886:	7a 33       	cpi	r23, 0x3A	; 58
    9888:	28 f0       	brcs	.+10     	; 0x9894 <__ftoa_engine+0x154>
    988a:	79 e3       	ldi	r23, 0x39	; 57
    988c:	7d 93       	st	X+, r23
    988e:	2a 95       	dec	r18
    9890:	e9 f7       	brne	.-6      	; 0x988c <__ftoa_engine+0x14c>
    9892:	10 c0       	rjmp	.+32     	; 0x98b4 <__ftoa_engine+0x174>
    9894:	7d 93       	st	X+, r23
    9896:	2a 95       	dec	r18
    9898:	89 f6       	brne	.-94     	; 0x983c <__ftoa_engine+0xfc>
    989a:	06 94       	lsr	r0
    989c:	97 95       	ror	r25
    989e:	67 95       	ror	r22
    98a0:	37 95       	ror	r19
    98a2:	17 95       	ror	r17
    98a4:	17 94       	ror	r1
    98a6:	e1 18       	sub	r14, r1
    98a8:	f1 0a       	sbc	r15, r17
    98aa:	43 0b       	sbc	r20, r19
    98ac:	56 0b       	sbc	r21, r22
    98ae:	c9 0b       	sbc	r28, r25
    98b0:	d0 09       	sbc	r29, r0
    98b2:	98 f0       	brcs	.+38     	; 0x98da <__ftoa_engine+0x19a>
    98b4:	23 95       	inc	r18
    98b6:	7e 91       	ld	r23, -X
    98b8:	73 95       	inc	r23
    98ba:	7a 33       	cpi	r23, 0x3A	; 58
    98bc:	08 f0       	brcs	.+2      	; 0x98c0 <__ftoa_engine+0x180>
    98be:	70 e3       	ldi	r23, 0x30	; 48
    98c0:	7c 93       	st	X, r23
    98c2:	20 13       	cpse	r18, r16
    98c4:	b8 f7       	brcc	.-18     	; 0x98b4 <__ftoa_engine+0x174>
    98c6:	7e 91       	ld	r23, -X
    98c8:	70 61       	ori	r23, 0x10	; 16
    98ca:	7d 93       	st	X+, r23
    98cc:	30 f0       	brcs	.+12     	; 0x98da <__ftoa_engine+0x19a>
    98ce:	83 95       	inc	r24
    98d0:	71 e3       	ldi	r23, 0x31	; 49
    98d2:	7d 93       	st	X+, r23
    98d4:	70 e3       	ldi	r23, 0x30	; 48
    98d6:	2a 95       	dec	r18
    98d8:	e1 f7       	brne	.-8      	; 0x98d2 <__ftoa_engine+0x192>
    98da:	11 24       	eor	r1, r1
    98dc:	ef 90       	pop	r14
    98de:	ff 90       	pop	r15
    98e0:	0f 91       	pop	r16
    98e2:	1f 91       	pop	r17
    98e4:	cf 91       	pop	r28
    98e6:	df 91       	pop	r29
    98e8:	99 27       	eor	r25, r25
    98ea:	87 fd       	sbrc	r24, 7
    98ec:	90 95       	com	r25
    98ee:	08 95       	ret

000098f0 <strnlen_P>:
    98f0:	fc 01       	movw	r30, r24
    98f2:	05 90       	lpm	r0, Z+
    98f4:	61 50       	subi	r22, 0x01	; 1
    98f6:	70 40       	sbci	r23, 0x00	; 0
    98f8:	01 10       	cpse	r0, r1
    98fa:	d8 f7       	brcc	.-10     	; 0x98f2 <strnlen_P+0x2>
    98fc:	80 95       	com	r24
    98fe:	90 95       	com	r25
    9900:	8e 0f       	add	r24, r30
    9902:	9f 1f       	adc	r25, r31
    9904:	08 95       	ret

00009906 <strtok>:
    9906:	46 e2       	ldi	r20, 0x26	; 38
    9908:	58 e2       	ldi	r21, 0x28	; 40
    990a:	0c 94 c3 4c 	jmp	0x9986	; 0x9986 <strtok_r>

0000990e <memcpy>:
    990e:	fb 01       	movw	r30, r22
    9910:	dc 01       	movw	r26, r24
    9912:	02 c0       	rjmp	.+4      	; 0x9918 <memcpy+0xa>
    9914:	01 90       	ld	r0, Z+
    9916:	0d 92       	st	X+, r0
    9918:	41 50       	subi	r20, 0x01	; 1
    991a:	50 40       	sbci	r21, 0x00	; 0
    991c:	d8 f7       	brcc	.-10     	; 0x9914 <memcpy+0x6>
    991e:	08 95       	ret

00009920 <memset>:
    9920:	dc 01       	movw	r26, r24
    9922:	01 c0       	rjmp	.+2      	; 0x9926 <memset+0x6>
    9924:	6d 93       	st	X+, r22
    9926:	41 50       	subi	r20, 0x01	; 1
    9928:	50 40       	sbci	r21, 0x00	; 0
    992a:	e0 f7       	brcc	.-8      	; 0x9924 <memset+0x4>
    992c:	08 95       	ret

0000992e <strcpy>:
    992e:	fb 01       	movw	r30, r22
    9930:	dc 01       	movw	r26, r24
    9932:	01 90       	ld	r0, Z+
    9934:	0d 92       	st	X+, r0
    9936:	00 20       	and	r0, r0
    9938:	e1 f7       	brne	.-8      	; 0x9932 <strcpy+0x4>
    993a:	08 95       	ret

0000993c <strnlen>:
    993c:	fc 01       	movw	r30, r24
    993e:	61 50       	subi	r22, 0x01	; 1
    9940:	70 40       	sbci	r23, 0x00	; 0
    9942:	01 90       	ld	r0, Z+
    9944:	01 10       	cpse	r0, r1
    9946:	d8 f7       	brcc	.-10     	; 0x993e <strnlen+0x2>
    9948:	80 95       	com	r24
    994a:	90 95       	com	r25
    994c:	8e 0f       	add	r24, r30
    994e:	9f 1f       	adc	r25, r31
    9950:	08 95       	ret

00009952 <strstr>:
    9952:	fb 01       	movw	r30, r22
    9954:	51 91       	ld	r21, Z+
    9956:	55 23       	and	r21, r21
    9958:	a9 f0       	breq	.+42     	; 0x9984 <strstr+0x32>
    995a:	bf 01       	movw	r22, r30
    995c:	dc 01       	movw	r26, r24
    995e:	4d 91       	ld	r20, X+
    9960:	45 17       	cp	r20, r21
    9962:	41 11       	cpse	r20, r1
    9964:	e1 f7       	brne	.-8      	; 0x995e <strstr+0xc>
    9966:	59 f4       	brne	.+22     	; 0x997e <strstr+0x2c>
    9968:	cd 01       	movw	r24, r26
    996a:	01 90       	ld	r0, Z+
    996c:	00 20       	and	r0, r0
    996e:	49 f0       	breq	.+18     	; 0x9982 <strstr+0x30>
    9970:	4d 91       	ld	r20, X+
    9972:	40 15       	cp	r20, r0
    9974:	41 11       	cpse	r20, r1
    9976:	c9 f3       	breq	.-14     	; 0x996a <strstr+0x18>
    9978:	fb 01       	movw	r30, r22
    997a:	41 11       	cpse	r20, r1
    997c:	ef cf       	rjmp	.-34     	; 0x995c <strstr+0xa>
    997e:	81 e0       	ldi	r24, 0x01	; 1
    9980:	90 e0       	ldi	r25, 0x00	; 0
    9982:	01 97       	sbiw	r24, 0x01	; 1
    9984:	08 95       	ret

00009986 <strtok_r>:
    9986:	fa 01       	movw	r30, r20
    9988:	a1 91       	ld	r26, Z+
    998a:	b0 81       	ld	r27, Z
    998c:	00 97       	sbiw	r24, 0x00	; 0
    998e:	19 f4       	brne	.+6      	; 0x9996 <strtok_r+0x10>
    9990:	10 97       	sbiw	r26, 0x00	; 0
    9992:	e1 f0       	breq	.+56     	; 0x99cc <strtok_r+0x46>
    9994:	cd 01       	movw	r24, r26
    9996:	dc 01       	movw	r26, r24
    9998:	cd 01       	movw	r24, r26
    999a:	0d 90       	ld	r0, X+
    999c:	00 20       	and	r0, r0
    999e:	11 f4       	brne	.+4      	; 0x99a4 <strtok_r+0x1e>
    99a0:	c0 01       	movw	r24, r0
    99a2:	13 c0       	rjmp	.+38     	; 0x99ca <strtok_r+0x44>
    99a4:	fb 01       	movw	r30, r22
    99a6:	21 91       	ld	r18, Z+
    99a8:	22 23       	and	r18, r18
    99aa:	19 f0       	breq	.+6      	; 0x99b2 <strtok_r+0x2c>
    99ac:	20 15       	cp	r18, r0
    99ae:	d9 f7       	brne	.-10     	; 0x99a6 <strtok_r+0x20>
    99b0:	f3 cf       	rjmp	.-26     	; 0x9998 <strtok_r+0x12>
    99b2:	fb 01       	movw	r30, r22
    99b4:	21 91       	ld	r18, Z+
    99b6:	20 15       	cp	r18, r0
    99b8:	19 f4       	brne	.+6      	; 0x99c0 <strtok_r+0x3a>
    99ba:	1e 92       	st	-X, r1
    99bc:	11 96       	adiw	r26, 0x01	; 1
    99be:	06 c0       	rjmp	.+12     	; 0x99cc <strtok_r+0x46>
    99c0:	22 23       	and	r18, r18
    99c2:	c1 f7       	brne	.-16     	; 0x99b4 <strtok_r+0x2e>
    99c4:	0d 90       	ld	r0, X+
    99c6:	00 20       	and	r0, r0
    99c8:	a1 f7       	brne	.-24     	; 0x99b2 <strtok_r+0x2c>
    99ca:	d0 01       	movw	r26, r0
    99cc:	fa 01       	movw	r30, r20
    99ce:	a1 93       	st	Z+, r26
    99d0:	b0 83       	st	Z, r27
    99d2:	08 95       	ret

000099d4 <fgets>:
    99d4:	cf 92       	push	r12
    99d6:	df 92       	push	r13
    99d8:	ef 92       	push	r14
    99da:	ff 92       	push	r15
    99dc:	0f 93       	push	r16
    99de:	1f 93       	push	r17
    99e0:	cf 93       	push	r28
    99e2:	df 93       	push	r29
    99e4:	fa 01       	movw	r30, r20
    99e6:	23 81       	ldd	r18, Z+3	; 0x03
    99e8:	20 fd       	sbrc	r18, 0
    99ea:	03 c0       	rjmp	.+6      	; 0x99f2 <fgets+0x1e>
    99ec:	80 e0       	ldi	r24, 0x00	; 0
    99ee:	90 e0       	ldi	r25, 0x00	; 0
    99f0:	1a c0       	rjmp	.+52     	; 0x9a26 <fgets+0x52>
    99f2:	16 16       	cp	r1, r22
    99f4:	17 06       	cpc	r1, r23
    99f6:	d4 f7       	brge	.-12     	; 0x99ec <fgets+0x18>
    99f8:	7a 01       	movw	r14, r20
    99fa:	8c 01       	movw	r16, r24
    99fc:	eb 01       	movw	r28, r22
    99fe:	6c 01       	movw	r12, r24
    9a00:	c1 30       	cpi	r28, 0x01	; 1
    9a02:	d1 05       	cpc	r29, r1
    9a04:	69 f0       	breq	.+26     	; 0x9a20 <fgets+0x4c>
    9a06:	c7 01       	movw	r24, r14
    9a08:	0e 94 c8 4f 	call	0x9f90	; 0x9f90 <fgetc>
    9a0c:	8f 3f       	cpi	r24, 0xFF	; 255
    9a0e:	ff ef       	ldi	r31, 0xFF	; 255
    9a10:	9f 07       	cpc	r25, r31
    9a12:	61 f3       	breq	.-40     	; 0x99ec <fgets+0x18>
    9a14:	f6 01       	movw	r30, r12
    9a16:	81 93       	st	Z+, r24
    9a18:	6f 01       	movw	r12, r30
    9a1a:	21 97       	sbiw	r28, 0x01	; 1
    9a1c:	0a 97       	sbiw	r24, 0x0a	; 10
    9a1e:	81 f7       	brne	.-32     	; 0x9a00 <fgets+0x2c>
    9a20:	f6 01       	movw	r30, r12
    9a22:	10 82       	st	Z, r1
    9a24:	c8 01       	movw	r24, r16
    9a26:	df 91       	pop	r29
    9a28:	cf 91       	pop	r28
    9a2a:	1f 91       	pop	r17
    9a2c:	0f 91       	pop	r16
    9a2e:	ff 90       	pop	r15
    9a30:	ef 90       	pop	r14
    9a32:	df 90       	pop	r13
    9a34:	cf 90       	pop	r12
    9a36:	08 95       	ret

00009a38 <fputc>:
    9a38:	0f 93       	push	r16
    9a3a:	1f 93       	push	r17
    9a3c:	cf 93       	push	r28
    9a3e:	df 93       	push	r29
    9a40:	fb 01       	movw	r30, r22
    9a42:	23 81       	ldd	r18, Z+3	; 0x03
    9a44:	21 fd       	sbrc	r18, 1
    9a46:	03 c0       	rjmp	.+6      	; 0x9a4e <fputc+0x16>
    9a48:	8f ef       	ldi	r24, 0xFF	; 255
    9a4a:	9f ef       	ldi	r25, 0xFF	; 255
    9a4c:	2c c0       	rjmp	.+88     	; 0x9aa6 <fputc+0x6e>
    9a4e:	22 ff       	sbrs	r18, 2
    9a50:	16 c0       	rjmp	.+44     	; 0x9a7e <fputc+0x46>
    9a52:	46 81       	ldd	r20, Z+6	; 0x06
    9a54:	57 81       	ldd	r21, Z+7	; 0x07
    9a56:	24 81       	ldd	r18, Z+4	; 0x04
    9a58:	35 81       	ldd	r19, Z+5	; 0x05
    9a5a:	42 17       	cp	r20, r18
    9a5c:	53 07       	cpc	r21, r19
    9a5e:	44 f4       	brge	.+16     	; 0x9a70 <fputc+0x38>
    9a60:	a0 81       	ld	r26, Z
    9a62:	b1 81       	ldd	r27, Z+1	; 0x01
    9a64:	9d 01       	movw	r18, r26
    9a66:	2f 5f       	subi	r18, 0xFF	; 255
    9a68:	3f 4f       	sbci	r19, 0xFF	; 255
    9a6a:	20 83       	st	Z, r18
    9a6c:	31 83       	std	Z+1, r19	; 0x01
    9a6e:	8c 93       	st	X, r24
    9a70:	26 81       	ldd	r18, Z+6	; 0x06
    9a72:	37 81       	ldd	r19, Z+7	; 0x07
    9a74:	2f 5f       	subi	r18, 0xFF	; 255
    9a76:	3f 4f       	sbci	r19, 0xFF	; 255
    9a78:	26 83       	std	Z+6, r18	; 0x06
    9a7a:	37 83       	std	Z+7, r19	; 0x07
    9a7c:	14 c0       	rjmp	.+40     	; 0x9aa6 <fputc+0x6e>
    9a7e:	8b 01       	movw	r16, r22
    9a80:	ec 01       	movw	r28, r24
    9a82:	fb 01       	movw	r30, r22
    9a84:	00 84       	ldd	r0, Z+8	; 0x08
    9a86:	f1 85       	ldd	r31, Z+9	; 0x09
    9a88:	e0 2d       	mov	r30, r0
    9a8a:	19 95       	eicall
    9a8c:	89 2b       	or	r24, r25
    9a8e:	e1 f6       	brne	.-72     	; 0x9a48 <fputc+0x10>
    9a90:	d8 01       	movw	r26, r16
    9a92:	16 96       	adiw	r26, 0x06	; 6
    9a94:	8d 91       	ld	r24, X+
    9a96:	9c 91       	ld	r25, X
    9a98:	17 97       	sbiw	r26, 0x07	; 7
    9a9a:	01 96       	adiw	r24, 0x01	; 1
    9a9c:	16 96       	adiw	r26, 0x06	; 6
    9a9e:	8d 93       	st	X+, r24
    9aa0:	9c 93       	st	X, r25
    9aa2:	17 97       	sbiw	r26, 0x07	; 7
    9aa4:	ce 01       	movw	r24, r28
    9aa6:	df 91       	pop	r29
    9aa8:	cf 91       	pop	r28
    9aaa:	1f 91       	pop	r17
    9aac:	0f 91       	pop	r16
    9aae:	08 95       	ret

00009ab0 <printf>:
    9ab0:	cf 93       	push	r28
    9ab2:	df 93       	push	r29
    9ab4:	cd b7       	in	r28, 0x3d	; 61
    9ab6:	de b7       	in	r29, 0x3e	; 62
    9ab8:	ae 01       	movw	r20, r28
    9aba:	4a 5f       	subi	r20, 0xFA	; 250
    9abc:	5f 4f       	sbci	r21, 0xFF	; 255
    9abe:	fa 01       	movw	r30, r20
    9ac0:	61 91       	ld	r22, Z+
    9ac2:	71 91       	ld	r23, Z+
    9ac4:	af 01       	movw	r20, r30
    9ac6:	80 91 95 2d 	lds	r24, 0x2D95	; 0x802d95 <__iob+0x2>
    9aca:	90 91 96 2d 	lds	r25, 0x2D96	; 0x802d96 <__iob+0x3>
    9ace:	0e 94 61 44 	call	0x88c2	; 0x88c2 <vfprintf>
    9ad2:	df 91       	pop	r29
    9ad4:	cf 91       	pop	r28
    9ad6:	08 95       	ret

00009ad8 <printf_P>:
    9ad8:	0f 93       	push	r16
    9ada:	1f 93       	push	r17
    9adc:	cf 93       	push	r28
    9ade:	df 93       	push	r29
    9ae0:	cd b7       	in	r28, 0x3d	; 61
    9ae2:	de b7       	in	r29, 0x3e	; 62
    9ae4:	ae 01       	movw	r20, r28
    9ae6:	48 5f       	subi	r20, 0xF8	; 248
    9ae8:	5f 4f       	sbci	r21, 0xFF	; 255
    9aea:	da 01       	movw	r26, r20
    9aec:	6d 91       	ld	r22, X+
    9aee:	7d 91       	ld	r23, X+
    9af0:	ad 01       	movw	r20, r26
    9af2:	03 e9       	ldi	r16, 0x93	; 147
    9af4:	1d e2       	ldi	r17, 0x2D	; 45
    9af6:	f8 01       	movw	r30, r16
    9af8:	82 81       	ldd	r24, Z+2	; 0x02
    9afa:	93 81       	ldd	r25, Z+3	; 0x03
    9afc:	dc 01       	movw	r26, r24
    9afe:	13 96       	adiw	r26, 0x03	; 3
    9b00:	2c 91       	ld	r18, X
    9b02:	13 97       	sbiw	r26, 0x03	; 3
    9b04:	28 60       	ori	r18, 0x08	; 8
    9b06:	13 96       	adiw	r26, 0x03	; 3
    9b08:	2c 93       	st	X, r18
    9b0a:	0e 94 61 44 	call	0x88c2	; 0x88c2 <vfprintf>
    9b0e:	d8 01       	movw	r26, r16
    9b10:	12 96       	adiw	r26, 0x02	; 2
    9b12:	ed 91       	ld	r30, X+
    9b14:	fc 91       	ld	r31, X
    9b16:	13 97       	sbiw	r26, 0x03	; 3
    9b18:	23 81       	ldd	r18, Z+3	; 0x03
    9b1a:	27 7f       	andi	r18, 0xF7	; 247
    9b1c:	23 83       	std	Z+3, r18	; 0x03
    9b1e:	df 91       	pop	r29
    9b20:	cf 91       	pop	r28
    9b22:	1f 91       	pop	r17
    9b24:	0f 91       	pop	r16
    9b26:	08 95       	ret

00009b28 <puts>:
    9b28:	0f 93       	push	r16
    9b2a:	1f 93       	push	r17
    9b2c:	cf 93       	push	r28
    9b2e:	df 93       	push	r29
    9b30:	e0 91 95 2d 	lds	r30, 0x2D95	; 0x802d95 <__iob+0x2>
    9b34:	f0 91 96 2d 	lds	r31, 0x2D96	; 0x802d96 <__iob+0x3>
    9b38:	23 81       	ldd	r18, Z+3	; 0x03
    9b3a:	21 ff       	sbrs	r18, 1
    9b3c:	1b c0       	rjmp	.+54     	; 0x9b74 <puts+0x4c>
    9b3e:	8c 01       	movw	r16, r24
    9b40:	d0 e0       	ldi	r29, 0x00	; 0
    9b42:	c0 e0       	ldi	r28, 0x00	; 0
    9b44:	f8 01       	movw	r30, r16
    9b46:	81 91       	ld	r24, Z+
    9b48:	8f 01       	movw	r16, r30
    9b4a:	60 91 95 2d 	lds	r22, 0x2D95	; 0x802d95 <__iob+0x2>
    9b4e:	70 91 96 2d 	lds	r23, 0x2D96	; 0x802d96 <__iob+0x3>
    9b52:	db 01       	movw	r26, r22
    9b54:	18 96       	adiw	r26, 0x08	; 8
    9b56:	ed 91       	ld	r30, X+
    9b58:	fc 91       	ld	r31, X
    9b5a:	19 97       	sbiw	r26, 0x09	; 9
    9b5c:	88 23       	and	r24, r24
    9b5e:	31 f0       	breq	.+12     	; 0x9b6c <puts+0x44>
    9b60:	19 95       	eicall
    9b62:	89 2b       	or	r24, r25
    9b64:	79 f3       	breq	.-34     	; 0x9b44 <puts+0x1c>
    9b66:	df ef       	ldi	r29, 0xFF	; 255
    9b68:	cf ef       	ldi	r28, 0xFF	; 255
    9b6a:	ec cf       	rjmp	.-40     	; 0x9b44 <puts+0x1c>
    9b6c:	8a e0       	ldi	r24, 0x0A	; 10
    9b6e:	19 95       	eicall
    9b70:	89 2b       	or	r24, r25
    9b72:	19 f0       	breq	.+6      	; 0x9b7a <puts+0x52>
    9b74:	8f ef       	ldi	r24, 0xFF	; 255
    9b76:	9f ef       	ldi	r25, 0xFF	; 255
    9b78:	02 c0       	rjmp	.+4      	; 0x9b7e <puts+0x56>
    9b7a:	8d 2f       	mov	r24, r29
    9b7c:	9c 2f       	mov	r25, r28
    9b7e:	df 91       	pop	r29
    9b80:	cf 91       	pop	r28
    9b82:	1f 91       	pop	r17
    9b84:	0f 91       	pop	r16
    9b86:	08 95       	ret

00009b88 <sprintf>:
    9b88:	0f 93       	push	r16
    9b8a:	1f 93       	push	r17
    9b8c:	cf 93       	push	r28
    9b8e:	df 93       	push	r29
    9b90:	cd b7       	in	r28, 0x3d	; 61
    9b92:	de b7       	in	r29, 0x3e	; 62
    9b94:	2e 97       	sbiw	r28, 0x0e	; 14
    9b96:	cd bf       	out	0x3d, r28	; 61
    9b98:	de bf       	out	0x3e, r29	; 62
    9b9a:	0e 89       	ldd	r16, Y+22	; 0x16
    9b9c:	1f 89       	ldd	r17, Y+23	; 0x17
    9b9e:	86 e0       	ldi	r24, 0x06	; 6
    9ba0:	8c 83       	std	Y+4, r24	; 0x04
    9ba2:	09 83       	std	Y+1, r16	; 0x01
    9ba4:	1a 83       	std	Y+2, r17	; 0x02
    9ba6:	8f ef       	ldi	r24, 0xFF	; 255
    9ba8:	9f e7       	ldi	r25, 0x7F	; 127
    9baa:	8d 83       	std	Y+5, r24	; 0x05
    9bac:	9e 83       	std	Y+6, r25	; 0x06
    9bae:	ae 01       	movw	r20, r28
    9bb0:	46 5e       	subi	r20, 0xE6	; 230
    9bb2:	5f 4f       	sbci	r21, 0xFF	; 255
    9bb4:	68 8d       	ldd	r22, Y+24	; 0x18
    9bb6:	79 8d       	ldd	r23, Y+25	; 0x19
    9bb8:	ce 01       	movw	r24, r28
    9bba:	01 96       	adiw	r24, 0x01	; 1
    9bbc:	0e 94 61 44 	call	0x88c2	; 0x88c2 <vfprintf>
    9bc0:	ef 81       	ldd	r30, Y+7	; 0x07
    9bc2:	f8 85       	ldd	r31, Y+8	; 0x08
    9bc4:	e0 0f       	add	r30, r16
    9bc6:	f1 1f       	adc	r31, r17
    9bc8:	10 82       	st	Z, r1
    9bca:	2e 96       	adiw	r28, 0x0e	; 14
    9bcc:	cd bf       	out	0x3d, r28	; 61
    9bce:	de bf       	out	0x3e, r29	; 62
    9bd0:	df 91       	pop	r29
    9bd2:	cf 91       	pop	r28
    9bd4:	1f 91       	pop	r17
    9bd6:	0f 91       	pop	r16
    9bd8:	08 95       	ret

00009bda <__ultoa_invert>:
    9bda:	fa 01       	movw	r30, r20
    9bdc:	aa 27       	eor	r26, r26
    9bde:	28 30       	cpi	r18, 0x08	; 8
    9be0:	51 f1       	breq	.+84     	; 0x9c36 <__ultoa_invert+0x5c>
    9be2:	20 31       	cpi	r18, 0x10	; 16
    9be4:	81 f1       	breq	.+96     	; 0x9c46 <__ultoa_invert+0x6c>
    9be6:	e8 94       	clt
    9be8:	6f 93       	push	r22
    9bea:	6e 7f       	andi	r22, 0xFE	; 254
    9bec:	6e 5f       	subi	r22, 0xFE	; 254
    9bee:	7f 4f       	sbci	r23, 0xFF	; 255
    9bf0:	8f 4f       	sbci	r24, 0xFF	; 255
    9bf2:	9f 4f       	sbci	r25, 0xFF	; 255
    9bf4:	af 4f       	sbci	r26, 0xFF	; 255
    9bf6:	b1 e0       	ldi	r27, 0x01	; 1
    9bf8:	3e d0       	rcall	.+124    	; 0x9c76 <__ultoa_invert+0x9c>
    9bfa:	b4 e0       	ldi	r27, 0x04	; 4
    9bfc:	3c d0       	rcall	.+120    	; 0x9c76 <__ultoa_invert+0x9c>
    9bfe:	67 0f       	add	r22, r23
    9c00:	78 1f       	adc	r23, r24
    9c02:	89 1f       	adc	r24, r25
    9c04:	9a 1f       	adc	r25, r26
    9c06:	a1 1d       	adc	r26, r1
    9c08:	68 0f       	add	r22, r24
    9c0a:	79 1f       	adc	r23, r25
    9c0c:	8a 1f       	adc	r24, r26
    9c0e:	91 1d       	adc	r25, r1
    9c10:	a1 1d       	adc	r26, r1
    9c12:	6a 0f       	add	r22, r26
    9c14:	71 1d       	adc	r23, r1
    9c16:	81 1d       	adc	r24, r1
    9c18:	91 1d       	adc	r25, r1
    9c1a:	a1 1d       	adc	r26, r1
    9c1c:	20 d0       	rcall	.+64     	; 0x9c5e <__ultoa_invert+0x84>
    9c1e:	09 f4       	brne	.+2      	; 0x9c22 <__ultoa_invert+0x48>
    9c20:	68 94       	set
    9c22:	3f 91       	pop	r19
    9c24:	2a e0       	ldi	r18, 0x0A	; 10
    9c26:	26 9f       	mul	r18, r22
    9c28:	11 24       	eor	r1, r1
    9c2a:	30 19       	sub	r19, r0
    9c2c:	30 5d       	subi	r19, 0xD0	; 208
    9c2e:	31 93       	st	Z+, r19
    9c30:	de f6       	brtc	.-74     	; 0x9be8 <__ultoa_invert+0xe>
    9c32:	cf 01       	movw	r24, r30
    9c34:	08 95       	ret
    9c36:	46 2f       	mov	r20, r22
    9c38:	47 70       	andi	r20, 0x07	; 7
    9c3a:	40 5d       	subi	r20, 0xD0	; 208
    9c3c:	41 93       	st	Z+, r20
    9c3e:	b3 e0       	ldi	r27, 0x03	; 3
    9c40:	0f d0       	rcall	.+30     	; 0x9c60 <__ultoa_invert+0x86>
    9c42:	c9 f7       	brne	.-14     	; 0x9c36 <__ultoa_invert+0x5c>
    9c44:	f6 cf       	rjmp	.-20     	; 0x9c32 <__ultoa_invert+0x58>
    9c46:	46 2f       	mov	r20, r22
    9c48:	4f 70       	andi	r20, 0x0F	; 15
    9c4a:	40 5d       	subi	r20, 0xD0	; 208
    9c4c:	4a 33       	cpi	r20, 0x3A	; 58
    9c4e:	18 f0       	brcs	.+6      	; 0x9c56 <__ultoa_invert+0x7c>
    9c50:	49 5d       	subi	r20, 0xD9	; 217
    9c52:	31 fd       	sbrc	r19, 1
    9c54:	40 52       	subi	r20, 0x20	; 32
    9c56:	41 93       	st	Z+, r20
    9c58:	02 d0       	rcall	.+4      	; 0x9c5e <__ultoa_invert+0x84>
    9c5a:	a9 f7       	brne	.-22     	; 0x9c46 <__ultoa_invert+0x6c>
    9c5c:	ea cf       	rjmp	.-44     	; 0x9c32 <__ultoa_invert+0x58>
    9c5e:	b4 e0       	ldi	r27, 0x04	; 4
    9c60:	a6 95       	lsr	r26
    9c62:	97 95       	ror	r25
    9c64:	87 95       	ror	r24
    9c66:	77 95       	ror	r23
    9c68:	67 95       	ror	r22
    9c6a:	ba 95       	dec	r27
    9c6c:	c9 f7       	brne	.-14     	; 0x9c60 <__ultoa_invert+0x86>
    9c6e:	00 97       	sbiw	r24, 0x00	; 0
    9c70:	61 05       	cpc	r22, r1
    9c72:	71 05       	cpc	r23, r1
    9c74:	08 95       	ret
    9c76:	9b 01       	movw	r18, r22
    9c78:	ac 01       	movw	r20, r24
    9c7a:	0a 2e       	mov	r0, r26
    9c7c:	06 94       	lsr	r0
    9c7e:	57 95       	ror	r21
    9c80:	47 95       	ror	r20
    9c82:	37 95       	ror	r19
    9c84:	27 95       	ror	r18
    9c86:	ba 95       	dec	r27
    9c88:	c9 f7       	brne	.-14     	; 0x9c7c <__ultoa_invert+0xa2>
    9c8a:	62 0f       	add	r22, r18
    9c8c:	73 1f       	adc	r23, r19
    9c8e:	84 1f       	adc	r24, r20
    9c90:	95 1f       	adc	r25, r21
    9c92:	a0 1d       	adc	r26, r0
    9c94:	08 95       	ret

00009c96 <strtod>:
    9c96:	8f 92       	push	r8
    9c98:	9f 92       	push	r9
    9c9a:	af 92       	push	r10
    9c9c:	bf 92       	push	r11
    9c9e:	cf 92       	push	r12
    9ca0:	df 92       	push	r13
    9ca2:	ef 92       	push	r14
    9ca4:	ff 92       	push	r15
    9ca6:	0f 93       	push	r16
    9ca8:	1f 93       	push	r17
    9caa:	cf 93       	push	r28
    9cac:	df 93       	push	r29
    9cae:	ec 01       	movw	r28, r24
    9cb0:	6b 01       	movw	r12, r22
    9cb2:	61 15       	cp	r22, r1
    9cb4:	71 05       	cpc	r23, r1
    9cb6:	19 f0       	breq	.+6      	; 0x9cbe <strtod+0x28>
    9cb8:	fb 01       	movw	r30, r22
    9cba:	80 83       	st	Z, r24
    9cbc:	91 83       	std	Z+1, r25	; 0x01
    9cbe:	7e 01       	movw	r14, r28
    9cc0:	ff ef       	ldi	r31, 0xFF	; 255
    9cc2:	ef 1a       	sub	r14, r31
    9cc4:	ff 0a       	sbc	r15, r31
    9cc6:	08 81       	ld	r16, Y
    9cc8:	80 2f       	mov	r24, r16
    9cca:	90 e0       	ldi	r25, 0x00	; 0
    9ccc:	0e 94 a7 4f 	call	0x9f4e	; 0x9f4e <isspace>
    9cd0:	89 2b       	or	r24, r25
    9cd2:	11 f0       	breq	.+4      	; 0x9cd8 <strtod+0x42>
    9cd4:	e7 01       	movw	r28, r14
    9cd6:	f3 cf       	rjmp	.-26     	; 0x9cbe <strtod+0x28>
    9cd8:	0d 32       	cpi	r16, 0x2D	; 45
    9cda:	39 f4       	brne	.+14     	; 0x9cea <strtod+0x54>
    9cdc:	7e 01       	movw	r14, r28
    9cde:	82 e0       	ldi	r24, 0x02	; 2
    9ce0:	e8 0e       	add	r14, r24
    9ce2:	f1 1c       	adc	r15, r1
    9ce4:	09 81       	ldd	r16, Y+1	; 0x01
    9ce6:	11 e0       	ldi	r17, 0x01	; 1
    9ce8:	08 c0       	rjmp	.+16     	; 0x9cfa <strtod+0x64>
    9cea:	0b 32       	cpi	r16, 0x2B	; 43
    9cec:	29 f4       	brne	.+10     	; 0x9cf8 <strtod+0x62>
    9cee:	7e 01       	movw	r14, r28
    9cf0:	92 e0       	ldi	r25, 0x02	; 2
    9cf2:	e9 0e       	add	r14, r25
    9cf4:	f1 1c       	adc	r15, r1
    9cf6:	09 81       	ldd	r16, Y+1	; 0x01
    9cf8:	10 e0       	ldi	r17, 0x00	; 0
    9cfa:	e7 01       	movw	r28, r14
    9cfc:	21 97       	sbiw	r28, 0x01	; 1
    9cfe:	43 e0       	ldi	r20, 0x03	; 3
    9d00:	50 e0       	ldi	r21, 0x00	; 0
    9d02:	6e e3       	ldi	r22, 0x3E	; 62
    9d04:	73 e0       	ldi	r23, 0x03	; 3
    9d06:	ce 01       	movw	r24, r28
    9d08:	0e 94 b0 4f 	call	0x9f60	; 0x9f60 <strncasecmp_P>
    9d0c:	89 2b       	or	r24, r25
    9d0e:	c1 f4       	brne	.+48     	; 0x9d40 <strtod+0xaa>
    9d10:	23 96       	adiw	r28, 0x03	; 3
    9d12:	45 e0       	ldi	r20, 0x05	; 5
    9d14:	50 e0       	ldi	r21, 0x00	; 0
    9d16:	69 e3       	ldi	r22, 0x39	; 57
    9d18:	73 e0       	ldi	r23, 0x03	; 3
    9d1a:	ce 01       	movw	r24, r28
    9d1c:	0e 94 b0 4f 	call	0x9f60	; 0x9f60 <strncasecmp_P>
    9d20:	89 2b       	or	r24, r25
    9d22:	09 f4       	brne	.+2      	; 0x9d26 <strtod+0x90>
    9d24:	25 96       	adiw	r28, 0x05	; 5
    9d26:	c1 14       	cp	r12, r1
    9d28:	d1 04       	cpc	r13, r1
    9d2a:	19 f0       	breq	.+6      	; 0x9d32 <strtod+0x9c>
    9d2c:	f6 01       	movw	r30, r12
    9d2e:	c0 83       	st	Z, r28
    9d30:	d1 83       	std	Z+1, r29	; 0x01
    9d32:	11 11       	cpse	r17, r1
    9d34:	f6 c0       	rjmp	.+492    	; 0x9f22 <strtod+0x28c>
    9d36:	60 e0       	ldi	r22, 0x00	; 0
    9d38:	70 e0       	ldi	r23, 0x00	; 0
    9d3a:	80 e8       	ldi	r24, 0x80	; 128
    9d3c:	9f e7       	ldi	r25, 0x7F	; 127
    9d3e:	fa c0       	rjmp	.+500    	; 0x9f34 <strtod+0x29e>
    9d40:	43 e0       	ldi	r20, 0x03	; 3
    9d42:	50 e0       	ldi	r21, 0x00	; 0
    9d44:	66 e3       	ldi	r22, 0x36	; 54
    9d46:	73 e0       	ldi	r23, 0x03	; 3
    9d48:	ce 01       	movw	r24, r28
    9d4a:	0e 94 b0 4f 	call	0x9f60	; 0x9f60 <strncasecmp_P>
    9d4e:	89 2b       	or	r24, r25
    9d50:	59 f4       	brne	.+22     	; 0x9d68 <strtod+0xd2>
    9d52:	c1 14       	cp	r12, r1
    9d54:	d1 04       	cpc	r13, r1
    9d56:	09 f4       	brne	.+2      	; 0x9d5a <strtod+0xc4>
    9d58:	e9 c0       	rjmp	.+466    	; 0x9f2c <strtod+0x296>
    9d5a:	f2 e0       	ldi	r31, 0x02	; 2
    9d5c:	ef 0e       	add	r14, r31
    9d5e:	f1 1c       	adc	r15, r1
    9d60:	f6 01       	movw	r30, r12
    9d62:	e0 82       	st	Z, r14
    9d64:	f1 82       	std	Z+1, r15	; 0x01
    9d66:	e2 c0       	rjmp	.+452    	; 0x9f2c <strtod+0x296>
    9d68:	20 e0       	ldi	r18, 0x00	; 0
    9d6a:	30 e0       	ldi	r19, 0x00	; 0
    9d6c:	a9 01       	movw	r20, r18
    9d6e:	c0 e0       	ldi	r28, 0x00	; 0
    9d70:	d0 e0       	ldi	r29, 0x00	; 0
    9d72:	f7 01       	movw	r30, r14
    9d74:	60 ed       	ldi	r22, 0xD0	; 208
    9d76:	a6 2e       	mov	r10, r22
    9d78:	a0 0e       	add	r10, r16
    9d7a:	89 e0       	ldi	r24, 0x09	; 9
    9d7c:	8a 15       	cp	r24, r10
    9d7e:	30 f1       	brcs	.+76     	; 0x9dcc <strtod+0x136>
    9d80:	91 2f       	mov	r25, r17
    9d82:	92 60       	ori	r25, 0x02	; 2
    9d84:	b9 2e       	mov	r11, r25
    9d86:	81 2f       	mov	r24, r17
    9d88:	88 70       	andi	r24, 0x08	; 8
    9d8a:	12 ff       	sbrs	r17, 2
    9d8c:	04 c0       	rjmp	.+8      	; 0x9d96 <strtod+0x100>
    9d8e:	81 11       	cpse	r24, r1
    9d90:	24 c0       	rjmp	.+72     	; 0x9dda <strtod+0x144>
    9d92:	21 96       	adiw	r28, 0x01	; 1
    9d94:	22 c0       	rjmp	.+68     	; 0x9dda <strtod+0x144>
    9d96:	81 11       	cpse	r24, r1
    9d98:	21 97       	sbiw	r28, 0x01	; 1
    9d9a:	a5 e0       	ldi	r26, 0x05	; 5
    9d9c:	b0 e0       	ldi	r27, 0x00	; 0
    9d9e:	0e 94 5a 48 	call	0x90b4	; 0x90b4 <__muluhisi3>
    9da2:	dc 01       	movw	r26, r24
    9da4:	cb 01       	movw	r24, r22
    9da6:	88 0f       	add	r24, r24
    9da8:	99 1f       	adc	r25, r25
    9daa:	aa 1f       	adc	r26, r26
    9dac:	bb 1f       	adc	r27, r27
    9dae:	9c 01       	movw	r18, r24
    9db0:	ad 01       	movw	r20, r26
    9db2:	2a 0d       	add	r18, r10
    9db4:	31 1d       	adc	r19, r1
    9db6:	41 1d       	adc	r20, r1
    9db8:	51 1d       	adc	r21, r1
    9dba:	28 39       	cpi	r18, 0x98	; 152
    9dbc:	89 e9       	ldi	r24, 0x99	; 153
    9dbe:	38 07       	cpc	r19, r24
    9dc0:	48 07       	cpc	r20, r24
    9dc2:	89 e1       	ldi	r24, 0x19	; 25
    9dc4:	58 07       	cpc	r21, r24
    9dc6:	48 f0       	brcs	.+18     	; 0x9dda <strtod+0x144>
    9dc8:	16 60       	ori	r17, 0x06	; 6
    9dca:	06 c0       	rjmp	.+12     	; 0x9dd8 <strtod+0x142>
    9dcc:	9e ef       	ldi	r25, 0xFE	; 254
    9dce:	a9 12       	cpse	r10, r25
    9dd0:	0a c0       	rjmp	.+20     	; 0x9de6 <strtod+0x150>
    9dd2:	13 fd       	sbrc	r17, 3
    9dd4:	40 c0       	rjmp	.+128    	; 0x9e56 <strtod+0x1c0>
    9dd6:	18 60       	ori	r17, 0x08	; 8
    9dd8:	b1 2e       	mov	r11, r17
    9dda:	8f ef       	ldi	r24, 0xFF	; 255
    9ddc:	e8 1a       	sub	r14, r24
    9dde:	f8 0a       	sbc	r15, r24
    9de0:	00 81       	ld	r16, Z
    9de2:	1b 2d       	mov	r17, r11
    9de4:	c6 cf       	rjmp	.-116    	; 0x9d72 <strtod+0xdc>
    9de6:	80 2f       	mov	r24, r16
    9de8:	8f 7d       	andi	r24, 0xDF	; 223
    9dea:	85 34       	cpi	r24, 0x45	; 69
    9dec:	a1 f5       	brne	.+104    	; 0x9e56 <strtod+0x1c0>
    9dee:	80 81       	ld	r24, Z
    9df0:	8d 32       	cpi	r24, 0x2D	; 45
    9df2:	11 f4       	brne	.+4      	; 0x9df8 <strtod+0x162>
    9df4:	10 61       	ori	r17, 0x10	; 16
    9df6:	06 c0       	rjmp	.+12     	; 0x9e04 <strtod+0x16e>
    9df8:	8b 32       	cpi	r24, 0x2B	; 43
    9dfa:	21 f0       	breq	.+8      	; 0x9e04 <strtod+0x16e>
    9dfc:	31 96       	adiw	r30, 0x01	; 1
    9dfe:	61 e0       	ldi	r22, 0x01	; 1
    9e00:	70 e0       	ldi	r23, 0x00	; 0
    9e02:	04 c0       	rjmp	.+8      	; 0x9e0c <strtod+0x176>
    9e04:	81 81       	ldd	r24, Z+1	; 0x01
    9e06:	32 96       	adiw	r30, 0x02	; 2
    9e08:	62 e0       	ldi	r22, 0x02	; 2
    9e0a:	70 e0       	ldi	r23, 0x00	; 0
    9e0c:	80 53       	subi	r24, 0x30	; 48
    9e0e:	8a 30       	cpi	r24, 0x0A	; 10
    9e10:	18 f0       	brcs	.+6      	; 0x9e18 <strtod+0x182>
    9e12:	e6 1b       	sub	r30, r22
    9e14:	f7 0b       	sbc	r31, r23
    9e16:	1f c0       	rjmp	.+62     	; 0x9e56 <strtod+0x1c0>
    9e18:	60 e0       	ldi	r22, 0x00	; 0
    9e1a:	70 e0       	ldi	r23, 0x00	; 0
    9e1c:	60 38       	cpi	r22, 0x80	; 128
    9e1e:	9c e0       	ldi	r25, 0x0C	; 12
    9e20:	79 07       	cpc	r23, r25
    9e22:	5c f4       	brge	.+22     	; 0x9e3a <strtod+0x1a4>
    9e24:	db 01       	movw	r26, r22
    9e26:	aa 0f       	add	r26, r26
    9e28:	bb 1f       	adc	r27, r27
    9e2a:	aa 0f       	add	r26, r26
    9e2c:	bb 1f       	adc	r27, r27
    9e2e:	6a 0f       	add	r22, r26
    9e30:	7b 1f       	adc	r23, r27
    9e32:	66 0f       	add	r22, r22
    9e34:	77 1f       	adc	r23, r23
    9e36:	68 0f       	add	r22, r24
    9e38:	71 1d       	adc	r23, r1
    9e3a:	31 96       	adiw	r30, 0x01	; 1
    9e3c:	df 01       	movw	r26, r30
    9e3e:	11 97       	sbiw	r26, 0x01	; 1
    9e40:	8c 91       	ld	r24, X
    9e42:	80 53       	subi	r24, 0x30	; 48
    9e44:	8a 30       	cpi	r24, 0x0A	; 10
    9e46:	50 f3       	brcs	.-44     	; 0x9e1c <strtod+0x186>
    9e48:	14 ff       	sbrs	r17, 4
    9e4a:	03 c0       	rjmp	.+6      	; 0x9e52 <strtod+0x1bc>
    9e4c:	71 95       	neg	r23
    9e4e:	61 95       	neg	r22
    9e50:	71 09       	sbc	r23, r1
    9e52:	c6 0f       	add	r28, r22
    9e54:	d7 1f       	adc	r29, r23
    9e56:	11 ff       	sbrs	r17, 1
    9e58:	08 c0       	rjmp	.+16     	; 0x9e6a <strtod+0x1d4>
    9e5a:	c1 14       	cp	r12, r1
    9e5c:	d1 04       	cpc	r13, r1
    9e5e:	29 f0       	breq	.+10     	; 0x9e6a <strtod+0x1d4>
    9e60:	cf 01       	movw	r24, r30
    9e62:	01 97       	sbiw	r24, 0x01	; 1
    9e64:	f6 01       	movw	r30, r12
    9e66:	80 83       	st	Z, r24
    9e68:	91 83       	std	Z+1, r25	; 0x01
    9e6a:	ca 01       	movw	r24, r20
    9e6c:	b9 01       	movw	r22, r18
    9e6e:	0e 94 3d 43 	call	0x867a	; 0x867a <__floatunsisf>
    9e72:	21 2f       	mov	r18, r17
    9e74:	23 70       	andi	r18, 0x03	; 3
    9e76:	23 30       	cpi	r18, 0x03	; 3
    9e78:	19 f0       	breq	.+6      	; 0x9e80 <strtod+0x1ea>
    9e7a:	4b 01       	movw	r8, r22
    9e7c:	5c 01       	movw	r10, r24
    9e7e:	06 c0       	rjmp	.+12     	; 0x9e8c <strtod+0x1f6>
    9e80:	4b 01       	movw	r8, r22
    9e82:	5c 01       	movw	r10, r24
    9e84:	b7 fa       	bst	r11, 7
    9e86:	b0 94       	com	r11
    9e88:	b7 f8       	bld	r11, 7
    9e8a:	b0 94       	com	r11
    9e8c:	20 e0       	ldi	r18, 0x00	; 0
    9e8e:	30 e0       	ldi	r19, 0x00	; 0
    9e90:	a9 01       	movw	r20, r18
    9e92:	c5 01       	movw	r24, r10
    9e94:	b4 01       	movw	r22, r8
    9e96:	0e 94 90 42 	call	0x8520	; 0x8520 <__cmpsf2>
    9e9a:	88 23       	and	r24, r24
    9e9c:	09 f4       	brne	.+2      	; 0x9ea0 <strtod+0x20a>
    9e9e:	3e c0       	rjmp	.+124    	; 0x9f1c <strtod+0x286>
    9ea0:	d7 ff       	sbrs	r29, 7
    9ea2:	06 c0       	rjmp	.+12     	; 0x9eb0 <strtod+0x21a>
    9ea4:	d1 95       	neg	r29
    9ea6:	c1 95       	neg	r28
    9ea8:	d1 09       	sbc	r29, r1
    9eaa:	05 e5       	ldi	r16, 0x55	; 85
    9eac:	13 e0       	ldi	r17, 0x03	; 3
    9eae:	02 c0       	rjmp	.+4      	; 0x9eb4 <strtod+0x21e>
    9eb0:	0d e6       	ldi	r16, 0x6D	; 109
    9eb2:	13 e0       	ldi	r17, 0x03	; 3
    9eb4:	68 01       	movw	r12, r16
    9eb6:	f8 e1       	ldi	r31, 0x18	; 24
    9eb8:	cf 1a       	sub	r12, r31
    9eba:	d1 08       	sbc	r13, r1
    9ebc:	90 e2       	ldi	r25, 0x20	; 32
    9ebe:	e9 2e       	mov	r14, r25
    9ec0:	f1 2c       	mov	r15, r1
    9ec2:	ce 15       	cp	r28, r14
    9ec4:	df 05       	cpc	r29, r15
    9ec6:	74 f0       	brlt	.+28     	; 0x9ee4 <strtod+0x24e>
    9ec8:	f8 01       	movw	r30, r16
    9eca:	25 91       	lpm	r18, Z+
    9ecc:	35 91       	lpm	r19, Z+
    9ece:	45 91       	lpm	r20, Z+
    9ed0:	54 91       	lpm	r21, Z
    9ed2:	c5 01       	movw	r24, r10
    9ed4:	b4 01       	movw	r22, r8
    9ed6:	0e 94 f4 43 	call	0x87e8	; 0x87e8 <__mulsf3>
    9eda:	4b 01       	movw	r8, r22
    9edc:	5c 01       	movw	r10, r24
    9ede:	ce 19       	sub	r28, r14
    9ee0:	df 09       	sbc	r29, r15
    9ee2:	ef cf       	rjmp	.-34     	; 0x9ec2 <strtod+0x22c>
    9ee4:	04 50       	subi	r16, 0x04	; 4
    9ee6:	11 09       	sbc	r17, r1
    9ee8:	f5 94       	asr	r15
    9eea:	e7 94       	ror	r14
    9eec:	0c 15       	cp	r16, r12
    9eee:	1d 05       	cpc	r17, r13
    9ef0:	41 f7       	brne	.-48     	; 0x9ec2 <strtod+0x22c>
    9ef2:	8a 2d       	mov	r24, r10
    9ef4:	88 0f       	add	r24, r24
    9ef6:	8b 2d       	mov	r24, r11
    9ef8:	88 1f       	adc	r24, r24
    9efa:	8f 3f       	cpi	r24, 0xFF	; 255
    9efc:	49 f0       	breq	.+18     	; 0x9f10 <strtod+0x27a>
    9efe:	20 e0       	ldi	r18, 0x00	; 0
    9f00:	30 e0       	ldi	r19, 0x00	; 0
    9f02:	a9 01       	movw	r20, r18
    9f04:	c5 01       	movw	r24, r10
    9f06:	b4 01       	movw	r22, r8
    9f08:	0e 94 90 42 	call	0x8520	; 0x8520 <__cmpsf2>
    9f0c:	81 11       	cpse	r24, r1
    9f0e:	06 c0       	rjmp	.+12     	; 0x9f1c <strtod+0x286>
    9f10:	82 e2       	ldi	r24, 0x22	; 34
    9f12:	90 e0       	ldi	r25, 0x00	; 0
    9f14:	80 93 99 2d 	sts	0x2D99, r24	; 0x802d99 <errno>
    9f18:	90 93 9a 2d 	sts	0x2D9A, r25	; 0x802d9a <errno+0x1>
    9f1c:	c5 01       	movw	r24, r10
    9f1e:	b4 01       	movw	r22, r8
    9f20:	09 c0       	rjmp	.+18     	; 0x9f34 <strtod+0x29e>
    9f22:	60 e0       	ldi	r22, 0x00	; 0
    9f24:	70 e0       	ldi	r23, 0x00	; 0
    9f26:	80 e8       	ldi	r24, 0x80	; 128
    9f28:	9f ef       	ldi	r25, 0xFF	; 255
    9f2a:	04 c0       	rjmp	.+8      	; 0x9f34 <strtod+0x29e>
    9f2c:	60 e0       	ldi	r22, 0x00	; 0
    9f2e:	70 e0       	ldi	r23, 0x00	; 0
    9f30:	80 ec       	ldi	r24, 0xC0	; 192
    9f32:	9f e7       	ldi	r25, 0x7F	; 127
    9f34:	df 91       	pop	r29
    9f36:	cf 91       	pop	r28
    9f38:	1f 91       	pop	r17
    9f3a:	0f 91       	pop	r16
    9f3c:	ff 90       	pop	r15
    9f3e:	ef 90       	pop	r14
    9f40:	df 90       	pop	r13
    9f42:	cf 90       	pop	r12
    9f44:	bf 90       	pop	r11
    9f46:	af 90       	pop	r10
    9f48:	9f 90       	pop	r9
    9f4a:	8f 90       	pop	r8
    9f4c:	08 95       	ret

00009f4e <isspace>:
    9f4e:	91 11       	cpse	r25, r1
    9f50:	0c 94 06 50 	jmp	0xa00c	; 0xa00c <__ctype_isfalse>
    9f54:	80 32       	cpi	r24, 0x20	; 32
    9f56:	19 f0       	breq	.+6      	; 0x9f5e <isspace+0x10>
    9f58:	89 50       	subi	r24, 0x09	; 9
    9f5a:	85 50       	subi	r24, 0x05	; 5
    9f5c:	c8 f7       	brcc	.-14     	; 0x9f50 <isspace+0x2>
    9f5e:	08 95       	ret

00009f60 <strncasecmp_P>:
    9f60:	fb 01       	movw	r30, r22
    9f62:	dc 01       	movw	r26, r24
    9f64:	41 50       	subi	r20, 0x01	; 1
    9f66:	50 40       	sbci	r21, 0x00	; 0
    9f68:	88 f0       	brcs	.+34     	; 0x9f8c <strncasecmp_P+0x2c>
    9f6a:	8d 91       	ld	r24, X+
    9f6c:	81 34       	cpi	r24, 0x41	; 65
    9f6e:	1c f0       	brlt	.+6      	; 0x9f76 <strncasecmp_P+0x16>
    9f70:	8b 35       	cpi	r24, 0x5B	; 91
    9f72:	0c f4       	brge	.+2      	; 0x9f76 <strncasecmp_P+0x16>
    9f74:	80 5e       	subi	r24, 0xE0	; 224
    9f76:	65 91       	lpm	r22, Z+
    9f78:	61 34       	cpi	r22, 0x41	; 65
    9f7a:	1c f0       	brlt	.+6      	; 0x9f82 <strncasecmp_P+0x22>
    9f7c:	6b 35       	cpi	r22, 0x5B	; 91
    9f7e:	0c f4       	brge	.+2      	; 0x9f82 <strncasecmp_P+0x22>
    9f80:	60 5e       	subi	r22, 0xE0	; 224
    9f82:	86 1b       	sub	r24, r22
    9f84:	61 11       	cpse	r22, r1
    9f86:	71 f3       	breq	.-36     	; 0x9f64 <strncasecmp_P+0x4>
    9f88:	99 0b       	sbc	r25, r25
    9f8a:	08 95       	ret
    9f8c:	88 1b       	sub	r24, r24
    9f8e:	fc cf       	rjmp	.-8      	; 0x9f88 <strncasecmp_P+0x28>

00009f90 <fgetc>:
    9f90:	cf 93       	push	r28
    9f92:	df 93       	push	r29
    9f94:	ec 01       	movw	r28, r24
    9f96:	2b 81       	ldd	r18, Y+3	; 0x03
    9f98:	20 ff       	sbrs	r18, 0
    9f9a:	33 c0       	rjmp	.+102    	; 0xa002 <__stack+0x3>
    9f9c:	26 ff       	sbrs	r18, 6
    9f9e:	0a c0       	rjmp	.+20     	; 0x9fb4 <fgetc+0x24>
    9fa0:	2f 7b       	andi	r18, 0xBF	; 191
    9fa2:	2b 83       	std	Y+3, r18	; 0x03
    9fa4:	8e 81       	ldd	r24, Y+6	; 0x06
    9fa6:	9f 81       	ldd	r25, Y+7	; 0x07
    9fa8:	01 96       	adiw	r24, 0x01	; 1
    9faa:	8e 83       	std	Y+6, r24	; 0x06
    9fac:	9f 83       	std	Y+7, r25	; 0x07
    9fae:	8a 81       	ldd	r24, Y+2	; 0x02
    9fb0:	90 e0       	ldi	r25, 0x00	; 0
    9fb2:	29 c0       	rjmp	.+82     	; 0xa006 <__stack+0x7>
    9fb4:	22 ff       	sbrs	r18, 2
    9fb6:	0f c0       	rjmp	.+30     	; 0x9fd6 <fgetc+0x46>
    9fb8:	e8 81       	ld	r30, Y
    9fba:	f9 81       	ldd	r31, Y+1	; 0x01
    9fbc:	80 81       	ld	r24, Z
    9fbe:	08 2e       	mov	r0, r24
    9fc0:	00 0c       	add	r0, r0
    9fc2:	99 0b       	sbc	r25, r25
    9fc4:	00 97       	sbiw	r24, 0x00	; 0
    9fc6:	19 f4       	brne	.+6      	; 0x9fce <fgetc+0x3e>
    9fc8:	20 62       	ori	r18, 0x20	; 32
    9fca:	2b 83       	std	Y+3, r18	; 0x03
    9fcc:	1a c0       	rjmp	.+52     	; 0xa002 <__stack+0x3>
    9fce:	31 96       	adiw	r30, 0x01	; 1
    9fd0:	e8 83       	st	Y, r30
    9fd2:	f9 83       	std	Y+1, r31	; 0x01
    9fd4:	0e c0       	rjmp	.+28     	; 0x9ff2 <fgetc+0x62>
    9fd6:	ea 85       	ldd	r30, Y+10	; 0x0a
    9fd8:	fb 85       	ldd	r31, Y+11	; 0x0b
    9fda:	19 95       	eicall
    9fdc:	97 ff       	sbrs	r25, 7
    9fde:	09 c0       	rjmp	.+18     	; 0x9ff2 <fgetc+0x62>
    9fe0:	2b 81       	ldd	r18, Y+3	; 0x03
    9fe2:	01 96       	adiw	r24, 0x01	; 1
    9fe4:	11 f0       	breq	.+4      	; 0x9fea <fgetc+0x5a>
    9fe6:	80 e2       	ldi	r24, 0x20	; 32
    9fe8:	01 c0       	rjmp	.+2      	; 0x9fec <fgetc+0x5c>
    9fea:	80 e1       	ldi	r24, 0x10	; 16
    9fec:	82 2b       	or	r24, r18
    9fee:	8b 83       	std	Y+3, r24	; 0x03
    9ff0:	08 c0       	rjmp	.+16     	; 0xa002 <__stack+0x3>
    9ff2:	2e 81       	ldd	r18, Y+6	; 0x06
    9ff4:	3f 81       	ldd	r19, Y+7	; 0x07
    9ff6:	2f 5f       	subi	r18, 0xFF	; 255
    9ff8:	3f 4f       	sbci	r19, 0xFF	; 255
    9ffa:	2e 83       	std	Y+6, r18	; 0x06
    9ffc:	3f 83       	std	Y+7, r19	; 0x07
    9ffe:	99 27       	eor	r25, r25
    a000:	02 c0       	rjmp	.+4      	; 0xa006 <__stack+0x7>
    a002:	8f ef       	ldi	r24, 0xFF	; 255
    a004:	9f ef       	ldi	r25, 0xFF	; 255
    a006:	df 91       	pop	r29
    a008:	cf 91       	pop	r28
    a00a:	08 95       	ret

0000a00c <__ctype_isfalse>:
    a00c:	99 27       	eor	r25, r25
    a00e:	88 27       	eor	r24, r24

0000a010 <__ctype_istrue>:
    a010:	08 95       	ret

0000a012 <_exit>:
    a012:	f8 94       	cli

0000a014 <__stop_program>:
    a014:	ff cf       	rjmp	.-2      	; 0xa014 <__stop_program>
